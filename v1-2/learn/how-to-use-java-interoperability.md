---
layout: ballerina-inner-page
title: How to Use Java Interoperability
permalink: /v1-2/learn/how-to-use-java-interoperability/
---

# How to call Java code from Ballerina

## Introduction
Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java.  Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering to Ballerina language semantics. 

### Ballerina bindings to Java code
Your task is to write Ballerina code (Ballerina bindings) that lets you call into the corresponding Java API. 

[TODO] Image 

This guide teaches you how to manually write those bindings as well as how to generate those bindings automatically, but first, let's look at why you want to call Java from Ballerina. 

### Why you want to call Java from Ballerina 
- Ballerina is a relatively new language. Therefore, you may experience a shortage of libraries in [Ballerina Central](https://central.ballerina.io/). In such situations, as a workaround, you can use an existing Java library.
- You are already familiar with a stable Java API that you would like to use in your Ballerina project. 
- You want to take advantage of the strengths of Ballerina, but you don’t want to reinvest in the libraries that you or your company have written already. 

There may be other reasons, but these are great motivations to use Ballerina bindings. 

### Writing Ballerina bindings
Manually writing Ballerina bindings is a tedious task. You’ll soon see why. Therefore, we’ve developed a tool called `bindgen` that can generate Ballerina bindings for given Java APIs. The [first section](#how-to-use-snakeyaml-java-library-in-ballerina) of this guide shows you how to use it. The [second section](#the-bindgen-tool) is a reference guide to the tool. 

The [third section](#packaging-java-libraries-with-ballerina-programs) explains how to package Java libraries (JAR files) with Ballerina programs. This section is useful because whenever you generate bindings for a Java library, you need to package this Java library and its transitive dependencies to produce a self-contained executable program. 

The [fourth](#ballerina-ffi) and [fifth](#calling-java-code-from-ballerina) sections explain how to write these bindings manually. It is also a useful section for those who want to understand the inner workings of calling Java from Ballerina and for those who want to customize the bindings generated by the `bindgen` tool. 

## Overview
- [How to use SnakeYAML Java library in Ballerina](#how-to-use-snakeyaml-java-library-in-ballerina)
- [The bindgen tool](#the-bindgen-tool)
- [Packaging Java libraries with Ballerina programs](#packaging-java-libraries-with-ballerina-programs)
- [Ballerina FFI](#ballerina-ffi)
- [Calling Java code from Ballerina](#calling-java-code-from-ballerina)

## How to use SnakeYAML Java library in Ballerina
SnakeYAML is a YAML parser for Java. In this section, we’ll learn how to use this library to parse a YAML document in Ballerina. 

We'll develop a Ballerina program that parses the given YAML file and writes the content to the standard out.

Let’s get started.  

### Step 1: Write the Java code
We recommend you to always start by writing the logic in Java. It gives you an idea of the set of Java classes required to implement your logic. Once you know the set of classes, we can use the bindgen tool to generate Ballerina bindings for those classes. 

The following Java code uses the SnakeYAML API to parse the given YAML file. Note that this is not the most idiomatic way of writing the Java code for this scenario. 

```java
import org.yaml.snakeyaml.Yaml;

import java.io.FileInputStream;
import java.io.InputStream;
import java.util.Map;

public class SnakeYamlSample {

    public static void main(String... a) {
	String filename = a[0];
	try (InputStream inputStream = new FileInputStream(filename)) {
		Yaml yaml = new Yaml(); 
		Map<String, Object> obj = yaml.load(inputStream);
		System.out.println(obj);
	} catch (Exception e) {
                System.err.println("The file '" + filename + "' cannot be loaded. Reason: " + e.getMessage());;
	}
    }
}
```

Here, we’ve used four Java classes. 
org.yaml.snakeyaml.Yaml
- `java.io.FileInputStream`
- `java.io.InputStream`
- `java.util.Map`

You can see them in the imported class list. We encourage you to generate Ballerina bindings for these four classes as a start.  

Now, we’ll create the environment for our Ballerina program. 

### Step 2: Setup the Ballerina project
This section assumes that you have already read the guide “How to Structure Ballerina Code”. 

#### Create a Ballerina project
```sh
→ ballerina new yaml-project
Created new Ballerina project at yaml-project

Next:
    Move into the project directory and use `ballerina add <module-name>` to
    add a new Ballerina module.
```
#### Add a Ballerina module to your project
```sh
→ ballerina add yamlparser
Added new ballerina module at 'src/yamlparser’
```
#### Add a sample YAML file 
Copy the following YAML to a file named invoice.yml in the project root directory.
```yaml
invoice: 34843
date   : 2001-01-23
bill-to: &id001
   given  : Chris
   family : Dumars
   address:
       lines: |
           458 Walkman Dr.
           Suite #292
       city    : Royal Oak
       state   : MI
       postal  : 48046
ship-to: *id001
product:
   - sku         : BL394D
     quantity    : 4
     description : Basketball
     price       : 450.00
   - sku         : BL4438H
     quantity    :
     description : Super Hoop
     price       : 2392.00
tax  : 251.42
total: 4443.52
comments: >
   Late afternoon is best.
   Backup contact is Nancy
   Billsmer @ 338-4338.\
```

#### Verify the project
```sh
> ballerina build yamlparser 
Compiling source
	sameera/yamlparser:0.1.0

Creating balos
	target/balo/yamlparser-2020r1-any-0.1.0.balo
... 
...

Generating executables
	target/bin/yamlparser.jar
```
```sh
> ballerina run target/bin/yamlparser.jar
Hello World!
```
Great! You are all set for the next step. 

### Step 3: Generate Ballerina bindings 
In this step, we’ll use the bindgen tool to generate the Ballerina bindings for those four classes that talked about in Step 1. If you want more information about the bindgen tool, you can refer to the [The bindgen tool](#the-bindgen-tool) section.

#### Copy the SnakeYAML library to your project
Download the latest version of the SnakeYAML library and copy it to the project. We need to copy only the SnakeYAML library, but for most cases, you may need to copy more than one JAR file. Make sure that you add all the direct and their transitive dependencies. 

Create a directory in your project root to store all the Java libraries. 
```sh
> mkdir javalibs
> cp <path-to-snakeyaml-lib>/snakeyaml-1.25.jar javalibs
```

Add SnakeYAML library to the Ballerina.toml file
Copy and paste the following TOML snippet to the Ballerina.toml file in your project’s root directory. This step ensures that the SnakeYAML library is always packaged with the stand-alone executable jar generated for your Ballerina program. Refer to the “Packaging Java libraries with Ballerina programs” for more details. 

```toml
[platform]
target = "java8"

   [[platform.libraries]]
   path = "./javalibs/snakeyaml-1.25.jar"
   modules = ["yamlparser"]
```

#### Generate Ballerina bindings
```sh
> ballerina bindgen -cp ./javalibs/snakeyaml-1.25.jar -o src/yamlparser
 org.yaml.snakeyaml.Yaml java.io.FileInputStream java.io.InputStream java.util.Map

Generating bindings for: 
	java.util.Map
	java.io.FileInputStream
	org.yaml.snakeyaml.Yaml
	java.io.InputStream

Generating dependency bindings for: 
	org.yaml.snakeyaml.introspector.BeanAccess
	java.util.function.BiFunction
	org.yaml.snakeyaml.constructor.BaseConstructor
	java.util.function.Function
	... 
	... 
```
- The -cp option specifies the list of Java libraries required to generate bindings. 
- The -o option specifies the output directory to which the generated bindings are stored. In this case, we instruct the tool to store bindings inside the yamlparser module. 
- The argument list specifies the Java class names. 

The bindgen tool generate bindings for 
- The specified Java classes 
- The Java classes exposed in the public APIs of all the specified classes. 


Before we move onto the next step, let’s verify the generated code. 
```sh
> ballerina build yamlparser 
... 
...

Generating executables
	target/bin/yamlparser.jar

> ballerina run target/bin/yamlparser.jar
Hello World!
```

### Step 4: Write the Ballerina code
Note that the bindgen tool is still experimental. We are in the process of improving the generated code.  

Now, we’ll use the generated bindings and write the Ballerina code that uses SnakeYAML library. Here is the Java code. Let’s develop the corresponding Ballerina code step by step. 
```java
public class SnakeYamlSample {

    public static void main(String... a) {
	String filename = a[0];
	try (InputStream inputStream = new FileInputStream(filename)) {
		Yaml yaml = new Yaml(); 
		Map<String, Object> obj = yaml.load(inputStream);
		System.out.println(obj);
	} catch (Exception e) {
                System.err.println("The file '" + filename + "' cannot be loaded. Reason: " + e.getMessage());;
	}
    }
}
```

### Create the FileInputStream
Our goal here is to create a new java.io.FileInputStream instance from the filename. In step 3, we generated bindings for required Java classes. Following is the code snippet that does the job. 

```ballerina
FileInputStream | error fileInputStream = newFileInputStream3(filename);
```

Here, FileInputStream is the Ballerina object generated for the java.io.FileInputStream class. 
- You can find functions that start with newFileInputStream in the generated code. Each such function creates a new java.io.FileInputStream instance. Ballerina does not support function overloading. Therefore, the bindgen tool generates a separate Ballerina function for each overloaded method or constructor. This is why you see “3” appended to the function newFileInputStream3. We will improve the functions names of generated bindings in a future release. 
- All the methods in the java.io.FileInputStream class are mapped to methods in the generated Ballerina object.  

Next, we’ll handle the error using a type guard
```ballerina

if fileInputStream is error {
	// The type of fileInputStream is error within this block
       io:println("The file '" + filename + "' cannot be loaded. Reason: " + fileInputStream.reason());
} else {
	// The type of fileInputStream is FileInputStream within this block
}
```
### Create SnakeYAML entry point
The org.yaml.snakeyaml.Yaml Class is the entrypoint to the SnakeYAML API.  The corresponding generated Ballerina object is Yaml. The  function newYaml5() is mapped to the default constructor of the Java class.  
```ballerina
Yaml yaml = newYaml5();
```
###  Loads the YAML Document
We’ll be using the org.yaml.snakeyaml.Yaml.load(InputStream is) method to get a Java Map instance from the given InputStream. 
```ballerina

InputStream inputStream = new (fileInputStream.jObj);
Object mapObj = yaml.load2(inputStream);
```
The generated code does not handle Java subtyping at the moment. Therefore InputStream inputStream = newFileInputStream3(filename) will not compile. We will improve this in a future release. As a workaround, you can create a new java.io.InputStream as above. You can find more details in the “The bindgen tool” section.

The org.yaml.snakeyaml.Yaml.load(InputStream is) method is a generic method. The bindgen tool does to support Java generics at the moment. That is why the corresponding Ballerina method returns an Object. 

###  Print returned the Map instance. 
You can print the content of the Map instance the standard out as follows. 
```ballerina
io:println(mapObj);
```
### Completed code 
Here is the complete code. You can replace the contents in src/yamlparser/main.bal with the following code.
```ballerina
import ballerina/io;
 
public function main(string... args) returns error? {
   string filename = args[0];
   FileInputStream | error fileInputStream = newFileInputStream3(filename);
   if fileInputStream is error {
       io:println("The file '" + filename + "' cannot be loaded. Reason: " + fileInputStream.reason());
   } else {
       Yaml yaml = newYaml5();
	InputStream inputStream = new (fileInputStream.jObj);
       Object mapObj = yaml.load2(inputStream);
       io:println(mapObj);
   }
}
```

Let’s build and run this code. 
```sh
> ballerina build yamlparser 
Compiling source
	sameera/yamlparser:0.1.0

Creating balos
	target/balo/yamlparser-2020r1-any-0.1.0.balo
... 
...

Generating executables
	target/bin/yamlparser.jar
```

Now we need to pass the YAML file name as the first argument. 
```sh
> ballerina run target/bin/yamlparser.jar invoice.yaml
{invoice=34843, date=Mon Jan 22 16:00:00 PST 2001, bill-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr.
Suite #292
, city=Royal Oak, state=MI, postal=48046}}, ship-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr.
Suite #292
, city=Royal Oak, state=MI, postal=48046}}, product=[{sku=BL394D, quantity=4, description=Basketball, price=450.0}, {sku=BL4438H, quantity=null, description=Super Hoop, price=2392.0}], tax=251.42, total=4443.52, comments=Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338.\}
```
In this section we explained how to use the bindgen tool to generate Ballerina bindings for Java classes and how to use those generated ones. 

The next sections provide more details on various aspects related to Java interoperability in Ballerina. 


## The `bindgen` tool
## Packaging Java libraries with Ballerina programs
## Ballerina FFI
## Calling Java code from Ballerina
