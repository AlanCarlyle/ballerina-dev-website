let contentIndex=[{"page":"/learn/api-docs/","name":"API Docs","summary":"The list of language and standard library modules that are available with the distribution."},{"page":"/1.2/learn/by-example/404.html","name":"Ballerina","summary":"Sorry, we couldn't find that! Check out the ?\n        by  |  |  | \n       ...","content":"Sorry, we couldn't find that! Check out the ?  by | | |"},{"page":"/1.2/learn/by-example/access-mutate-java-fields.html","name":"Access/Mutate Java Fields","summary":"Java fields (both static and instance) can be read and updated in Ballerina.\n From the Ballerina side, they will appear as function calls. This example shows how to read a field value.\n Similarly, the @java:FieldSet annotation can be used to create a Ballerina function with\n an external function that acts ...","content":"/  /  /  / Access/Mutate Java Fields  import ballerina/io; import ballerina/java;  // Define a Ballerina function which will act as a Java field getter. public function pi() returns float = @java:FieldGet {  name: \"PI\",  class: \"java/lang/Math\" } external;  public function main() {  float r = 4;  // If a field is an instance field, the receiver instance has to be provided as the first parameter.  float l = 2 * pi() * r;  io:println(l); }    Access/Mutate Java Fields  Java fields (both static and instance) can be read and updated in Ballerina.  From the Ballerina side, they will appear as function calls. This example shows how to read a field value.  Similarly, the @java:FieldSet annotation can be used to create a Ballerina function with  an external function that acts as a field setter.    import ballerina/io; import ballerina/java;    public function pi() returns float = @java:FieldGet {  name: \"PI\",  class: \"java/lang/Math\" } external;    Define a Ballerina function which will act as a Java field getter.   public function main() {  float r = 4;    float l = 2 * pi() * r;  io:println(l); }    If a field is an instance field, the receiver instance has to be provided as the first parameter.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run access_mutate_java_fields.bal 25.132741228718345    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/abstract-objects.html","name":"Abstract Objects","summary":"In Ballerina, objects can be abstract. Abstract objects only describe the fields and the signatures of the methods.\n An abstract object cannot be initialized and does not have a default value.Defines an abstract object called Person. It should only contain\n fields and method declarations. An abstract object cannot have\n an ...","content":"/  /  /  / Abstract Objects  import ballerina/io;  // Defines an abstract object called `Person`. It should only contain // fields and method declarations. An abstract object cannot have // an initializer or method definitions. type Person abstract object {  public int age;  public string firstName;  public string lastName;   // Method declarations can be within the object. However, the method cannot  // have a body.  function getFullName() returns string;   function checkAndModifyAge(int condition, int a); };  // Defines a non-abstract object called `Employee`, which is structurally equivalent // to `Person`. A non-abstract object cannot have any methods // without a body. type Employee object {  public int age;  public string firstName;  public string lastName;   // Non-abstract objects can have initializers.  function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }   // Methods should have a body.  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }   function checkAndModifyAge(int condition, int a) {  if (self.age < condition) {  self.age = a;  }  } };  public function main() {  // An abstract object type cannot be initialized. It does not have // an implicit initial value.   // Initializes a value using the non-abstract object `Employee`,  // and then assigns the value to the abstract object type variable.  Person p = new Employee(5, \"John\", \"Doe\");  io:println(p.getFullName());  p.checkAndModifyAge(10, 50);   io:println(p.age); }    Abstract Objects  In Ballerina, objects can be abstract. Abstract objects only describe the fields and the signatures of the methods.  An abstract object cannot be initialized and does not have a default value.    import ballerina/io;    type Person abstract object {  public int age;  public string firstName;  public string lastName;    Defines an abstract object called Person. It should only contain  fields and method declarations. An abstract object cannot have  an initializer or method definitions.   function getFullName() returns string;    Method declarations can be within the object. However, the method cannot  have a body.   function checkAndModifyAge(int condition, int a); };    type Employee object {  public int age;  public string firstName;  public string lastName;    Defines a non-abstract object called Employee, which is structurally equivalent  to Person. A non-abstract object cannot have any methods  without a body.   function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }    Non-abstract objects can have initializers.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    Methods should have a body.   function checkAndModifyAge(int condition, int a) {  if (self.age < condition) {  self.age = a;  }  } };    public function main() {    An abstract object type cannot be initialized. It does not have  an implicit initial value.   Person p = new Employee(5, \"John\", \"Doe\");  io:println(p.getFullName());  p.checkAndModifyAge(10, 50);    Initializes a value using the non-abstract object Employee,  and then assigns the value to the abstract object type variable.   io:println(p.age); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run abstract_objects.bal John Doe 50    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/anonymous-functions.html","name":"Anonymous Functions","summary":"In Ballerina, anonymous functions are a syntactic shortcut for defining inline functions.\n The only difference between an anonymous function and a normal function definition is that\n an anonymous function does not have a name.Defines an anonymous function.Defines an anonymous function with var.If an anonymous function contains only the return statement ...","content":"/  /  /  / Anonymous Functions  import ballerina/io;  public function main() {  // Defines an anonymous function.  function (string, string) returns string anonFunction =  function (string x, string y) returns string {  return x + y;  };  io:println(\"Output: \", anonFunction(\"Hello \", \"World.!!!\"));   // Defines an anonymous function with `var`.  var anonFunction2 = function (string x, string y, string... z) returns string {  string value = x + y;  foreach var item in z {  value += item;  }  return value;  };  io:println(\"Output: \", anonFunction2(\"Ballerina \", \"is \", \"an \", \"open \",  \"source \", \"programming \", \"language.\"));   // If an anonymous function contains only the return statement in the body,  // you can use the `arrow function expression` instead of the anonymous function.  // The types of the input parameters are inferred from the left-hand side.  // The return of the arrow function expression is determined by the  // evaluation of the expression on the right-hand side of the `=>` symbol.  function (string, string) returns string arrowExpr = (x, y) => x + y;  io:println(\"Output: \", arrowExpr(\"Hello \", \"World.!!!\")); }    Anonymous Functions  In Ballerina, anonymous functions are a syntactic shortcut for defining inline functions.  The only difference between an anonymous function and a normal function definition is that  an anonymous function does not have a name.    import ballerina/io;    public function main() {    function (string, string) returns string anonFunction =  function (string x, string y) returns string {  return x + y;  };  io:println(\"Output: \", anonFunction(\"Hello \", \"World.!!!\"));    Defines an anonymous function.   var anonFunction2 = function (string x, string y, string... z) returns string {  string value = x + y;  foreach var item in z {  value += item;  }  return value;  };  io:println(\"Output: \", anonFunction2(\"Ballerina \", \"is \", \"an \", \"open \",  \"source \", \"programming \", \"language.\"));    Defines an anonymous function with var.   function (string, string) returns string arrowExpr = (x, y) => x + y;  io:println(\"Output: \", arrowExpr(\"Hello \", \"World.!!!\")); }    If an anonymous function contains only the return statement in the body,  you can use the arrow function expression instead of the anonymous function.  The types of the input parameters are inferred from the left-hand side.  The return of the arrow function expression is determined by the  evaluation of the expression on the right-hand side of the => symbol.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run anonymous_functions.bal Output: Hello World.!!! Output: Ballerina is an open source programming language. Output: Hello World.!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/anonymous-objects.html","name":"Anonymous Objects","summary":"Object types can be defined in-line as well. These types do not have a type name associated with them.\n Such anonymous object types can be used in instances in which there is no need to refer to the object type by its name\n (e.g., objects as fields of records or ...","content":"/  /  /  / Anonymous Objects  import ballerina/io;  public type Person record {  string name;  int age;  // This is an anonymous object type descriptor. All the fields and  // methods are made public. This is done to allow the declaration of  // variables equivalent to this object type (since two public object types  // are considered unequivalent if either of the objects have  // any private members).  object {  public string city;  public string country;   public function __init(string city, string country) {  self.city = city;  self.country = country;  }   public function value() returns string {  return self.city + \", \" + self.country;  }  } address; };  public function main() {  // There is no difference in how objects of anonymous types are created.  Person john = {  name: \"John Doe\",  age: 25,  address: new (\"Colombo\", \"Sri Lanka\")  };  io:println(john.address.city);   // Since anonymous objects do not have a type name associated with them,  // the object descriptor itself has to be specified when declaring  // variables of an anonymous object type.  object {  public string city;  public string country;   public function __init(string city, string country) {  self.city = city;  self.country = country;  }   public function value() returns string {  return self.city + \", \" + self.country;  }  } adr = new (\"London\", \"UK\");   Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane.address.country); }    Anonymous Objects  Object types can be defined in-line as well. These types do not have a type name associated with them.  Such anonymous object types can be used in instances in which there is no need to refer to the object type by its name  (e.g., objects as fields of records or objects or objects as function parameters).    import ballerina/io;    public type Person record {  string name;  int age;    object {  public string city;  public string country;    This is an anonymous object type descriptor. All the fields and  methods are made public. This is done to allow the declaration of  variables equivalent to this object type (since two public object types  are considered unequivalent if either of the objects have  any private members).   public function __init(string city, string country) {  self.city = city;  self.country = country;  }    public function value() returns string {  return self.city + \", \" + self.country;  }  } address; };    public function main() {    Person john = {  name: \"John Doe\",  age: 25,  address: new (\"Colombo\", \"Sri Lanka\")  };  io:println(john.address.city);    There is no difference in how objects of anonymous types are created.   object {  public string city;  public string country;    Since anonymous objects do not have a type name associated with them,  the object descriptor itself has to be specified when declaring  variables of an anonymous object type.   public function __init(string city, string country) {  self.city = city;  self.country = country;  }    public function value() returns string {  return self.city + \", \" + self.country;  }  } adr = new (\"London\", \"UK\");    Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane.address.country); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run anonymous_objects.bal Colombo UK    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/any-type.html","name":"Any Type","summary":"The any type can represent a variable of any type except the error type.\n When you do not have prior knowledge of the type of a variable, you can assign it to a variable of type any.\n Values of these variables can come from dynamic content such as the request ...","content":"/  /  /  / Any Type  import ballerina/io;  type Person object {  string fname;  string lname;   function __init(string fname, string lname) {  self.fname = fname;  self.lname = lname;  }   function getFullName() returns string {  return self.fname + \" \" + self.lname;  } };  // This function returns a value of the `any` type. function getValue() returns any {  string name = \"cat\";  return name; }  public function main() {  // In this example, the variable named `a` of the `any` type holds  // a `Person` object.  any a = new Person(\"John\", \"Doe\");   // Before anything useful can be done with `a`, it is required to ascertain  // its type. A type cast or a type guard can be used for this.  Person john = <Person>a;  io:println(\"Full name: \", john.getFullName());   if (a is Person) {  io:println(\"First name: \", john.fname);  }   // Variables of type `any` can hold values of any type except for `error`.  int[] ia = [1, 3, 5, 6];  any ar = ia;  io:println(ar);   io:println(getValue()); }    Any Type  The any type can represent a variable of any type except the error type.  When you do not have prior knowledge of the type of a variable, you can assign it to a variable of type any.  Values of these variables can come from dynamic content such as the request and response message references and  reference variable types.    import ballerina/io;    type Person object {  string fname;  string lname;    function __init(string fname, string lname) {  self.fname = fname;  self.lname = lname;  }    function getFullName() returns string {  return self.fname + \" \" + self.lname;  } };    function getValue() returns any {  string name = \"cat\";  return name; }    This function returns a value of the any type.   public function main() {    any a = new Person(\"John\", \"Doe\");    In this example, the variable named a of the any type holds  a Person object.   Person john = <Person>a;  io:println(\"Full name: \", john.getFullName());    Before anything useful can be done with a, it is required to ascertain  its type. A type cast or a type guard can be used for this.   if (a is Person) {  io:println(\"First name: \", john.fname);  }    int[] ia = [1, 3, 5, 6];  any ar = ia;  io:println(ar);    Variables of type any can hold values of any type except for error.   io:println(getValue()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run any_type.bal Full name: John Doe First name: John 1 3 5 6 cat    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/anonymous-records.html","name":"Anonymous Records","summary":"Record types can be defined in-line as well. These types do not have a type name associated with them.\n Such anonymous record types can be used in instances where there is no need to refer to the record type by its name\n (e.g., records as record or object fields, records ...","content":"/  /  /  / Anonymous Records  import ballerina/io;  public type Person record {  string name;  int age;  // This is an anonymous record type descriptor.  record {|  string city;  string country;  |} address; };  public function main() {  // There is no difference in how we create normal records vs.  // how we create anonymous records.  Person john = {  name: \"John Doe\",  age: 25,  address: {city: \"Colombo\", country: \"Sri Lanka\"}  };  io:println(john);   // Since anonymous records do not have a type name associated with them,  // the record descriptor itself has to be specified when declaring  // variables of an anonymous record type.  record {|  string city;  string country;  |} adr = {city: \"London\", country: \"UK\"};   Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane);   anydata[] fields = toFieldsArray(john);  io:println(fields); }  // This function accepts any record with `anydata`-typed fields. // Anonymous record types are implicitly public. function toFieldsArray(record {} anydataRecord) returns anydata[] {  anydata[] fields = [];   foreach var recField in anydataRecord {  fields.push(recField);  }   return fields; }    Anonymous Records  Record types can be defined in-line as well. These types do not have a type name associated with them.  Such anonymous record types can be used in instances where there is no need to refer to the record type by its name  (e.g., records as record or object fields, records as function parameters).    import ballerina/io;    public type Person record {  string name;  int age;    record {|  string city;  string country;  |} address; };    This is an anonymous record type descriptor.   public function main() {    Person john = {  name: \"John Doe\",  age: 25,  address: {city: \"Colombo\", country: \"Sri Lanka\"}  };  io:println(john);    There is no difference in how we create normal records vs.  how we create anonymous records.   record {|  string city;  string country;  |} adr = {city: \"London\", country: \"UK\"};    Since anonymous records do not have a type name associated with them,  the record descriptor itself has to be specified when declaring  variables of an anonymous record type.   Person jane = {name: \"Jane Doe\", age: 20, address: adr};  io:println(jane);    anydata[] fields = toFieldsArray(john);  io:println(fields); }    function toFieldsArray(record {} anydataRecord) returns anydata[] {  anydata[] fields = [];    This function accepts any record with anydata-typed fields.  Anonymous record types are implicitly public.   foreach var recField in anydataRecord {  fields.push(recField);  }    return fields; }    # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run anonymous_records.bal name=John Doe age=25 address=city=Colombo country=Sri Lanka name=Jane Doe age=20 address=city=London country=UK John Doe 25 city=Colombo country=Sri Lanka    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/anydata-type.html","name":"Anydata Type","summary":"The anydata type consists of pure values whose basic type is not error. Thus, the anydata type is\n equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.\n Although json and byte are not explicitly mentioned, they are subsets of the aforementioned union.\n The same is true for a record of which the type of each individual ...","content":"/  /  /  / Anydata Type  import ballerina/io;  // This function returns a value of the `anydata` type. function getValue() returns anydata {  string name = \"cat\";  return name; }  public function main() {  // In this example, the variable named `a` of the `anydata` type holds an `int` value.  anydata a = 5;  io:println(a);   // Before using the value of `a` in arithmetic operations, we need to  // ascertain that it is indeed an `int`. A type cast or  // a type guard can be used for this.  int intVal = <int>a;  io:println(intVal + 10);   if (a is int) {  io:println(a + 20);  }   // A variable of type `anydata` can hold any value of an `anydata` compatible type.  int[] ia = [1, 3, 5, 6];  anydata ar = ia;  io:println(ar);   io:println(getValue()); }    Anydata Type  The anydata type consists of pure values whose basic type is not error. Thus, the anydata type is  equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.  Although json and byte are not explicitly mentioned, they are subsets of the aforementioned union.  The same is true for a record of which the type of each individual field is a subtype of anydata(including the rest field in open records).  anydata variables can be used in places where you expect pure values (sans error).    import ballerina/io;    function getValue() returns anydata {  string name = \"cat\";  return name; }    This function returns a value of the anydata type.   public function main() {    anydata a = 5;  io:println(a);    In this example, the variable named a of the anydata type holds an int value.   int intVal = <int>a;  io:println(intVal + 10);    Before using the value of a in arithmetic operations, we need to  ascertain that it is indeed an int. A type cast or  a type guard can be used for this.   if (a is int) {  io:println(a + 20);  }    int[] ia = [1, 3, 5, 6];  anydata ar = ia;  io:println(ar);    A variable of type anydata can hold any value of an anydata compatible type.   io:println(getValue()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run anydata_type.bal 5 15 25 1 3 5 6 cat    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/arrays.html","name":"Arrays","summary":"Arrays are mutable lists of values of dynamic length in which each member in the list is\n of the same type.\n A fixed length array can be created by specifying the length of the array at the time of declaration.Creates an int array of length 0.Creates an array specifying an ...","content":"/  /  /  / Arrays  import ballerina/io;  public function main() {  // Creates an `int` array of length 0.  int[] a = [];  io:println(a.length());   // Creates an array specifying an array literal.  int[] b = [1, 2, 3, 4, 5, 6, 7, 8];  io:println(b[0]);  io:println(b.length());   // Arrays support several inbuilt functions such as `.reverse()`, `.pop()`, `.push()`, and `.removeAll()`.  int[] bReveresed = b.reverse();  io:println(\"Reversed: \", bReveresed);   io:println(\"Before pop: \", b);  int poppedValue = b.pop();  io:println(\"Popped value: \", poppedValue);  io:println(\"After pop: \", b);   // Arrays are an iterable type and arrays support functional iteration operations such as `.map()`, `.filter()`, and  // `.reduce()`.  int[] doubled = b.map(function (int value) returns int {  return value * 2;  });  io:println(\"Doubled: \", doubled);   // Unless the length is explicitly specified or is expected to be inferred, arrays are unbounded in length.  // They can grow up to any length based on the given index.  // In this example, the length of the array is 1000.  b[999] = 23;  io:println(b[999]);  io:println(b.length());   // Initializes a two dimensional `int` array.  int[][] iarray = [[1, 2, 3], [10, 20, 30], [5, 6, 7]];  io:println(iarray.length());  io:println(iarray[0].length());   // Initializes the outermost array to an empty array.  iarray = [];  // Adds a new array as the first element.  int[] d = [9];  iarray[0] = d;   // Prints the first value of the two-dimensional array.  io:println(iarray[0][0]);   // Creates an `int` array with the fixed length of five.  int[5] e = [1, 2, 3, 4, 5];  io:println(e.length());   // To infer the size of the array from the array literal, use the following syntax.  // The length of the array is set to four here.  int[*] g = [1, 2, 3, 4];  io:println(g.length()); }    Arrays  Arrays are mutable lists of values of dynamic length in which each member in the list is  of the same type.  A fixed length array can be created by specifying the length of the array at the time of declaration.    import ballerina/io;    public function main() {    int[] a = [];  io:println(a.length());    Creates an int array of length 0.   int[] b = [1, 2, 3, 4, 5, 6, 7, 8];  io:println(b[0]);  io:println(b.length());    Creates an array specifying an array literal.   int[] bReveresed = b.reverse();  io:println(\"Reversed: \", bReveresed);    Arrays support several inbuilt functions such as .reverse(), .pop(), .push(), and .removeAll().   io:println(\"Before pop: \", b);  int poppedValue = b.pop();  io:println(\"Popped value: \", poppedValue);  io:println(\"After pop: \", b);    int[] doubled = b.map(function (int value) returns int {  return value * 2;  });  io:println(\"Doubled: \", doubled);    Arrays are an iterable type and arrays support functional iteration operations such as .map(), .filter(), and  .reduce().   b[999] = 23;  io:println(b[999]);  io:println(b.length());    Unless the length is explicitly specified or is expected to be inferred, arrays are unbounded in length.  They can grow up to any length based on the given index.  In this example, the length of the array is 1000.   int[][] iarray = [[1, 2, 3], [10, 20, 30], [5, 6, 7]];  io:println(iarray.length());  io:println(iarray[0].length());    Initializes a two dimensional int array.   iarray = [];    Initializes the outermost array to an empty array.   int[] d = [9];  iarray[0] = d;    Adds a new array as the first element.   io:println(iarray[0][0]);    Prints the first value of the two-dimensional array.   int[5] e = [1, 2, 3, 4, 5];  io:println(e.length());    Creates an int array with the fixed length of five.   int[*] g = [1, 2, 3, 4];  io:println(g.length()); }    To infer the size of the array from the array literal, use the following syntax.  The length of the array is set to four here.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run arrays.bal 0 1 8 Reversed: 8 7 6 5 4 3 2 1 Before pop: 1 2 3 4 5 6 7 8 Popped value: 8 After pop: 1 2 3 4 5 6 7 Doubled: 2 4 6 8 10 12 14 23 1000 3 3 9 5 4    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/aws-lambda-deployment.html","name":"AWS Lambda Deployment","summary":"AWS Lambda is an event driven, serverless computing platform.\n Ballerina functions can be deployed in AWS Lambda by annotating a\n a Ballerina function with “@awslambda:Function”, which should have\n the function signature function (awslambda:Context, json|EventType) returns json|error.\n For more information, see the .The @awslambda:Function annotation marks a function to\n generate an ...","content":"/  /  /  / AWS Lambda Deployment  import ballerinax/awslambda; import ballerina/system; import ballerina/io;  // The `@awslambda:Function` annotation marks a function to // generate an AWS Lambda function @awslambda:Function public function echo(awslambda:Context ctx, json input) returns json {  return input; }  @awslambda:Function public function uuid(awslambda:Context ctx, json input) returns json {  return system:uuid(); }  // The `awslambda:Context` object contains request execution // context information @awslambda:Function public function ctxinfo(awslambda:Context ctx, json input) returns json|error {  json result = { RequestID: ctx.getRequestId(),  DeadlineMS: ctx.getDeadlineMs(),  InvokedFunctionArn: ctx.getInvokedFunctionArn(),  TraceID: ctx.getTraceId(),  RemainingExecTime: ctx.getRemainingExecutionTime() };  return result; }  @awslambda:Function public function notifySQS(awslambda:Context ctx, awslambda:SQSEvent event) returns json {  return event.Records[0].body; }  @awslambda:Function public function notifyS3(awslambda:Context ctx, awslambda:S3Event event) returns json {  return event.Records[0].s3.'object.key; }  @awslambda:Function public function notifyDynamoDB(awslambda:Context ctx, awslambda:DynamoDBEvent event) returns json {  return event.Records[0].dynamodb.Keys.toString(); }  @awslambda:Function public function notifySES(awslambda:Context ctx, awslambda:SESEvent event) returns json {  return event.Records[0].ses.mail.commonHeaders.subject; }  @awslambda:Function public function apigwRequest(awslambda:Context ctx, awslambda:APIGatewayProxyRequest request) {  io:println(\"Path: \", request.path); }    AWS Lambda Deployment  AWS Lambda is an event driven, serverless computing platform.  Ballerina functions can be deployed in AWS Lambda by annotating a  a Ballerina function with “@awslambda:Function”, which should have  the function signature function (awslambda:Context, json|EventType) returns json|error.  For more information, see the .    import ballerinax/awslambda; import ballerina/system; import ballerina/io;    @awslambda:Function public function echo(awslambda:Context ctx, json input) returns json {  return input; }    The @awslambda:Function annotation marks a function to  generate an AWS Lambda function   @awslambda:Function public function uuid(awslambda:Context ctx, json input) returns json {  return system:uuid(); }    @awslambda:Function public function ctxinfo(awslambda:Context ctx, json input) returns json|error {  json result = { RequestID: ctx.getRequestId(),  DeadlineMS: ctx.getDeadlineMs(),  InvokedFunctionArn: ctx.getInvokedFunctionArn(),  TraceID: ctx.getTraceId(),  RemainingExecTime: ctx.getRemainingExecutionTime() };  return result; }    The awslambda:Context object contains request execution  context information   @awslambda:Function public function notifySQS(awslambda:Context ctx, awslambda:SQSEvent event) returns json {  return event.Records[0].body; }    @awslambda:Function public function notifyS3(awslambda:Context ctx, awslambda:S3Event event) returns json {  return event.Records[0].s3.'object.key; }    @awslambda:Function public function notifyDynamoDB(awslambda:Context ctx, awslambda:DynamoDBEvent event) returns json {  return event.Records[0].dynamodb.Keys.toString(); }    @awslambda:Function public function notifySES(awslambda:Context ctx, awslambda:SESEvent event) returns json {  return event.Records[0].ses.mail.commonHeaders.subject; }    @awslambda:Function public function apigwRequest(awslambda:Context ctx, awslambda:APIGatewayProxyRequest request) {  io:println(\"Path: \", request.path); }    # Prerequisites: AWS CLI tools installation and configuration    # Build the Ballerina program to generate the AWS Lambda functions $ ballerina build functions.bal Compiling source \tfunctions.bal    Generating executables \tfunctions.jar \t@awslambda:Function: echo, uuid, ctxinfo, notifySQS, notifyS3    Run the following command to deploy each Ballerina AWS Lambda function: \taws lambda create-function --function-name $FUNCTION_NAME --zip-file fileb://aws-ballerina-lambda-functions.zip --handler functions.$FUNCTION_NAME --runtime provided --role $LAMBDA_ROLE_ARN --layers arn:aws:lambda:$REGION_ID:141896495686:layer:ballerina:2 --memory-size 512 --timeout 10    Run the following command to re-deploy an updated Ballerina AWS Lambda function: \taws lambda update-function-code --function-name $FUNCTION_NAME --zip-file fileb://aws-ballerina-lambda-functions.zip    # Execute the AWS CLI commands to create and publish the functions; and set your respective AWS $LAMBDA_ROLE_ARN, $REGION_ID, and $FUNCTION_NAME values; following are some examples:- $ aws lambda create-function --function-name echo --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.echo --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --layers arn:aws:lambda:us-west-1:141896495686:layer:ballerina:2 --memory-size 512 --timeout 10 $ aws lambda create-function --function-name uuid --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.uuid --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --layers arn:aws:lambda:us-west-1:141896495686:layer:ballerina:2 --memory-size 512 --timeout 10 $ aws lambda create-function --function-name ctxinfo --zip-file fileb://aws-ballerina-lambda-functions.zip --handler aws_lambda_deployment.ctxinfo --runtime provided --role arn:aws:iam::908363916111:role/lambda-role  --layers arn:aws:lambda:us-west-1:141896495686:layer:ballerina:2 --memory-size 512 --timeout 10    # Invoke the functions $ aws lambda invoke --function-name echo --payload '{\"MESSAGE\":\"HELLO\"}' echo-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat echo-response.txt {\"MESSAGE\":\"HELLO\"}    $ aws lambda invoke --function-name uuid uuid-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat uuid-response.txt \"711cd328-1937-40cc-9078-c3628c6edb02\"    $ aws lambda invoke --function-name ctxinfo ctxinfo-response.txt {  \"ExecutedVersion\": \"$LATEST\", \"StatusCode\": 200 } $ cat ctxinfo-response.txt {\"RequestID\":\"d55f7d06-f2ab-4b6e-8606-482607785a91\", \"DeadlineMS\":1548069389978, \"InvokedFunctionArn\":\"arn:aws:lambda:us-west-2:908363916138:function:ctxinfo\", \"TraceID\":\"Root=1-5c45aa03-f8aff4c9e24dc4fbf48f2990;Parent=17ad3b290def98fd;Sampled=0\", \"RemainingExecTime\":9946}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/async.html","name":"Async","summary":"Async functionality in Ballerina is a way to execute operations in an asynchronous manner by returning a future.\n The future can be used to extract the result of the async function call (if available), check the running status of an execution,\n or cancel the operation if needed. You can wait ...","content":"/  /  /  / Async  import ballerina/http; import ballerina/io; import ballerina/runtime;  int count = 0;  http:Client clientEndpoint = new (\"http://postman-echo.com\");  public function main() {  // Asynchronously calls the function named `sum()`.  future<int> f1 = start sum(40, 50);  // You can pass the value of the `future` variable  // and call its results later.  int result = squarePlusCube(f1);  // Waits for the future `f1` to finish.  _ = wait f1;  io:println(\"SQ + CB = \", result);   // Calls the `countInfinity()` function, which runs forever  // in asynchronous mode.  future<()> f2 = start countInfinity();   // Cancels the asynchronous execution.  f2.cancel();  io:println(\"Counting done in one second: \", count);   // Asynchronously invokes the action call `get()`.  // By default this async call runs on the same physical thread of the caller.  // `@strand` annotation allows the invocation to run parallel.  future<http:Response|error> f3 = @strand {thread:\"any\"} start clientEndpoint-> get(\"/get?test=123\");   // Waits for action call `f3` to finish.  http:Response|error response = wait f3;  // Prints the response payload of the action call if successful or prints the  // reason for the failure.  if (response is http:Response) {  io:println(response.getJsonPayload());  } else {  io:println(response.detail()?.message);  }   // Asynchronously invokes the functions named `square()` and `greet()`.  future<int> f4 = start square(20);  future<string> f5 = start greet(\"Bert\");   // You can wait for any one of the given futures to complete.  // In this example,`f4` will finish before `f5` since `runtime:sleep()` is called  // in the `greet()` function to delay its execution. The value returned  // by the future that finishes first will be taken as the result.  int|string anyResult = wait f4|f5;  io:println(anyResult);   // Asynchronously invokes the functions named `sum()`, `cube()`, and `greet()`.  future<int> f6 = start sum(40, 60);  future<int> f7 = start cube(3);  future<string> f8 = start greet(\"Moose\");  // A `runtime:sleep` is added to delay the execution.  runtime:sleep(2000);   // You can wait for all the given futures to complete.  // The result of this `wait` action can be assigned to a map or a record.  // If the result is a map, it will contain the returned values from each  // future with the key as the name of the future (if a key is not provided).  map<int|string> resultMap = wait {first_field: f6, second_field: f7,  third_field: f8};  io:println(resultMap);    // If the result is a record, it will contain the returned values from each  // future with the field name as the name of the future (if a field name is  // not provided).  record {int first_field; int second_field; string third_field;} rec =  wait {first_field: f6, second_field: f7, third_field: f8};  io:println(\"first field of record --> \", rec.first_field);  io:println(\"second field of record --> \", rec.second_field);  io:println(\"third field of record --> \", rec.third_field); }  function sum(int a, int b) returns int {  return a + b; }  function square(int n) returns int {  return n * n; }  function cube(int n) returns int {  return n * n * n; }  function greet(string name) returns string {  // A `runtime:sleep` is added to delay the execution.  runtime:sleep(2000);  return \"Hello \" + name + \"!!\"; }  function squarePlusCube(future<int> f) returns int {  worker w1 {  int n = wait f;  int sq = square(n);  sq -> w2;  }  worker w2 returns int {  int n = wait f;  int cb = cube(n);  int sq;  sq = <- w1;  return sq + cb;  }  // Waits for the worker `W2` to complete.  return wait w2; }  function countInfinity() {  while (true) {  runtime:sleep(1);  count += 1;  } }    Async  Async functionality in Ballerina is a way to execute operations in an asynchronous manner by returning a future.  The future can be used to extract the result of the async function call (if available), check the running status of an execution,  or cancel the operation if needed. You can wait for a future to complete using the wait action.    import ballerina/http; import ballerina/io; import ballerina/runtime;    int count = 0;    http:Client clientEndpoint = new (\"http://postman-echo.com\");    public function main() {    future<int> f1 = start sum(40, 50);    Asynchronously calls the function named sum().   int result = squarePlusCube(f1);    You can pass the value of the future variable  and call its results later.   _ = wait f1;  io:println(\"SQ + CB = \", result);    Waits for the future f1 to finish.   future<()> f2 = start countInfinity();    Calls the countInfinity() function, which runs forever  in asynchronous mode.   f2.cancel();  io:println(\"Counting done in one second: \", count);    Cancels the asynchronous execution.   future<http:Response|error> f3 = @strand {thread:\"any\"} start clientEndpoint-> get(\"/get?test=123\");    Asynchronously invokes the action call get().  By default this async call runs on the same physical thread of the caller.  @strand annotation allows the invocation to run parallel.   http:Response|error response = wait f3;    Waits for action call f3 to finish.   if (response is http:Response) {  io:println(response.getJsonPayload());  } else {  io:println(response.detail()?.message);  }    Prints the response payload of the action call if successful or prints the  reason for the failure.   future<int> f4 = start square(20);  future<string> f5 = start greet(\"Bert\");    Asynchronously invokes the functions named square() and greet().   int|string anyResult = wait f4|f5;  io:println(anyResult);    You can wait for any one of the given futures to complete.  In this example,f4 will finish before f5 since runtime:sleep() is called  in the greet() function to delay its execution. The value returned  by the future that finishes first will be taken as the result.   future<int> f6 = start sum(40, 60);  future<int> f7 = start cube(3);  future<string> f8 = start greet(\"Moose\");    Asynchronously invokes the functions named sum(), cube(), and greet().   runtime:sleep(2000);    A runtime:sleep is added to delay the execution.   map<int|string> resultMap = wait {first_field: f6, second_field: f7,  third_field: f8};  io:println(resultMap);    You can wait for all the given futures to complete.  The result of this wait action can be assigned to a map or a record.  If the result is a map, it will contain the returned values from each  future with the key as the name of the future (if a key is not provided).   record {int first_field; int second_field; string third_field;} rec =  wait {first_field: f6, second_field: f7, third_field: f8};  io:println(\"first field of record --> \", rec.first_field);  io:println(\"second field of record --> \", rec.second_field);  io:println(\"third field of record --> \", rec.third_field); }    If the result is a record, it will contain the returned values from each  future with the field name as the name of the future (if a field name is  not provided).   function sum(int a, int b) returns int {  return a + b; }    function square(int n) returns int {  return n * n; }    function cube(int n) returns int {  return n * n * n; }    function greet(string name) returns string {    runtime:sleep(2000);  return \"Hello \" + name + \"!!\"; }    A runtime:sleep is added to delay the execution.   function squarePlusCube(future<int> f) returns int {  worker w1 {  int n = wait f;  int sq = square(n);  sq -> w2;  }  worker w2 returns int {  int n = wait f;  int cb = cube(n);  int sq;  sq = <- w1;  return sq + cb;  }    return wait w2; }    Waits for the worker W2 to complete.   function countInfinity() {  while (true) {  runtime:sleep(1);  count += 1;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run async.bal SQ + CB = 737100 Counting done in one second: 0 args=test=123 headers=x-forwarded-proto=https host=postman-echo.com user-agent=ballerina/1.2.0 x-forwarded-port=80 url=https://postman-echo.com/get?test=123 400 first_field=100 second_field=27 third_field=Hello Moose!! first field of record --> 100 second field of record --> 27 third field of record --> Hello Moose!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/ballerina-to-openapi.html","name":"Ballerina To OpenAPI","summary":"The Ballerina to OpenApi tool is used to generate an OpenAPI Specification(OAS) v3 definition of a Ballerina service.\n This tool’s command structure is as below.\n ballerina openapi gen-contract [<module>:]<service-name> [-i <ballerina-file>] [-o <contract-file>] [-s|--skip-bind] [-h|--help]This website uses cookies so that we can provide you with the best user experience. Read ...","content":"/  /  /  / Ballerina To OpenAPI  import ballerina/http; import ballerina/log;  listener http:Listener helloEp = new (9090);  service hello on helloEp {  resource function hi(http:Caller caller, http:Request request) {  http:Response res = new;  res.setPayload(\"Hello World!\");   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Ballerina To OpenAPI  The Ballerina to OpenApi tool is used to generate an OpenAPI Specification(OAS) v3 definition of a Ballerina service.  This tool’s command structure is as below.  ballerina openapi gen-contract [<module>:]<service-name> [-i <ballerina-file>] [-o <contract-file>] [-s|--skip-bind] [-h|--help]    import ballerina/http; import ballerina/log;    listener http:Listener helloEp = new (9090);    service hello on helloEp {  resource function hi(http:Caller caller, http:Request request) {  http:Response res = new;  res.setPayload(\"Hello World!\");    var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To export the OpenAPI definition of ballerina service `hello`, navigate to the directory that contains the # `ballerina_to_openapi.bal` file, and execute `ballerina openapi gen-contract` command below. ballerina openapi gen-contract hello -i ballerina_to_openapi.bal Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Successfully generated the ballerina contract at location /examples/ballerina-to-openapi/hello.openapi.yaml    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/base-path-and-path.html","name":"Base Path and Path","summary":"Ballerina supports writing RESTful services according to the JAX-RS specification.\n You can use BasePath, Path, and HTTP verb annotations such as POST and GET to\n constrain your service in a RESTful manner.The basePath attribute associates a path to the service.\n When bound to a listener endpoint, the service will be ...","content":"/  /  /  / Base Path and Path  import ballerina/http; import ballerina/log;  // The `basePath` attribute associates a path to the service. // When bound to a listener endpoint, the service will be accessible at the specified path. @http:ServiceConfig {  basePath: \"/foo\" } service echo on new http:Listener(9090) {  // When the `methods` attribute is used, it confines the resource to the HTTP methods specified.  // In this instance, only `POST` requests are allowed.  // The `path` attribute associates a subpath to the resource (i.e., relative to the `basePath` given in the `ServiceConfig` annotation).  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/bar\"  }  resource function echo(http:Caller caller, http:Request req) {  // This method retrieves the request payload as a JSON.  var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {  // Since the JSON is known to be valid, `untaint` the data denoting that the data is trusted and set the JSON to the response.  res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  }  // Reply to the client with the response.  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Base Path and Path  Ballerina supports writing RESTful services according to the JAX-RS specification.  You can use BasePath, Path, and HTTP verb annotations such as POST and GET to  constrain your service in a RESTful manner.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/foo\" } service echo on new http:Listener(9090) {    The basePath attribute associates a path to the service.  When bound to a listener endpoint, the service will be accessible at the specified path.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/bar\"  }  resource function echo(http:Caller caller, http:Request req) {    When the methods attribute is used, it confines the resource to the HTTP methods specified.  In this instance, only POST requests are allowed.  The path attribute associates a subpath to the resource (i.e., relative to the basePath given in the ServiceConfig annotation).   var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {    This method retrieves the request payload as a JSON.   res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  }    Since the JSON is known to be valid, untaint the data denoting that the data is trusted and set the JSON to the response.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Reply to the client with the response.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run base_path_and_path.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run this curl command below to use the client. curl http://localhost:9090/foo/bar -d \"{\\\"hello\\\": \\\"world\\\"}\" -H \"Content-Type: application/json\" {\"hello\": \"world\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/basic-documentation.html","name":"Basic documentation","summary":"Documentation attachments allow you to document different Ballerina constructs such as functions, records, objects, and listeners that are defined in modules.\n These attachments are used by Docerina (i.e., the Ballerina documentation generation tool) to generate API documentation for the modules.This is the documentation attachment of the DummyObject object.This is the ...","content":"/  /  /  / Basic documentation  import ballerina/io;  public function main() {  io:println(\"Documentation attachments are non executable constructs.\"); }  // This is the documentation attachment of the `DummyObject` object. # The `DummyObject` is a user-defined object. # This `DummyObject` has two `string` data fields and a # function definition (i.e., `doThatOnObject`), which performs a certain # functionality on the associated `DummyObject` instance. # # + fieldOne - This is the description of the `DummyObject`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyObject`'s `fieldTwo` field. public type DummyObject abstract object {   public string fieldOne;  public string fieldTwo;   // This is the documentation attachment of the `doThatOnObject` function.  # The `doThatOnObject` function is attached to the `DummyObject` object.  #  # + paramOne - This is the description of the parameter of  # the `doThatOnObject` function.  # + return - This is the description of the return value of  # the `doThatOnObject` function.  public function doThatOnObject(string paramOne) returns boolean; };  // This is the documentation attachment of the `DummyRecord` record. # `DummyRecord` is a user-defined record. # This `DummyRecord` has a `string` data field and an `int` data field. # # + fieldOne - This is the description of the `DummyRecord`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyRecord`'s `fieldTwo` field. public type DummyRecord record {  string fieldOne;  int fieldTwo; };  // This is the documentation attachment of the `dummyFunction` function. # This function returns the `fieldTwo` field of the `DummyRecord`-typed # record value passed as an argument. # # + recordValue - Parameter of type `DummyRecord`. # + return - The `fieldTwo` field of the record value passed as an argument. public function dummyFunction(DummyRecord recordValue) returns int {  return recordValue.fieldTwo; }    Basic documentation  Documentation attachments allow you to document different Ballerina constructs such as functions, records, objects, and listeners that are defined in modules.  These attachments are used by Docerina (i.e., the Ballerina documentation generation tool) to generate API documentation for the modules.    import ballerina/io;    public function main() {  io:println(\"Documentation attachments are non executable constructs.\"); }    # The `DummyObject` is a user-defined object. # This `DummyObject` has two `string` data fields and a # function definition (i.e., `doThatOnObject`), which performs a certain # functionality on the associated `DummyObject` instance. # # + fieldOne - This is the description of the `DummyObject`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyObject`'s `fieldTwo` field. public type DummyObject abstract object {    This is the documentation attachment of the DummyObject object.   public string fieldOne;  public string fieldTwo;    # The `doThatOnObject` function is attached to the `DummyObject` object.  #  # + paramOne - This is the description of the parameter of  # the `doThatOnObject` function.  # + return - This is the description of the return value of  # the `doThatOnObject` function.  public function doThatOnObject(string paramOne) returns boolean; };    This is the documentation attachment of the doThatOnObject function.   # `DummyRecord` is a user-defined record. # This `DummyRecord` has a `string` data field and an `int` data field. # # + fieldOne - This is the description of the `DummyRecord`'s `fieldOne` field. # + fieldTwo - This is the description of the `DummyRecord`'s `fieldTwo` field. public type DummyRecord record {  string fieldOne;  int fieldTwo; };    This is the documentation attachment of the DummyRecord record.   # This function returns the `fieldTwo` field of the `DummyRecord`-typed # record value passed as an argument. # # + recordValue - Parameter of type `DummyRecord`. # + return - The `fieldTwo` field of the record value passed as an argument. public function dummyFunction(DummyRecord recordValue) returns int {  return recordValue.fieldTwo; }    This is the documentation attachment of the dummyFunction function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run basic_documentation.bal Documentation attachments are non executable constructs.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/binary-bitwise-expressions.html","name":"Binary Bitwise Expressions","summary":"Ballerina supports three bitwise binary expressions; AND, OR, and XOR.\n Both operands should have static types that are subtypes of the int type.\n All bitwise binary operations are based on the 64-bit representations of the values.For a bitwise “AND” (&) expression, if the type of either operand is a subtype ...","content":"/  /  /  / Binary Bitwise Expressions  import ballerina/io; import ballerina/lang.'int;  public function main() {  int a = 385;  'int:Unsigned8 b = 128;  // For a bitwise \"AND\" (`&`) expression, if the type of either operand is a subtype of  // `int:UnsignedK` when K is 8, 16 or 32, then the type of the result is `int:UnsignedN`  // where N is the smallest such K.  'int:Unsigned8 res1 = a & b;  io:println(\"`int` 385 & `int:Unsigned8` 128: \", res1);   'int:Signed16 c = -32700;  int d = 249;  // Else, if neither operand is of a type that is a subtype of an unsigned `int` type,  // the type of the result for a bitwise \"AND\" expression is `int`.  int res2 = c & d;  io:println(\"`int:Signed16` -32700 & `int` 249: \", res2);   'int:Unsigned8 e = 254;  'int:Unsigned16 f = 511;  // For bitwise \"OR\" (`|`) and \"XOR\" (`^`) expressions, if the types of both operands are  // subtypes of `int:UnsignedK` when K is 8, 16 or 32, then the type of the result is  // `int:UnsignedN` where N is the smallest such K.  'int:Unsigned8 res3 = e | f;  io:println(\"`int:Unsigned8` 254 | `int:Unsigned16` 511: \", res3);  'int:Unsigned8 res4 = e ^ f;  io:println(\"`int:Unsigned8` 254 ^ `int:Unsigned16` 511: \", res4);   int g = 12345678;  'int:Signed8 h = -127;  // Else, if at least one operand's type is not a subtype of an unsigned `int` type,  // the type of the result for a bitwise \"OR\" or \"XOR\" expression is `int`.  int res5 = g | h;  io:println(\"`int` 12345678 | `int:Signed8` -127: \", res5);  int res6 = g ^ h;  io:println(\"`int` 12345678 ^ `int:Signed8` -127: \", res6); }    Binary Bitwise Expressions  Ballerina supports three bitwise binary expressions; AND, OR, and XOR.  Both operands should have static types that are subtypes of the int type.  All bitwise binary operations are based on the 64-bit representations of the values.    import ballerina/io; import ballerina/lang.'int;    public function main() {  int a = 385;  'int:Unsigned8 b = 128;    'int:Unsigned8 res1 = a & b;  io:println(\"`int` 385 & `int:Unsigned8` 128: \", res1);    For a bitwise “AND” (&) expression, if the type of either operand is a subtype of  int:UnsignedK when K is 8, 16 or 32, then the type of the result is int:UnsignedN  where N is the smallest such K.   'int:Signed16 c = -32700;  int d = 249;    int res2 = c & d;  io:println(\"`int:Signed16` -32700 & `int` 249: \", res2);    Else, if neither operand is of a type that is a subtype of an unsigned int type,  the type of the result for a bitwise “AND” expression is int.   'int:Unsigned8 e = 254;  'int:Unsigned16 f = 511;    'int:Unsigned8 res3 = e | f;  io:println(\"`int:Unsigned8` 254 | `int:Unsigned16` 511: \", res3);  'int:Unsigned8 res4 = e ^ f;  io:println(\"`int:Unsigned8` 254 ^ `int:Unsigned16` 511: \", res4);    For bitwise “OR” (|) and “XOR” (^) expressions, if the types of both operands are  subtypes of int:UnsignedK when K is 8, 16 or 32, then the type of the result is  int:UnsignedN where N is the smallest such K.   int g = 12345678;  'int:Signed8 h = -127;    int res5 = g | h;  io:println(\"`int` 12345678 | `int:Signed8` -127: \", res5);  int res6 = g ^ h;  io:println(\"`int` 12345678 ^ `int:Signed8` -127: \", res6); }    Else, if at least one operand’s type is not a subtype of an unsigned int type,  the type of the result for a bitwise “OR” or “XOR” expression is int.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run binary_bitwise_expressions.bal `int` 385 & `int:Unsigned8` 128: 128 `int:Signed16` -32700 & `int` 249: 64 `int:Unsigned8` 254 | `int:Unsigned16` 511: 255 `int:Unsigned8` 254 ^ `int:Unsigned16` 511: 1 `int` 12345678 | `int:Signed8` -127: -49 `int` 12345678 ^ `int:Signed8` -127: -12345649    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/azure-functions-deployment.html","name":"Azure Functions Deployment","summary":"Azure Functions is an event driven, serverless computing platform.\n Ballerina functions can be deployed in Azure Functions by annotating a Ballerina function with “@functions:Function”.\n For more information, see .HTTP request/response with no authenticationHTTP request to add data to a queueA message put to a queue is copied to another queueA ...","content":"/  /  /  / Azure Functions Deployment  import ballerina/http; import ballerina/system; import ballerinax/azure.functions as af;  // HTTP request/response with no authentication @af:Function public function hello(@af:HTTPTrigger { authLevel: \"anonymous\" } http:Request req) returns @af:HTTPOutput string|error {  return \"Hello, \" + check <@untainted> req.getTextPayload() + \"!\"; }  // HTTP request to add data to a queue @af:Function public function fromHttpToQueue(af:Context ctx, @af:HTTPTrigger {} af:HTTPRequest req, @af:QueueOutput { queueName: \"queue1\" } af:StringOutputBinding msg) returns @af:HTTPOutput af:HTTPBinding {  msg.value = req.body;  return { statusCode: 200, payload: \"Request: \" + req.toString() }; }  // A message put to a queue is copied to another queue @af:Function public function fromQueueToQueue(af:Context ctx, @af:QueueTrigger { queueName: \"queue2\" } string inMsg,  @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  ctx.log(\"In Message: \" + inMsg);  ctx.log(\"Metadata: \" + ctx.metadata.toString());  outMsg.value = inMsg; }  // A blob added to a container is copied to a queue @af:Function public function fromBlobToQueue(af:Context ctx, @af:BlobTrigger { path: \"bpath1/{name}\" } byte[] blobIn,  @af:BindingName { } string name,  @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) returns error? {  outMsg.value = \"Name: \" + name + \" Content: \" + blobIn.toString(); }  // HTTP request to read a blob value @af:Function public function httpTriggerBlobInput(@af:HTTPTrigger { } af:HTTPRequest req, @af:BlobInput { path: \"bpath1/{Query.name}\" } byte[]? blobIn)  returns @af:HTTPOutput string {  int length = 0;  if blobIn is byte[] {  length = blobIn.length();  }  return \"Blob: \" + req.query[\"name\"].toString() + \" Length: \" + length.toString() + \" Content: \" + blobIn.toString(); }  // HTTP request to add a new blob @af:Function public function httpTriggerBlobOutput(@af:HTTPTrigger { } af:HTTPRequest req, @af:BlobOutput { path: \"bpath1/{Query.name}\" } af:StringOutputBinding bb)  returns @af:HTTPOutput string|error {  bb.value = req.body;  return \"Blob: \" + req.query[\"name\"].toString() + \" Content: \" + bb?.value.toString(); }  // Sending an SMS @af:Function public function sendSMS(@af:HTTPTrigger { } af:HTTPRequest req, @af:TwilioSmsOutput { fromNumber: \"+12069845840\" } af:TwilioSmsOutputBinding tb)  returns @af:HTTPOutput string {  tb.to = req.query[\"to\"].toString();  tb.body = req.body.toString();  return \"Message - to: \" + tb?.to.toString() + \" body: \" + tb?.body.toString(); }  public type Person record {  string id;  string name;  int birthYear; };  // CosmosDB record trigger @af:Function public function cosmosDBToQueue1(@af:CosmosDBTrigger { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } Person[] req, @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  outMsg.value = req.toString(); }  @af:Function public function cosmosDBToQueue2(@af:CosmosDBTrigger { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c2\" } json req, @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  outMsg.value = req.toString(); }  // HTTP request to read CosmosDB records @af:Function public function httpTriggerCosmosDBInput1(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", id: \"{Query.id}\" } json dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }  @af:Function public function httpTriggerCosmosDBInput2(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", id: \"{Query.id}\" } Person? dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }  @af:Function public function httpTriggerCosmosDBInput3(@af:HTTPTrigger { route: \"c1/{country}\" } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", sqlQuery: \"select * from c1 where c1.country = {country}\" } Person[] dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }  // HTTP request to write records to CosmosDB @af:Function public function httpTriggerCosmosDBOutput1(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:HTTPOutput af:HTTPBinding hb) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } json {  json entry = { id: system:uuid(), name: \"John Doe\", birthYear: 1980 };  hb.payload = \"Adding entry: \" + entry.toString();  return entry; }  @af:Function public function httpTriggerCosmosDBOutput2(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:HTTPOutput af:HTTPBinding hb) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } json {  json entry = [{ id: system:uuid(), name: \"John Doe A\", birthYear: 1985 }, { id: system:uuid(), name: \"John Doe B\", birthYear: 1990 }];  hb.payload = \"Adding entries: \" + entry.toString();  return entry; }  @af:Function public function httpTriggerCosmosDBOutput3(@af:HTTPTrigger { } af:HTTPRequest httpReq) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } Person[] {  Person[] persons = [];  persons.push({id: system:uuid(), name: \"Jack\", birthYear: 2001});  persons.push({id: system:uuid(), name: \"Will\", birthYear: 2005});  return persons; }  // A timer function which is executed every 10 seconds. @af:Function public function queuePopulationTimer(@af:TimerTrigger { schedule: \"*/10 * * * * *\" } json triggerInfo, @af:QueueOutput { queueName: \"queue4\" } af:StringOutputBinding msg) {  msg.value = triggerInfo.toString(); }    Azure Functions Deployment  Azure Functions is an event driven, serverless computing platform.  Ballerina functions can be deployed in Azure Functions by annotating a Ballerina function with “@functions:Function”.  For more information, see .    import ballerina/http; import ballerina/system; import ballerinax/azure.functions as af;    @af:Function public function hello(@af:HTTPTrigger { authLevel: \"anonymous\" } http:Request req) returns @af:HTTPOutput string|error {  return \"Hello, \" + check <@untainted> req.getTextPayload() + \"!\"; }    HTTP request/response with no authentication   @af:Function public function fromHttpToQueue(af:Context ctx, @af:HTTPTrigger {} af:HTTPRequest req, @af:QueueOutput { queueName: \"queue1\" } af:StringOutputBinding msg) returns @af:HTTPOutput af:HTTPBinding {  msg.value = req.body;  return { statusCode: 200, payload: \"Request: \" + req.toString() }; }    HTTP request to add data to a queue   @af:Function public function fromQueueToQueue(af:Context ctx, @af:QueueTrigger { queueName: \"queue2\" } string inMsg,  @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  ctx.log(\"In Message: \" + inMsg);  ctx.log(\"Metadata: \" + ctx.metadata.toString());  outMsg.value = inMsg; }    A message put to a queue is copied to another queue   @af:Function public function fromBlobToQueue(af:Context ctx, @af:BlobTrigger { path: \"bpath1/{name}\" } byte[] blobIn,  @af:BindingName { } string name,  @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) returns error? {  outMsg.value = \"Name: \" + name + \" Content: \" + blobIn.toString(); }    A blob added to a container is copied to a queue   @af:Function public function httpTriggerBlobInput(@af:HTTPTrigger { } af:HTTPRequest req, @af:BlobInput { path: \"bpath1/{Query.name}\" } byte[]? blobIn)  returns @af:HTTPOutput string {  int length = 0;  if blobIn is byte[] {  length = blobIn.length();  }  return \"Blob: \" + req.query[\"name\"].toString() + \" Length: \" + length.toString() + \" Content: \" + blobIn.toString(); }    HTTP request to read a blob value   @af:Function public function httpTriggerBlobOutput(@af:HTTPTrigger { } af:HTTPRequest req, @af:BlobOutput { path: \"bpath1/{Query.name}\" } af:StringOutputBinding bb)  returns @af:HTTPOutput string|error {  bb.value = req.body;  return \"Blob: \" + req.query[\"name\"].toString() + \" Content: \" + bb?.value.toString(); }    HTTP request to add a new blob   @af:Function public function sendSMS(@af:HTTPTrigger { } af:HTTPRequest req, @af:TwilioSmsOutput { fromNumber: \"+12069845840\" } af:TwilioSmsOutputBinding tb)  returns @af:HTTPOutput string {  tb.to = req.query[\"to\"].toString();  tb.body = req.body.toString();  return \"Message - to: \" + tb?.to.toString() + \" body: \" + tb?.body.toString(); }    Sending an SMS   public type Person record {  string id;  string name;  int birthYear; };    @af:Function public function cosmosDBToQueue1(@af:CosmosDBTrigger { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } Person[] req, @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  outMsg.value = req.toString(); }    CosmosDB record trigger   @af:Function public function cosmosDBToQueue2(@af:CosmosDBTrigger { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c2\" } json req, @af:QueueOutput { queueName: \"queue3\" } af:StringOutputBinding outMsg) {  outMsg.value = req.toString(); }    @af:Function public function httpTriggerCosmosDBInput1(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", id: \"{Query.id}\" } json dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }    HTTP request to read CosmosDB records   @af:Function public function httpTriggerCosmosDBInput2(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", id: \"{Query.id}\" } Person? dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }    @af:Function public function httpTriggerCosmosDBInput3(@af:HTTPTrigger { route: \"c1/{country}\" } af:HTTPRequest httpReq, @af:CosmosDBInput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\", sqlQuery: \"select * from c1 where c1.country = {country}\" } Person[] dbReq)  returns @af:HTTPOutput string|error {  return dbReq.toString(); }    @af:Function public function httpTriggerCosmosDBOutput1(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:HTTPOutput af:HTTPBinding hb) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } json {  json entry = { id: system:uuid(), name: \"John Doe\", birthYear: 1980 };  hb.payload = \"Adding entry: \" + entry.toString();  return entry; }    HTTP request to write records to CosmosDB   @af:Function public function httpTriggerCosmosDBOutput2(@af:HTTPTrigger { } af:HTTPRequest httpReq, @af:HTTPOutput af:HTTPBinding hb) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } json {  json entry = [{ id: system:uuid(), name: \"John Doe A\", birthYear: 1985 }, { id: system:uuid(), name: \"John Doe B\", birthYear: 1990 }];  hb.payload = \"Adding entries: \" + entry.toString();  return entry; }    @af:Function public function httpTriggerCosmosDBOutput3(@af:HTTPTrigger { } af:HTTPRequest httpReq) returns @af:CosmosDBOutput { connectionStringSetting: \"CosmosDBConnection\", databaseName: \"db1\", collectionName: \"c1\" } Person[] {  Person[] persons = [];  persons.push({id: system:uuid(), name: \"Jack\", birthYear: 2001});  persons.push({id: system:uuid(), name: \"Will\", birthYear: 2005});  return persons; }    @af:Function public function queuePopulationTimer(@af:TimerTrigger { schedule: \"*/10 * * * * *\" } json triggerInfo, @af:QueueOutput { queueName: \"queue4\" } af:StringOutputBinding msg) {  msg.value = triggerInfo.toString(); }    A timer function which is executed every 10 seconds.   # Prerequisites: Azure CLI tools installation and configuration    # Build the Ballerina program to generate the Azure Functions ballerina build azure_functions_deployment.bal Compiling source \tazure_functions_deployment.bal    Generating executables \tazure_functions_deployment.jar \t@azure.functions:Function: hello, fromHttpToQueue, fromQueueToQueue, fromBlobToQueue, httpTriggerBlobInput, httpTriggerBlobOutput, sendSMS, cosmosDBToQueue1, cosmosDBToQueue2, httpTriggerCosmosDBInput1, httpTriggerCosmosDBInput2, httpTriggerCosmosDBInput3, httpTriggerCosmosDBOutput1, httpTriggerCosmosDBOutput2, httpTriggerCosmosDBOutput3, queuePopulationTimer    Run the following command to deploy Ballerina Azure Functions: \taz functionapp deployment source config-zip -g <resource_group> -n <function_app_name> --src azure-functions.zip    # Execute the following Azure CLI command to publish the functions (replace with your respective Azure <resource_group> and <function_app_name>) az functionapp deployment source config-zip -g functions1777 -n functions1777 --src azure-functions.zip Getting scm site credentials for zip deployment Starting zip deployment. This operation can take a while to complete ... Deployment endpoint responded with status code 202 {  \"active\": true,  \"author\": \"N/A\",  \"author_email\": \"N/A\",  \"complete\": true,  \"deployer\": \"ZipDeploy\",  \"end_time\": \"2020-07-02T06:48:08.7706207Z\",  \"id\": \"2bacf185fb114d42aab762dfd5f303dc\",  \"is_readonly\": true,  \"is_temp\": false,  \"last_success_end_time\": \"2020-07-02T06:48:08.7706207Z\",  \"log_url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest/log\",  \"message\": \"Created via a push deployment\",  \"progress\": \"\",  \"provisioningState\": null,  \"received_time\": \"2020-07-02T06:47:56.2756472Z\",  \"site_name\": \"functions1777\",  \"start_time\": \"2020-07-02T06:47:56.7600364Z\",  \"status\": 4,  \"status_text\": \"\",  \"url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest\" }    # Invoke the functions (replace with your <auth_code> value in authenticated requests) curl -d \"Jack\" https://functions1777.azurewebsites.net/api/hello Hello, Jack!    curl -d \"ABCDE\" https://functions1777.azurewebsites.net/api/fromHttpToQueue?code=<auth_code> Request: url=https://functions1777.azurewebsites.net/api/fromHttpToQueue... body=ABCDE    curl \"https://functions1777.azurewebsites.net/api/httpTriggerBlobInput?name=input.txt&code=<auth_code>\" Blob: input.txt Length: 6 Content: 65 66 67 68 69 10    curl -d \"123456\" \"https://functions1777.azurewebsites.net/api/httpTriggerBlobOutput?name=payload.txt&code=<auth_code>\" Blob: payload.txt Content: 123456    curl -d \"Hello!\" \"https://functions1777.azurewebsites.net/api/sendSMS?to=xxxxxxxxxx&code=<auth_code>\" Message - to: xxxxxxxxxx body: Hello!    curl \"https://functions1777.azurewebsites.net/api/httpTriggerCosmosDBInput1?id=id1&code=<auth_code>\" id=id1 _rid=zEkwANYTRPoFAAAAAAAAAA== _self=dbs/zEkwAA==/colls/zEkwANYTRPo=/docs/zEkwANYTRPoFAAAAAAAAAA==/ _ts=1591201470 _etag=\"10009f6c-0000-0100-0000-5ed7cebe0000\" name=Tom birthYear=1950 country=Sri Lanka pk=p1    curl \"https://functions1777.azurewebsites.net/api/httpTriggerCosmosDBInput2?id=id1&code=<auth_code>\" id=id1 name=Tom birthYear=1950 _rid=zEkwANYTRPoFAAAAAAAAAA== _self=dbs/zEkwAA==/colls/zEkwANYTRPo=/docs/zEkwANYTRPoFAAAAAAAAAA==/ _ts=1591201470 _etag=\"10009f6c-0000-0100-0000-5ed7cebe0000\" country=Sri Lanka pk=p1    curl \"https://functions1777.azurewebsites.net/api/c1/Sri%20Lanka?code=<auth_code>\" id=id3 name=Jack X birthYear=1950 country=Sri Lanka pk=p1 _rid=zEkwANYTRPoEAAAAAAAAAA== _self=dbs/zEkwAA==/colls/zEkwANYTRPo=/docs/zEkwANYTRPoEAAAAAAAAAA==/ _etag=\"1000076b-0000-0100-0000-5ed7cc110000\" _attachments=attachments/ _ts=1591200785 id=id4 name=Tom birthYear=1950 country=Sri Lanka pk=p1 _rid=zEkwANYTRPoFAAAAAAAAAA== _self=dbs/zEkwAA==/colls/zEkwANYTRPo=/docs/zEkwANYTRPoFAAAAAAAAAA==/ _etag=\"10009f6c-0000-0100-0000-5ed7cebe0000\" _attachments=attachments/ _ts=1591201470    curl https://functions1777.azurewebsites.net/api/httpTriggerCosmosDBOutput1?code=<auth_code> Adding entry: id=abf42517-53d7-4fa3-a30c-87cb65e9597d name=John Doe birthYear=1980    curl https://functions1777.azurewebsites.net/api/httpTriggerCosmosDBOutput2?code=<auth_code> Adding entries: id=f510e0d2-5341-4901-8c12-9aac1b212378 name=John Doe A birthYear=1985 id=cc145a0f-cb4f-4a5f-8d0f-fbf01209aa2d name=John Doe B birthYear=1990    curl https://functions1777.azurewebsites.net/api/httpTriggerCosmosDBOutput3?code=<auth_code> [{\"id\":\"4ba53cb4-47a1-4028-af7b-2515f0a9c6bf\",\"name\":\"Jack\",\"birthYear\":2001},{\"id\":\"5b8a6697-c9e9-488d-91b3-3942574efeef\",\"name\":\"Will\",\"birthYear\":2005}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/basic-https-listener-client.html","name":"Basic HTTPS Listener Client","summary":"This example demonstrates how the Ballerina https client can be configured to connect to an https listener through 1-way SSL connection (i.e., the server is verified by the client). This example uses the Ballerina https listener to host a service and the https client sends requests for that listener.helloWorldEP listener ...","content":"/  /  /  / Basic HTTPS Listener Client  import ballerina/config; import ballerina/http; import ballerina/log;  // `helloWorldEP` listener endpoint is configured to communicate through HTTPS. // It is configured to listen on port 9095. As this is an HTTPS Listener, // it is required to give the PKCS12 keystore file location and its password. http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };  listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  // Send the response back to the `caller`.  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond\", result);  }  } } import ballerina/config; import ballerina/http; import ballerina/log;  // This is a client endpoint configured to connect to the HTTPS service. // As this is a 1-way SSL connection, the client needs to provide // trust store file path and its password. http:ClientConfiguration clientEPConfig = {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };  public function main() {  // Create an HTTP client to interact with the created listener endpoint.  http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);  // Sends an outbound request.  var resp = clientEP->get(\"/hello/\");  if (resp is http:Response) {  // If the request is successful, retrieve the text payload from the  // response.  var payload = resp.getTextPayload();  if (payload is string) {  // Log the retrieved text paylod.  log:printInfo(payload);  } else {  // If an error occurs when retrieving the text payload, log the error.  log:printError(<string>payload.detail()[\"message\"]);  }  } else {  // If an error occurs when getting the response, log the error.  log:printError(<string>resp.detail()[\"message\"]);  } }    Basic HTTPS Listener Client  This example demonstrates how the Ballerina https client can be configured to connect to an https listener through 1-way SSL connection (i.e., the server is verified by the client). This example uses the Ballerina https listener to host a service and the https client sends requests for that listener.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    helloWorldEP listener endpoint is configured to communicate through HTTPS.  It is configured to listen on port 9095. As this is an HTTPS Listener,  it is required to give the PKCS12 keystore file location and its password.   listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Failed to respond\", result);  }  } }    Send the response back to the caller.   # To start the service and run the main function, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below along with the Ballerina home path as a config. ballerina run basic_https_listener.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    This is a client endpoint configured to connect to the HTTPS service.  As this is a 1-way SSL connection, the client needs to provide  trust store file path and its password.   public function main() {    http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);    Create an HTTP client to interact with the created listener endpoint.   var resp = clientEP->get(\"/hello/\");  if (resp is http:Response) {    Sends an outbound request.   var payload = resp.getTextPayload();  if (payload is string) {    If the request is successful, retrieve the text payload from the  response.   log:printInfo(payload);  } else {    Log the retrieved text paylod.   log:printError(<string>payload.detail()[\"message\"]);  }  } else {    If an error occurs when retrieving the text payload, log the error.   log:printError(<string>resp.detail()[\"message\"]);  } }    If an error occurs when getting the response, log the error.   # To start the service and run the main function, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below along with the Ballerina home path as a config. ballerina run https_client.bal --b7a.home=<ballerina_home_path> INFO [] - Hello World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/byte-type.html","name":"Byte Type","summary":"The byte type is just shorthand for 0|1|2|…|255.\n Along with the general byte array there is also a special syntax to define base16 and base64 based arrays of\n bytes. This example demonstrates how byte and byte array can be used in Ballerina programs.Define a byte variable.Create a byte array using ...","content":"/  /  /  / Byte Type  import ballerina/io;  public function main() {  // Define a `byte` variable.  byte a = 12;  io:println(a);   // Create a `byte` array using the list constructor.  byte[] arr1 = [5, 24, 56, 243];  // Create a `byte` array using the `base16` byte array literal.  byte[] arr2 = base16 `aeeecdefabcd12345567888822`;  // Create a `byte` array using the `base64` byte array literal.  byte[] arr3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`;   io:println(arr1.length());  io:println(arr1[1]);   io:println(arr2.length());  io:println(arr2[2]);   io:println(arr3.length());  io:println(arr3[3]);   byte[][] arr4 = [[1, 2, 3], [23, 45, 117, 213], [45, 3, 254, 65, 78, 99]];  io:println(arr4.length());  io:println(arr4[2].length()); }    Byte Type  The byte type is just shorthand for 0|1|2|…|255.  Along with the general byte array there is also a special syntax to define base16 and base64 based arrays of  bytes. This example demonstrates how byte and byte array can be used in Ballerina programs.    import ballerina/io;    public function main() {    byte a = 12;  io:println(a);    Define a byte variable.   byte[] arr1 = [5, 24, 56, 243];    Create a byte array using the list constructor.   byte[] arr2 = base16 `aeeecdefabcd12345567888822`;    Create a byte array using the base16 byte array literal.   byte[] arr3 = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==`;    Create a byte array using the base64 byte array literal.   io:println(arr1.length());  io:println(arr1[1]);    io:println(arr2.length());  io:println(arr2[2]);    io:println(arr3.length());  io:println(arr3[3]);    byte[][] arr4 = [[1, 2, 3], [23, 45, 117, 213], [45, 3, 254, 65, 78, 99]];  io:println(arr4.length());  io:println(arr4[2].length()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run byte_type.bal 12 4 24 13 205 19 108 3 6    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/byte-io.html","name":"Byte I/O","summary":"This example demonstrates how bytes can be read and written through the I/O API.Copies the content from the source channel to a destination channel.The below example shows how to read all the content from\n the source and copy it to the destination.The operation attempts to read a maximum of 1000 ...","content":"/  /  /  / Byte I/O  import ballerina/io; import ballerina/log;  // Copies the content from the source channel to a destination channel. function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {  // The below example shows how to read all the content from  // the source and copy it to the destination.  while (true) {  // The operation attempts to read a maximum of 1000 bytes and returns  // with the available content, which could be < 1000.  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  // The operation writes the given content into the channel.  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }  // Closes a given readable or writable byte channel. function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }  public function main() returns @tainted error? {  string srcPath = \"./files/ballerina.jpg\";  string dstPath = \"./files/ballerinaCopy.jpg\";  // Initializes the readable byte channel.  io:ReadableByteChannel srcCh = check io:openReadableFile(srcPath);  // Initializes the writable byte channel.  io:WritableByteChannel dstCh = check io:openWritableFile(dstPath);  io:println(\"Start to copy files from \" + srcPath + \" to \" + dstPath);  // Copies the source byte channel to the target byte channel.  var result = copy(srcCh, dstCh);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  } else {  io:println(\"File copy completed. The copied file is located at \" +  dstPath);  }  // Closes the connections.  close(srcCh);  close(dstCh); }    Byte I/O  This example demonstrates how bytes can be read and written through the I/O API.    import ballerina/io; import ballerina/log;    function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {    Copies the content from the source channel to a destination channel.   while (true) {    The below example shows how to read all the content from  the source and copy it to the destination.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    The operation attempts to read a maximum of 1000 bytes and returns  with the available content, which could be < 1000.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    The operation writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes a given readable or writable byte channel.   public function main() returns @tainted error? {  string srcPath = \"./files/ballerina.jpg\";  string dstPath = \"./files/ballerinaCopy.jpg\";    io:ReadableByteChannel srcCh = check io:openReadableFile(srcPath);    Initializes the readable byte channel.   io:WritableByteChannel dstCh = check io:openWritableFile(dstPath);  io:println(\"Start to copy files from \" + srcPath + \" to \" + dstPath);    Initializes the writable byte channel.   var result = copy(srcCh, dstCh);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  } else {  io:println(\"File copy completed. The copied file is located at \" +  dstPath);  }    Copies the source byte channel to the target byte channel.   close(srcCh);  close(dstCh); }    Closes the connections.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run byte_io.bal Start to copy files from ./files/ballerina.jpg to ./files/ballerinaCopy.jpg File copy completed. The copied file could be located in ./files/ballerinaCopy.jpg    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/cache.html","name":"Cache","summary":"The ballerina/cache module is provides capability to extend custom cache\n storage and eviction policies while providing a in-memory storage and LRU\n eviction policy by default.This creates a new cache of size 10. The eviction factor is set to 0.2,\n which means at the time of eviction 10*0.2=2 entries get removed ...","content":"/  /  /  / Cache  import ballerina/cache; import ballerina/io; import ballerina/runtime;  public function main() returns error? {  // This creates a new cache of size 10. The eviction factor is set to 0.2,  // which means at the time of eviction 10*0.2=2 entries get removed from  // the cache.  // The default max age of the cache entry is set to 2 seconds. The cache  // cleanup task runs every 3 seconds and clears all the expired entries.  cache:Cache cache = new({  capacity: 10,  evictionFactor: 0.2,  defaultMaxAgeInSeconds: 2,  cleanupIntervalInSeconds: 3  });   // Adds a new entry to the cache.  _ = check cache.put(\"key1\", \"value1\");  // Adds a new entry to the cache by overriding the default max age.  _ = check cache.put(\"key2\", \"value2\", 3600);   // Checks for the cached key availability.  if (cache.hasKey(\"key1\")) {  // Fetches the cached value.  string value = <string> check cache.get(\"key1\");  io:println(\"key1: \" + value);  }   // This sends the current worker to the sleep mode for 4 seconds.  // No execution takes place during this period.  runtime:sleep(4000);   // During this period, the cache entry with the key 'key1' should be removed  // since the max of it is set to 2 seconds by default. However, the cache  // entry with the key 'key2' should exist in the cache.   // Get the keys of the cache entries.  string[] keys = cache.keys();  io:println(\"keys: [\" + keys.toString() + \"]\");   // Get the size of the cache.  int size = cache.size();   // Get the capacity of the cache.  int capacity = cache.capacity();   // Discard the given cache entry.  _ = check cache.invalidate(\"key2\");   // Discard all the cache entries of the cache.  _ = check cache.invalidateAll(); }    Cache  The ballerina/cache module is provides capability to extend custom cache  storage and eviction policies while providing a in-memory storage and LRU  eviction policy by default.    import ballerina/cache; import ballerina/io; import ballerina/runtime;    public function main() returns error? {    cache:Cache cache = new({  capacity: 10,  evictionFactor: 0.2,  defaultMaxAgeInSeconds: 2,  cleanupIntervalInSeconds: 3  });    This creates a new cache of size 10. The eviction factor is set to 0.2,  which means at the time of eviction 10*0.2=2 entries get removed from  the cache.  The default max age of the cache entry is set to 2 seconds. The cache  cleanup task runs every 3 seconds and clears all the expired entries.   _ = check cache.put(\"key1\", \"value1\");    Adds a new entry to the cache.   _ = check cache.put(\"key2\", \"value2\", 3600);    Adds a new entry to the cache by overriding the default max age.   if (cache.hasKey(\"key1\")) {    Checks for the cached key availability.   string value = <string> check cache.get(\"key1\");  io:println(\"key1: \" + value);  }    Fetches the cached value.   runtime:sleep(4000);    This sends the current worker to the sleep mode for 4 seconds.  No execution takes place during this period.   During this period, the cache entry with the key ‘key1’ should be removed  since the max of it is set to 2 seconds by default. However, the cache  entry with the key ‘key2’ should exist in the cache.   string[] keys = cache.keys();  io:println(\"keys: [\" + keys.toString() + \"]\");    Get the keys of the cache entries.   int size = cache.size();    Get the size of the cache.   int capacity = cache.capacity();    Get the capacity of the cache.   _ = check cache.invalidate(\"key2\");    Discard the given cache entry.   _ = check cache.invalidateAll(); }    Discard all the cache entries of the cache.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run cache.bal key1: value1 keys: [key2]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/check.html","name":"Check","summary":"The check expression is a unary expression that is used to handle errors.\n The check expression checks the result of the sub expression and returns if the result is of type error.\n Hence, check can only be used in a function which has error in its return type.The parse() function ...","content":"/  /  /  / Check  import ballerina/io; import ballerina/lang.'int;  // The `parse()` function takes a `string` argument and attempts to convert it to an `int`. function parse(string num) returns int|error {  return 'int:fromString(num); }  function scale(string num) returns int|error {  // The `check` unary operator can be used to return early on error.  // Here, `check` is used to return the error if the `parse()`  // function evaluates to `error`. If the actual value returned  // by the `parse()` function is an error, this function immediately returns  // the error, else the `int` value returned by `parse()` is set to `x` and  // execution continues. If `check` is used within a function, the return type  // of the function must include `error` in its return signature.  int x = check parse(num);  return x * 10; }  public function main() {  // Passing a valid integer as a `string` will return an `int`.  int|error w = parse(\"12\");  io:println(w);   // Passing a random `string` will return an `error`.  int|error x = parse(\"invalid\");  io:println(x);   int|error y = scale(\"12\");  io:println(y);   int|error z = scale(\"Invalid\");  io:println(z); }    Check  The check expression is a unary expression that is used to handle errors.  The check expression checks the result of the sub expression and returns if the result is of type error.  Hence, check can only be used in a function which has error in its return type.    import ballerina/io; import ballerina/lang.'int;    function parse(string num) returns int|error {  return 'int:fromString(num); }    The parse() function takes a string argument and attempts to convert it to an int.   function scale(string num) returns int|error {    int x = check parse(num);  return x * 10; }    The check unary operator can be used to return early on error.  Here, check is used to return the error if the parse()  function evaluates to error. If the actual value returned  by the parse() function is an error, this function immediately returns  the error, else the int value returned by parse() is set to x and  execution continues. If check is used within a function, the return type  of the function must include error in its return signature.   public function main() {    int|error w = parse(\"12\");  io:println(w);    Passing a valid integer as a string will return an int.   int|error x = parse(\"invalid\");  io:println(x);    Passing a random string will return an error.   int|error y = scale(\"12\");  io:println(y);    int|error z = scale(\"Invalid\");  io:println(z); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run check.bal 12 error {ballerina/lang.int}NumberParsingError message='string' value 'invalid' cannot be converted to 'int' 120 error {ballerina/lang.int}NumberParsingError message='string' value 'Invalid' cannot be converted to 'int'    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/character-io.html","name":"Read/Write Files","summary":"This demonstrates how characters could be read and written through I/O APIs.This function reads content from a file,\n appends the additional string, and writes the content.Reads the characters from the source channel.Writes the characters to the destination channel.Closes the readable character channel.Closes the writable character channel.This example uses the /examples/character-io/files/sample.txt ...","content":"/  /  /  / Read/Write Files  import ballerina/io; import ballerina/log;  // This function reads content from a file, // appends the additional `string`, and writes the content. function process(io:ReadableCharacterChannel sc,  io:WritableCharacterChannel dc) returns @tainted error? {  string intermediateCharacterString = \" my name is \";  // Reads the characters from the source channel.  string greetingText = check sc.read(5);  string name = check sc.read(15);  // Writes the characters to the destination channel.  var writeCharResult = check dc.write(greetingText, 0);  var writeCharResult1 = check dc.write(intermediateCharacterString, 0);  var writeCharResult2 = check dc.write(name, 1);  return; }  // Closes the readable character channel. function closeRc(io:ReadableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }  // Closes the writable character channel. function closeWc(io:WritableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }  public function main() returns @tainted error? {  // This example uses the <BALLERINA_LANG>/examples/character-io/files/sample.txt file as the // source file, which includes the text \"Hello Ballerina!!\".  // You can replace this with the file path of a preferred text file. io:ReadableByteChannel readableFieldResult =  check io:openReadableFile(\"./files/sample.txt\");  io:ReadableCharacterChannel sourceChannel =  new (readableFieldResult, \"UTF-8\");   // This example creates the <BALLERINA_LANG>/examples/character-io/files/sampleResponse.txt  // destination file and writes the text \"Hello my name is Ballerina!!\"\". // You can replace this with the file path of a preferred text file.  io:WritableByteChannel writableFileResult =  check io:openWritableFile(\"./files/sampleResponse.txt\");  io:WritableCharacterChannel destinationChannel =  new (writableFileResult, \"UTF-8\");  io:println(\"Started to process the file.\");  // Processes the given `string`.  var result = process(sourceChannel, destinationChannel);  if (result is error) {  log:printError(\"error occurred while processing chars \", result);  } else {  io:println(\"File processing complete.\");  }  // Closes the readable channel.  closeRc(sourceChannel);  // Closes the writable channel.  closeWc(destinationChannel); }    Read/Write Files  This demonstrates how characters could be read and written through I/O APIs.    import ballerina/io; import ballerina/log;    function process(io:ReadableCharacterChannel sc,  io:WritableCharacterChannel dc) returns @tainted error? {  string intermediateCharacterString = \" my name is \";    This function reads content from a file,  appends the additional string, and writes the content.   string greetingText = check sc.read(5);  string name = check sc.read(15);    Reads the characters from the source channel.   var writeCharResult = check dc.write(greetingText, 0);  var writeCharResult1 = check dc.write(intermediateCharacterString, 0);  var writeCharResult2 = check dc.write(name, 1);  return; }    Writes the characters to the destination channel.   function closeRc(io:ReadableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the readable character channel.   function closeWc(io:WritableCharacterChannel ch) {  var cr = ch.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the writable character channel.   public function main() returns @tainted error? {    io:ReadableByteChannel readableFieldResult =  check io:openReadableFile(\"./files/sample.txt\");  io:ReadableCharacterChannel sourceChannel =  new (readableFieldResult, \"UTF-8\");    This example uses the /examples/character-io/files/sample.txt file as the  source file, which includes the text “Hello Ballerina!!”.  You can replace this with the file path of a preferred text file.   io:WritableByteChannel writableFileResult =  check io:openWritableFile(\"./files/sampleResponse.txt\");  io:WritableCharacterChannel destinationChannel =  new (writableFileResult, \"UTF-8\");  io:println(\"Started to process the file.\");    This example creates the /examples/character-io/files/sampleResponse.txt  destination file and writes the text “Hello my name is Ballerina!!”“.  You can replace this with the file path of a preferred text file.   var result = process(sourceChannel, destinationChannel);  if (result is error) {  log:printError(\"error occurred while processing chars \", result);  } else {  io:println(\"File processing complete.\");  }    Processes the given string.   closeRc(sourceChannel);    Closes the readable channel.   closeWc(destinationChannel); }    Closes the writable channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run character_io.bal Started to process the file. File processing complete.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/client-generation.html","name":"Client Generation","summary":"This example generates a client for a Ballerina service.\n Add the @openapi:ClientEndpoint annotation to mark the listener(s) that are used for client generation.\n Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation.\n The generated client can be found in the <project.home>/target/bin/client/ or <program.dir>/client/ directory.Add the @openapi:ClientEndpoint ...","content":"/  /  /  / Client Generation  import ballerina/http; import ballerina/log; import ballerina/openapi;  // Add the `@openapi:ClientEndpoint` annotation to the listener that is to be used for client generation. @openapi:ClientEndpoint listener http:Listener helloEp = new (9090);  // Add the `@openapi:ClientConfig {generate: true}` annotation to the service to enable client generation for it. @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Client Generation  This example generates a client for a Ballerina service.  Add the @openapi:ClientEndpoint annotation to mark the listener(s) that are used for client generation.  Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation.  The generated client can be found in the <project.home>/target/bin/client/ or <program.dir>/client/ directory.    import ballerina/http; import ballerina/log; import ballerina/openapi;    @openapi:ClientEndpoint listener http:Listener helloEp = new (9090);    Add the @openapi:ClientEndpoint annotation to the listener that is to be used for client generation.   @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp {    Add the @openapi:ClientConfig {generate: true} annotation to the service to enable client generation for it.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  var result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina build` command below. ballerina build client_generation.bal Compiling source  client_generation.bal Generating executables  client_generation.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/checkpanic.html","name":"Check Panic","summary":"checkpanic is a unary expression that is used to handle errors.\n The checkpanic expression checks the result of the sub expression and panics if the result is error.\n Hence, checkpanic can be considered as a built-in type-guard for errors where the program will panic\n if the result is an error.The ...","content":"/  /  /  / Check Panic  import ballerina/io; import ballerina/lang.'int;  // The `parse()` function takes a `string` argument and attempts to convert it to an `int`. function parse(string num) returns int|error {  return 'int:fromString(num); }  public function main() {  // The `checkpanic` unary operator can be used to terminate execution on error.  // Here, `checkpanic` is used to panic if the `parse()`  // function evaluates to `error`. If the actual value returned  // by the function is an `error`, the function immediately panics  // with the error.  // Passing a valid integer as a `string` will return an `int`.  int y = checkpanic parse(\"120\");  io:println(y);   // Passing a random `string` will result in a panic.  int z = checkpanic parse(\"Invalid\");  io:println(z); }    Check Panic  checkpanic is a unary expression that is used to handle errors.  The checkpanic expression checks the result of the sub expression and panics if the result is error.  Hence, checkpanic can be considered as a built-in type-guard for errors where the program will panic  if the result is an error.    import ballerina/io; import ballerina/lang.'int;    function parse(string num) returns int|error {  return 'int:fromString(num); }    The parse() function takes a string argument and attempts to convert it to an int.   public function main() {    int y = checkpanic parse(\"120\");  io:println(y);    The checkpanic unary operator can be used to terminate execution on error.  Here, checkpanic is used to panic if the parse()  function evaluates to error. If the actual value returned  by the function is an error, the function immediately panics  with the error.  Passing a valid integer as a string will return an int.   int z = checkpanic parse(\"Invalid\");  io:println(z); }    Passing a random string will result in a panic.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run checkpanic.bal 120 error: {ballerina/lang.int}NumberParsingError message='string' value 'Invalid' cannot be converted to 'int'  at ballerina.lang_int:fromString(int.bal:113)  checkpanic:parse(checkpanic.bal:6)  checkpanic:main(checkpanic.bal:20)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/clone.html","name":"Cloning Values","summary":"The .clone() method can be used to make a copy of an anydata value.\n anydata is equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.\n Clone is defined for all structured types that belong to anydata.\n The resultant copy is a deep copy.\n A deep copy copies all fields and makes copies of the dynamically-allocated memory ...","content":"/  /  /  / Cloning Values  import ballerina/io;  // A record representing a `Person`. public type Person record {  string name;  int age;  boolean married;  float salary;  Address address; };  // A record representing an `Address`. public type Address record {  string country;  string state;  string city;  string street; };  public function main() {  // Define an `Address` value.  Address address = {  country: \"USA\",  state: \"NC\",  city: \"Raleigh\",  street: \"Daniels St\"  };   // Define a `Person` value.  Person person = {  name: \"Alex\",  age: 24,  married: false,  salary: 8000.0,  address: address  };   // Invoke the `.clone()` method. The return type is also `Person`.  // Provided that the type of the value being cloned belongs to `anydata`, the return type of `.clone()` would be  // the same as the type of the value being cloned.  // E.g., `anydata result = anydataValue.clone();` where `anydataValue` is a variable of type `anydata`.  Person result = person.clone();   io:println(\"Source value: \", person);  io:println(\"Cloned value: \", result);  // Check reference inequality between the original value and the cloned value.  io:println(\"Source and Clone are at two different memory locations: \", result !== person); }    Cloning Values  The .clone() method can be used to make a copy of an anydata value.  anydata is equivalent to ()|boolean|int|float|decimal|string|(anydata|error)[]|map<anydata|error>|xml|table.  Clone is defined for all structured types that belong to anydata.  The resultant copy is a deep copy.  A deep copy copies all fields and makes copies of the dynamically-allocated memory that is pointed to by the fields.  It preserves cycles, storage type, and immutability.  Cloning an immutable value will return the value itself.    import ballerina/io;    public type Person record {  string name;  int age;  boolean married;  float salary;  Address address; };    A record representing a Person.   public type Address record {  string country;  string state;  string city;  string street; };    A record representing an Address.   public function main() {    Address address = {  country: \"USA\",  state: \"NC\",  city: \"Raleigh\",  street: \"Daniels St\"  };    Define an Address value.   Person person = {  name: \"Alex\",  age: 24,  married: false,  salary: 8000.0,  address: address  };    Define a Person value.   Person result = person.clone();    Invoke the .clone() method. The return type is also Person.  Provided that the type of the value being cloned belongs to anydata, the return type of .clone() would be  the same as the type of the value being cloned.  E.g., anydata result = anydataValue.clone(); where anydataValue is a variable of type anydata.   io:println(\"Source value: \", person);  io:println(\"Cloned value: \", result);    io:println(\"Source and Clone are at two different memory locations: \", result !== person); }    Check reference inequality between the original value and the cloned value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run clone.bal Source value: name=Alex age=24 married=false salary=8000.0 address=country=USA state=NC city=Raleigh street=Daniels St Cloned value: name=Alex age=24 married=false salary=8000.0 address=country=USA state=NC city=Raleigh street=Daniels St Source and Clone are at two different memory locations: true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/closures.html","name":"Closures","summary":"In Ballerina, a closure is an inner anonymous function that has visibility to\n the scope of its enclosing environment. It can access its own scope, its enclosing\n environment’s scope, and variables defined in the global scope.A basic example in which an anonymous function with an if block accesses its outer ...","content":"/  /  /  / Closures  import ballerina/io;  int globalA = 5;  // A basic example in which an anonymous function with an `if` block accesses its outer scope // variables. function basicClosure() returns (function (int) returns int) {  int a = 3;  var foo = function (int b) returns int {  int c = 34;  if (b == 3) {  c = c + b + a + globalA;  }  return c + a;  };  return foo; }  // An example function with multiple levels of anonymous functions in which the // innermost anonymous function has access to all of its outer scope variables. function multilevelClosure() returns (function (int) returns int) {  int a = 2;  var func1 = function (int x) returns int {  int b = 23;  // The variable `a` defined in the outer scope is modified.  // The original value of `a` will be changed to `10`.  a = a + 8;  var func2 = function (int y) returns int {  int c = 7;  var func3 = function (int z) returns int {  // The variable `b` defined in the `func1` function is modified.  // The original value of `b` will be changed to `24`.  b = b + 1;  return x + y + z + a + b + c;  };  return func3(8) + y + x;  };  return func2(4) + x;  };  return func1; }  // An Example to represent how function pointers are passed with closures // so that the inner scope anonymous function can access the outer scope variables. function functionPointers(int a) returns  (function (int) returns (function (int) returns int)) {  return function (int b) returns (function (int) returns int) {  return function (int c) returns int {  return a + b + c;  };  }; }   public function main() {  // Invokes the function that shows basic closure support.  var foo = basicClosure();  int result1 = foo(3);  io:println(\"Answer: \", result1);   // The function invocation that represents multiple levels of anonymous functions  // with closure support.  var bar = multilevelClosure();  int result2 = bar(5);  io:println(\"Answer: \", result2);   // This function invocation shows how function pointers with closures  // are passed around.  var baz1 = functionPointers(7);  var baz2 = baz1(5);  int result3 = baz2(3);  io:println(\"Answer: \", result3); }    Closures  In Ballerina, a closure is an inner anonymous function that has visibility to  the scope of its enclosing environment. It can access its own scope, its enclosing  environment’s scope, and variables defined in the global scope.    import ballerina/io;    int globalA = 5;    function basicClosure() returns (function (int) returns int) {  int a = 3;  var foo = function (int b) returns int {  int c = 34;  if (b == 3) {  c = c + b + a + globalA;  }  return c + a;  };  return foo; }    A basic example in which an anonymous function with an if block accesses its outer scope  variables.   function multilevelClosure() returns (function (int) returns int) {  int a = 2;  var func1 = function (int x) returns int {  int b = 23;    An example function with multiple levels of anonymous functions in which the  innermost anonymous function has access to all of its outer scope variables.   a = a + 8;  var func2 = function (int y) returns int {  int c = 7;  var func3 = function (int z) returns int {    The variable a defined in the outer scope is modified.  The original value of a will be changed to 10.   b = b + 1;  return x + y + z + a + b + c;  };  return func3(8) + y + x;  };  return func2(4) + x;  };  return func1; }    The variable b defined in the func1 function is modified.  The original value of b will be changed to 24.   function functionPointers(int a) returns  (function (int) returns (function (int) returns int)) {  return function (int b) returns (function (int) returns int) {  return function (int c) returns int {  return a + b + c;  };  }; }    An Example to represent how function pointers are passed with closures  so that the inner scope anonymous function can access the outer scope variables.   public function main() {    var foo = basicClosure();  int result1 = foo(3);  io:println(\"Answer: \", result1);    Invokes the function that shows basic closure support.   var bar = multilevelClosure();  int result2 = bar(5);  io:println(\"Answer: \", result2);    The function invocation that represents multiple levels of anonymous functions  with closure support.   var baz1 = functionPointers(7);  var baz2 = baz1(5);  int result3 = baz2(3);  io:println(\"Answer: \", result3); }    This function invocation shows how function pointers with closures  are passed around.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run closures.bal Answer: 48 Answer: 72 Answer: 15    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/compound-assignment-operators.html","name":"Compound Assignment Operators","summary":"Compound assignment operators can be used to simplify the code and increase readability. These operators can only be\n used as statements (i.e., they cannot be used as expressions).Compound add operator.Compound subtract operator.Compound divide operator.Compound multiply operator.Compound and operator.Compound or operator.Compound xor operator.Compound left shift operator.Compound right shift operator.Compound logical shift ...","content":"/  /  /  / Compound Assignment Operators  import ballerina/io;  public function main() {  int value = 1;  io:println(\"value: \", value);   // Compound `add` operator.  value += 7;  io:println(\"value += 7: \", value);   // Compound `subtract` operator.  value -= 2;  io:println(\"value -= 2: \", value);   // Compound `divide` operator.  value /= 3;  io:println(\"value /= 3: \", value);   // Compound `multiply` operator.  value *= 2;  io:println(\"value *= 2: \", value);   // Compound `and` operator.  value &= 4;  io:println(\"value &= 4: \", value);   // Compound `or` operator.  value |= 3;  io:println(\"value |= 3: \", value);   // Compound `xor` operator.  value ^= 5;  io:println(\"value ^= 5: \", value);   // Compound `left shift` operator.  value <<= 1;  io:println(\"value <<= 1: \", value);   // Compound `right shift` operator.  value >>= 1;  io:println(\"value >>= 1: \", value);   // Compound `logical shift` operator.  value >>>= 1;  io:println(\"value >>>= 1: \", value); }    Compound Assignment Operators  Compound assignment operators can be used to simplify the code and increase readability. These operators can only be  used as statements (i.e., they cannot be used as expressions).    import ballerina/io;    public function main() {  int value = 1;  io:println(\"value: \", value);    value += 7;  io:println(\"value += 7: \", value);    Compound add operator.   value -= 2;  io:println(\"value -= 2: \", value);    Compound subtract operator.   value /= 3;  io:println(\"value /= 3: \", value);    Compound divide operator.   value *= 2;  io:println(\"value *= 2: \", value);    Compound multiply operator.   value &= 4;  io:println(\"value &= 4: \", value);    Compound and operator.   value |= 3;  io:println(\"value |= 3: \", value);    Compound or operator.   value ^= 5;  io:println(\"value ^= 5: \", value);    Compound xor operator.   value <<= 1;  io:println(\"value <<= 1: \", value);    Compound left shift operator.   value >>= 1;  io:println(\"value >>= 1: \", value);    Compound right shift operator.   value >>>= 1;  io:println(\"value >>>= 1: \", value); }    Compound logical shift operator.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run compound_assignment_operators.bal value: 1 value += 7: 8 value -= 2: 6 value /= 3: 2 value *= 2: 4 value &= 4: 4 value |= 3: 7 value ^= 5: 2 value <<= 1: 4 value >>= 1: 2 value >>>= 1: 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/config-api.html","name":"Config","summary":"The Ballerina Config API allows you to look up values from configuration\n files, CLI parameters, and environment variables. The precedence order for\n configuration resolution is as follows: If a specific configuration defined in the file is also defined as an\n environment variable, the environment variable takes precedence. Similarly,\n if the ...","content":"/  /  /  / Config  import ballerina/config; import ballerina/io;  public function main() {  // Look up the configuration values. string username = config:getAsString(\"app.auth.username\");  string password = config:getAsString(\"app.auth.password\");   io:println(string `Authenticating user '${username}'`); }    Config  The Ballerina Config API allows you to look up values from configuration  files, CLI parameters, and environment variables. The precedence order for  configuration resolution is as follows: CLI parameters Environment variables Configuration files   If a specific configuration defined in the file is also defined as an  environment variable, the environment variable takes precedence. Similarly,  if the same is set as a CLI parameter, it replaces the environment  variable value.  If a mapping does not exist for the specified key, the default value  is returned as the configuration value. The default values of these  optional configurations are the default values of the return types of  the functions. For more information on the underlying module,  see the .    import ballerina/config; import ballerina/io;    public function main() {    string username = config:getAsString(\"app.auth.username\");  string password = config:getAsString(\"app.auth.password\");    Look up the configuration values.   io:println(string `Authenticating user '${username}'`); }    # Sensitive data such as passwords can be encrypted and accessed securely in code. To encrypt a value, the # `ballerina encrypt` command is used. It prompts the user to enter the value and a secret. In this example, # `ballerina` is the value and `12345` is the secret. ballerina encrypt Enter value:    Enter secret:    Re-enter secret to verify:    Add the following to the configuration file: <key>=\"@encrypted:{njjb2H9u7Bax2FZX/X+UPZ50lR6+ckKmkesE87Yuw/x9wE1yvhcww1ehOc+mjgCc}\"}\"    Or provide it as a command line argument: --<key>=@encrypted:{njjb2H9u7Bax2FZX/X+UPZ50lR6+ckKmkesE87Yuw/x9wE1yvhcww1ehOc+mjgCc}\"}    # The secret needs to be provided if a configuration contains an encrypted value. The secret can be provided # via a `secret.txt` file (which gets deleted immediately after its contents are read) or via the CLI. In this example, the CLI is used. ballerina run config_api.bal ballerina: enter secret for config value decryption:    # To specify a configuration file explicitly, use the `--b7a.config.file=<path_to_configuration_file>` property. # If this property is not set, Ballerina looks for a `ballerina.conf` file in the current directory. The path # to the configuration file can be either an absolute or a relative path. # To run this example, place the following configurations in a file and provide its path. # ``` # [app.auth] # username=jack # [app.auth] # password=\"@encrypted:{njjb2H9u7Bax2FZX/X+UPZ50lR6+ckKmkesE87Yuw/x9wE1yvhcww1ehOc+mjgCc}\"}\" # # ``` ballerina run config_api.bal --b7a.config.file=path/to/conf/file/custom-config-file-name.conf ballerina: enter secret for config value decryption:    Authenticating user 'jack'    # The same configurations given via a configuration file can also be given via CLI parameters. <br> # e.g., app.auth.username ballerina run config_api.bal --app.auth.username=jack --hello.keystore.password=@encrypted:{njjb2H9u7Bax2FZX/X+UPZ50lR6+ckKmkesE87Yuw/x9wE1yvhcww1ehOc+mjgCc}\"} ballerina: enter secret for config value decryption:    Authenticating user 'jack'    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/content-based-routing.html","name":"Content-Based Routing","summary":"The Content-Based Router service reads the content of a request and routes it to a specific recipient based on the content.Use resourceConfig annotation to declare the HTTP method.Define the attributes associated with the client endpoint here.Get the json payload from the request message.Get the string value relevant to the key ...","content":"/  /  /  / Content-Based Routing  import ballerina/http; import ballerina/log;  @http:ServiceConfig {  basePath: \"/cbr\" } service contentBasedRouting on new http:Listener(9090) {   // Use `resourceConfig` annotation to declare the HTTP method.  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/route\"  }  resource function cbrResource(http:Caller outboundEP, http:Request req) {  // Define the attributes associated with the client endpoint here.  http:Client locationEP = new (\"http://www.mocky.io\");   // Get the `json` payload from the request message.  var jsonMsg = req.getJsonPayload();   if (jsonMsg is json) {  // Get the `string` value relevant to the key `name`.  json|error nameString = jsonMsg.name;  http:Response|error clientResponse;  if (nameString is json) {  if (nameString.toString() == \"sanFrancisco\") {  // Here, `post` remote function represents the POST operation of  // the HTTP client.  // This routes the payload to the relevant service when the server  // accepts the enclosed entity.  clientResponse =  locationEP->post(\"/v2/594e018c1100002811d6d39a\", ());   } else {  clientResponse =  locationEP->post(\"/v2/594e026c1100004011d6d39c\", ());  }   // Use the remote function `respond` to send the client response  // back to the caller.  if (clientResponse is http:Response) {  var result = outboundEP->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>nameString.detail()?.message);   var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>jsonMsg.detail()?.message);   var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Content-Based Routing  The Content-Based Router service reads the content of a request and routes it to a specific recipient based on the content.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/cbr\" } service contentBasedRouting on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/route\"  }  resource function cbrResource(http:Caller outboundEP, http:Request req) {    Use resourceConfig annotation to declare the HTTP method.   http:Client locationEP = new (\"http://www.mocky.io\");    Define the attributes associated with the client endpoint here.   var jsonMsg = req.getJsonPayload();    Get the json payload from the request message.   if (jsonMsg is json) {    json|error nameString = jsonMsg.name;  http:Response|error clientResponse;  if (nameString is json) {  if (nameString.toString() == \"sanFrancisco\") {    Get the string value relevant to the key name.   clientResponse =  locationEP->post(\"/v2/594e018c1100002811d6d39a\", ());    Here, post remote function represents the POST operation of  the HTTP client.  This routes the payload to the relevant service when the server  accepts the enclosed entity.   } else {  clientResponse =  locationEP->post(\"/v2/594e026c1100004011d6d39c\", ());  }    if (clientResponse is http:Response) {  var result = outboundEP->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>nameString.detail()?.message);    Use the remote function respond to send the client response  back to the caller.   var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>jsonMsg.detail()?.message);    var result = outboundEP->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run content_based_routing.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/cbr/route -d '{\"name\" : \"sanFrancisco\"}' -H \"Content-Type:application/json\" {  \"name\": \"San Francisco Test Station,USA\",  \"longitude\": -122.43,  \"latitude\": 37.76,  \"altitude\": 150,  \"rank\": 1 }    curl http://localhost:9090/cbr/route -d '{\"name\" : \"london\"}' -H \"Content-Type:application/json\" {  \"name\": \"London Test Station,England\",  \"longitude\": -156.49,  \"latitude\": 57.76,  \"altitude\": 430,  \"rank\": 5 }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/constants.html","name":"Constants","summary":"Constants are values known at compile time. As of now, only value-type constants (i.e., constants of boolean, byte,\n decimal, float, int, and string types) are supported. Constants are useful for defining enumeration types.These constants can be used just like any other value-type variable except the value of these constants cannot ...","content":"/  /  /  / Constants  import ballerina/io;  // Constants are defined using the `const` modifier. const string GET = \"GET\";  // Constants can be defined without the type. Then, the type is inferred from the right hand side. const POST = \"POST\";  // Constants can be used to create type definitions. The type definition below specifies that a variable of the type // `ACTION` can only hold either `GET` or `POST` as its value. type ACTION GET|POST;  // An integer constant. const int I = 125;  // Constants of the `map` type can be defined as well. The constraint of these constant maps should be either a simple type // or another map type, which should eventually have a simple type constraint. `var` cannot be used to declare // constant maps. Therefore, the correct type should be present when declaring the constant. const map<string> data = {\"user\": \"Ballerina\", \"ID\": \"1234\"};  // Constant with nested map literals. const map<map<string>> complexData = {\"data\": data, \"data2\": {\"user\": \"WSO2\"}};  public function main() {  // This is identical to the code line `ACTION get = \"GET\";`.  ACTION get = GET;  testAction(get);   ACTION post = \"POST\";  testAction(POST);   // `I` can be concatenated with any other integer value.  int value = I + 10;  io:println(value);   io:println(data);  io:println(complexData);   // Values of a constant map can be accessed and used as usual.  io:println(complexData[\"data\"][\"user\"]);   // However, updating a constant map will produce a compile-time error. E.g., -  // data.ID = \"4321\";  // data.newField = 10; }  function testAction(ACTION action) {  if (action == GET) {  io:println(\"GET action\");  } else if (action == POST) {  io:println(\"POST action\");  } }    Constants  Constants are values known at compile time. As of now, only value-type constants (i.e., constants of boolean, byte,  decimal, float, int, and string types) are supported. Constants are useful for defining enumeration types.  These constants can be used just like any other value-type variable except the value of these constants cannot be  changed after initializing. The difference between the final variables and constants is that the value of the final  variables can be initialized at runtime. However, constants must be initialized at compile time.    import ballerina/io;    const string GET = \"GET\";    Constants are defined using the const modifier.   const POST = \"POST\";    Constants can be defined without the type. Then, the type is inferred from the right hand side.   type ACTION GET|POST;    Constants can be used to create type definitions. The type definition below specifies that a variable of the type  ACTION can only hold either GET or POST as its value.   const int I = 125;    An integer constant.   const map<string> data = {\"user\": \"Ballerina\", \"ID\": \"1234\"};    Constants of the map type can be defined as well. The constraint of these constant maps should be either a simple type  or another map type, which should eventually have a simple type constraint. var cannot be used to declare  constant maps. Therefore, the correct type should be present when declaring the constant.   const map<map<string>> complexData = {\"data\": data, \"data2\": {\"user\": \"WSO2\"}};    Constant with nested map literals.   public function main() {    ACTION get = GET;  testAction(get);    This is identical to the code line ACTION get = \"GET\";.   ACTION post = \"POST\";  testAction(POST);    int value = I + 10;  io:println(value);    I can be concatenated with any other integer value.   io:println(data);  io:println(complexData);    io:println(complexData[\"data\"][\"user\"]);    Values of a constant map can be accessed and used as usual.   }    However, updating a constant map will produce a compile-time error. E.g., -  data.ID = “4321”;  data.newField = 10;   function testAction(ACTION action) {  if (action == GET) {  io:println(\"GET action\");  } else if (action == POST) {  io:println(\"POST action\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run constant.bal GET action POST action 135 user=Ballerina ID=1234 data=user=Ballerina ID=1234 data2=user=WSO2 Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/counter-metrics.html","name":"Counter-Based Metrics","summary":"Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can define and use metrics to measure their own logic. A counter is one type ...","content":"/  /  /  / Counter-Based Metrics  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;  //Create a counter as a global variable in the service with optional field description. observe:Counter globalCounter = new (\"total_orders\",  desc = \"Total quantity required\");  // Make sure you start the service with '--b7a.observability.enabled=true', or metrics enabled. @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  //Incrementing the global counter defined with the default value 1.  globalCounter.increment();   //Create a counter with simply a name.  observe:Counter localCounter = new (\"local_operations\");  localCounter.increment();  //Increment the value of the counter by 20.  localCounter.increment(20);   //Create a counter with optional fields description, and tags.  observe:Counter registeredCounter = new (\"total_product_order_quantity\",  desc = \"Total quantity required\",  tags = {prodName: \"HeadPhone\", prodType: \"Electronics\"});   //Register the counter instance, therefore it is stored in the global registry and can be reported to the  //metrics server such as Prometheus. Additionally, this operation will register to the global registry for the  //first invocation and will throw an error if there is already a registration of different metrics instance  //or type. Subsequent invocations of register() will simply retrieve the stored metrics instance  //for the provided name and tags fields, and use that instance for the subsequent operations on the  //counter instance.  error? result = registeredCounter.register();  if (result is error) {  log:printError(\"Error in registering counter\", result);  }   //Increase the amount of the registered counter instance by amount 10.  registeredCounter.increment(10);   //Get the value of the counter instances.  io:println(\"------------------------------------------\");  io:println(\"Global Counter = \", globalCounter.getValue());  io:println(\"Local Counter = \", localCounter.getValue());  io:println(\"Registered Counter = \", registeredCounter.getValue());  io:println(\"------------------------------------------\");   //Send reponse to the client.  http:Response res = new;  // Use a util method to set a string payload.  res.setPayload(\"Order Processed!\");   // Send the response back to the caller.  result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Counter-Based Metrics  Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can define and use metrics to measure their own logic. A counter is one type of metric that is  supported by default in Ballerina, and it is a cumulative metric that represents a single monotonically increasing  counter whose value can only increase or be reset to zero.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;    observe:Counter globalCounter = new (\"total_orders\",  desc = \"Total quantity required\");    Create a counter as a global variable in the service with optional field description.   @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {    Make sure you start the service with ‘–b7a.observability.enabled=true’, or metrics enabled.   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {    globalCounter.increment();    Incrementing the global counter defined with the default value 1.   observe:Counter localCounter = new (\"local_operations\");  localCounter.increment();    Create a counter with simply a name.   localCounter.increment(20);    Increment the value of the counter by 20.   observe:Counter registeredCounter = new (\"total_product_order_quantity\",  desc = \"Total quantity required\",  tags = {prodName: \"HeadPhone\", prodType: \"Electronics\"});    Create a counter with optional fields description, and tags.   error? result = registeredCounter.register();  if (result is error) {  log:printError(\"Error in registering counter\", result);  }    Register the counter instance, therefore it is stored in the global registry and can be reported to the metrics server such as Prometheus. Additionally, this operation will register to the global registry for the first invocation and will throw an error if there is already a registration of different metrics instance or type. Subsequent invocations of register() will simply retrieve the stored metrics instance for the provided name and tags fields, and use that instance for the subsequent operations on the counter instance.   registeredCounter.increment(10);    Increase the amount of the registered counter instance by amount 10.   io:println(\"------------------------------------------\");  io:println(\"Global Counter = \", globalCounter.getValue());  io:println(\"Local Counter = \", localCounter.getValue());  io:println(\"Registered Counter = \", registeredCounter.getValue());  io:println(\"------------------------------------------\");    Get the value of the counter instances.   http:Response res = new;    Send reponse to the client.   res.setPayload(\"Order Processed!\");    Use a util method to set a string payload.   result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below with the '--b7a.observability.enabled=true' property. ballerina run counter_metrics.bal --b7a.observability.enabled=true [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 ------------------------------------------ Global Counter = 1 Local Counter = 21 Registered Counter = 10 ------------------------------------------ ------------------------------------------ Global Counter = 2 Local Counter = 21 Registered Counter = 20 ------------------------------------------ ------------------------------------------ Global Counter = 3 Local Counter = 21 Registered Counter = 30 ------------------------------------------    curl http://localhost:9090/online-store-service/make-order Order Processed! curl http://localhost:9090/online-store-service/make-order Order Processed! curl http://localhost:9090/online-store-service/make-order Order Processed!    Invoke the service using cURL three times.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/create-java-objects.html","name":"Create Java Objects","summary":"jBallerina is an implementation of the Ballerina language specification that targets the JVM.\n Java interoperability in jBallerina enables developers to call existing Java code from Ballerina.\n Ballerina spec describes a reference type called handle. A handle value is a reference to\n storage managed externally to a Ballerina program. Handle values ...","content":"/  /  /  / Create Java Objects  import ballerina/io; import ballerina/java;  // The `@java:Constructor` annotation links the default constructor of // the class `java.util.ArrayDeque` with this Ballerina function declaration. function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  // This ballerina function is linked with the `java.util.ArrayDeque` constructor that takes the initial capacity. // There are other overloaded constructors that take a single parameter in this class. // To link with the exact constructor, you can specify the `paramTypes` field. Refer to the `Overloaded // Methods/Constructors` section for more details on dealing with overloaded methods and constructors. // This function returns a `handle` value, which refers to an object of `java.util.ArrayDeque` class. function newArrayDequeWithInitialCapacity(int numElements) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;   public function main() {  // Create a new `java.util.ArrayDeque` object by invoking the default constructor via `newArrayDeque` function.  var arrayDeque = newArrayDeque();  io:println(arrayDeque);   // Create a new `java.util.ArrayDeque` object by invoking the constructor that takes an `int` argument  // via `newArrayDeque` function.  var arrayDequeWithCapacity = newArrayDequeWithInitialCapacity(10);  io:println(arrayDequeWithCapacity); }    Create Java Objects  jBallerina is an implementation of the Ballerina language specification that targets the JVM.  Java interoperability in jBallerina enables developers to call existing Java code from Ballerina.  Ballerina spec describes a reference type called handle. A handle value is a reference to  storage managed externally to a Ballerina program. Handle values cannot be created within a Ballerina program.  They can be created only by functions with an external function body. In jBallerina handle value refers to  Java reference value, i.e., a Java object. Also, in jBallerina, Java constructors and Java methods can provide  the implementations of Ballerina functions that are marked as external.  In this example, let’s look at how to create Java objects by invoking their constructors from Ballerina.    import ballerina/io; import ballerina/java;    function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The @java:Constructor annotation links the default constructor of  the class java.util.ArrayDeque with this Ballerina function declaration.   function newArrayDequeWithInitialCapacity(int numElements) returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;    This ballerina function is linked with the java.util.ArrayDeque constructor that takes the initial capacity.  There are other overloaded constructors that take a single parameter in this class.  To link with the exact constructor, you can specify the paramTypes field. Refer to the Overloaded  Methods/Constructors section for more details on dealing with overloaded methods and constructors.  This function returns a handle value, which refers to an object of java.util.ArrayDeque class.   public function main() {    var arrayDeque = newArrayDeque();  io:println(arrayDeque);    Create a new java.util.ArrayDeque object by invoking the default constructor via newArrayDeque function.   var arrayDequeWithCapacity = newArrayDequeWithInitialCapacity(10);  io:println(arrayDequeWithCapacity); }    Create a new java.util.ArrayDeque object by invoking the constructor that takes an int argument  via newArrayDeque function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run create-java-objects.bal [] []    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/data-io.html","name":"Data I/O","summary":"This sample demonstrates how data i/o APIs could be used to read/write data.Serializes the record into binary.Deserializes the record from binary.Reads a 32-bit-signed integer.Reads a UTF-8-encoded string represented through the specified amounts of bytes.Reads a 16-bit-signed integer.Reads a 64-bit-signed float.Reads a boolean.Finally closes the data channel.Serializes and writes the record ...","content":"/  /  /  / Data I/O  import ballerina/io; import ballerina/log;  public type Person record {|  string name = \"\";  int age = 0;  float income = 0.0;  boolean isMarried = false; |};  // Serializes the record into binary. function serialize(Person p, io:WritableByteChannel byteChannel) {  io:WritableDataChannel dc = new io:WritableDataChannel(byteChannel);  var length = p.name.toBytes().length();  var lengthResult = dc.writeInt32(length);  var nameResult = dc.writeString(p.name, \"UTF-8\");  var ageResult = dc.writeInt16(p.age);  var incomeResult = dc.writeFloat64(p.income);  var maritalStatusResult = dc.writeBool(p.isMarried);  var closeResult = dc.close(); }  //Deserializes the record from binary. function deserialize(io:ReadableByteChannel byteChannel) returns Person {  Person person = {};  int nameLength = 0;  string nameValue;  io:ReadableDataChannel dc = new io:ReadableDataChannel(byteChannel);  //Reads a 32-bit-signed integer.  var int32Result = dc.readInt32();  if (int32Result is int) {  nameLength = int32Result;  } else {  log:printError(\"Error occurred while reading name length\",  err = int32Result);  }  //Reads a UTF-8-encoded string represented through the specified amounts of bytes.  var strResult = dc.readString(nameLength, \"UTF-8\");  if (strResult is string) {  person.name = strResult;  } else {  log:printError(\"Error occurred while reading name\", strResult);  }  //Reads a 16-bit-signed integer.  var int16Result = dc.readInt16();  if (int16Result is int) {  person.age = int16Result;  } else {  log:printError(\"Error occurred while reading age\",  err = int16Result);  }  //Reads a 64-bit-signed float.  var float64Result = dc.readFloat64();  if (float64Result is float) {  person.income = float64Result;  } else {  log:printError(\"Error occurred while reading income\",  err = float64Result);  }  //Reads a boolean.  var boolResult = dc.readBool();  if (boolResult is boolean) {  person.isMarried = boolResult;  } else {  log:printError(\"Error occurred while reading marital status\",  err = boolResult);  }  //Finally closes the data channel.  var closeResult = dc.close();  return person; }  //Serializes and writes the record to a file. function writeRecordToFile(Person p, string path) returns error? {  io:WritableByteChannel wc = check io:openWritableFile(path);  serialize(p, wc); }  //Reads the serialized record from the file. function readRecordFromFile(string path) returns @tainted Person|error {  io:ReadableByteChannel rc = check io:openReadableFile(path);  return deserialize(rc); }  public function main() returns error? {  Person wPerson = {  name: \"Ballerina\",  age: 21,  income: 1543.12,  isMarried: true  };  //Writes the record to a file.  check writeRecordToFile(wPerson, \"./files/person.bin\");  io:println(\"Person record successfully written to file\");  //Reads record from a file.  Person rPerson = check readRecordFromFile(\"./files/person.bin\");  io:println(\"Reading person record from file\");  io:println(rPerson); }    Data I/O  This sample demonstrates how data i/o APIs could be used to read/write data.    import ballerina/io; import ballerina/log;    public type Person record {|  string name = \"\";  int age = 0;  float income = 0.0;  boolean isMarried = false; |};    function serialize(Person p, io:WritableByteChannel byteChannel) {  io:WritableDataChannel dc = new io:WritableDataChannel(byteChannel);  var length = p.name.toBytes().length();  var lengthResult = dc.writeInt32(length);  var nameResult = dc.writeString(p.name, \"UTF-8\");  var ageResult = dc.writeInt16(p.age);  var incomeResult = dc.writeFloat64(p.income);  var maritalStatusResult = dc.writeBool(p.isMarried);  var closeResult = dc.close(); }    Serializes the record into binary.   function deserialize(io:ReadableByteChannel byteChannel) returns Person {  Person person = {};  int nameLength = 0;  string nameValue;  io:ReadableDataChannel dc = new io:ReadableDataChannel(byteChannel);    Deserializes the record from binary.   var int32Result = dc.readInt32();  if (int32Result is int) {  nameLength = int32Result;  } else {  log:printError(\"Error occurred while reading name length\",  err = int32Result);  }    Reads a 32-bit-signed integer.   var strResult = dc.readString(nameLength, \"UTF-8\");  if (strResult is string) {  person.name = strResult;  } else {  log:printError(\"Error occurred while reading name\", strResult);  }    Reads a UTF-8-encoded string represented through the specified amounts of bytes.   var int16Result = dc.readInt16();  if (int16Result is int) {  person.age = int16Result;  } else {  log:printError(\"Error occurred while reading age\",  err = int16Result);  }    Reads a 16-bit-signed integer.   var float64Result = dc.readFloat64();  if (float64Result is float) {  person.income = float64Result;  } else {  log:printError(\"Error occurred while reading income\",  err = float64Result);  }    Reads a 64-bit-signed float.   var boolResult = dc.readBool();  if (boolResult is boolean) {  person.isMarried = boolResult;  } else {  log:printError(\"Error occurred while reading marital status\",  err = boolResult);  }    Reads a boolean.   var closeResult = dc.close();  return person; }    Finally closes the data channel.   function writeRecordToFile(Person p, string path) returns error? {  io:WritableByteChannel wc = check io:openWritableFile(path);  serialize(p, wc); }    Serializes and writes the record to a file.   function readRecordFromFile(string path) returns @tainted Person|error {  io:ReadableByteChannel rc = check io:openReadableFile(path);  return deserialize(rc); }    Reads the serialized record from the file.   public function main() returns error? {  Person wPerson = {  name: \"Ballerina\",  age: 21,  income: 1543.12,  isMarried: true  };    check writeRecordToFile(wPerson, \"./files/person.bin\");  io:println(\"Person record successfully written to file\");    Writes the record to a file.   Person rPerson = check readRecordFromFile(\"./files/person.bin\");  io:println(\"Reading person record from file\");  io:println(rPerson); }    Reads record from a file.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run data_io.bal Person record successfully written to file Reading person record from file name=Ballerina age=21 income=1543.12 isMarried=true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/csv-io.html","name":"CSV I/O","summary":"This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O APIThis function reads records one by one and prints the records.Reads all the records from the provided file\n until there are no more records.Reads the records.Prints the records.Specifies the location of the .CSV ...","content":"/  /  /  / CSV I/O  import ballerina/io; import ballerina/log;  type Employee record {  string id;  string name;  float salary; };  // This function reads records one by one and prints the records. function process(io:ReadableCSVChannel csvChannel)  returns @tainted error? {  // Reads all the records from the provided file  // until there are no more records.  while (csvChannel.hasNext()) {  // Reads the records.  var records = check csvChannel.getNext();  // Prints the records.  if (records is string[]) {  io:println(records);  }  }  return; }  //Specifies the location of the `.CSV` file. public function main() returns @tainted error? {  string srcFileName = \"./files/sample.csv\";  // Opens a CSV channel in the `write` mode and writes some data to  // the `./files/sample.csv` file for later use.  // The record separator of the `.CSV` file is a  // new line and the field separator is a comma (,).  io:WritableCSVChannel wCsvChannel =  check io:openWritableCsvFile(srcFileName);  string[][] data = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];  writeDataToCSVChannel(wCsvChannel, ...data);  closeWritableCSVChannel(wCsvChannel);  // Opens a CSV channel in the `read` mode, which is the default mode.  io:ReadableCSVChannel rCsvChannel =  check io:openReadableCsvFile(srcFileName);  io:println(\"Start processing the CSV file from \", srcFileName);  var processedResult = process(rCsvChannel);  if (processedResult is error) {  log:printError(\"An error occurred while processing the records: \",  err = processedResult);  }  io:println(\"Processing completed.\");  // Closes the CSV channel.  closeReadableCSVChannel(rCsvChannel);  // Opens a CSV channel in the `read` mode, which is the default mode.  io:ReadableCSVChannel rCsvChannel2 =  check io:openReadableCsvFile(srcFileName);  // Reads the `.CSV` file as a `table`.  io:println(\"Reading \" + srcFileName + \" as a table\");  var tblResult = rCsvChannel2.getTable(Employee);  if (tblResult is table<record {}>) {  table<Employee> empTable = <table<Employee>> tblResult;  foreach var rec in empTable {  io:println(rec);  }  } else {  log:printError(\"An error occurred while creating table: \",  err = tblResult);  }  closeReadableCSVChannel(rCsvChannel2);  // Opens a CSV channel in the \"write\" mode and writes the `table` to a `.CSV` file.  string targetFileName = \"./files/output.csv\";  io:WritableCSVChannel wCsvChannel2 =  check io:openWritableCsvFile(targetFileName);  io:println(\"Creating a table and adding data\");  table<Employee> employeeTable = createTableAndAddData();  io:println(\"Writing the table to \" + targetFileName);  foreach var entry in employeeTable {  string[] rec = [entry.id, entry.name, entry.salary.toString()];  writeDataToCSVChannel(wCsvChannel2, rec);  }  closeWritableCSVChannel(wCsvChannel2); }  // Creates a `table` and adds some data. function createTableAndAddData() returns table<Employee> {  table<Employee> employeeTable = table {};  Employee[] employees = [];  employees[0] = {id: \"1\", name: \"Allen\", salary: 300000.0};  employees[1] = {id: \"2\", name: \"Wallace\", salary: 200000.0};  employees[2] = {id: \"3\", name: \"Sheldon\", salary: 1000000.0};  foreach var employee in employees {  var result = employeeTable.add(employee);  if (result is error) {  log:printError(\"Error occurred while adding data to table: \",  err = result);  }  }  return employeeTable; }  // Writes data to a given CSV Channel. function writeDataToCSVChannel(io:WritableCSVChannel csvChannel,  string[]... data) {  foreach var rec in data {  var returnedVal = csvChannel.write(rec);  if (returnedVal is error) {  log:printError(\"Error occurred while writing to target file: \",  err = returnedVal);  }  } }  // Closes the Readable CSV channel. function closeReadableCSVChannel(io:ReadableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }  // Closes the Writable CSV channel. function closeWritableCSVChannel(io:WritableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    CSV I/O  This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O API    import ballerina/io; import ballerina/log;    type Employee record {  string id;  string name;  float salary; };    function process(io:ReadableCSVChannel csvChannel)  returns @tainted error? {    This function reads records one by one and prints the records.   while (csvChannel.hasNext()) {    Reads all the records from the provided file  until there are no more records.   var records = check csvChannel.getNext();    Reads the records.   if (records is string[]) {  io:println(records);  }  }  return; }    Prints the records.   public function main() returns @tainted error? {  string srcFileName = \"./files/sample.csv\";    Specifies the location of the .CSV file.   io:WritableCSVChannel wCsvChannel =  check io:openWritableCsvFile(srcFileName);  string[][] data = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];  writeDataToCSVChannel(wCsvChannel, ...data);  closeWritableCSVChannel(wCsvChannel);    Opens a CSV channel in the write mode and writes some data to  the ./files/sample.csv file for later use.  The record separator of the .CSV file is a  new line and the field separator is a comma (,).   io:ReadableCSVChannel rCsvChannel =  check io:openReadableCsvFile(srcFileName);  io:println(\"Start processing the CSV file from \", srcFileName);  var processedResult = process(rCsvChannel);  if (processedResult is error) {  log:printError(\"An error occurred while processing the records: \",  err = processedResult);  }  io:println(\"Processing completed.\");    Opens a CSV channel in the read mode, which is the default mode.   closeReadableCSVChannel(rCsvChannel);    Closes the CSV channel.   io:ReadableCSVChannel rCsvChannel2 =  check io:openReadableCsvFile(srcFileName);    Opens a CSV channel in the read mode, which is the default mode.   io:println(\"Reading \" + srcFileName + \" as a table\");  var tblResult = rCsvChannel2.getTable(Employee);  if (tblResult is table<record {}>) {  table<Employee> empTable = <table<Employee>> tblResult;  foreach var rec in empTable {  io:println(rec);  }  } else {  log:printError(\"An error occurred while creating table: \",  err = tblResult);  }  closeReadableCSVChannel(rCsvChannel2);    Reads the .CSV file as a table.   string targetFileName = \"./files/output.csv\";  io:WritableCSVChannel wCsvChannel2 =  check io:openWritableCsvFile(targetFileName);  io:println(\"Creating a table and adding data\");  table<Employee> employeeTable = createTableAndAddData();  io:println(\"Writing the table to \" + targetFileName);  foreach var entry in employeeTable {  string[] rec = [entry.id, entry.name, entry.salary.toString()];  writeDataToCSVChannel(wCsvChannel2, rec);  }  closeWritableCSVChannel(wCsvChannel2); }    Opens a CSV channel in the “write” mode and writes the table to a .CSV file.   function createTableAndAddData() returns table<Employee> {  table<Employee> employeeTable = table {};  Employee[] employees = [];  employees[0] = {id: \"1\", name: \"Allen\", salary: 300000.0};  employees[1] = {id: \"2\", name: \"Wallace\", salary: 200000.0};  employees[2] = {id: \"3\", name: \"Sheldon\", salary: 1000000.0};  foreach var employee in employees {  var result = employeeTable.add(employee);  if (result is error) {  log:printError(\"Error occurred while adding data to table: \",  err = result);  }  }  return employeeTable; }    Creates a table and adds some data.   function writeDataToCSVChannel(io:WritableCSVChannel csvChannel,  string[]... data) {  foreach var rec in data {  var returnedVal = csvChannel.write(rec);  if (returnedVal is error) {  log:printError(\"Error occurred while writing to target file: \",  err = returnedVal);  }  } }    Writes data to a given CSV Channel.   function closeReadableCSVChannel(io:ReadableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    Closes the Readable CSV channel.   function closeWritableCSVChannel(io:WritableCSVChannel csvChannel) {  var result = csvChannel.close();  if (result is error) {  log:printError(\"Error occurred while closing the channel: \",  err = result);  } }    Closes the Writable CSV channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run csv_io.bal Start processing the CSV file from ./files/sample.csv 1 James 10000 2 Nathan 150000 3 Ronald 120000 4 Roy 6000 5 Oliver 1100000 Processing completed. Reading ./files/sample.csv as a table id=1 name=James salary=10000.0 id=2 name=Nathan salary=150000.0 id=3 name=Ronald salary=120000.0 id=4 name=Roy salary=6000.0 id=5 name=Oliver salary=1100000.0 Creating a table and adding data Writing the table to ./files/output.csv    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/deprecation.html","name":"Deprecation","summary":"In Ballerina, type definitions, functions, object methods, and constants can be deprecated using the @deprecated annotation.\n The compiler will generate warnings if a user uses a deprecated construct. If the deprecated construct contains documentation,\n the user has to add some additional documentation called Deprecated documentation.\n The Deprecated documentation should ideally ...","content":"/  /  /  / Deprecation  import ballerina/io;  // The constant `LKA` is marked as deprecated using the `@deprecated` annotation. // Since it has documentation, the `# # Deprecated` documentation needs to be added as well. // This will appear in the generated documentation. # Country code for Sri Lanka. # # Deprecated # This constant is deprecated. Use the constant `LK` instead. @deprecated public const string LKA = \"LKA\";  # New country code for Sri Lanka. public const string LK = \"LK\";  # Country code for USA. public const string USA = \"USA\";  // The type definition contains both the deprecated constant and its replacement. public type CountryCode LK|LKA|USA;  // The `Address` record type is deprecated, but does not have the `# # Deprecated` documentation. @deprecated public type Address record {|  string street;  string city;  CountryCode countryCode; |};  // The `Person` object type is deprecated, but does not have the `# # Deprecated` documentation. @deprecated public type Person object {  public string firstName = \"John\";  public string lastName = \"Doe\";  // Usage of the deprecated record `Address`.  Address addr = {  street: \"Palm Grove\",  city: \"Colombo 3\",  // Usage of the deprecated constant `LKA`.  countryCode: LKA  };   // Object methods can also be deprecated.  @deprecated  public function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }  };  // The function `createPerson` is marked as deprecated using the `@deprecated` annotation. // Since it has documentation, the `# # Deprecated` documentation needs to be added as well. # Creates and returns a `Person` object given the parameters. # # + fname - First name of the person # + lname - Last name of the person # + street - Street the person is living at # + city - The city the person is living in # + countryCode - The country code for the country the person is living in # + return - A new `Person` object # # # Deprecated # This function is deprecated since the `Person` type is deprecated. @deprecated public function createPerson(string fname, string lname, string street,  string city, CountryCode countryCode) returns Person {   // Usage of the deprecated object `Person`.  Person p = new;   p.firstName = fname;  p.lastName = lname;  p.addr = {street, city, countryCode};  return p; }  public function main() {  // Usage of the deprecated object `Person` and function `createPerson`.  Person p = createPerson(\"Jane\", \"Doe\", \"Castro Street\", \"Mountain View\", USA);   // Usage of the deprecated object method `getFullName`  io:println(p.getFullName());  }    Deprecation  In Ballerina, type definitions, functions, object methods, and constants can be deprecated using the @deprecated annotation.  The compiler will generate warnings if a user uses a deprecated construct. If the deprecated construct contains documentation,  the user has to add some additional documentation called Deprecated documentation.  The Deprecated documentation should ideally include details on why the construct was deprecated and suitable alternate options, which should be used instead.    import ballerina/io;    # Country code for Sri Lanka. # # Deprecated # This constant is deprecated. Use the constant `LK` instead. @deprecated public const string LKA = \"LKA\";    The constant LKA is marked as deprecated using the @deprecated annotation.  Since it has documentation, the # # Deprecated documentation needs to be added as well.  This will appear in the generated documentation.   # New country code for Sri Lanka. public const string LK = \"LK\";    # Country code for USA. public const string USA = \"USA\";    public type CountryCode LK|LKA|USA;    The type definition contains both the deprecated constant and its replacement.   @deprecated public type Address record {|  string street;  string city;  CountryCode countryCode; |};    The Address record type is deprecated, but does not have the # # Deprecated documentation.   @deprecated public type Person object {  public string firstName = \"John\";  public string lastName = \"Doe\";    The Person object type is deprecated, but does not have the # # Deprecated documentation.   Address addr = {  street: \"Palm Grove\",  city: \"Colombo 3\",    Usage of the deprecated record Address.   countryCode: LKA  };    Usage of the deprecated constant LKA.   @deprecated  public function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    Object methods can also be deprecated.   };    # Creates and returns a `Person` object given the parameters. # # + fname - First name of the person # + lname - Last name of the person # + street - Street the person is living at # + city - The city the person is living in # + countryCode - The country code for the country the person is living in # + return - A new `Person` object # # # Deprecated # This function is deprecated since the `Person` type is deprecated. @deprecated public function createPerson(string fname, string lname, string street,  string city, CountryCode countryCode) returns Person {    The function createPerson is marked as deprecated using the @deprecated annotation.  Since it has documentation, the # # Deprecated documentation needs to be added as well.   Person p = new;    Usage of the deprecated object Person.   p.firstName = fname;  p.lastName = lname;  p.addr = {street, city, countryCode};  return p; }    public function main() {    Person p = createPerson(\"Jane\", \"Doe\", \"Castro Street\", \"Mountain View\", USA);    Usage of the deprecated object Person and function createPerson.   io:println(p.getFullName());    Usage of the deprecated object method getFullName   }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run deprecation.bal warning: .::deprecation.bal:35:5: usage of construct 'Address' is deprecated warning: .::deprecation.bal:39:22: usage of construct 'LKA' is deprecated warning: .::deprecation.bal:68:5: usage of construct 'Person' is deprecated warning: .::deprecation.bal:78:5: usage of construct 'Person' is deprecated warning: .::deprecation.bal:78:16: usage of construct 'createPerson' is deprecated warning: .::deprecation.bal:81:16: usage of construct 'Person.getFullName' is deprecated Running executables    Jane Doe    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/directory-listener.html","name":"Directory Listener","summary":"The Directory Listener is used to listen to a directory in the local file system. It notifies when new files are created in the directory or when the existing files are deleted or modified.In this example, the listener monitors any modifications done to a specific directoy.\n Before running the example, ...","content":"/  /  /  / Directory Listener  import ballerina/file; import ballerina/log;  // In this example, the listener monitors any modifications done to a specific directoy. // Before running the example, change the value of the 'path' field // to indicate the path of the directory that you want the listener to monitor. // As the recursive property is set to false, // the listener does not monitor the child directories of the main directory // that it listens to. listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false });  // The directory listener should have at least one of these predefined resources. service localObserver on inFolder {   // This resource is invoked once a new file is created in the listening directory.  resource function onCreate(file:FileEvent m) {  string msg = \"Create: \" + m.name;  log:printInfo(msg);  }   // This resource is invoked once an existing file is deleted from the listening directory.  resource function onDelete(file:FileEvent m) {  string msg = \"Delete: \" + m.name;  log:printInfo(msg);  }   // This resource is invoked once an existing file is modified in the listening directory.  resource function onModify(file:FileEvent m) {  string msg = \"Modify: \" + m.name;  log:printInfo(msg);  } }    Directory Listener  The Directory Listener is used to listen to a directory in the local file system. It notifies when new files are created in the directory or when the existing files are deleted or modified.    import ballerina/file; import ballerina/log;    listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false });    In this example, the listener monitors any modifications done to a specific directoy.  Before running the example, change the value of the ‘path’ field  to indicate the path of the directory that you want the listener to monitor.  As the recursive property is set to false,  the listener does not monitor the child directories of the main directory  that it listens to.   service localObserver on inFolder {    The directory listener should have at least one of these predefined resources.   resource function onCreate(file:FileEvent m) {  string msg = \"Create: \" + m.name;  log:printInfo(msg);  }    This resource is invoked once a new file is created in the listening directory.   resource function onDelete(file:FileEvent m) {  string msg = \"Delete: \" + m.name;  log:printInfo(msg);  }    This resource is invoked once an existing file is deleted from the listening directory.   resource function onModify(file:FileEvent m) {  string msg = \"Modify: \" + m.name;  log:printInfo(msg);  } }    This resource is invoked once an existing file is modified in the listening directory.   # Before running the sample, create a new file called `test1.txt` in the directory called `observed-dir` and modify and delete it. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run directory_listener.bal Create: /home/ballerina/fs-server-connector/observed-dir/test1.txt Modify: /home/ballerina/fs-server-connector/observed-dir/test1.txt Delete: /home/ballerina/fs-server-connector/observed-dir/test1.txt    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/elvis-operator.html","name":"Elvis","summary":"The Elvis operator is a conditional operator that handles nil. It evaluates an expression\n and if the value is nil (()), it executes the second expression.The elvis operator takes two operands and uses the ‘?:’ symbol to form it as shown in the syntax below.\n      ...","content":"/  /  /  / Elvis  import ballerina/io;  public function main() {  string? x = ();   // If you need to get the value of `x` if it is a `string`, or assign some  // other `string` value if `x` is `()`, you can do it using the type-guard  // as follows.  string output = x is string ? \"value is string: \" + x : \"value is nil\";  io:println(\"The output from the type-guard: \" + output);   // You can achieve the same using the elvis operator as follows.  string elvisOutput = x ?: \"value is nil\";  io:println(\"The output from the elvis operator: \" + elvisOutput); }    Elvis  The Elvis operator is a conditional operator that handles nil. It evaluates an expression  and if the value is nil (()), it executes the second expression.  The elvis operator takes two operands and uses the ‘?:’ symbol to form it as shown in the syntax below.  expression ?: expressionIfNil    import ballerina/io;    public function main() {  string? x = ();    string output = x is string ? \"value is string: \" + x : \"value is nil\";  io:println(\"The output from the type-guard: \" + output);    If you need to get the value of x if it is a string, or assign some  other string value if x is (), you can do it using the type-guard  as follows.   string elvisOutput = x ?: \"value is nil\";  io:println(\"The output from the elvis operator: \" + elvisOutput); }    You can achieve the same using the elvis operator as follows.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run elvis_operator.bal The output from the type-guard: value is nil The output from the elvis operator: value is nil    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/docker-deployment.html","name":"Docker Deployment","summary":"Ballerina supports generating Docker images, Dockerfile based on annotations.\nA single Ballerina module is mapped to a single Docker Image.\nDocker should be configured to run the sample.\nFor more information, see the .Adding the @docker:Expose{} annotation to a listener endpoint exposes the endpoint port.Adding the @docker:Config{} annotation to a service modifies the ...","content":"/  /  /  / Docker Deployment  import ballerina/http; import ballerina/log; import ballerina/docker;  //Adding the `@docker:Expose{}` annotation to a listener endpoint exposes the endpoint port. @docker:Expose {} listener http:Listener helloWorldEP = new(9090);  //Adding the `@docker:Config{}` annotation to a service modifies the generated Docker image and Dockerfile. //This sample generates a Docker image as `helloworld:v1.0.0`. @docker:Config {  //Docker image name should be helloworld.  name: \"helloworld\",  //Docker image version should be v1.0.  tag: \"v1.0\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello World from Docker ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Docker Deployment  Ballerina supports generating Docker images, Dockerfile based on annotations. A single Ballerina module is mapped to a single Docker Image. Docker should be configured to run the sample. For more information, see the .    import ballerina/http; import ballerina/log; import ballerina/docker;    @docker:Expose {} listener http:Listener helloWorldEP = new(9090);    Adding the @docker:Expose{} annotation to a listener endpoint exposes the endpoint port.   @docker:Config {    Adding the @docker:Config{} annotation to a service modifies the generated Docker image and Dockerfile. This sample generates a Docker image as helloworld:v1.0.0.   name: \"helloworld\",    Docker image name should be helloworld.   tag: \"v1.0\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello World from Docker ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Docker image version should be v1.0.   # Build the Ballerina program to generate the Docker image and Dockerfile. $ ballerina build docker_deployment.bal Compiling source \tdocker_deployment.bal Generating executables \tdocker_deployment.jar    Generating docker artifacts... \t@docker - complete 2/2 Run the following command to start a Docker container: \tdocker run -d -p 9090:9090 helloworld:v1.0    # Verify if the Docker image is generated $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE helloworld v1.0 8d5b2f26145b 2 seconds ago 127MB    # Run the generated Docker image $ docker run -d -p 9090:9090 helloworld:v1.0    # Access the service $ curl http://localhost:9090/helloWorld/sayHello Hello World from Docker!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/crypto.html","name":"Cryptographic Operations","summary":"The crypto stdlib provides functions usable to perform different cryptographic operations such as hashing,\n HMAC generation, checksum generation and digitally signing data.Input value for crypto operations.Hashing input value using MD5 hashing algorithm, and printing hash value using Hex encoding.Hashing input value using SHA1 hashing algorithm, and printing hash value using ...","content":"/  /  /  / Cryptographic Operations  import ballerina/crypto; import ballerina/io; import ballerina/lang.'string; import ballerina/math;  public function main() returns error? {   // Input value for crypto operations.  string input = \"Hello Ballerina!\";  byte[] inputArr = input.toBytes();   // Hashing input value using MD5 hashing algorithm, and printing hash value using Hex encoding.  byte[] output = crypto:hashMd5(inputArr);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());   // Hashing input value using SHA1 hashing algorithm, and printing hash value using Base64 encoding.  output = crypto:hashSha1(inputArr);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());   // Hashing input value using SHA256 hashing algorithm, and printing hash value using Hex encoding.  output = crypto:hashSha256(inputArr);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());   // Hashing input value using SHA384 hashing algorithm, and printing hash value using Base64 encoding.  output = crypto:hashSha384(inputArr);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());   // Hashing input value using SHA512 hashing algorithm, and printing hash value using Hex encoding.  output = crypto:hashSha512(inputArr);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());    // The key used for HMAC generation.  string key = \"somesecret\";  byte[] keyArr = key.toBytes();   // HMAC generation for input value using MD5 hashing algorithm, and printing HMAC value using Hex encoding.  output = crypto:hmacMd5(inputArr, keyArr);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());   // HMAC generation for input value using SHA1 hashing algorithm, and printing HMAC value using Base64 encoding.  output = crypto:hmacSha1(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());   // HMAC generation for input value using SHA256 hashing algorithm, and printing HMAC value using Hex encoding.  output = crypto:hmacSha256(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());   // HMAC generation for input value using SHA384 hashing algorithm, and printing HMAC value using Base64 encoding.  output = crypto:hmacSha384(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());   // HMAC generation for input value using SHA512 hashing algorithm, and printing HMAC value using Hex encoding.  output = crypto:hmacSha512(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16());    // Hex encoded CRC32B checksum generation for input value.  io:println(\"CRC32B for text: \" + crypto:crc32b(inputArr));   // Hex encoded CRC32B checksum generation for XML data.  xml xmlContent = xml `<foo>Hello Ballerina</foo>`;  io:println(\"CRC32 for xml content: \" + crypto:crc32b(xmlContent.toString().toBytes()));    // Obtaining reference to a RSA private key stored within a PKCS#12 or PFX format archive file.  crypto:KeyStore keyStore = {path: \"./sampleKeystore.p12\", password: \"ballerina\"};  var privateKey = crypto:decodePrivateKey(keyStore, \"ballerina\", \"ballerina\");   if (privateKey is crypto:PrivateKey) {  // Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.  output = check crypto:signRsaMd5(inputArr, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());   // Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.  output = check crypto:signRsaSha1(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());   // Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.  output = check crypto:signRsaSha256(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());   // Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.  output = check crypto:signRsaSha384(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());   // Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.  output = check crypto:signRsaSha512(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());  } else {  io:println(\"Invalid private key\");  }   // Randomly generate a 128 bit key for AES encryption.  byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKeyArr[i] = <byte>(math:randomInRange(0, 255));  }   // Randomly generate a 128 bit IV for AES encryption.  byte[16] ivArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  ivArr[i] = <byte>(math:randomInRange(0, 255));  }   // Encrypt and decrypt an input value using AES CBC PKCS5 padding.  output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr);  io:println(\"AES CBC PKCS5 decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt an input value using AES CBC without padding.  output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt an input value using AES GCM PKCS5 padding.  output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr);  io:println(\"AES GCM PKCS5 decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt an input value using AES GCM without padding.  output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt an input value using AES ECB PKCS5 padding.  output = check crypto:encryptAesEcb(inputArr, rsaKeyArr);  output = check crypto:decryptAesEcb(output, rsaKeyArr);  io:println(\"AES ECB PKCS5 decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt input value using AES ECB without padding.  output = check crypto:encryptAesEcb(inputArr, rsaKeyArr, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKeyArr, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" + check 'string:fromBytes(output));   // Public key used for RSA encryption.  crypto:PublicKey rsaPublicKey = check crypto:decodePublicKey(keyStore, \"ballerina\");   // Private key used for RSA decryption.  crypto:PrivateKey rsaPrivateKey = check crypto:decodePrivateKey(keyStore, \"ballerina\",  \"ballerina\");   // Encrypt and decrypt an input value using RSA ECB PKCS1 padding.  output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" + check 'string:fromBytes(output));   // Encrypt and decrypt an input value using RSA ECB OAEPwithSHA512andMGF1 padding.  output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check 'string:fromBytes(output)); }    Cryptographic Operations  The crypto stdlib provides functions usable to perform different cryptographic operations such as hashing,  HMAC generation, checksum generation and digitally signing data.    import ballerina/crypto; import ballerina/io; import ballerina/lang.'string; import ballerina/math;    public function main() returns error? {    string input = \"Hello Ballerina!\";  byte[] inputArr = input.toBytes();    Input value for crypto operations.   byte[] output = crypto:hashMd5(inputArr);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());    Hashing input value using MD5 hashing algorithm, and printing hash value using Hex encoding.   output = crypto:hashSha1(inputArr);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());    Hashing input value using SHA1 hashing algorithm, and printing hash value using Base64 encoding.   output = crypto:hashSha256(inputArr);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());    Hashing input value using SHA256 hashing algorithm, and printing hash value using Hex encoding.   output = crypto:hashSha384(inputArr);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());    Hashing input value using SHA384 hashing algorithm, and printing hash value using Base64 encoding.   output = crypto:hashSha512(inputArr);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());    Hashing input value using SHA512 hashing algorithm, and printing hash value using Hex encoding.   string key = \"somesecret\";  byte[] keyArr = key.toBytes();    The key used for HMAC generation.   output = crypto:hmacMd5(inputArr, keyArr);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());    HMAC generation for input value using MD5 hashing algorithm, and printing HMAC value using Hex encoding.   output = crypto:hmacSha1(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());    HMAC generation for input value using SHA1 hashing algorithm, and printing HMAC value using Base64 encoding.   output = crypto:hmacSha256(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());    HMAC generation for input value using SHA256 hashing algorithm, and printing HMAC value using Hex encoding.   output = crypto:hmacSha384(inputArr, keyArr);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());    HMAC generation for input value using SHA384 hashing algorithm, and printing HMAC value using Base64 encoding.   output = crypto:hmacSha512(inputArr, keyArr);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16());    HMAC generation for input value using SHA512 hashing algorithm, and printing HMAC value using Hex encoding.   io:println(\"CRC32B for text: \" + crypto:crc32b(inputArr));    Hex encoded CRC32B checksum generation for input value.   xml xmlContent = xml `<foo>Hello Ballerina</foo>`;  io:println(\"CRC32 for xml content: \" + crypto:crc32b(xmlContent.toString().toBytes()));    Hex encoded CRC32B checksum generation for XML data.   crypto:KeyStore keyStore = {path: \"./sampleKeystore.p12\", password: \"ballerina\"};  var privateKey = crypto:decodePrivateKey(keyStore, \"ballerina\", \"ballerina\");    Obtaining reference to a RSA private key stored within a PKCS#12 or PFX format archive file.   if (privateKey is crypto:PrivateKey) {    output = check crypto:signRsaMd5(inputArr, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   output = check crypto:signRsaSha1(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.   output = check crypto:signRsaSha256(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   output = check crypto:signRsaSha384(inputArr, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Base64 encoding.   output = check crypto:signRsaSha512(inputArr, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());  } else {  io:println(\"Invalid private key\");  }    Signing input value using RSA-MD5 signature algorithms, and printing the signature value using Hex encoding.   byte[16] rsaKeyArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKeyArr[i] = <byte>(math:randomInRange(0, 255));  }    Randomly generate a 128 bit key for AES encryption.   byte[16] ivArr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  ivArr[i] = <byte>(math:randomInRange(0, 255));  }    Randomly generate a 128 bit IV for AES encryption.   output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr);  io:println(\"AES CBC PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES CBC PKCS5 padding.   output = check crypto:encryptAesCbc(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES CBC without padding.   output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr);  io:println(\"AES GCM PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES GCM PKCS5 padding.   output = check crypto:encryptAesGcm(inputArr, rsaKeyArr, ivArr, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKeyArr, ivArr, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES GCM without padding.   output = check crypto:encryptAesEcb(inputArr, rsaKeyArr);  output = check crypto:decryptAesEcb(output, rsaKeyArr);  io:println(\"AES ECB PKCS5 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using AES ECB PKCS5 padding.   output = check crypto:encryptAesEcb(inputArr, rsaKeyArr, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKeyArr, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt input value using AES ECB without padding.   crypto:PublicKey rsaPublicKey = check crypto:decodePublicKey(keyStore, \"ballerina\");    Public key used for RSA encryption.   crypto:PrivateKey rsaPrivateKey = check crypto:decodePrivateKey(keyStore, \"ballerina\",  \"ballerina\");    Private key used for RSA decryption.   output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" + check 'string:fromBytes(output));    Encrypt and decrypt an input value using RSA ECB PKCS1 padding.   output = check crypto:encryptRsaEcb(inputArr, rsaPublicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, rsaPrivateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check 'string:fromBytes(output)); }    Encrypt and decrypt an input value using RSA ECB OAEPwithSHA512andMGF1 padding.   # To run this sample, navigate to the directory that contains the # `.bal` file, make sure `sampleKeystore.p12` file is present in the # same folder and issue the `ballerina run` command. ballerina run crypto.bal Hex encoded hash with MD5: 0605402ee16d8e96511a58ff105bc24a Base64 encoded hash with SHA1: /8fwbGIevBvv2Nl3gEL9DtWas+Q= Hex encoded hash with SHA256: a984a643c350b17f0738bac0fef17f2cd91d91e04596351d0  af670c79adc12d5 Base64 encoded hash with SHA384: lselzItgAZHQmqNbkf/s2aRjBSd93O3ayc0PB0Dxk6AEo1  s44zyTz/Qp0FJO1n6b Hex encoded hash with SHA512: a6f0770f1582f49396a97fbd5973ac22a3a578ac6a991786427  dfec17dbd984d8d6289771ac6f44176160a3dcd59f4a8c6b3ab97bef0caa5c67a3fac78c8e946 Hex encoded HMAC with MD5: b69fa2cc698e0923a7eea9d8f2b156fe Base64 encoded HMAC with SHA1: AkWFajkb/gml703Zf4pPgxrjam4= Hex encoded HMAC with SHA256: 13a3369b8ba326fd311d4500b06a5214a02ed2a033917108f6b  9af58b7ede381 Base64 encoded HMAC with SHA384: 0AjKoWLhNPgdobGTPJs0PdkA0W9wkJtzUvXigzC1ZmXDJJsx  p4icks4JrPiwHGm6 Hex encoded HMAC with SHA512: 27588ad08e772a6bba5fca5f45cf467819c8de69a70a42be6fe  3eb09ceb3bfeb8b2976bda8ea5c10dcfa2294b12cb0b50b22a06309bada98af21857904a03205 CRC32B for text: db9230c5 CRC32 for xml content: 7d5c0879 Hex encoded RSA-MD5 signature: 2cfd121e4ff2409d1b2482ebbf37d0c035884d6d858e307e44  60b092d79cb20abb624a0dfae76b73b1fc85447be3060a36b318813f0115b1919e5efa7a7f9b1  173ec869f56fd9448d99770e1565db1c69a04fd0075fa0e33423a7e829a8b9c25a4dd2c68f3ee  e021c0c4ff27979750b395384e280afd87af5274c8d2d99ad4438d9bfc9b2c5a2814212ba29ce  6ff70cbe30a5c23f86b0330e143c4d8813ff10092cd313c6861706d37df5f4bb4e9fc72354975  ee1786cf24c79b9edfa909968f198c4da37464f3d214a68fb39956717e92d667bb5a9a7f5986b  a055d431813d4053a028873499f98c94fd6b5c6fd5aefad432669f957ab4ce9e91c5e77b36ec0 Base64 encoded RSA-SHA1 signature: bYMHKKVkjbOUp9ly3AdW9/euxF94krkkF9SDk2FfbVEc0m  qpGIxVoZlPiFxszurZF1YPcqOSeOehDkaHXUMfQkTjBq7XlcePtkywy0fChqw8/SWqZR8nbYv97tt  8+MVTkymbm26syQLwYNLiGp/EsN6X+fJpkdakwHE+TrdE+rEFrNysGyAm1DWwc4c+l7MEmSYMUnh/  GWPY5r2knOOdDA3mr+XyrsxzFRWZgO7ebVvEQfq9XkRp8kdiGVgpLS5au0jKj3EpbCdS1prFgy3gr  kuSJTTUQCwgPo7WSjWbuehFGni7rbas8HIqNlyWF0qUyznJ3eqbUwZ95QqOoVWZoQ== Hex encoded RSA-SHA256 signature: 215c6ea96c9e82348430c6bb02e715560b4fbd3afcf24fb  eb41ff12d4d68a797d61c4d6f822807688e4dc604e212b3cc7ac563b3cbe4e5690e2aebaf4e3d  f35c19d4b0f7043f50501f390634303577053b029d495104c0e98bc887f0be744ef6f726f7192  01907ad4e86cef82eb030b60c384f7034a85159081e598e197bb8904a9123f39d190796dc7fd9  46157547c10523999b8fa956d4119dbfe3c1435911c0585cf3c537964516706772e87f2470557  40cc4867ac6b99d7bf699fce1b59956c7f55368c8c88c9d47e51ef120ed3f27c3e555691a6971  42c78cbd72c23b81b43fa5ab67164a35f8e8c6bf1da187d3feb866add13f1fb9576a2f7887535  311 Base64 encoded RSA-SHA384 signature: BjQ40dffGiRQ4zo1s+ld+zKhJL21RbO5sW3L2+4xmonU  t126u9D4/FZ2sM1QGGamj8btB9otiYmWr9sFm4fTs1EX6vrxcCGCAiDdkMxiRs7kShaz2x/BjJQ7c  Od9OY+amwo7DQ/FAk9mNOt4lFUpjc9WyEW9F1PEJRXZQvMmVabDu8lp/Fh02lmEquG15DT5qT0jRx  RJiS8CNa+97cMZdOmF2KeADfRbNJSz70mZ76MrsNxYIXYIiJzJBQod0efQr0Sr/HDn4JDVph9rpDM  3p8m94TyXvSOwxwxzZWRLEwB0ANdfDmbrW4bOpxfZZFmy1hltqNJQ9G0BcKOHsZDj6Q== Hex encoded RSA-SHA512 signature: 15428fdc7b26d18b1f3eae4569399ae6ebfd430c8f073bf  2fa77ebfe1ad5645640374ea4a4aeadd252af3a198e55e69ad2a910e28470d9b54748887de06a  5c3ed7ab12399a404359332553e051e8ae0f3ef741faa15a21ad17a9c235e5f91d567bcca0e5a  6117689dccada4a33ee897514f7a8a32f12dac0087f5dcbb094c93c792f672e1685618ac5d93a  a9d30f6d8e306145ef2d1b9cfdc04d6c61b43376089a78471e8e03d97ee3b57e1b734a23f4436  6a99234a0abeb1d36d01c474833b4c2beaf430dae06ab95a1c951645fb1e0a5e7b9eed44d40e3  5036f2cd2764df6cc04fe1248e1bb772a53c8201a974109333a318ce57930494d4cb5e41d0dc8  f1c AES CBC PKCS5 decrypted value: Hello Ballerina! AES CBC no padding decrypted value: Hello Ballerina! AES GCM PKCS5 decrypted value: Hello Ballerina! AES GCM no padding decrypted value: Hello Ballerina! AES ECB PKCS5 decrypted value: Hello Ballerina! AES ECB no padding decrypted value: Hello Ballerina! RSA ECB PKCS1 decrypted value: Hello Ballerina! RSA ECB OAEPwithSHA512andMGF1 decrypted value: Hello Ballerina!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/error-destructure-binding-pattern.html","name":"Error Destructure Binding Pattern","summary":"Error destructuring binding patterns are used to destructure the reason string and the detail mapping values from an\n error value, and assign the values to existing variable references.This error-destructure binding pattern will destructure an error value of the type SampleError\n and assign the values to the relevant variable references.\n The ...","content":"/  /  /  / Error Destructure Binding Pattern  import ballerina/io;  type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };  type SampleError error<string, SampleErrorData>;  public function main() {  string reason;  string info;  boolean fatal;  // This error-destructure binding pattern will destructure an `error` value of the type `SampleError`  // and assign the values to the relevant variable references.  // The value of the reason string in the `SampleError` will be assigned to the variable `reason`.  // The values in the detail mapping will be assigned to the relevant variables.  error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);   string reasonTwo;  map<anydata|error> params;  // The detail mapping can be destructured into an existing `map<anydata|error>`-typed variable by using a rest parameter.  error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Map: \", params);  // The underscore '_' sign can be used to ignore either the reason string or the detail mapping.  string? detailMsg;  error(_, detailMsg = detailMsg) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }  function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Info\", fatal = true);  return e; }  type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};  function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    Error Destructure Binding Pattern  Error destructuring binding patterns are used to destructure the reason string and the detail mapping values from an  error value, and assign the values to existing variable references.    import ballerina/io;    type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };    type SampleError error<string, SampleErrorData>;    public function main() {  string reason;  string info;  boolean fatal;    error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);    This error-destructure binding pattern will destructure an error value of the type SampleError  and assign the values to the relevant variable references.  The value of the reason string in the SampleError will be assigned to the variable reason.  The values in the detail mapping will be assigned to the relevant variables.   string reasonTwo;  map<anydata|error> params;    error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Map: \", params);  The detail mapping can be destructured into an existing map<anydata|error>-typed variable by using a rest parameter.   string? detailMsg;  error(_, detailMsg = detailMsg) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }    The underscore ‘_’ sign can be used to ignore either the reason string or the detail mapping.   function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Info\", fatal = true);  return e; }    type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};    function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run error_destructure_binding_pattern.bal Reason String: Sample Error Info: Detail Info Fatal: true Reason String: Sample Error Detail Map: info=Detail Info fatal=true Detail Message: Failed Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/equality.html","name":"Equality","summary":"Ballerina provides the below equality operators:\n == for deep value equality of anydata|error typed values.\n === for reference equality.\n != and !== as the negations.The == and != are used with the values of compatible anydata|error types and serves as deep value equality checks.The === and !== are used with ...","content":"/  /  /  / Equality  import ballerina/io;  type Employee record {  string name;  int id; };  type Person record {  string name; };  final Employee globalEmployee = {name: \"John\", id: 2102};  public function main() {  // The `==` and `!=` are used with the values of compatible `anydata|error` types and serves as deep value equality checks.  int i1 = 1;  int i2 = 1;  boolean isEqual = i1 == i2;  io:println(i1, \" == \", i2, \" is \", isEqual);   int i3 = 2;  boolean isNotEqual = i1 != i3;  io:println(i1, \" != \", i3, \" is \", isNotEqual);   [string|int, float, boolean] t1 = [1, 1.0, false];  [int, float|string, boolean] t2 = [1, 1.0, false];  isEqual = t1 == t2;  io:println(t1, \" == \", t2, \" is \", isEqual);   [int, float|string, boolean] t3 = [11, 1.0, true];  isNotEqual = t1 != t3;  io:println(t1, \" != \", t3, \" is \", isNotEqual);   Employee e1 = {name: \"Jane\", id: 1100};  Employee e2 = {name: \"Jane\", id: 1100};  isNotEqual = e1 != e2;  io:println(e1, \" != \", e2, \" is \", isNotEqual);   Employee e3 = {name: \"Anne\", id: 1100};  isEqual = e1 == e3;  io:println(e1, \" == \", e3, \" is \", isEqual);   // The `===` and `!==` are used with values of compatible types and serves as reference equality checks.  Employee e4 = getGlobalEmployee();  Person e5 = getGlobalEmployee();  boolean isRefEqual = e4 === e5;  io:println(\"e4 === e5 is \", isRefEqual);   e4 = {name: \"John\", id: 2102};  boolean isNotRefEqual = e4 !== e5;  io:println(\"e4 !== e5 is \", isNotRefEqual);   // `===` for non-reference types is the same as `==`.  float f1 = 1.1;  float f2 = 1.1;  isRefEqual = f1 === f2;  io:println(\"f1 === f2 is \", isRefEqual);   f2 = 12.1;  isNotRefEqual = f1 !== f2;  io:println(\"f1 !== f2 is \", isNotRefEqual); }  function getGlobalEmployee() returns Employee {  return globalEmployee; }    Equality  Ballerina provides the below equality operators:  == for deep value equality of anydata|error typed values.  === for reference equality.  != and !== as the negations.    import ballerina/io;    type Employee record {  string name;  int id; };    type Person record {  string name; };    final Employee globalEmployee = {name: \"John\", id: 2102};    public function main() {    int i1 = 1;  int i2 = 1;  boolean isEqual = i1 == i2;  io:println(i1, \" == \", i2, \" is \", isEqual);    The == and != are used with the values of compatible anydata|error types and serves as deep value equality checks.   int i3 = 2;  boolean isNotEqual = i1 != i3;  io:println(i1, \" != \", i3, \" is \", isNotEqual);    [string|int, float, boolean] t1 = [1, 1.0, false];  [int, float|string, boolean] t2 = [1, 1.0, false];  isEqual = t1 == t2;  io:println(t1, \" == \", t2, \" is \", isEqual);    [int, float|string, boolean] t3 = [11, 1.0, true];  isNotEqual = t1 != t3;  io:println(t1, \" != \", t3, \" is \", isNotEqual);    Employee e1 = {name: \"Jane\", id: 1100};  Employee e2 = {name: \"Jane\", id: 1100};  isNotEqual = e1 != e2;  io:println(e1, \" != \", e2, \" is \", isNotEqual);    Employee e3 = {name: \"Anne\", id: 1100};  isEqual = e1 == e3;  io:println(e1, \" == \", e3, \" is \", isEqual);    Employee e4 = getGlobalEmployee();  Person e5 = getGlobalEmployee();  boolean isRefEqual = e4 === e5;  io:println(\"e4 === e5 is \", isRefEqual);    The === and !== are used with values of compatible types and serves as reference equality checks.   e4 = {name: \"John\", id: 2102};  boolean isNotRefEqual = e4 !== e5;  io:println(\"e4 !== e5 is \", isNotRefEqual);    float f1 = 1.1;  float f2 = 1.1;  isRefEqual = f1 === f2;  io:println(\"f1 === f2 is \", isRefEqual);    === for non-reference types is the same as ==.   f2 = 12.1;  isNotRefEqual = f1 !== f2;  io:println(\"f1 !== f2 is \", isNotRefEqual); }    function getGlobalEmployee() returns Employee {  return globalEmployee; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run equality.bal 1 == 1 is true 1 != 2 is true 1 1.0 false == 1 1.0 false is true 1 1.0 false != 11 1.0 true is true name=Jane id=1100 != name=Jane id=1100 is false name=Jane id=1100 == name=Anne id=1100 is false e4 === e5 is true e4 !== e5 is true f1 === f2 is true f1 !== f2 is true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/different-payload-types.html","name":"Handling Different Payload Types","summary":"Ballerina supports different payload types to be used directly with HTTP client actions\n(eg: POST, PUT, DELETE etc..) and service respond calls.Client endpoint.Service to test HTTP client remote functions with different payload types.GET remote function without any payload.GET remote function with request as message.POST remote function without any payload.POST remote function ...","content":"/  /  /  / Handling Different Payload Types  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  //Client endpoint. http:Client clientEP = new (\"http://localhost:9091/backEndService\");  //Service to test HTTP client remote functions with different payload types. service actionService on new http:Listener(9090) {   resource function messageUsage(http:Caller caller, http:Request req) {   //GET remote function without any payload.  var response = clientEP->get(\"/greeting\");  handleResponse(response);   //GET remote function with request as message.  http:Request request = new;  response = clientEP->get(\"/greeting\", message = request);  handleResponse(response);   //POST remote function without any payload.  response = clientEP->post(\"/echo\", ());  handleResponse(response);   //POST remote function with text as payload.  response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);   //POST remote function with `xml` as payload.  response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);   //POST remote function with `json` as payload.  response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);   //POST remote function with `byte[]` as payload.  string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);   //Get a byte channel to a given file.  var bChannel = io:openReadableFile(\"./files/logo.png\");   if (bChannel is io:ReadableByteChannel) {  //POST remote function with byte channel as payload. Since the file path is static  //`untaint` is used to denote that the byte channel is trusted .  response = clientEP->post(\"/image\", <@untainted>bChannel);  handleResponse(response);   //Create a JSON body part.  mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});   //Create a text body part.  mime:Entity part2 = new;  part2.setText(\"Hello\");   //POST remote function with body parts as payload.  mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response);   var result = caller->respond(\"Client actions successfully executed!\");  handleError(result);  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>bChannel.detail()?.message);  var result = caller->respond(res);  handleError(result);  }  } }  //Back end service that send out different payload types as response. service backEndService on new http:Listener(9091) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/greeting\"  }  resource function replyText(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  }   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/echo\"  }  resource function directResponse(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = <string>returnValue.detail()?.message;  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  }   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/image\"  }  resource function sendByteChannel(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } }  //Handle response data received from HTTP client remote functions. function handleResponse(http:Response|error response) {  if (response is http:Response) {  //Print the content type of the received data.  if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"Xml data: \" + strValue);  } else {  log:printError(\"Error in parsing xml data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\", payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\", payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\", payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.reason(), response);  } }  function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message);  var result = caller->respond(res);  handleError(result); }  function handleError(error? result) {  if (result is error) {  log:printError(result.reason(), result);  } }  //Get the base type from a given content type. function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }  //Loop through body parts and print its content. function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.reason(), payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.reason(), payload);  }  }  } }    Handling Different Payload Types  Ballerina supports different payload types to be used directly with HTTP client actions (eg: POST, PUT, DELETE etc..) and service respond calls.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9091/backEndService\");    Client endpoint.   service actionService on new http:Listener(9090) {    Service to test HTTP client remote functions with different payload types.   resource function messageUsage(http:Caller caller, http:Request req) {    var response = clientEP->get(\"/greeting\");  handleResponse(response);    GET remote function without any payload.   http:Request request = new;  response = clientEP->get(\"/greeting\", message = request);  handleResponse(response);    GET remote function with request as message.   response = clientEP->post(\"/echo\", ());  handleResponse(response);    POST remote function without any payload.   response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);    POST remote function with text as payload.   response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);    POST remote function with xml as payload.   response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);    POST remote function with json as payload.   string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);    POST remote function with byte[] as payload.   var bChannel = io:openReadableFile(\"./files/logo.png\");    Get a byte channel to a given file.   if (bChannel is io:ReadableByteChannel) {    response = clientEP->post(\"/image\", <@untainted>bChannel);  handleResponse(response);    POST remote function with byte channel as payload. Since the file path is static untaint is used to denote that the byte channel is trusted .   mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});    Create a JSON body part.   mime:Entity part2 = new;  part2.setText(\"Hello\");    Create a text body part.   mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response);    POST remote function with body parts as payload.   var result = caller->respond(\"Client actions successfully executed!\");  handleError(result);  } else {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>bChannel.detail()?.message);  var result = caller->respond(res);  handleError(result);  }  } }    service backEndService on new http:Listener(9091) {    Back end service that send out different payload types as response.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/greeting\"  }  resource function replyText(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/echo\"  }  resource function directResponse(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = <string>returnValue.detail()?.message;  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/image\"  }  resource function sendByteChannel(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {    Handle response data received from HTTP client remote functions.   if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"Xml data: \" + strValue);  } else {  log:printError(\"Error in parsing xml data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\", payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\", payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\", payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.reason(), response);  } }    Print the content type of the received data.   function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message);  var result = caller->respond(res);  handleError(result); }    function handleError(error? result) {  if (result is error) {  log:printError(result.reason(), result);  } }    function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Get the base type from a given content type.   function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.reason(), payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.reason(), payload);  }  }  } }    Loop through body parts and print its content.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run different_payload_types.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9091 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2018-12-04 21:17:59,696 INFO [ballerina/log] - Text data: Hello 2018-12-04 21:17:59,717 INFO [ballerina/log] - Text data: Hello 2018-12-04 21:17:59,727 INFO [ballerina/log] - Entity body is not available 2018-12-04 21:17:59,737 INFO [ballerina/log] - Text data: Sample Text 2018-12-04 21:18:00,005 INFO [ballerina/log] - Xml data: <yy>Sample Xml</yy> 2018-12-04 21:18:00,026 INFO [ballerina/log] - Json data: {\"name\":\"apple\", \"color\":\"red\"} 2018-12-04 21:18:00,036 INFO [ballerina/log] - Response contains binary data: Sample Text 2018-12-04 21:18:00,051 INFO [ballerina/log] - Response contains an image 2018-12-04 21:18:00,081 INFO [ballerina/log] - Response contains body parts: 2018-12-04 21:18:00,084 INFO [ballerina/log] - Json Part: {\"name\":\"Jane\"} 2018-12-04 21:18:00,085 INFO [ballerina/log] - Text Part: Hello    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/error-handling.html","name":"Error Handling","summary":"Ballerina distinguishes ordinary errors such as failing to open a file or\n failing to send a network response, from an exceptional condition\n in the code, such as type cast errors.\n Error handling in Ballerina incorporates two different strategies\n depending on the type of error. For ordinary errors such as failing ...","content":"/  /  /  / Error Handling  import ballerina/io;  const ACCOUNT_NOT_FOUND = \"AccountNotFound\"; const INVALID_ACCOUNT_ID = \"InvalidAccountID\";  function getAccountBalance(int accountID) returns int|error {  if (accountID < 0) {  // Return an error with \"InvalidAccountID\" as the reason if `accountID` is less than zero.  return error(INVALID_ACCOUNT_ID, accountID = accountID);  } else if (accountID > 100) {  // Return an error with \"AccountNotFound\" as the reason if `accountID` is greater than hundred.  return error(ACCOUNT_NOT_FOUND, accountID = accountID);  }  // Return a value if `accountID` is in between zero and hundred inclusive.  return 600; }  public function main() {  // Define an error of the generic `error` type using the default error constructor.  // The error reason must be the first and only positional argument to the default error constructor and the type of the // value must be a subtype of `string`. Additional fields providing more details can be passed as named arguments to the constructor  // and the type of each of those must be a subtype of `anydata|error`.  error simpleError = error(\"SimpleErrorType\", message = \"Simple error occurred\");   // Print the error reason and the `message` field from the error detail.  // The `.reason()` and `.detail()` methods can be invoked on error values  // to retrieve the reason and details of the error.  // `message` is an optional field in the generic error `Detail` record.  io:println(\"Error: \", simpleError.reason(),  \", Message: \", simpleError.detail()?.message);   int|error result = getAccountBalance(-1);  // If the `result` is an `int`, then print the value.  if (result is int) {  io:println(\"Account Balance: \", result);  // If an error is returned, print the reason and the account ID from the detail record.  // Each additional error detail field provided to the error constructor is available as a field in the error detail record.  } else {  io:println(\"Error: \", result.reason(),  \", Account ID: \", result.detail()[\"accountID\"]);  } }    Error Handling  Ballerina distinguishes ordinary errors such as failing to open a file or  failing to send a network response, from an exceptional condition  in the code, such as type cast errors.  Error handling in Ballerina incorporates two different strategies  depending on the type of error. For ordinary errors such as failing to  open a file or failing to send a network response,  the error value is returned.  When the Ballerina runtime encounters exceptional conditions the runtime  panics resulting in abrupt completion of execution,  unless the error is explicitly handled.  Ballerina provides language constructs to handle both returned error values  and panics. This example demonstrates how errors can be created,  returned, and how returned errors can be handled.  Ballerina error values are immutable structured values composed of  an error reason string, a stack trace representing the execution stack  at the point at which the error value was created,  and an error detail record.    import ballerina/io;    const ACCOUNT_NOT_FOUND = \"AccountNotFound\"; const INVALID_ACCOUNT_ID = \"InvalidAccountID\";    function getAccountBalance(int accountID) returns int|error {  if (accountID < 0) {    return error(INVALID_ACCOUNT_ID, accountID = accountID);  } else if (accountID > 100) {    Return an error with “InvalidAccountID” as the reason if accountID is less than zero.   return error(ACCOUNT_NOT_FOUND, accountID = accountID);  }    Return an error with “AccountNotFound” as the reason if accountID is greater than hundred.   return 600; }    Return a value if accountID is in between zero and hundred inclusive.   public function main() {    error simpleError = error(\"SimpleErrorType\", message = \"Simple error occurred\");    Define an error of the generic error type using the default error constructor.  The error reason must be the first and only positional argument to the default error constructor and the type of the  value must be a subtype of string. Additional fields providing more details can be passed as named arguments to the constructor  and the type of each of those must be a subtype of anydata|error.   io:println(\"Error: \", simpleError.reason(),  \", Message: \", simpleError.detail()?.message);    Print the error reason and the message field from the error detail.  The .reason() and .detail() methods can be invoked on error values  to retrieve the reason and details of the error.  message is an optional field in the generic error Detail record.   int|error result = getAccountBalance(-1);    if (result is int) {  io:println(\"Account Balance: \", result);    If the result is an int, then print the value.   } else {  io:println(\"Error: \", result.reason(),  \", Account ID: \", result.detail()[\"accountID\"]);  } }    If an error is returned, print the reason and the account ID from the detail record.  Each additional error detail field provided to the error constructor is available as a field in the error detail record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run error_handling.bal Error: SimpleErrorType, Message: Simple error occurred Error: InvalidAccountID, Account ID: -1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/expression-bodied-functions.html","name":"Expression-bodied Functions","summary":"A function body can be a single expression. Such a function is called an expression-bodied function and the\n expression function body takes the form => E. This is equivalent to the block function body { return E; }.Note the syntactic difference in the function body of an expression-bodied function\n compared ...","content":"/  /  /  / Expression-bodied Functions  import ballerina/io;  // Note the syntactic difference in the function body of an expression-bodied function // compared to a regular block function body. This is equivalent to // `function add(int a, int b) returns int { return a + b; }`. The static type of // the expression should either be the same or a subtype of the return type // of the function. function add(int a, int b) returns int => a + b;  public function main() {  // There is no difference in how you call an expression-bodied function.  int sum = add(10, 20);  io:println(sum);   // Anonymous functions can have expression bodies as well.  // Here, an expression bodied anonymous function is used to easily map a  // record to another record type.  var toEmployee = function (Person p, string pos) returns Employee => {  name: p.fname + \" \" + p.lname,  designation: pos  };   Person john = { fname: \"John\", lname: \"Doe\", age: 25 };  Employee johnEmp = toEmployee(john, \"Software Engineer\");   io:println(johnEmp); }  type Person record {|  string fname;  string lname;  int age; |};  type Employee record {|  string name;  string designation; |};    Expression-bodied Functions  A function body can be a single expression. Such a function is called an expression-bodied function and the  expression function body takes the form => E. This is equivalent to the block function body { return E; }.    import ballerina/io;    function add(int a, int b) returns int => a + b;    Note the syntactic difference in the function body of an expression-bodied function  compared to a regular block function body. This is equivalent to  function add(int a, int b) returns int { return a + b; }. The static type of  the expression should either be the same or a subtype of the return type  of the function.   public function main() {    int sum = add(10, 20);  io:println(sum);    There is no difference in how you call an expression-bodied function.   var toEmployee = function (Person p, string pos) returns Employee => {  name: p.fname + \" \" + p.lname,  designation: pos  };    Anonymous functions can have expression bodies as well.  Here, an expression bodied anonymous function is used to easily map a  record to another record type.   Person john = { fname: \"John\", lname: \"Doe\", age: 25 };  Employee johnEmp = toEmployee(john, \"Software Engineer\");    io:println(johnEmp); }    type Person record {|  string fname;  string lname;  int age; |};    type Employee record {|  string name;  string designation; |};    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run expression_bodied_functions.bal 30 name=John Doe designation=Software Engineer    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/error-match-statement.html","name":"Error Match","summary":"The match statement in Ballerina only supports value-based match patterns. There are static and structured\n match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Error binding pattern is one of the structured binding patterns that can be used\n with ...","content":"/  /  /  / Error Match  import ballerina/io;  type SampleError error<string, Foo>;  const INVALID_ID = \"Invalid ID\"; type InvalidIdError error<INVALID_ID, InvalidIdDetail>;  type Foo record {|  string message?;  error cause?;  boolean fatal; |};  type InvalidIdDetail record {|  string message?;  error cause?;  string id; |};  public function main() {  [string, string] v1 = [\"Sample String\", \"Sample String 2\"];  Foo v2 = {message: \"A\", fatal: false};  error e1 = error(\"Generic Error\", message = \"Failed\");  SampleError e2 = error(\"Sample Error\", message = \"Fatal\", fatal = true);  InvalidIdError e3 = InvalidIdError(id = \"33456\");   basicMatch(v1);  basicMatch(v2);  basicMatch(e1);  basicMatch(e2);  basicMatch(e3); }  function basicMatch(any|error v) {  match v {  var [tVar1, tVar2] => {  io:println(\"Matched a value with a tuple shape\");  }  var {message, fatal} => {  io:println(\"Matched a value with a record shape\");  }  // If the variable 'v' contains an `error` values of shape that matches  // `InvalidIdError` it will be matched to `InvalidIdError` indirect  // error match pattern.  var InvalidIdError(id = id) => {  io:println(\"Matched `InvalidError` id=\", id);  }  // If the variable `v` contains an `error` value, it will be matched  // to this pattern and the reason string and the detail record will be  // destructed within the pattern block.  var error(reason, message = message) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, message: %s\", reason, message));  }   // If a rest binding pattern is used, the error details that are not  // matched will be recorded in a map.  var error(reason, message = message, ...rest) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, rest detail: %s\", reason, rest));  }  } }    Error Match  The match statement in Ballerina only supports value-based match patterns. There are static and structured  match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Error binding pattern is one of the structured binding patterns that can be used  with the match statement.    import ballerina/io;    type SampleError error<string, Foo>;    const INVALID_ID = \"Invalid ID\"; type InvalidIdError error<INVALID_ID, InvalidIdDetail>;    type Foo record {|  string message?;  error cause?;  boolean fatal; |};    type InvalidIdDetail record {|  string message?;  error cause?;  string id; |};    public function main() {  [string, string] v1 = [\"Sample String\", \"Sample String 2\"];  Foo v2 = {message: \"A\", fatal: false};  error e1 = error(\"Generic Error\", message = \"Failed\");  SampleError e2 = error(\"Sample Error\", message = \"Fatal\", fatal = true);  InvalidIdError e3 = InvalidIdError(id = \"33456\");    basicMatch(v1);  basicMatch(v2);  basicMatch(e1);  basicMatch(e2);  basicMatch(e3); }    function basicMatch(any|error v) {  match v {  var [tVar1, tVar2] => {  io:println(\"Matched a value with a tuple shape\");  }  var {message, fatal} => {  io:println(\"Matched a value with a record shape\");  }    var InvalidIdError(id = id) => {  io:println(\"Matched `InvalidError` id=\", id);  }    If the variable ‘v’ contains an error values of shape that matches  InvalidIdError it will be matched to InvalidIdError indirect  error match pattern.   var error(reason, message = message) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, message: %s\", reason, message));  }    If the variable v contains an error value, it will be matched  to this pattern and the reason string and the detail record will be  destructed within the pattern block.   var error(reason, message = message, ...rest) => {  io:println(\"Matched an error value : \",  io:sprintf(\"reason: %s, rest detail: %s\", reason, rest));  }  } }    If a rest binding pattern is used, the error details that are not  matched will be recorded in a map.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run error_match_statement.bal Matched a value with a tuple shape Matched a value with a record shape Matched an error value : reason: Generic Error, message: Failed Matched an error value : reason: Sample Error, rest detail: fatal=true Matched `InvalidError` id=33456    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/error-typed-binding-pattern.html","name":"Error-Typed Binding Pattern","summary":"Error-type binding patterns are used in declaring and defining new variables by destructuring an error value.\n The error-type binding pattern statement must have an assignment expression on the right hand side.This error-type binding pattern will destructure an error of the type SampleError, and create two variables as follows:\n The value ...","content":"/  /  /  / Error-Typed Binding Pattern  import ballerina/io;  type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };  type SampleError error<string, SampleErrorData>;  public function main() {  // This error-type binding pattern will destructure an `error` of the type `SampleError`, and create two variables as follows:  // The value of the reason string in the`SampleError` will be set to a new `string` variable `reason`.  // The values in the detail mapping will be set to new variables `info` and `fatal`.  var error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);   // The detail mapping can also be destructured using a rest parameter.  // `params` will be of the type `map<anydata|error>`, and will have the  // `info` and `fatal` fields.  var error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Mapping: \", params);   // When some error detail field names are provided rest parameter will only contain detail field that are not matched.  var error(reasonThree, info = info2, ...filteredParams) = getSampleError();  io:println(\"Detail Mapping: \", filteredParams);  // The underscore '_' sign can be used to ignore either the reason string or the detail mapping.  var error(_, detailMsg = detailMsg, isFatal = isFatal) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }  function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Msg\", fatal = true);  return e; }  type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};  function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    Error-Typed Binding Pattern  Error-type binding patterns are used in declaring and defining new variables by destructuring an error value.  The error-type binding pattern statement must have an assignment expression on the right hand side.    import ballerina/io;    type SampleErrorData record {  string message?;  error cause?;  string info;  boolean fatal; };    type SampleError error<string, SampleErrorData>;    public function main() {    var error(reason, info = info, fatal = fatal) = getSampleError();  io:println(\"Reason String: \" + reason);  io:println(\"Info: \", info);  io:println(\"Fatal: \", fatal);    This error-type binding pattern will destructure an error of the type SampleError, and create two variables as follows:  The value of the reason string in theSampleError will be set to a new string variable reason.  The values in the detail mapping will be set to new variables info and fatal.   var error(reasonTwo, ...params) = getSampleError();  io:println(\"Reason String: \", reasonTwo);  io:println(\"Detail Mapping: \", params);    The detail mapping can also be destructured using a rest parameter.  params will be of the type map<anydata|error>, and will have the  info and fatal fields.   var error(reasonThree, info = info2, ...filteredParams) = getSampleError();  io:println(\"Detail Mapping: \", filteredParams);  When some error detail field names are provided rest parameter will only contain detail field that are not matched.   var error(_, detailMsg = detailMsg, isFatal = isFatal) = getRecordConstrainedError();  io:println(\"Detail Message: \", detailMsg); }    The underscore ‘_’ sign can be used to ignore either the reason string or the detail mapping.   function getSampleError() returns SampleError {  SampleError e = error(\"Sample Error\", info = \"Detail Msg\", fatal = true);  return e; }    type Foo record {|  string message?;  error cause?;  string detailMsg;  boolean isFatal; |};    function getRecordConstrainedError() returns error<string, Foo> {  error<string, Foo> e = error(\"Some Error\", detailMsg = \"Failed Message\", isFatal = true);  return e; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run error_type_binding_pattern.bal Reason String: Sample Error Info: Detail Msg Fatal: true Reason String: Sample Error Detail Mapping: info=Detail Msg fatal=true Detail Mapping: fatal=true Detail Message: Failed Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/file.html","name":"File","summary":"The Ballerina File API contains functions to perform file-system operations.Get the path of the current directory.Create a new directory.Create a new directory with any none-existent parents.Create a file in the given file path.Get metadata information of the file.Check whether the file or directory of the provided path exists.Copy the file ...","content":"/  /  /  / File  import ballerina/file; import ballerina/filepath; import ballerina/io;  public function main() {   // Get the path of the current directory.  io:println(\"Current directory: \" + file:getCurrentDirectory());   // Create a new directory.  string|error createDirResults = file:createDir(\"foo\");  if (createDirResults is string) {  io:println(\"Created directory path: \" + createDirResults);  }   // Create a new directory with any none-existent parents.  string dirPath = checkpanic filepath:build(\"foo\", \"bar\");  createDirResults = file:createDir(dirPath, true);  if (createDirResults is string) {  io:println(\"Created nested directory path: \" + createDirResults);  }   // Create a file in the given file path.  string|error createFileResults = file:createFile(\"bar.txt\");  if (createFileResults is string) {  io:println(\"Created file path: \" + createFileResults);  }   // Get metadata information of the file.  file:FileInfo|error fileInfoResults = file:getFileInfo(\"bar.txt\");  if (fileInfoResults is file:FileInfo) {  io:println(\"File name: \" + fileInfoResults.getName());  io:println(\"File size: \" + fileInfoResults.getSize().toString());  io:println(\"Is directory: \" + fileInfoResults.isDir().toString());  io:println(\"Modified at \" +  fileInfoResults.getLastModifiedTime().toString());  }   // Check whether the file or directory of the provided path exists.  boolean fileExists = file:exists(\"bar.txt\");  io:println(\"bar.txt file exists: \" + fileExists.toString());   // Copy the file or directory to the new path.  string filePath = checkpanic filepath:build(\"foo\", \"bar\", \"bar.txt\");  error? copyDirResults = file:copy(\"bar.txt\", filePath, true);  if (copyDirResults is ()) {  io:println(\"bar.txt file is copied to new path \" + filePath);  }   // Rename(Move) the file or directory to the new path.  string newFilePath = checkpanic filepath:build(\"foo\", \"bar1.txt\");  error? renameResults = file:rename(\"bar.txt\", newFilePath);  if (renameResults is ()) {  io:println(\"bar.txt file is moved to new path \" + newFilePath);  }   // Get the default directory used for temporary files.  string tempDirPath = file:tempDir();  io:println(\"Temporary directory: \" + tempDirPath);   // Get the list of files in the directory.  file:FileInfo[]|error readDirResults = file:readDir(\"foo\");   // Remove the file or directory in the specified file path.  error? removeResults = file:remove(newFilePath);  if (removeResults is ()) {  io:println(\"Remove file at \" + newFilePath);  }   // Remove the directory in the specified file path with all its children.  removeResults = file:remove(\"foo\", true);  if (removeResults is ()) {  io:println(\"Remove foo directory with all child elements.\");  } }    File  The Ballerina File API contains functions to perform file-system operations.    import ballerina/file; import ballerina/filepath; import ballerina/io;    public function main() {    io:println(\"Current directory: \" + file:getCurrentDirectory());    Get the path of the current directory.   string|error createDirResults = file:createDir(\"foo\");  if (createDirResults is string) {  io:println(\"Created directory path: \" + createDirResults);  }    Create a new directory.   string dirPath = checkpanic filepath:build(\"foo\", \"bar\");  createDirResults = file:createDir(dirPath, true);  if (createDirResults is string) {  io:println(\"Created nested directory path: \" + createDirResults);  }    Create a new directory with any none-existent parents.   string|error createFileResults = file:createFile(\"bar.txt\");  if (createFileResults is string) {  io:println(\"Created file path: \" + createFileResults);  }    Create a file in the given file path.   file:FileInfo|error fileInfoResults = file:getFileInfo(\"bar.txt\");  if (fileInfoResults is file:FileInfo) {  io:println(\"File name: \" + fileInfoResults.getName());  io:println(\"File size: \" + fileInfoResults.getSize().toString());  io:println(\"Is directory: \" + fileInfoResults.isDir().toString());  io:println(\"Modified at \" +  fileInfoResults.getLastModifiedTime().toString());  }    Get metadata information of the file.   boolean fileExists = file:exists(\"bar.txt\");  io:println(\"bar.txt file exists: \" + fileExists.toString());    Check whether the file or directory of the provided path exists.   string filePath = checkpanic filepath:build(\"foo\", \"bar\", \"bar.txt\");  error? copyDirResults = file:copy(\"bar.txt\", filePath, true);  if (copyDirResults is ()) {  io:println(\"bar.txt file is copied to new path \" + filePath);  }    Copy the file or directory to the new path.   string newFilePath = checkpanic filepath:build(\"foo\", \"bar1.txt\");  error? renameResults = file:rename(\"bar.txt\", newFilePath);  if (renameResults is ()) {  io:println(\"bar.txt file is moved to new path \" + newFilePath);  }    Rename(Move) the file or directory to the new path.   string tempDirPath = file:tempDir();  io:println(\"Temporary directory: \" + tempDirPath);    Get the default directory used for temporary files.   file:FileInfo[]|error readDirResults = file:readDir(\"foo\");    Get the list of files in the directory.   error? removeResults = file:remove(newFilePath);  if (removeResults is ()) {  io:println(\"Remove file at \" + newFilePath);  }    Remove the file or directory in the specified file path.   removeResults = file:remove(\"foo\", true);  if (removeResults is ()) {  io:println(\"Remove foo directory with all child elements.\");  } }    Remove the directory in the specified file path with all its children.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run file.bal Current directory: /A/B Created directory path: /A/B/foo Created nested directory path: /A/B/foo/bar Created file path: /A/B/bar.txt File name: bar.txt File size: 0 Is directory: false Modified at time=1567597039000 zone=id=Z offset=0 bar.txt file exists: true bar.txt file is copied to new path foo/bar/bar.txt bar.txt file is moved to new path foo/bar1.txt Temporary directory: /var/folders/4z/xvlnvsp54ks9793d6k5_6bw40000gn/T/ Remove file at foo/bar1.txt Remove foo directory with all child elements.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/filepath.html","name":"File Path","summary":"The Ballerina File Path API contains utility functions to manipulate the file path in a way compatible with the\n target operating system.Get the absolute representation of the path.Check whether the path is absolute.Get the base name of the path.Get the enclosing parent directory.Get the shortest path name equivalent to path ...","content":"/  /  /  / File Path  import ballerina/filepath; import ballerina/io;  public function main() {  // Get the absolute representation of the path.  string absValue = checkpanic filepath:absolute(\"test.txt\");   // Check whether the path is absolute.  boolean isAbs = checkpanic filepath:isAbsolute(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);   // Get the base name of the path.  string name = checkpanic filepath:filename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name); // returns C   // Get the enclosing parent directory.  string parentPath = checkpanic filepath:parent(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath); // returns B   // Get the shortest path name equivalent to path by purely lexical processing.  string normalizedPath = checkpanic filepath:normalize(\"foo/../bar\");  io:println(\"Normalized path of foo/../bar: \", normalizedPath); // returns bar   // Get the list of path elements joined by the OS-specific Path Separator.  string[] parts = checkpanic filepath:split(\"/A/B/C\");  io:println(io:sprintf(\"Path elements of /A/B/C: %s\", parts)); // returns {\"A\", \"B\", \"C\"}   // Join any number of path elements into a single path.  string path = checkpanic filepath:build(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path); // On Unix : returns /foo/bar   // Get the extension of the file path.  string ext = checkpanic filepath:extension(\"path.bal\");  io:println(\"Extension of path.bal: \", ext); // returns bal   // Returns a relative path that is logically equivalent to the target path when joined to the base path.  string relPath = checkpanic filepath:relative(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); // On Unix : returns ../../c/d  }    File Path  The Ballerina File Path API contains utility functions to manipulate the file path in a way compatible with the  target operating system.    import ballerina/filepath; import ballerina/io;    public function main() {    string absValue = checkpanic filepath:absolute(\"test.txt\");    Get the absolute representation of the path.   boolean isAbs = checkpanic filepath:isAbsolute(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);    Check whether the path is absolute.   string name = checkpanic filepath:filename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name); // returns C    Get the base name of the path.   string parentPath = checkpanic filepath:parent(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath); // returns B    Get the enclosing parent directory.   string normalizedPath = checkpanic filepath:normalize(\"foo/../bar\");  io:println(\"Normalized path of foo/../bar: \", normalizedPath); // returns bar    Get the shortest path name equivalent to path by purely lexical processing.   string[] parts = checkpanic filepath:split(\"/A/B/C\");  io:println(io:sprintf(\"Path elements of /A/B/C: %s\", parts)); // returns {\"A\", \"B\", \"C\"}    Get the list of path elements joined by the OS-specific Path Separator.   string path = checkpanic filepath:build(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path); // On Unix : returns /foo/bar    Join any number of path elements into a single path.   string ext = checkpanic filepath:extension(\"path.bal\");  io:println(\"Extension of path.bal: \", ext); // returns bal    Get the extension of the file path.   string relPath = checkpanic filepath:relative(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); // On Unix : returns ../../c/d    Returns a relative path that is logically equivalent to the target path when joined to the base path.   }    # To run this sample, navigate to the directory that contains the # `.bal` file and issue the `ballerina run` command below. ballerina run filepath.bal On Unix: /A/B/C is absolute: true Filename of /A/B/C: C Parent of /A/B/C: /A/B Normalized path of foo/../bar: bar Path elements of /A/B/C: A B C Built path of '/', 'foo', 'bar': /foo/bar Extension of path.bal: bal Relative path between 'a/b/c' and 'a/c/d': ../../c/d    On Windows: /A/B/C is absolute: false Filename of /A/B/C: C Parent of /A/B/C: \\A\\B Normalized path of foo/../bar: bar Path elements of /A/B/C: A B C Built path of '/', 'foo', 'bar': \\foo\\bar Extension of path.bal: bal Relative path between 'a/b/c' and 'a/c/d': ..\\..\\c\\d    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/foreach.html","name":"Foreach","summary":"The foreach statement is a looping construct that traverses through the items of a collection of data such as\n arrays, maps, JSON, XML, and tables.The foreach statement can be used to iterate an array. Each iteration returns an element in the array.\n The index of the corresponding element is not ...","content":"/  /  /  / Foreach  import ballerina/io;  public function main() {  io:println(\"Iterating a string array :\");  string[] fruits = [\"apple\", \"banana\", \"cherry\"];   // The `foreach` statement can be used to iterate an array. Each iteration returns an element in the array.  // The index of the corresponding element is not returned.  foreach var v in fruits {  io:println(\"fruit: \", v);  }   io:println(\"\\nIterating a map :\");  map<string> words = {a: \"apple\", b: \"banana\", c: \"cherry\"};  // Iterating a map will return the values in the map.  foreach var fruit in words {  io:println(fruit);  }  // Calling the `.entries()' method on a `map` and iterating it will return the key (`string`) and the value as a  // `tuple` variable. Tuple destructuring can be used to split the tuple variable into two variables.  foreach var [k, v] in words.entries() {  io:println(\"letter: \", k, \", word: \", v);  }   io:println(\"\\nIterating a JSON object :\");  json apple = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  // Iterating a JSON is only supported with `map<json>` or `json[]`.  // To iterate a JSON, first cast it to the relevant iterable type.  map<json> mapValue = <map<json>>apple;  foreach var value in mapValue {  if (value is string) {  io:println(\"string value: \", value);  } else if (value is int) {  io:println(\"int value: \", value);  } else if (value is json[]) {  io:println(\"json array value: \", value);  } else {  // JSON is a union type for `()` or `null`|`int`|`float`|`decimal`|`string`|`json[]`|`map<json>`.  // The else block will be reached if `j` is neither `string`, `int`, or `json[]`.  io:println(\"non-string value: \", value);  }  }   io:println(\"\\nIterating a JSON array :\");  // To iterate a JSON array, you need to first cast it into a JSON array (`json[]`).  json[] colors = <json[]>apple.colors;  int counter = 0;  foreach var j in colors {  io:println(\"color \", counter, \": \", j);  counter += 1;  }   io:println(\"\\nIterating XML :\");  xml book = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  </book>`;  // Iterating an XML will return each element in each iteration.  counter = 0;  foreach var x in book/<*> {  io:println(\"xml at \", counter, \": \", x);  counter += 1;  }   io:println(\"\\nIterating a closed integer range :\");  int endValue = 10;  int sum = 0;  // A closed integer range in the `foreach` statement represents an incremental integer value range from the start  // expression (`1`) to the end expression (`endValue`) inclusively.  foreach var i in 1 ... endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue, \" is \", sum);   io:println(\"\\nIterating a half open integer range :\");  sum = 0;  // A half-open integer range in the `foreach` statement represents an incremental integer value range from the start  // expression (`1`) inclusively, to the end expression (`endValue`) exclusively.  foreach var i in 1 ..< endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue,  \" excluding \", endValue, \" is \", sum); }    Foreach  The foreach statement is a looping construct that traverses through the items of a collection of data such as  arrays, maps, JSON, XML, and tables.    import ballerina/io;    public function main() {  io:println(\"Iterating a string array :\");  string[] fruits = [\"apple\", \"banana\", \"cherry\"];    foreach var v in fruits {  io:println(\"fruit: \", v);  }    The foreach statement can be used to iterate an array. Each iteration returns an element in the array.  The index of the corresponding element is not returned.   io:println(\"\\nIterating a map :\");  map<string> words = {a: \"apple\", b: \"banana\", c: \"cherry\"};    foreach var fruit in words {  io:println(fruit);  }    Iterating a map will return the values in the map.   foreach var [k, v] in words.entries() {  io:println(\"letter: \", k, \", word: \", v);  }    Calling the .entries()' method on amapand iterating it will return the key (string) and the value as a tuple` variable. Tuple destructuring can be used to split the tuple variable into two variables.   io:println(\"\\nIterating a JSON object :\");  json apple = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};    map<json> mapValue = <map<json>>apple;  foreach var value in mapValue {  if (value is string) {  io:println(\"string value: \", value);  } else if (value is int) {  io:println(\"int value: \", value);  } else if (value is json[]) {  io:println(\"json array value: \", value);  } else {    Iterating a JSON is only supported with map<json> or json[].  To iterate a JSON, first cast it to the relevant iterable type.   io:println(\"non-string value: \", value);  }  }    JSON is a union type for () or null|int|float|decimal|string|json[]|map<json>.  The else block will be reached if j is neither string, int, or json[].   io:println(\"\\nIterating a JSON array :\");    json[] colors = <json[]>apple.colors;  int counter = 0;  foreach var j in colors {  io:println(\"color \", counter, \": \", j);  counter += 1;  }    To iterate a JSON array, you need to first cast it into a JSON array (json[]).   io:println(\"\\nIterating XML :\");  xml book = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  </book>`;    counter = 0;  foreach var x in book/<*> {  io:println(\"xml at \", counter, \": \", x);  counter += 1;  }    Iterating an XML will return each element in each iteration.   io:println(\"\\nIterating a closed integer range :\");  int endValue = 10;  int sum = 0;    foreach var i in 1 ... endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue, \" is \", sum);    A closed integer range in the foreach statement represents an incremental integer value range from the start  expression (1) to the end expression (endValue) inclusively.   io:println(\"\\nIterating a half open integer range :\");  sum = 0;    foreach var i in 1 ..< endValue {  sum = sum + i;  }  io:println(\"summation from 1 to \", endValue,  \" excluding \", endValue, \" is \", sum); }    A half-open integer range in the foreach statement represents an incremental integer value range from the start  expression (1) inclusively, to the end expression (endValue) exclusively.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run foreach.bal Iterating a string array : fruit: apple fruit: banana fruit: cherry    Iterating a map : apple banana cherry letter: a, word: apple letter: b, word: banana letter: c, word: cherry    Iterating a JSON object : string value: apple json array value: red green int value: 5    Iterating a JSON array : color 0: red color 1: green    Iterating XML : xml at 0: <name>Sherlock Holmes</name> xml at 1: <author>Sir Arthur Conan Doyle</author>    Iterating a closed integer range : summation from 1 to 10 is 55    Iterating a half open integer range : summation from 1 to 10 excluding 10 is 45    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/fork.html","name":"Fork","summary":"The fork block allows you to start any number of workers simultaneously. Workers are visible outside the fork block as futures.\n These futures behave similar to the futures returned by asynchronous functions created by start. You may wait until the worker\n finishes by using the wait expression.\n You can only ...","content":"/  /  /  / Fork  import ballerina/io;  public function main() {   // The `fork` block allows you to spawn (fork) multiple workers  // within any execution flow of a Ballerina program.  fork {  worker w1 returns [int, string] {  int i = 23;  string s = \"Colombo\";  io:println(\"[w1] i: \", i, \" s: \", s);  // Return of worker `w1`.  return [i, s];  }   worker w2 returns float {  float f = 10.344;  io:println(\"[w2] f: \", f);  // Return of worker `w2`.  return f;  }  }   // Workers are visible outside the `fork` as futures.  // The `wait` action will wait for both workers `w1` and `w2` to finish.  record {[int, string] w1; float w2;} results = wait {w1, w2};   // The resulting record contains returned values from each worker with  // the field name as the worker name (if a field name is not provided).  var [iW1, sW1] = results.w1;  var fW2 = results.w2;  io:println(\"[main] iW1: \", iW1, \" sW1: \", sW1, \" fW2: \", fW2); }    Fork  The fork block allows you to start any number of workers simultaneously. Workers are visible outside the fork block as futures.  These futures behave similar to the futures returned by asynchronous functions created by start. You may wait until the worker  finishes by using the wait expression.  You can only send anydata variables from a worker of one fork to another worker in the same fork.    import ballerina/io;    public function main() {    fork {  worker w1 returns [int, string] {  int i = 23;  string s = \"Colombo\";  io:println(\"[w1] i: \", i, \" s: \", s);    The fork block allows you to spawn (fork) multiple workers  within any execution flow of a Ballerina program.   return [i, s];  }    Return of worker w1.   worker w2 returns float {  float f = 10.344;  io:println(\"[w2] f: \", f);    return f;  }  }    Return of worker w2.   record {[int, string] w1; float w2;} results = wait {w1, w2};    Workers are visible outside the fork as futures.  The wait action will wait for both workers w1 and w2 to finish.   var [iW1, sW1] = results.w1;  var fW2 = results.w2;  io:println(\"[main] iW1: \", iW1, \" sW1: \", sW1, \" fW2: \", fW2); }    The resulting record contains returned values from each worker with  the field name as the worker name (if a field name is not provided).   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run fork.bal [w1] i: 23 s: Colombo [w2] f: 10.344 [main] iW1: 23 sW1: Colombo fW2: 10.344    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/function-pointers.html","name":"Function Pointers","summary":"A function pointer is a Ballerina type that allows you to use functions as variables,\n arguments to functions, and function return values. The name of a function serves as\n a pointer to that function when called from other functions or operations. The definition\n of the function name provides the type ...","content":"/  /  /  / Function Pointers  import ballerina/io; import ballerina/lang.'int;  // The `test` function acts as a variable function pointer in the `main` function. function test(string s, int... x) returns float {  int|error y = 'int:fromString(s);  float f = 0.0;   if (y is int) {  foreach var item in x {  f += item * 1.0 * y;  }  } else {  // The type of `y` within the else block would be `error`.  panic y;  }  return f; }  // A function pointer as a parameter. A function pointer can be invoked similar to how a normal function is invoked. function foo(int x, function (string, int...) returns float bar)  returns float {  return x * bar(\"2\", 2, 3, 4, 5); }  // A function pointer as a return type. function getFunctionPointer() returns  (function (string, int...) returns float) {  return test; }  public function main() {  // Value `test` will serve as a function pointer for the `foo` function.  io:println(\"Answer: \", foo(10, test));  io:println(\"Answer: \", foo(10, getFunctionPointer()));   // A function pointer as a variable.  function (string, int...) returns float f = getFunctionPointer();   io:println(\"Answer: \", foo(10, f)); }    Function Pointers  A function pointer is a Ballerina type that allows you to use functions as variables,  arguments to functions, and function return values. The name of a function serves as  a pointer to that function when called from other functions or operations. The definition  of the function name provides the type of the pointer in terms of a function signature.    import ballerina/io; import ballerina/lang.'int;    function test(string s, int... x) returns float {  int|error y = 'int:fromString(s);  float f = 0.0;    The test function acts as a variable function pointer in the main function.   if (y is int) {  foreach var item in x {  f += item * 1.0 * y;  }  } else {    panic y;  }  return f; }    The type of y within the else block would be error.   function foo(int x, function (string, int...) returns float bar)  returns float {  return x * bar(\"2\", 2, 3, 4, 5); }    A function pointer as a parameter. A function pointer can be invoked similar to how a normal function is invoked.   function getFunctionPointer() returns  (function (string, int...) returns float) {  return test; }    A function pointer as a return type.   public function main() {    io:println(\"Answer: \", foo(10, test));  io:println(\"Answer: \", foo(10, getFunctionPointer()));    Value test will serve as a function pointer for the foo function.   function (string, int...) returns float f = getFunctionPointer();    A function pointer as a variable.   io:println(\"Answer: \", foo(10, f)); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run function_pointers.bal Answer: 280.0 Answer: 280.0 Answer: 280.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/fork-variable-access.html","name":"Fork Variable Access","summary":"Workers within a fork can access the variables that are declared within the scope of that block.\n The variables can be value-type variables or reference -ype variables.\n Both value-type variables such as string, int, float, and byte and reference-type\n variables such as map, json, xml, and record are passed into ...","content":"/  /  /  / Fork Variable Access  import ballerina/io;  // The in-scope variables can be accessed by the workers inside the `fork` block. public function main() {  // These variables can be accessed by the forked workers.  int i = 100;  string s = \"WSO2\";  map<string> m = {\"name\": \"Bert\", \"city\": \"New York\", \"postcode\": \"10001\"};   string name = <string>m[\"name\"];  string city = <string>m[\"city\"];  string postcode = <string>m[\"postcode\"];   io:println(\"[value type variables] before fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");   io:println(\"[reference type variables] before fork: value \" +  \"of name is [\", name , \"] value of city is [\", city, \"] value of \" +  \"postcode is [\", postcode, \"]\");   // Declares the `fork` block.  fork {  worker W1 {  // Changes the value of the integer variable `i` within the worker `W1`.  i = 23;  // Changes the value of the `map` variable `m` within the worker `W1`.  m[\"name\"] = \"Moose\";   fork {  worker W3 {  // Changes the value of the `map` variable `m` within // the worker `W3`.  string street = \"Wall Street\";  m[\"street\"] = street;   // Changes the value of the integer variable `i` within  // the worker `W3`.  i = i + 100;  }  }   // Waits for the worker `W3` to finish.  wait W3;  }   worker W2 {  // Changes the value of the `string` variable `s` within the worker `W2`.  s = \"Ballerina\";  // Changes the value of the `map` variable `m` within the worker `W2`.  m[\"city\"] = \"Manhattan\";  }  }   // Waits for both workers `W1` and `W2` to finish.  _ = wait {W1, W2};   // Prints the values after the `fork` block to check if the values of the  // variables have changed.   // The value-type variables have changed since the original variables are passed in.  io:println(\"[value type variables] after fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");   // The internal content of the reference-type variables have got updated // since they are passed in as a reference to the workers.  name = <string>m[\"name\"];  city = <string>m[\"city\"];  // Gets the value of the new field added to the `map` variable `m` inside the worker `W3`.  string street = <string>m[\"street\"];  io:println(\"[reference type variables] after fork: \" +  \"value of name is [\", name,  \"] value of city is [\", city, \"] value of street is [\", street,  \"] value of postcode is [\", postcode, \"]\"); }    Fork Variable Access  Workers within a fork can access the variables that are declared within the scope of that block.  The variables can be value-type variables or reference -ype variables.  Both value-type variables such as string, int, float, and byte and reference-type  variables such as map, json, xml, and record are passed into the workers as a reference to the  original data. Therefore, if you update the value of these variables within a worker, the value gets  updated for the entire function. You may wait until the worker finishes by using the wait expression.    import ballerina/io;    public function main() {    The in-scope variables can be accessed by the workers inside the fork block.   int i = 100;  string s = \"WSO2\";  map<string> m = {\"name\": \"Bert\", \"city\": \"New York\", \"postcode\": \"10001\"};    These variables can be accessed by the forked workers.   string name = <string>m[\"name\"];  string city = <string>m[\"city\"];  string postcode = <string>m[\"postcode\"];    io:println(\"[value type variables] before fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");    io:println(\"[reference type variables] before fork: value \" +  \"of name is [\", name , \"] value of city is [\", city, \"] value of \" +  \"postcode is [\", postcode, \"]\");    fork {  worker W1 {    Declares the fork block.   i = 23;    Changes the value of the integer variable i within the worker W1.   m[\"name\"] = \"Moose\";    Changes the value of the map variable m within the worker W1.   fork {  worker W3 {    string street = \"Wall Street\";  m[\"street\"] = street;    Changes the value of the map variable m within  the worker W3.   i = i + 100;  }  }    Changes the value of the integer variable i within  the worker W3.   wait W3;  }    Waits for the worker W3 to finish.   worker W2 {    s = \"Ballerina\";    Changes the value of the string variable s within the worker W2.   m[\"city\"] = \"Manhattan\";  }  }    Changes the value of the map variable m within the worker W2.   _ = wait {W1, W2};    Waits for both workers W1 and W2 to finish.   Prints the values after the fork block to check if the values of the  variables have changed.   io:println(\"[value type variables] after fork: \" +  \"value of integer variable is [\", i, \"] \",  \"value of string variable is [\", s, \"]\");    The value-type variables have changed since the original variables are passed in.   name = <string>m[\"name\"];  city = <string>m[\"city\"];    The internal content of the reference-type variables have got updated  since they are passed in as a reference to the workers.   string street = <string>m[\"street\"];  io:println(\"[reference type variables] after fork: \" +  \"value of name is [\", name,  \"] value of city is [\", city, \"] value of street is [\", street,  \"] value of postcode is [\", postcode, \"]\"); }    Gets the value of the new field added to the map variable m inside the worker W3.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run fork_variable_access.bal [value type variables] before fork: value of integer variable is [100] value of string variable is [WSO2] [reference type variables] before fork: value of name is [Bert] value of city is [New York] value of postcode is [10001]    # The value-type variables have changed since the original variables are passed in to the workers. [value type variables] after fork: value of integer variable is [123] value of string variable is [Ballerina]    # The content of the reference-type variables have got updated since they are passed in as a reference to the workers. [reference type variables] after fork: value of name is [Moose] value of city is [Manhattan] value of street is [Wall Street] value of postcode is [10001]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/functional-iteration.html","name":"Functional Iteration","summary":"Iterable operations are a set of built-in operations that are available for\n iterable collections such as arrays, maps, JSON, XML, and more.Defines a map of string values.The length() function returns the number of elements in the container.The map() function applies the given function to each item of the container\n and ...","content":"/  /  /  / Functional Iteration  import ballerina/io;  public function main() {  // Defines a `map` of `string` values.  map<string> words = {  a: \"ant\",  b: \"bear\",  c: \"cat\",  d: \"dear\",  e: \"elephant\"  };   // The `length()` function returns the number of elements in the container.  io:println(\"Number of elements in 'words': \", words.length());   // The `map()` function applies the given function to each item of the container  // and returns a new container of the same type and length.  map<string> animals = words.map(toUpper);  io:println(animals);   // Defines an array of `int` values.  int[] numbers = [-5, -3, 2, 7, 12];   // The `filter()` function returns a new container of the same type with  // all the elements that satisfy the input predicate function.  int[] positive = numbers.filter(function (int i) returns boolean {  return i >= 0;  });  io:println(\"Positive numbers: \", positive);   // The `forEach()` function executes a specified function once for each of  // the elements in the container.  numbers.forEach(function(int i) {  io:println(i);  });   // The `reduce()` function uses the given combining function to produce  // a single value. The combining function takes the combined value so far  // and an element of the container and returns a new combined value.  int total = numbers.reduce(sum, 0);  io:println(\"Total: \", total);   int totalWithInitialValue = numbers.reduce(sum, 5);  io:println(\"Total with initial value: \", totalWithInitialValue);   io:println(\"\\nExecution Order:-\");  // The `forEach()` function applies the given function to each item of the container.  map<json> j = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  j.map(function (json value) returns string {  string result = value.toString();  io:println(\"- map operation's value: \", result);  return result;  }).forEach(function (string s) {  io:println(\"-- foreach operation's value: \", s);  });  }  function toUpper(string value) returns string {  return value.toUpperAscii(); }  function sum(int accumulator, int currentValue) returns int {  return accumulator + currentValue; }    Functional Iteration  Iterable operations are a set of built-in operations that are available for  iterable collections such as arrays, maps, JSON, XML, and more.    import ballerina/io;    public function main() {    map<string> words = {  a: \"ant\",  b: \"bear\",  c: \"cat\",  d: \"dear\",  e: \"elephant\"  };    Defines a map of string values.   io:println(\"Number of elements in 'words': \", words.length());    The length() function returns the number of elements in the container.   map<string> animals = words.map(toUpper);  io:println(animals);    The map() function applies the given function to each item of the container  and returns a new container of the same type and length.   int[] numbers = [-5, -3, 2, 7, 12];    Defines an array of int values.   int[] positive = numbers.filter(function (int i) returns boolean {  return i >= 0;  });  io:println(\"Positive numbers: \", positive);    The filter() function returns a new container of the same type with  all the elements that satisfy the input predicate function.   numbers.forEach(function(int i) {  io:println(i);  });    The forEach() function executes a specified function once for each of  the elements in the container.   int total = numbers.reduce(sum, 0);  io:println(\"Total: \", total);    The reduce() function uses the given combining function to produce  a single value. The combining function takes the combined value so far  and an element of the container and returns a new combined value.   int totalWithInitialValue = numbers.reduce(sum, 5);  io:println(\"Total with initial value: \", totalWithInitialValue);    io:println(\"\\nExecution Order:-\");    map<json> j = {name: \"apple\", colors: [\"red\", \"green\"], price: 5};  j.map(function (json value) returns string {  string result = value.toString();  io:println(\"- map operation's value: \", result);  return result;  }).forEach(function (string s) {  io:println(\"-- foreach operation's value: \", s);  });    The forEach() function applies the given function to each item of the container.   }    function toUpper(string value) returns string {  return value.toUpperAscii(); }    function sum(int accumulator, int currentValue) returns int {  return accumulator + currentValue; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run functional_iteration.bal Number of elements in 'words': 5 a=ANT b=BEAR c=CAT d=DEAR e=ELEPHANT Positive numbers: 2 7 12 -5 -3 2 7 12 Total: 13 Total with initial value: 18    Execution Order:- - map operation's value: apple - map operation's value: red green - map operation's value: 5 -- foreach operation's value: apple -- foreach operation's value: red green -- foreach operation's value: 5    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/functions-with-defaultable-parameters.html","name":"Defaultable Parameters","summary":"Ballerina functions can have defaultable parameters. Defaultable parameters are optional parameters that have a default\n value. A function with defaultable parameters can be invoked without providing values for the defaultable parameters.\n When invoking the function, arguments for the defaultable parameters can be passed as key-value pairs in which case\n the ...","content":"/  /  /  / Defaultable Parameters  import ballerina/io;  // This function takes the base salary, annual increment, and bonus rate as input // parameters and prints them. The first parameter `baseSalary` is a required // parameter. The next two parameters `annualIncrement` and `bonusRate` are // two defaultable parameters. They are optional parameters that have default // values of 20 and 0.02 respectively. Defaultable parameters must always be // defined after the required parameters. function printSalaryDetails(int baseSalary,  int annualIncrement = 20,  float bonusRate = 0.02) {   io:println(\"Base Salary: \", baseSalary, \" | Annual Increment: \", annualIncrement,  \" | Bonus Rate: \", bonusRate); }  public function main() {  // Call the function by passing a value only for the `baseSalary` parameter.  // The `annualIncrement` and `bonusRate` parameters default to  // 20 and 0.02 respectively.  printSalaryDetails(2500);   // Call the function by passing values only for the `baseSalary` and `annualIncrement`  // parameters. The value for the `annualIncrement` parameter is passed as a named argument.  // The `bonusRate` parameter defaults to 0.02.  printSalaryDetails(2500, annualIncrement = 100);   // Call the function again by passing values only for the `baseSalary` and `annualIncrement`  // parameters, now passing the value for the `annualIncrement` parameter as a positional argument.  // The `bonusRate` parameter defaults to 0.02.  printSalaryDetails(2500, 100);   // Call the function by passing values only for the `baseSalary` and `bonusRate` parameters.  // The `annualIncrement` parameter defaults to 20.  printSalaryDetails(2500, bonusRate = 0.1);   // In order to pass the value for `bonusRate` as a positional argument, a value would  // have to be specified for the `annualIncrement` parameter too.  // All arguments are positional arguments here.  printSalaryDetails(2500, 20, 0.1);   // Call the function by passing values for all three parameters, the first argument as  // a positional argument and the rest as named arguments.  printSalaryDetails(2500, annualIncrement = 100, bonusRate = 0.1);   // Call the function by passing all three arguments as named arguments.  // Any and all arguments after the first named argument need to be specified  // as named arguments but could be specified in any order.  printSalaryDetails(annualIncrement = 100, baseSalary = 2500, bonusRate = 0.1); }    Defaultable Parameters  Ballerina functions can have defaultable parameters. Defaultable parameters are optional parameters that have a default  value. A function with defaultable parameters can be invoked without providing values for the defaultable parameters.  When invoking the function, arguments for the defaultable parameters can be passed as key-value pairs in which case  the placement of the arguments within the function call does not matter. However, all arguments after the first named  argument (key-value pair) need to be passed as named arguments.  Arguments for defaultable parameters can also be passed as positional arguments, in which case the arguments need to  be passed in order.    import ballerina/io;    function printSalaryDetails(int baseSalary,  int annualIncrement = 20,  float bonusRate = 0.02) {    This function takes the base salary, annual increment, and bonus rate as input  parameters and prints them. The first parameter baseSalary is a required  parameter. The next two parameters annualIncrement and bonusRate are  two defaultable parameters. They are optional parameters that have default  values of 20 and 0.02 respectively. Defaultable parameters must always be  defined after the required parameters.   io:println(\"Base Salary: \", baseSalary, \" | Annual Increment: \", annualIncrement,  \" | Bonus Rate: \", bonusRate); }    public function main() {    printSalaryDetails(2500);    Call the function by passing a value only for the baseSalary parameter.  The annualIncrement and bonusRate parameters default to  20 and 0.02 respectively.   printSalaryDetails(2500, annualIncrement = 100);    Call the function by passing values only for the baseSalary and annualIncrement  parameters. The value for the annualIncrement parameter is passed as a named argument.  The bonusRate parameter defaults to 0.02.   printSalaryDetails(2500, 100);    Call the function again by passing values only for the baseSalary and annualIncrement  parameters, now passing the value for the annualIncrement parameter as a positional argument.  The bonusRate parameter defaults to 0.02.   printSalaryDetails(2500, bonusRate = 0.1);    Call the function by passing values only for the baseSalary and bonusRate parameters.  The annualIncrement parameter defaults to 20.   printSalaryDetails(2500, 20, 0.1);    In order to pass the value for bonusRate as a positional argument, a value would  have to be specified for the annualIncrement parameter too.  All arguments are positional arguments here.   printSalaryDetails(2500, annualIncrement = 100, bonusRate = 0.1);    Call the function by passing values for all three parameters, the first argument as  a positional argument and the rest as named arguments.   printSalaryDetails(annualIncrement = 100, baseSalary = 2500, bonusRate = 0.1); }    Call the function by passing all three arguments as named arguments.  Any and all arguments after the first named argument need to be specified  as named arguments but could be specified in any order.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run functions_with_defaultable_parameters.bal Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.02 Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 20 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.1 Base Salary: 2500 | Annual Increment: 100 | Bonus Rate: 0.1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/functions-with-required-parameters.html","name":"Required Parameters","summary":"Ballerina functions can have required parameters. Invoking a function with required parameters requires arguments\n to be specified for each and every required parameter.This function accepts three int values, performs a calculation,\n and returns the result as an integer.\n All three parameters are required parameters.Call the calculate() function to retrieve the ...","content":"/  /  /  / Required Parameters  import ballerina/io;  // This function accepts three `int` values, performs a calculation, // and returns the result as an integer. // All three parameters are required parameters. function calculate(int a, int b, int c) returns int {  return a + 2 * b + 3 * c; }  public function main() {  // Call the `calculate()` function to retrieve the integer result.  // Arguments for required parameters can be passed as positional arguments.  // Positional arguments need to be passed in the expected order.  int result = calculate(5, 6, 7);  // Print the result.  io:println(result);   // Arguments for required parameters can also be passed as named arguments.  // All arguments after the first named argument need to be passed by name.  // Named arguments do not have to be specified in the order in which the parameters are defined.  result = calculate(5, c = 7, b = 6);  // Print the result.  io:println(result); }    Required Parameters  Ballerina functions can have required parameters. Invoking a function with required parameters requires arguments  to be specified for each and every required parameter.    import ballerina/io;    function calculate(int a, int b, int c) returns int {  return a + 2 * b + 3 * c; }    This function accepts three int values, performs a calculation,  and returns the result as an integer.  All three parameters are required parameters.   public function main() {    int result = calculate(5, 6, 7);    Call the calculate() function to retrieve the integer result.  Arguments for required parameters can be passed as positional arguments.  Positional arguments need to be passed in the expected order.   io:println(result);    Print the result.   result = calculate(5, c = 7, b = 6);    Arguments for required parameters can also be passed as named arguments.  All arguments after the first named argument need to be passed by name.  Named arguments do not have to be specified in the order in which the parameters are defined.   io:println(result); }    Print the result.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run functions_with_required_parameters.bal 38 38    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/functions-with-rest-parameter.html","name":"Rest Parameters","summary":"A Ballerina function can have only one rest parameter and the rest parameter\n can take zero or more values. The rest parameter inside a function is equivalent to a list of\n the same type.\n When values are passed for the rest parameter, other arguments also need to be passed as ...","content":"/  /  /  / Rest Parameters  import ballerina/io;  // This function takes one required parameter, one defaultable parameter, and // one rest parameter of the type `string`. A function can have only one rest // parameter. The rest parameter can take any number of values and is // equivalent to a list of the same type. function printDetails(string name,  int age = 18,  string... modules) {  string detailString = \"Name: \" + name + \", Age: \" + age.toString();   if (modules.length() == 0) {  io:println(detailString);  return;  }   int index = 0;  string moduleString = \"Module(s): \";   foreach string module in modules {  if (index == 0) {  moduleString += module;  } else {  moduleString += \", \" + module;  }  index += 1;  }   io:println(detailString, \", \", moduleString); }  public function main() {  // Call the function by passing only the required parameter.  printDetails(\"Alice\");   // Call the function by passing the required parameter and  // the defaultable parameter. Named arguments can also be used  // since values are not passed for the rest parameter.  printDetails(\"Bob\", 20);   // Call the function by passing the required parameter, the defaultable  // parameter, and one value for the rest parameter.  // Arguments cannot be passed as named arguments since values are specified  // for the rest parameter.  printDetails(\"Corey\", 19, \"Math\");   // Call the function by passing the required parameter, defaultable parameter,  // and multiple values for the rest parameter.  printDetails(\"Diana\", 20, \"Math\", \"Physics\");   // Pass an array as the rest parameter instead of calling the  // function by passing each value separately.  string[] modules = [\"Math\", \"Physics\"];  printDetails(\"Diana\", 20, ...modules); }    Rest Parameters  A Ballerina function can have only one rest parameter and the rest parameter  can take zero or more values. The rest parameter inside a function is equivalent to a list of  the same type.  When values are passed for the rest parameter, other arguments also need to be passed as positional  arguments (i.e., they cannot be passed as named arguments).    import ballerina/io;    function printDetails(string name,  int age = 18,  string... modules) {  string detailString = \"Name: \" + name + \", Age: \" + age.toString();    This function takes one required parameter, one defaultable parameter, and  one rest parameter of the type string. A function can have only one rest  parameter. The rest parameter can take any number of values and is  equivalent to a list of the same type.   if (modules.length() == 0) {  io:println(detailString);  return;  }    int index = 0;  string moduleString = \"Module(s): \";    foreach string module in modules {  if (index == 0) {  moduleString += module;  } else {  moduleString += \", \" + module;  }  index += 1;  }    io:println(detailString, \", \", moduleString); }    public function main() {    printDetails(\"Alice\");    Call the function by passing only the required parameter.   printDetails(\"Bob\", 20);    Call the function by passing the required parameter and  the defaultable parameter. Named arguments can also be used  since values are not passed for the rest parameter.   printDetails(\"Corey\", 19, \"Math\");    Call the function by passing the required parameter, the defaultable  parameter, and one value for the rest parameter.  Arguments cannot be passed as named arguments since values are specified  for the rest parameter.   printDetails(\"Diana\", 20, \"Math\", \"Physics\");    Call the function by passing the required parameter, defaultable parameter,  and multiple values for the rest parameter.   string[] modules = [\"Math\", \"Physics\"];  printDetails(\"Diana\", 20, ...modules); }    Pass an array as the rest parameter instead of calling the  function by passing each value separately.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run functions_with_rest_parameter.bal Name: Alice, Age: 18 Name: Bob, Age: 20 Name: Corey, Age: 19, Module(s): Math Name: Diana, Age: 20, Module(s): Math, Physics Name: Diana, Age: 20, Module(s): Math, Physics    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/functions.html","name":"Functions","summary":"Functions operate in the same way as in any other language. It is a mechanism to create a reusable unit of\n functionality within a program.This function takes a string argument. However, it does not return a value.This function takes in two int values as arguments and returns their\n sum as ...","content":"/  /  /  / Functions  import ballerina/io;  // This function takes a `string` argument. However, it does not return a value. function printValue(string value) {  io:println(value); }  // This function takes in two `int` values as arguments and returns their // sum as an integer. function add(int a, int b) returns int {  return a + b; }  function printAndReturnValue(string s) returns string {  string t = \"Hello \".concat(s);  io:println(t);  return t; }  // A public function named `main` is considered as a default entry point of a // Ballerina program. public function main() {  // Call the `printValue()` function that prints the value provided.  printValue(\"This is a sample text\");   // Call the `add()` function to retrieve the result of adding two given values.  int result = add(5, 6);  // Print the result.  io:println(result);   // Ballerina does not allow ignoring the return value of a function  // invocation implicitly unless the return type is `()`. A return value can be ignored  // using `_` if the value may never be an `error` (i.e., the return type of the  // function does not contain `error`).  _ = printAndReturnValue(\"World\"); }    Functions  Functions operate in the same way as in any other language. It is a mechanism to create a reusable unit of  functionality within a program.    import ballerina/io;    function printValue(string value) {  io:println(value); }    This function takes a string argument. However, it does not return a value.   function add(int a, int b) returns int {  return a + b; }    This function takes in two int values as arguments and returns their  sum as an integer.   function printAndReturnValue(string s) returns string {  string t = \"Hello \".concat(s);  io:println(t);  return t; }    public function main() {    A public function named main is considered as a default entry point of a  Ballerina program.   printValue(\"This is a sample text\");    Call the printValue() function that prints the value provided.   int result = add(5, 6);    Call the add() function to retrieve the result of adding two given values.   io:println(result);    Print the result.   _ = printAndReturnValue(\"World\"); }    Ballerina does not allow ignoring the return value of a function  invocation implicitly unless the return type is (). A return value can be ignored  using _ if the value may never be an error (i.e., the return type of the  function does not contain error).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run functions.bal This is a sample text 11 Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/gauge-metrics.html","name":"Gauge-Based Metrics","summary":"Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can define and use metrics to measure their own logic. A gauge is one type ...","content":"/  /  /  / Gauge-Based Metrics  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;  //Create a gauge as a global variable in the service with optional field description, //and default statistics configurations = { timeWindow: 600000, buckets: 5, // percentiles: [0.33, 0.5, 0.66, 0.99] }. observe:Gauge globalGauge = new (\"global_gauge\", \"Global gauge defined\");  // Make sure you start the service with the '--b7a.observability.enabled=true' property or with metrics enabled. @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  io:println(\"------------------------------------------\");  //Incrementing the global gauge defined by 15.0.  globalGauge.increment(15.0);  //Log the current state of global gauge.  printGauge(globalGauge);    //Create a gauge with simply a name, and default statistics configurations.  observe:Gauge localGauge = new (\"local_operations\");  //Increment the local gauge by default value 1.0.  localGauge.increment();  //Increment the value of the gauge by 20.  localGauge.increment(20.0);  //Decrement the local gauge by default value 1.0.  localGauge.decrement();  //Decrement the value of the gauge by 20.  localGauge.decrement(10.0);  //Log the current state of local gauge.  printGauge(localGauge);    //Create a gauge with optional fields description, and tags defined.  observe:Gauge registeredGaugeWithTags = new (\"registered_gauge_with_tags\",  \"RegisteredGauge\",  {property: \"gaugeProperty\", gaugeType: \"RegisterType\"});   //Register the gauge instance, therefore it is stored in the global registry and can be reported to the  //metrics server such as Prometheus. Additionally, this operation will register to the global registry for the  //first invocation and will throw an error if there is already a registration of different metrics instance  //or type. And subsequent invocations of register() will simply retrieve the stored metrics instance  //for the provided name and tags fields, and use that instance for the subsequent operations on the  //counter instance.  error? result = registeredGaugeWithTags.register();  if (result is error) {  log:printError(\"Error in registering gauge\", result);  }   //Set the value of the gauge with the new value.  registeredGaugeWithTags.increment();  float value = registeredGaugeWithTags.getValue();  float newValue = value * 12;  registeredGaugeWithTags.setValue(newValue);  //Log the current state of registered gauge with tags.  printGauge(registeredGaugeWithTags);    //Create a gauge with statistics disabled by passing empty statistics config array.  observe:StatisticConfig[] statsConfigs = [];  observe:Gauge gaugeWithNoStats = new (\"gauge_with_no_stats\",  \"Some description\", (), statsConfigs);  gaugeWithNoStats.setValue(100);  printGauge(gaugeWithNoStats);    //Create gauge with custom statistics config.  observe:StatisticConfig config = {  timeWindow: 30000,  percentiles: [0.33, 0.5, 0.9, 0.99],  buckets: 3  };  statsConfigs[0] = config;  observe:Gauge gaugeWithCustomStats = new (\"gauge_with_custom_stats\",  \"Some description\", (), statsConfigs);  int i = 1;  while (i < 6) {  gaugeWithCustomStats.setValue(100.0 * i);  i = i + 1;  }  //Log the current state of registered gauge with tags.  printGauge(gaugeWithCustomStats);   io:println(\"------------------------------------------\");   //Send response to the client.  http:Response res = new;  // Use a util method to set a string payload.  res.setPayload(\"Order Processed!\");   // Send the response back to the caller.  result = caller->respond(res);   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }  function printGauge(observe:Gauge gauge) {  //Get the statistics snapshot of the gauge.  io:print(\"Gauge - \" + gauge.name + \" Snapshot: \");  observe:Snapshot[]? snapshots = gauge.getSnapshot();  json|error snapshotAsAJson = json.constructFrom(snapshots);  if snapshotAsAJson is json {  io:println(snapshotAsAJson.toJsonString());  }  //Get the current value of the gauge.  io:println(\"Gauge - \", gauge.name, \" Current Value: \"  , gauge.getValue()); }    Gauge-Based Metrics  Ballerina supports Observability out of the box, and Metrics is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can define and use metrics to measure their own logic. A gauge is one type of metric that is  supported by default in Ballerina, and it represents a single numerical value that can arbitrarily go up and down,  and also based on the statistics configurations provided to the Gauge, it can also report the statistics such as max,  min, mean, percentiles, etc.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/observe;    observe:Gauge globalGauge = new (\"global_gauge\", \"Global gauge defined\");    Create a gauge as a global variable in the service with optional field description, and default statistics configurations = { timeWindow: 600000, buckets: 5,  percentiles: [0.33, 0.5, 0.66, 0.99] }.   @http:ServiceConfig {  basePath: \"/online-store-service\" } service onlineStoreService on new http:Listener(9090) {    Make sure you start the service with the ‘–b7a.observability.enabled=true’ property or with metrics enabled.   @http:ResourceConfig {  path: \"/make-order\"  }  resource function makeOrder(http:Caller caller, http:Request req) {  io:println(\"------------------------------------------\");    globalGauge.increment(15.0);    Incrementing the global gauge defined by 15.0.   printGauge(globalGauge);    Log the current state of global gauge.   observe:Gauge localGauge = new (\"local_operations\");    Create a gauge with simply a name, and default statistics configurations.   localGauge.increment();    Increment the local gauge by default value 1.0.   localGauge.increment(20.0);    Increment the value of the gauge by 20.   localGauge.decrement();    Decrement the local gauge by default value 1.0.   localGauge.decrement(10.0);    Decrement the value of the gauge by 20.   printGauge(localGauge);    Log the current state of local gauge.   observe:Gauge registeredGaugeWithTags = new (\"registered_gauge_with_tags\",  \"RegisteredGauge\",  {property: \"gaugeProperty\", gaugeType: \"RegisterType\"});    Create a gauge with optional fields description, and tags defined.   error? result = registeredGaugeWithTags.register();  if (result is error) {  log:printError(\"Error in registering gauge\", result);  }    Register the gauge instance, therefore it is stored in the global registry and can be reported to the metrics server such as Prometheus. Additionally, this operation will register to the global registry for the first invocation and will throw an error if there is already a registration of different metrics instance or type. And subsequent invocations of register() will simply retrieve the stored metrics instance for the provided name and tags fields, and use that instance for the subsequent operations on the counter instance.   registeredGaugeWithTags.increment();  float value = registeredGaugeWithTags.getValue();  float newValue = value * 12;  registeredGaugeWithTags.setValue(newValue);    Set the value of the gauge with the new value.   printGauge(registeredGaugeWithTags);    Log the current state of registered gauge with tags.   observe:StatisticConfig[] statsConfigs = [];  observe:Gauge gaugeWithNoStats = new (\"gauge_with_no_stats\",  \"Some description\", (), statsConfigs);  gaugeWithNoStats.setValue(100);  printGauge(gaugeWithNoStats);    Create a gauge with statistics disabled by passing empty statistics config array.   observe:StatisticConfig config = {  timeWindow: 30000,  percentiles: [0.33, 0.5, 0.9, 0.99],  buckets: 3  };  statsConfigs[0] = config;  observe:Gauge gaugeWithCustomStats = new (\"gauge_with_custom_stats\",  \"Some description\", (), statsConfigs);  int i = 1;  while (i < 6) {  gaugeWithCustomStats.setValue(100.0 * i);  i = i + 1;  }    Create gauge with custom statistics config.   printGauge(gaugeWithCustomStats);    Log the current state of registered gauge with tags.   io:println(\"------------------------------------------\");    http:Response res = new;    Send response to the client.   res.setPayload(\"Order Processed!\");    Use a util method to set a string payload.   result = caller->respond(res);    Send the response back to the caller.   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    function printGauge(observe:Gauge gauge) {    io:print(\"Gauge - \" + gauge.name + \" Snapshot: \");  observe:Snapshot[]? snapshots = gauge.getSnapshot();  json|error snapshotAsAJson = json.constructFrom(snapshots);  if snapshotAsAJson is json {  io:println(snapshotAsAJson.toJsonString());  }    Get the statistics snapshot of the gauge.   io:println(\"Gauge - \", gauge.name, \" Current Value: \"  , gauge.getValue()); }    Get the current value of the gauge.   curl http://localhost:9090/online-store-service/make-order Order Processed! curl http://localhost:9090/online-store-service/make-order Order Processed! curl http://localhost:9090/online-store-service/make-order Order Processed!    Invoke the service using cURL three times.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-bidirectional-streaming.html","name":"Bidirectional Streaming","summary":"The gRPC Server Connector exposes the gRPC service over http2.\n This sample demonstrates how the gRPC bidirectional streaming service and the non blocking client operate when each of them sends a sequence of messages using a read-write stream. In such scenarios, the two streams operate independently. Therefore, clients and servers ...","content":"/  /  /  / Bidirectional Streaming  // This is the server implementation for the bidirectional streaming scenario. import ballerina/grpc; import ballerina/log;  map<grpc:Caller> consMap = {};  @grpc:ServiceConfig {  name: \"Chat\",  clientStreaming: true,  serverStreaming: true } service Chat on new grpc:Listener(9090) {   //This `resource` is triggered when a new caller connection is initialized.  resource function onOpen(grpc:Caller caller) {  log:printInfo(string `${caller.getId()} connected to chat`);  consMap[caller.getId().toString()] = <@untainted>caller;  }   //This `resource` is triggered when the caller sends a request message to the `service`.  resource function onMessage(grpc:Caller caller, ChatMessage chatMsg) {  grpc:Caller ep;  string msg = string `${chatMsg.name}: ${chatMsg.message}`;  log:printInfo(\"Server received message: \" + msg);  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  }   //This `resource` is triggered when the server receives an error message from the caller.  resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   //This `resource` is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.  resource function onComplete(grpc:Caller caller) {  grpc:Caller ep;  string msg = string `${caller.getId()} left the chat`;  log:printInfo(msg);  var v = consMap.remove(caller.getId().toString());  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  } } // This is client implementation for bidirectional streaming scenario. import ballerina/grpc; import ballerina/io; import ballerina/runtime;  int total = 0; public function main() {   //Client endpoint configuration.  ChatClient chatEp = new (\"http://localhost:9090\");   grpc:StreamingClient ep;  // Executes unary non-blocking call registering server message listener.  var res = chatEp->chat(ChatMessageListener);   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }   // Sends multiple messages to the server.  ChatMessage mes = {name: \"Sam\", message: \"Hi \"};  grpc:Error? connErr = ep->send(mes);   if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  }  runtime:sleep(6000);   // Once all messages are sent, client send complete message to notify the server, I’m done.  grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  } }   service ChatMessageListener = service {   // Resource registered to receive server messages.  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }   // Resource registered to receive server error messages.  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   // Resource registered to receive server completed message.  resource function onComplete() {  io:println(\"Server Complete Sending Responses.\");  } };    Bidirectional Streaming  The gRPC Server Connector exposes the gRPC service over http2.  This sample demonstrates how the gRPC bidirectional streaming service and the non blocking client operate when each of them sends a sequence of messages using a read-write stream. In such scenarios, the two streams operate independently. Therefore, clients and servers can read and write in any order.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service Chat { \trpc chat (stream ChatMessage)  returns (stream google.protobuf.StringValue); } message ChatMessage { \tstring name = 1; \tstring message = 2; }    This is the service definition for the bidirectional streaming scenario.   # Create new Protocol Buffers definition file `grpc_bidirectional_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_bidirectional_streaming.proto --output stubs    # Once you run the command, `grpc_bidirectional_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the bidirectional streaming scenario.   map<grpc:Caller> consMap = {};    @grpc:ServiceConfig {  name: \"Chat\",  clientStreaming: true,  serverStreaming: true } service Chat on new grpc:Listener(9090) {    resource function onOpen(grpc:Caller caller) {  log:printInfo(string `${caller.getId()} connected to chat`);  consMap[caller.getId().toString()] = <@untainted>caller;  }    This resource is triggered when a new caller connection is initialized.   resource function onMessage(grpc:Caller caller, ChatMessage chatMsg) {  grpc:Caller ep;  string msg = string `${chatMsg.name}: ${chatMsg.message}`;  log:printInfo(\"Server received message: \" + msg);  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  }    This resource is triggered when the caller sends a request message to the service.   resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    This resource is triggered when the server receives an error message from the caller.   resource function onComplete(grpc:Caller caller) {  grpc:Caller ep;  string msg = string `${caller.getId()} left the chat`;  log:printInfo(msg);  var v = consMap.remove(caller.getId().toString());  foreach var [callerId, connection] in consMap.entries() {  ep = connection;  grpc:Error? err = ep->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server message to caller \" + callerId  + \" sent successfully.\");  }  }  } }    This resource is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_bidirectional_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # Run the service using the following command. ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io; import ballerina/runtime;    This is client implementation for bidirectional streaming scenario.   int total = 0; public function main() {    ChatClient chatEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:StreamingClient ep;    var res = chatEp->chat(ChatMessageListener);    Executes unary non-blocking call registering server message listener.   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }    ChatMessage mes = {name: \"Sam\", message: \"Hi \"};  grpc:Error? connErr = ep->send(mes);    Sends multiple messages to the server.   if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  }  runtime:sleep(6000);    grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  } }    Once all messages are sent, client send complete message to notify the server, I’m done.   service ChatMessageListener = service {    resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    Resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Resource registered to receive server error messages.   resource function onComplete() {  io:println(\"Server Complete Sending Responses.\");  } };    Resource registered to receive server completed message.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_bidirectional_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_bidirectional_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # Run the client using the following command. ballerina run target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-secured-unary.html","name":"Secured Unary","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample demonstrates how a gRPC secured unary service interacts with a gRPC secured blocking client.This is the service definition for the secured connection (HTTPS) scenario.This is the server implementation for the secured connection (HTTPS) scenario.Server endpoint configuration ...","content":"/  /  /  / Secured Unary  // This is the server implementation for the secured connection (HTTPS) scenario. import ballerina/config; import ballerina/grpc; import ballerina/log;  // Server endpoint configuration with the SSL configurations. listener grpc:Listener ep = new (9090, {  host: \"localhost\",  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service HelloWorld on ep {  resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;   // Send a response message to the caller.  grpc:Error? err = caller->send(message);   if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : \" + message);  }   // Send the `completed` notification to the caller.  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } } // This is the client implementation of the secured connection (HTTPS) scenario. import ballerina/config; import ballerina/grpc; import ballerina/io;  public function main() {  // Client endpoint configuration with SSL configurations.  HelloWorldBlockingClient helloWorldBlockingEp = new (\"https://localhost:9090\", {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });   // Executes unary blocking secured call.  var unionResp = helloWorldBlockingEp->hello(\"WSO2\");  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  [result, _] = unionResp;  io:println(\"Client Got Response : \" + result);  } }    Secured Unary  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample demonstrates how a gRPC secured unary service interacts with a gRPC secured blocking client.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the secured connection (HTTPS) scenario.   # Create new Protocol Buffers definition file `grpc_secured_unary.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_secured_unary.proto --output stubs    # Once you run the command, `grpc_secured_unary_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/config; import ballerina/grpc; import ballerina/log;    This is the server implementation for the secured connection (HTTPS) scenario.   listener grpc:Listener ep = new (9090, {  host: \"localhost\",  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Server endpoint configuration with the SSL configurations.   service HelloWorld on ep {  resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    grpc:Error? err = caller->send(message);    Send a response message to the caller.   if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : \" + message);  }    grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Send the completed notification to the caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_secured_unary.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # To run the service, execute the below command by passing Ballerina home path as a system property. ballerina run target/bin/service.jar --b7a.home=<ballerina_home_path>    import ballerina/config; import ballerina/grpc; import ballerina/io;    This is the client implementation of the secured connection (HTTPS) scenario.   public function main() {    HelloWorldBlockingClient helloWorldBlockingEp = new (\"https://localhost:9090\", {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  });    Client endpoint configuration with SSL configurations.   var unionResp = helloWorldBlockingEp->hello(\"WSO2\");  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  [result, _] = unionResp;  io:println(\"Client Got Response : \" + result);  } }    Executes unary blocking secured call.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_secured_unary_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_secured_unary_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # To run the client, execute the below command by passing the path to the Ballerina home directory using the --`b7a.home` parameter. ballerina run target/bin/client.jar --b7a.home=<ballerina_home_path>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-client-streaming.html","name":"Client Streaming","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample includes a gRPC client streaming service and non-blocking client. The client writes a sequence of messages and sends them to the server via a stream.\n Once the client has finished writing the messages, it waits for ...","content":"/  /  /  / Client Streaming  // This is the server implementation for the client streaming scenario. import ballerina/grpc; import ballerina/log;  @grpc:ServiceConfig {  name: \"HelloWorld\",  clientStreaming: true } service HelloWorld on new grpc:Listener(9090) {   //This `resource` is triggered when a new caller connection is initialized.  resource function onOpen(grpc:Caller caller) {  log:printInfo(\"Client connected sucessfully.\");  }   //This `resource` is triggered when the caller sends a request message to the service.  resource function onMessage(grpc:Caller caller, string name) {  log:printInfo(\"Server received greet: \" + name);  }   //This `resource` is triggered when the server receives an error message from the caller.  resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   //This `resource` is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.  resource function onComplete(grpc:Caller caller) {  grpc:Error? err = caller->send(\"Ack\");  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : Ack\");  }  } } // This is the client implementation for the client streaming scenario. import ballerina/grpc; import ballerina/io;  int total = 0; public function main() {  // Client endpoint configuration.  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");   grpc:StreamingClient ep;  // Execute the unary non-blocking call that registers a server message listener.  var res = helloWorldEp->lotsOfGreetings(HelloWorldMessageListener);   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }   // Send multiple messages to the server.  string[] greets = [\"Hi\", \"Hey\", \"GM\"];  var name = \"John\";  foreach string greet in greets {  grpc:Error? connErr = ep->send(greet + \" \" + name);  if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  } else {  io:println(\"send greeting: \" + greet + \" \" + name);  }  }   // Once all the messages are sent, the server notifies the caller with a `complete` message.  grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  }   while (total == 0) {}  io:println(\"completed successfully\"); }  // Server Message Listener. service HelloWorldMessageListener = service {   // Resource registered to receive server messages.  resource function onMessage(string message) {  total = 1;  io:println(\"Response received from server: \" + message);  }   // Resource registered to receive server error messages.  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   // Resource registered to receive server completed messages.  resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    Client Streaming  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample includes a gRPC client streaming service and non-blocking client. The client writes a sequence of messages and sends them to the server via a stream.  Once the client has finished writing the messages, it waits for the server to read them and return a response.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfGreetings (stream google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the client streaming scenario.   # Create new Protocol Buffers definition file `grpc_client_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_client_streaming.proto --output stubs    # Once you run the command, `grpc_client_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the client streaming scenario.   @grpc:ServiceConfig {  name: \"HelloWorld\",  clientStreaming: true } service HelloWorld on new grpc:Listener(9090) {    resource function onOpen(grpc:Caller caller) {  log:printInfo(\"Client connected sucessfully.\");  }    This resource is triggered when a new caller connection is initialized.   resource function onMessage(grpc:Caller caller, string name) {  log:printInfo(\"Server received greet: \" + name);  }    This resource is triggered when the caller sends a request message to the service.   resource function onError(grpc:Caller caller, error err) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    This resource is triggered when the server receives an error message from the caller.   resource function onComplete(grpc:Caller caller) {  grpc:Error? err = caller->send(\"Ack\");  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Server send response : Ack\");  }  } }    This resource is triggered when the caller sends a notification to the server to indicate that it has finished sending messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_client_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # Run the service using the following command. ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the client streaming scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:StreamingClient ep;    var res = helloWorldEp->lotsOfGreetings(HelloWorldMessageListener);    Execute the unary non-blocking call that registers a server message listener.   if (res is grpc:Error) {  io:println(\"Error from Connector: \" + res.reason() + \" - \"  + <string>res.detail()[\"message\"]);  return;  } else {  io:println(\"Initialized connection sucessfully.\");  ep = res;  }    string[] greets = [\"Hi\", \"Hey\", \"GM\"];  var name = \"John\";  foreach string greet in greets {  grpc:Error? connErr = ep->send(greet + \" \" + name);  if (connErr is grpc:Error) {  io:println(\"Error from Connector: \" + connErr.reason() + \" - \"  + <string>connErr.detail()[\"message\"]);  } else {  io:println(\"send greeting: \" + greet + \" \" + name);  }  }    Send multiple messages to the server.   grpc:Error? result = ep->complete();  if (result is grpc:Error) {  io:println(\"Error in sending complete message\", result);  }    Once all the messages are sent, the server notifies the caller with a complete message.   while (total == 0) {}  io:println(\"completed successfully\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  total = 1;  io:println(\"Response received from server: \" + message);  }    Resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Resource registered to receive server error messages.   resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    Resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_client_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_client_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # Run the client using the following command. ballerina run target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/hello-world-client.html","name":"Hello World Client","summary":"Ballerina clients can be used to connect to and interact with HTTP endpoints.\n Ballerina creates an HTTP/1.1 client by default.Create an HTTP client to interact with a remote endpoint.Send a GET request to the server.Retrieve the text payload from the response.Log the retrieved text payload.This website uses cookies so that ...","content":"/  /  /  / Hello World Client  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  // Create an HTTP client to interact with a remote endpoint.  http:Client clientEP = new (\"http://www.mocky.io\");  // Send a GET request to the server.  http:Response resp = check clientEP->get(\"/v2/5ae082123200006b00510c3d/\");  // Retrieve the text payload from the response.  string payload = check resp.getTextPayload();  // Log the retrieved text payload.  io:println(payload); }    Hello World Client  Ballerina clients can be used to connect to and interact with HTTP endpoints.  Ballerina creates an HTTP/1.1 client by default.    import ballerina/http; import ballerina/io;    public function main() returns @tainted error? {    http:Client clientEP = new (\"http://www.mocky.io\");    Create an HTTP client to interact with a remote endpoint.   http:Response resp = check clientEP->get(\"/v2/5ae082123200006b00510c3d/\");    Send a GET request to the server.   string payload = check resp.getTextPayload();    Retrieve the text payload from the response.   io:println(payload); }    Log the retrieved text payload.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run hello_world_client.bal Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-server-streaming.html","name":"Server Streaming","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample includes a gRPC server streaming service and a non-blocking client. The\n client sends a request to the server and gets a stream to read the messages until all the messages are read.This is the service definition ...","content":"/  /  /  / Server Streaming  // This is the server implementation for the server streaming scenario. import ballerina/grpc; import ballerina/log;  service HelloWorld on new grpc:Listener(9090) {  // The annotation indicates how the service resource operates as server streaming.  @grpc:ResourceConfig {streaming: true}  resource function lotsOfReplies(grpc:Caller caller, string name) {   log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];   // Send multiple messages to the caller.  foreach string greet in greets {  string msg = greet + \" \" + name;  grpc:Error? err = caller->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Send reply: \" + msg);  }  }   // Once all the messages are sent, the server notifies the caller with a `complete` message.  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } } // This is the client implementation for the server streaming scenario. import ballerina/grpc; import ballerina/io;  int total = 0; public function main() {  // Client endpoint configuration.  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");   // Execute the unary non-blocking call that registers the server message listener.  grpc:Error? result = helloWorldEp->lotsOfReplies(\"Sam\",  HelloWorldMessageListener);  if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }   while (total == 0) {}  io:println(\"Client got response successfully.\"); }  // Server Message Listener. service HelloWorldMessageListener = service {   // The `resource` registered to receive server messages  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }   // The `resource` registered to receive server error messages  resource function onError(error err) {  io:println(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   // The `resource` registered to receive server completed messages.  resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    Server Streaming  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample includes a gRPC server streaming service and a non-blocking client. The  client sends a request to the server and gets a stream to read the messages until all the messages are read.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfReplies (google.protobuf.StringValue)  returns (stream google.protobuf.StringValue); }    This is the service definition for the server streaming scenario.   # Create new Protocol Buffers definition file `grpc_server_streaming.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_server_streaming.proto --output stubs    # Once you run the command, `grpc_server_streaming_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the server streaming scenario.   service HelloWorld on new grpc:Listener(9090) {    @grpc:ResourceConfig {streaming: true}  resource function lotsOfReplies(grpc:Caller caller, string name) {    The annotation indicates how the service resource operates as server streaming.   log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];    foreach string greet in greets {  string msg = greet + \" \" + name;  grpc:Error? err = caller->send(msg);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  } else {  log:printInfo(\"Send reply: \" + msg);  }  }    Send multiple messages to the caller.   grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Once all the messages are sent, the server notifies the caller with a complete message.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_server_streaming.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # Run the service using the following command. ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the server streaming scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Error? result = helloWorldEp->lotsOfReplies(\"Sam\",  HelloWorldMessageListener);  if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }    Execute the unary non-blocking call that registers the server message listener.   while (total == 0) {}  io:println(\"Client got response successfully.\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    The resource registered to receive server messages   resource function onError(error err) {  io:println(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    The resource registered to receive server error messages   resource function onComplete() {  total = 1;  io:println(\"Server Complete Sending Responses.\");  } };    The resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_server_streaming_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_server_streaming_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # Run the client using the following command. ballerina run target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-unary-blocking.html","name":"Unary Blocking","summary":"The gRPC Server Connector exposes the gRPC service over http2.\n This sample demonstrates how the gRPC unary service interacts with the gRPC blocking client, and how\n header values are handled.This is the service definition for the unary blocking/unblocking scenario.This is the server implementation for the unary blocking/unblocking scenario.Reads custom headers ...","content":"/  /  /  / Unary Blocking  // This is the server implementation for the unary blocking/unblocking scenario. import ballerina/grpc; import ballerina/log;  service HelloWorld on new grpc:Listener(9090) {   resource function hello(grpc:Caller caller, string name,  grpc:Headers headers) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;  // Reads custom headers in request message.  string reqHeader = headers.get(\"client_header_key\") ?: \"none\";  log:printInfo(\"Server received header value: \" + reqHeader);   // Writes custom headers to response message.  grpc:Headers resHeader = new;  resHeader.setEntry(\"server_header_key\", \"Response Header value\");   // Sends response message with headers.  grpc:Error? err = caller->send(message, resHeader);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   // Sends `completed` notification to caller.  grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } } // This is client implementation for unary blocking scenario. import ballerina/grpc; import ballerina/io;  public function main() {  // Client endpoint configuration.  HelloWorldBlockingClient helloWorldBlockingEp = new (\"http://localhost:9090\");   // Writes custom headers to request message.  grpc:Headers headers = new;  headers.setEntry(\"client_header_key\", \"Request Header Value\");   // Executes unary blocking call with headers.  var unionResp = helloWorldBlockingEp->hello(\"WSO2\", headers);   // Reads message and headers from response.  if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  grpc:Headers resHeaders;  [result, resHeaders] = unionResp;  io:println(\"Client Got Response : \" + result);  string headerValue = resHeaders.get(\"server_header_key\") ?: \"none\";  io:println(\"Headers: \" + headerValue);  } }    Unary Blocking  The gRPC Server Connector exposes the gRPC service over http2.  This sample demonstrates how the gRPC unary service interacts with the gRPC blocking client, and how  header values are handled.    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the unary blocking/unblocking scenario.   # Create new Protocol Buffers definition file `grpc_unary_blocking.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_unary_blocking.proto --output stubs    # Once you run the command, `grpc_unary_blocking_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the unary blocking/unblocking scenario.   service HelloWorld on new grpc:Listener(9090) {    resource function hello(grpc:Caller caller, string name,  grpc:Headers headers) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    string reqHeader = headers.get(\"client_header_key\") ?: \"none\";  log:printInfo(\"Server received header value: \" + reqHeader);    Reads custom headers in request message.   grpc:Headers resHeader = new;  resHeader.setEntry(\"server_header_key\", \"Response Header value\");    Writes custom headers to response message.   grpc:Error? err = caller->send(message, resHeader);  if (err is grpc:Error) {  log:printError(\"Error from Connector: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    Sends response message with headers.   grpc:Error? result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error in sending completed notification to caller\",  err = result);  }  } }    Sends completed notification to caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_unary_blocking.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # Run the service using the following command. ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is client implementation for unary blocking scenario.   public function main() {    HelloWorldBlockingClient helloWorldBlockingEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Headers headers = new;  headers.setEntry(\"client_header_key\", \"Request Header Value\");    Writes custom headers to request message.   var unionResp = helloWorldBlockingEp->hello(\"WSO2\", headers);    Executes unary blocking call with headers.   if (unionResp is grpc:Error) {  io:println(\"Error from Connector: \" + unionResp.reason() + \" - \"  + <string>unionResp.detail()[\"message\"]);  } else {  string result;  grpc:Headers resHeaders;  [result, resHeaders] = unionResp;  io:println(\"Client Got Response : \" + result);  string headerValue = resHeaders.get(\"server_header_key\") ?: \"none\";  io:println(\"Headers: \" + headerValue);  } }    Reads message and headers from response.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_unary_blocking_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # Run the client using the following command. ballerina run target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/hello-world-parallel.html","name":"Hello World Parallel","summary":"This example uses Ballerina to print “Hello, World!” in parallel using workers.\n A worker is a sequence of statements that is executed concurrently with all\n other workers in the function.Use one or more workers to define a function execution.\n The function invocation starts all the workers.This website uses cookies so ...","content":"/  /  /  / Hello World Parallel  import ballerina/io;  // Use one or more workers to define a function execution. // The function invocation starts all the workers. public function main() {  @strand {thread: \"any\"}  worker w1 {  io:println(\"Hello, World! #m\");  }   @strand {thread: \"any\"}  worker w2 {  io:println(\"Hello, World! #n\");  }   @strand {thread: \"any\"}  worker w3 {  io:println(\"Hello, World! #k\");  } }    Hello World Parallel  This example uses Ballerina to print “Hello, World!” in parallel using workers.  A worker is a sequence of statements that is executed concurrently with all  other workers in the function.    import ballerina/io;    public function main() {  @strand {thread: \"any\"}  worker w1 {  io:println(\"Hello, World! #m\");  }    Use one or more workers to define a function execution.  The function invocation starts all the workers.   @strand {thread: \"any\"}  worker w2 {  io:println(\"Hello, World! #n\");  }    @strand {thread: \"any\"}  worker w3 {  io:println(\"Hello, World! #k\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run hello_world_parallel.bal Hello, World! #m Hello, World! #k Hello, World! #n    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/grpc-unary-non-blocking.html","name":"Unary Non-Blocking","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This sample demonstrates how the gRPC unary service interacts with the gRPC non-blocking client.This is the service definition for the unary blocking/unblocking scenario.This is the server implementation for the unary blocking/unblocking scenario.Bind the service to the port.Send a ...","content":"/  /  /  / Unary Non-Blocking  // This is the server implementation for the unary blocking/unblocking scenario. import ballerina/grpc; import ballerina/log;  // Bind the `service` to the port. service HelloWorld on new grpc:Listener(9090) {   resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;   // Send a response message to the caller.  grpc:Error? result = caller->send(message);  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  // Send the `completed` notification to the caller.  result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  } } // This is the client implementation for the unary non blocking scenario. import ballerina/grpc; import ballerina/io;  int total = 0; public function main() {  // Client endpoint configuration.  HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");   // Execute the unary non-blocking call that registers the server message listener.  grpc:Error? result = helloWorldEp->hello(\"WSO2\", HelloWorldMessageListener);   if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }   while (total == 0) {}  io:println(\"Client got response successfully.\"); }  // Server Message Listener. service HelloWorldMessageListener = service {   // The `resource` registered to receive server messages.  resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }   // The `resource` registered to receive server error messages.  resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }   // The `resource` registered to receive server completed messages.  resource function onComplete() {  io:println(\"Server Complete Sending Response.\");  total = 1;  } };    Unary Non-Blocking  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This sample demonstrates how the gRPC unary service interacts with the gRPC non-blocking client.    syntax = \"proto3\"; package service; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the unary blocking/unblocking scenario.   # Create new Protocol Buffers definition file `grpc_unary_non_blocking.proto` and add service definition. # Run the following command in Ballerina tools distribution for stub generation. ballerina grpc --input grpc_unary_non_blocking.proto --output stubs    # Once you run the command, `grpc_unary_non_blocking_pb.bal` file is generated inside stubs directory.    # Please refer example `Proto To Ballerina` to get information on how to use Ballerina Protocol Buffers tool.    import ballerina/grpc; import ballerina/log;    This is the server implementation for the unary blocking/unblocking scenario.   service HelloWorld on new grpc:Listener(9090) {    Bind the service to the port.   resource function hello(grpc:Caller caller, string name) {  log:printInfo(\"Server received hello from \" + name);  string message = \"Hello \" + name;    grpc:Error? result = caller->send(message);  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }    Send a response message to the caller.   result = caller->complete();  if (result is grpc:Error) {  log:printError(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  }  } }    Send the completed notification to the caller.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `service`, copy the stub file to the `service` module.    # Add new Ballerina file `grpc_unary_non_blocking.bal` inside the `service` module and add service implementation.    # Execute the following command to build the 'service' module. ballerina build service    # Run the service using the following command. ballerina run target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the unary non blocking scenario.   int total = 0; public function main() {    HelloWorldClient helloWorldEp = new (\"http://localhost:9090\");    Client endpoint configuration.   grpc:Error? result = helloWorldEp->hello(\"WSO2\", HelloWorldMessageListener);    Execute the unary non-blocking call that registers the server message listener.   if (result is grpc:Error) {  io:println(\"Error from Connector: \" + result.reason() + \" - \"  + <string>result.detail()[\"message\"]);  } else {  io:println(\"Connected successfully\");  }    while (total == 0) {}  io:println(\"Client got response successfully.\"); }    service HelloWorldMessageListener = service {    Server Message Listener.   resource function onMessage(string message) {  io:println(\"Response received from server: \" + message);  }    The resource registered to receive server messages.   resource function onError(error err) {  io:println(\"Error reported from server: \" + err.reason() + \" - \"  + <string>err.detail()[\"message\"]);  }    The resource registered to receive server error messages.   resource function onComplete() {  io:println(\"Server Complete Sending Response.\");  total = 1;  } };    The resource registered to receive server completed messages.   # Create a Ballerina project and a module inside it. # Copy generated stub file `grpc_unary_non_blocking_pb.bal` to the module. # For example, if you create a module named `client`, copy the stub file to the `client` module.    # Add new Ballerina file `grpc_unary_non_blocking_client.bal` inside the `client` module and add client implementation.    # Execute the following command to build the 'client' module. ballerina build client    # Run the client using the following command. ballerina run target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/header-based-routing.html","name":"Header-Based Routing","summary":"The Header-Based Router service reads a particular Header of a request and routes it to a specific recipient based on the Header value.Service is invoked using basePath value “/hbr”.http:resourceConfig{} annotation with ‘GET’ method declares the\n HTTP method.Create a new outbound request to handle client call.Check whether x-type header exists in ...","content":"/  /  /  / Header-Based Routing  import ballerina/config; import ballerina/http; import ballerina/log;  http:ClientConfiguration weatherEPConfig = {  followRedirects: {enabled: true, maxCount: 5},  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } };  //Service is invoked using `basePath` value \"/hbr\". @http:ServiceConfig {  basePath: \"/hbr\" }  service headerBasedRouting on new http:Listener(9090) {  // `http:resourceConfig{}` annotation with 'GET' method declares the  // HTTP method.  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/route\"  }   resource function hbrResource(http:Caller caller, http:Request req) {  http:Client weatherEP = new (\"http://samples.openweathermap.org\",  weatherEPConfig);  http:Client locationEP = new (\"http://www.mocky.io\");  // Create a new outbound request to handle client call.  http:Request newRequest = new;  // Check whether `x-type` header exists in the request.  if (!req.hasHeader(\"x-type\")) {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  json errMsg = {\"error\": \"'x-type' header is not found\"};  errorResponse.setPayload(errMsg);   var result = caller->respond(errorResponse);   if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  //`getHeader()` returns header value of the specified header name.  string nameString = req.getHeader(\"x-type\");   http:Response|error response;  if (nameString == \"location\") {  //`post()` remote function represents the 'POST' operation  // of the HTTP client.  // Route payload to the relevant service.  response = locationEP->post(\"/v2/5adddd66300000bd2a4b2912\",  newRequest);   } else {  //`get()` remote function can be used to make an http GET call.  response =  weatherEP->get(\"/data/2.5/weather?lat=35&lon=139&appid=b1b1\",  newRequest);   }   if (response is http:Response) {  // `respond()` sends back the inbound clientResponse to the caller  // if no error occurs.   var result = caller->respond(response);   if (result is error) {  log:printError(\"Error sending response\", result);  }   } else {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  errorResponse.setPayload(<string>response.detail()?.message);  var result = caller->respond(errorResponse);   if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Header-Based Routing  The Header-Based Router service reads a particular Header of a request and routes it to a specific recipient based on the Header value.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration weatherEPConfig = {  followRedirects: {enabled: true, maxCount: 5},  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } };    @http:ServiceConfig {  basePath: \"/hbr\" }    Service is invoked using basePath value “/hbr”.   service headerBasedRouting on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/route\"  }    http:resourceConfig{} annotation with ‘GET’ method declares the  HTTP method.   resource function hbrResource(http:Caller caller, http:Request req) {  http:Client weatherEP = new (\"http://samples.openweathermap.org\",  weatherEPConfig);  http:Client locationEP = new (\"http://www.mocky.io\");    http:Request newRequest = new;    Create a new outbound request to handle client call.   if (!req.hasHeader(\"x-type\")) {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  json errMsg = {\"error\": \"'x-type' header is not found\"};  errorResponse.setPayload(errMsg);    Check whether x-type header exists in the request.   var result = caller->respond(errorResponse);    if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }    string nameString = req.getHeader(\"x-type\");    getHeader() returns header value of the specified header name.   http:Response|error response;  if (nameString == \"location\") {    response = locationEP->post(\"/v2/5adddd66300000bd2a4b2912\",  newRequest);    post() remote function represents the ‘POST’ operation  of the HTTP client.  Route payload to the relevant service.   } else {    response =  weatherEP->get(\"/data/2.5/weather?lat=35&lon=139&appid=b1b1\",  newRequest);    get() remote function can be used to make an http GET call.   }    if (response is http:Response) {    respond() sends back the inbound clientResponse to the caller  if no error occurs.   var result = caller->respond(response);    if (result is error) {  log:printError(\"Error sending response\", result);  }    } else {  http:Response errorResponse = new;  errorResponse.statusCode = 500;  errorResponse.setPayload(<string>response.detail()?.message);  var result = caller->respond(errorResponse);    if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below along with the # Ballerina home path as a config. ballerina run header_based_routing.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/hbr/route -H \"x-type:location\" {  \"name\": \"Colombo,Sri Lanka\",  \"longitude\": -556.49,  \"latitude\": 257.76,  \"altitude\": 230 }    curl http://localhost:9090/hbr/route -H \"x-type:weather\" {\"coord\":{\"lon\":139.01,\"lat\":35.02},\"weather\":[{\"id\":800, \"main\":\"Clear\",\"description\":\"clear sky\",\"icon\":\"01n\"}], \"base\":\"stations\",\"main\":{\"temp\":285.514,\"pressure\":1013.75, \"humidity\":100,\"temp_min\":285.514,\"temp_max\":285.514, \"sea_level\":1023.22,\"grnd_level\":1013.75}, \"wind\":{\"speed\":5.52,\"deg\":311},\"clouds\":{\"all\":0}, \"dt\":1485792967,\"sys\":{\"message\":0.0025,\"country\":\"JP\", \"sunrise\":1485726240,\"sunset\":1485763863}, \"id\":1907296,\"name\":\"Tawarano\",\"cod\":200}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/hello-world.html","name":"Hello World Main","summary":"Let’s print “Hello, World!” using a main function in Ballerina.\n A public function named main is considered as an entry point to a Ballerina program.The main function, which acts as the entry point.This website uses cookies so that we can provide you with the best user experience. Read our  ...","content":"/  /  /  / Hello World Main  import ballerina/io;  // The `main` function, which acts as the entry point. public function main() {  io:println(\"Hello, World!\"); }    Hello World Main  Let’s print “Hello, World!” using a main function in Ballerina.  A public function named main is considered as an entry point to a Ballerina program.    import ballerina/io;    public function main() {  io:println(\"Hello, World!\"); }    The main function, which acts as the entry point.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run hello_world.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/hello-world-service.html","name":"Hello World Service","summary":"In Ballerina, services represent collections of network-accessible entry points.\n Resources represent one such entry point.\n How a resource is exposed over a network protocol depends on the listener to which a service is attached.By default, Ballerina exposes an HTTP service via HTTP/1.1.Resource functions are invoked with the HTTP caller and ...","content":"/  /  /  / Hello World Service  import ballerina/http;  // By default, Ballerina exposes an HTTP service via HTTP/1.1. service hello on new http:Listener(9090) {   // Resource functions are invoked with the HTTP caller and the  // incoming request as arguments.  resource function sayHello(http:Caller caller,  http:Request req) returns error? {  // Send a response back to the caller.  check caller->respond(\"Hello, World!\");  } }    Hello World Service  In Ballerina, services represent collections of network-accessible entry points.  Resources represent one such entry point.  How a resource is exposed over a network protocol depends on the listener to which a service is attached.    import ballerina/http;    service hello on new http:Listener(9090) {    By default, Ballerina exposes an HTTP service via HTTP/1.1.   resource function sayHello(http:Caller caller,  http:Request req) returns error? {    Resource functions are invoked with the HTTP caller and the  incoming request as arguments.   check caller->respond(\"Hello, World!\");  } }    Send a response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run hello_world_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/hello/sayHello Hello, World!    Invoke the service using this “curl” command below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-100-continue.html","name":"100 Continue","summary":"Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.\n 100-continue indicates that the server has received the request headers and the client can proceed with sending the request.Check if the client expects a 100-continue response.Send a 100-continue response to the client.Send a 417 ...","content":"/  /  /  / 100 Continue  import ballerina/http; import ballerina/log;  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {   @http:ResourceConfig {  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {  // Check if the client expects a 100-continue response.  if (request.expects100Continue()) {  string mediaType = request.getHeader(\"Content-Type\");  if (mediaType.toLowerAscii() == \"text/plain\") {  // Send a 100-continue response to the client.  var result = caller->continue();  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  // Send a 417 response to ignore the payload since content type is mismatched  // with the expected content type.  http:Response res = new;  res.statusCode = 417;  res.setPayload(\"Unprocessable Entity\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  }   // The client starts sending the payload once it receives the  // 100-continue response. Retrieve the payload that is sent by the client.  http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  res.statusCode = 200;  res.setPayload(\"Hello World!\\n\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    100 Continue  Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.  100-continue indicates that the server has received the request headers and the client can proceed with sending the request.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {    if (request.expects100Continue()) {  string mediaType = request.getHeader(\"Content-Type\");  if (mediaType.toLowerAscii() == \"text/plain\") {    Check if the client expects a 100-continue response.   var result = caller->continue();  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {    Send a 100-continue response to the client.   http:Response res = new;  res.statusCode = 417;  res.setPayload(\"Unprocessable Entity\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  return;  }  }    Send a 417 response to ignore the payload since content type is mismatched  with the expected content type.   http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  res.statusCode = 200;  res.setPayload(\"Hello World!\\n\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>payload.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    The client starts sending the payload once it receives the  100-continue response. Retrieve the payload that is sent by the client.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_expect_header.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2018-12-04 21:37:36,272 INFO [ballerina/log] - TEST 100 CONTINUE    #Run the following curl command to run the client. curl -v -d \"TEST 100 CONTINUE\" http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: text/plain' * Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Length: 17 > Content-Type: text/plain > < HTTP/1.1 100 Continue * We are completely uploaded and fine < HTTP/1.1 200 OK < content-type: text/plain < content-length: 13 < Hello World! * Connection #0 to host localhost left intact    # Use the following client to invoke the service using an unsupported media type. Service is supposed to ignore # the payload if the content type does not matched. curl -v -d '{\"TEST\":\"100 CONTINUE\"}' http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: application/json' * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Type: application/json > Content-Length: 25 > < HTTP/1.1 417 Expectation Failed < content-type: text/plain < content-length: 20 * HTTP error before end of send, stop sending < * Closing connection 0 Unprocessable Entity    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-1-1-to-2-0-protocol-switch.html","name":"HTTP 1.1 to 2.0 Protocol Switch","summary":"In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it\n to another service over the HTTP/2.0 protocol.HTTP version is set to 2.0.Forward the clientRequest to the http2 service.Handle the errors that are returned when invoking the\n forward function.Send the response back to the ...","content":"/  /  /  / HTTP 1.1 to 2.0 Protocol Switch  import ballerina/http; import ballerina/log;  // HTTP version is set to 2.0. http:Client http2serviceClientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});  @http:ServiceConfig {  basePath: \"/http11Service\" } service http11Service on new http:Listener(9090) {   @http:ResourceConfig {  path: \"/\"  }  resource function http11Resource(http:Caller caller,  http:Request clientRequest) {  // Forward the `clientRequest` to the `http2` service.  var clientResponse = http2serviceClientEP->forward(\"/http2service\",  clientRequest);   http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {  // Handle the errors that are returned when invoking the  // `forward` function.  response.statusCode = 500;  response.setPayload(<string>clientResponse.detail()?.message);  }  // Send the response back to the caller.  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }   } }  // HTTP version is set to 2.0. listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});  @http:ServiceConfig {  basePath: \"/http2service\" } service http2service on http2serviceEP {   @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller,  http:Request clientRequest) {  // Construct the response message.  http:Response response = new;  json msg = {\"response\": {\"message\": \"response from http2 service\"}};  response.setPayload(msg);   // Send the response back to the caller (http11Service).  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }  } }    HTTP 1.1 to 2.0 Protocol Switch  In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it  to another service over the HTTP/2.0 protocol.    import ballerina/http; import ballerina/log;    http:Client http2serviceClientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http11Service\" } service http11Service on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function http11Resource(http:Caller caller,  http:Request clientRequest) {    var clientResponse = http2serviceClientEP->forward(\"/http2service\",  clientRequest);    Forward the clientRequest to the http2 service.   http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {    response.statusCode = 500;  response.setPayload(<string>clientResponse.detail()?.message);  }    Handle the errors that are returned when invoking the  forward function.   var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }    Send the response back to the caller.   } }    listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http2service\" } service http2service on http2serviceEP {    @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller,  http:Request clientRequest) {    http:Response response = new;  json msg = {\"response\": {\"message\": \"response from http2 service\"}};  response.setPayload(msg);    Construct the response message.   var result = caller->respond(response);  if (result is error) {  log:printError(\"Error occurred while sending the response\",  err = result);  }  } }    Send the response back to the caller (http11Service).   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_1.1_to_2.0_protocol_switch.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/http11Service {\"response\":{\"message\":\"response from http2 service\"}}    Invoke the HTTP/1.1 service using “curl”.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-access-logs.html","name":"Access Logs","summary":"Ballerina supports HTTP access logs for HTTP services. The access log format used is the combined log format.Respond with the message “Successful” for each request.Log the error in case of a failure.This website uses cookies so that we can provide you with the best user experience. Read our  to ...","content":"/  /  /  / Access Logs  import ballerina/http; import ballerina/log;  @http:ServiceConfig {  basePath: \"/hello\" } service helloService on new http:Listener(9095) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {  // Respond with the message \"Successful\" for each request.  var result = caller->respond(\"Successful\");  // Log the `error` in case of a failure.  if (result is error) {  log:printError(\"Error occurred while responding\", result);  }  } }    Access Logs  Ballerina supports HTTP access logs for HTTP services. The access log format used is the combined log format.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloService on new http:Listener(9095) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function hello(http:Caller caller, http:Request request) {    var result = caller->respond(\"Successful\");    Respond with the message “Successful” for each request.   if (result is error) {  log:printError(\"Error occurred while responding\", result);  }  } }    Log the error in case of a failure.   # At the command line, navigate to the directory that contains the # `.bal` file and do one of the following depending on whether you want the logs to be logged on the console, or in a file. # Run the service by setting the `--b7a.http.accesslog.console=true` property to log to the console. ballerina run http_access_logs.bal --b7a.http.accesslog.console=true ballerina: HTTP access log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 127.0.0.1 - - [30/Oct/2018:11:23:08 +0530] \"GET /hello HTTP/1.1\" 200 10 \"-\" \"curl/7.58.0\"    # Or, run the service by setting `--b7a.http.accesslog.path=path/to/file.txt` to log to the specified file. ballerina run http_access_logs.bal --b7a.http.accesslog.path=path/to/file.txt ballerina: HTTP access log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    # Invoke the service. curl -k http://localhost:9095/hello Successful    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-caching-client.html","name":"HTTP Caching","summary":"HTTP caching is disabled by default in HTTP client endpoints.\n Users can configure caching using the cache field in the endpoint configurations.HTTP caching is disabled by default for client endpoints. Caching can be\n enabled by setting enabled=true in the cache config of the client\n endpoint. In this example, the isShared ...","content":"/  /  /  / HTTP Caching  import ballerina/http; import ballerina/log;  // HTTP caching is disabled by default for client endpoints. Caching can be // enabled by setting `enabled=true` in the `cache` config of the client // endpoint. In this example, the `isShared` field of the `cacheConfig` is set // to true, as the cache will be a public cache in this particular scenario. // // The default caching policy is to cache a response only if it contains a // `cache-control` header and either an `etag` header, or a `last-modified` // header. The user can control this behaviour by setting the `policy` field of // the `cacheConfig`. Currently, there are only 2 policies: // `CACHE_CONTROL_AND_VALIDATORS` (the default policy) and `RFC_7234`.  http:Client cachingEP = new (\"http://localhost:8080\",  {cache: {enabled: true, isShared: true}});  @http:ServiceConfig {  basePath: \"/cache\" } service cachingProxy on new http:Listener(9090) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function cacheableResource(http:Caller caller, http:Request req) {  var response = cachingEP->forward(\"/hello\", req);   if (response is http:Response) {  // If the request was successful, an HTTP response will be  // returned. In this example, the received response is  // forwarded to the client through the outbound endpoint.  var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } else {  // For failed requests, a `500` response is sent back to the  // caller.  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>response.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  }  } }  json payload = {\"message\": \"Hello, World!\"};  // Sample backend service which serves cacheable responses. @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {   @http:ResourceConfig {path: \"/\"}  resource function sayHello(http:Caller caller, http:Request req) {  http:Response res = new;   // The `ResponseCacheControl` object in the `Response` object can be  // used for setting the cache control directives associated with the  // response. In this example, `max-age` directive is set to 15 seconds  // indicating that the response will be fresh for 15 seconds. The  // `must-revalidate` directive instructs that the cache should not  // serve a stale response without validating it with the origin server  // first. The `public` directive is set by setting `isPrivate=false`.  // This indicates that the response can be cached even by intermediary  // caches which serve multiple users.  http:ResponseCacheControl resCC = new;  resCC.maxAge = 15;  resCC.mustRevalidate = true;  resCC.isPrivate = false;   res.cacheControl = resCC;   // The `setETag()` function can be used for generating ETags for  // `string`, `json`, and `xml` types. This uses the `getCRC32()`  // function from the `ballerina/crypto` module for generating the ETag.  res.setETag(payload);   // The `setLastModified()` function sets the current time as the  // `last-modified` header.  res.setLastModified();   res.setPayload(payload);  // When sending the response, if the `cacheControl` field of the  // response is set, and the user has not already set a `cache-control`  // header, a `cache-control` header will be set using the directives set  // in the `cacheControl` object.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    HTTP Caching  HTTP caching is disabled by default in HTTP client endpoints.  Users can configure caching using the cache field in the endpoint configurations.    import ballerina/http; import ballerina/log;    HTTP caching is disabled by default for client endpoints. Caching can be  enabled by setting enabled=true in the cache config of the client  endpoint. In this example, the isShared field of the cacheConfig is set  to true, as the cache will be a public cache in this particular scenario.  The default caching policy is to cache a response only if it contains a  cache-control header and either an etag header, or a last-modified  header. The user can control this behaviour by setting the policy field of  the cacheConfig. Currently, there are only 2 policies:  CACHE_CONTROL_AND_VALIDATORS (the default policy) and RFC_7234.   http:Client cachingEP = new (\"http://localhost:8080\",  {cache: {enabled: true, isShared: true}});    @http:ServiceConfig {  basePath: \"/cache\" } service cachingProxy on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function cacheableResource(http:Caller caller, http:Request req) {  var response = cachingEP->forward(\"/hello\", req);    if (response is http:Response) {    var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } else {    If the request was successful, an HTTP response will be  returned. In this example, the received response is  forwarded to the client through the outbound endpoint.   http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>response.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  }  } }    For failed requests, a 500 response is sent back to the  caller.   json payload = {\"message\": \"Hello, World!\"};    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {    Sample backend service which serves cacheable responses.   @http:ResourceConfig {path: \"/\"}  resource function sayHello(http:Caller caller, http:Request req) {  http:Response res = new;    http:ResponseCacheControl resCC = new;  resCC.maxAge = 15;  resCC.mustRevalidate = true;  resCC.isPrivate = false;    The ResponseCacheControl object in the Response object can be  used for setting the cache control directives associated with the  response. In this example, max-age directive is set to 15 seconds  indicating that the response will be fresh for 15 seconds. The  must-revalidate directive instructs that the cache should not  serve a stale response without validating it with the origin server  first. The public directive is set by setting isPrivate=false.  This indicates that the response can be cached even by intermediary  caches which serve multiple users.   res.cacheControl = resCC;    res.setETag(payload);    The setETag() function can be used for generating ETags for  string, json, and xml types. This uses the getCRC32()  function from the ballerina/crypto module for generating the ETag.   res.setLastModified();    The setLastModified() function sets the current time as the  last-modified header.   res.setPayload(payload);    When sending the response, if the cacheControl field of the  response is set, and the user has not already set a cache-control  header, a cache-control header will be set using the directives set  in the cacheControl object.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Failed to respond to the caller\", result);  }  } }    # The two services have to be run separately to observe the following output. # For clarity, only the relevant parts of the HTTP trace logs have been included here. # At the command line, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below by setting the `--b7a.http.tracelog.console=true` property to start the service. ballerina run caching_proxy.bal --b7a.http.tracelog.console=true ballerina: deploying service(s) in 'caching_proxy.bal' ballerina: started HTTP/WS listener 0.0.0.0:9090 # The caching proxy receives a request from a client. [2019-09-08 12:35:46,581] TRACE {http.tracelog.downstream} - [id: 0x75aee346, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54140] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # The proxy in turn, makes a request to the backend service. [2019-09-08 12:35:46,750] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Accept: */* host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive    # The backend service responds with a `200 OK` and it contains `etag` and `cache-control` headers. This response can be cached and as such, the caching client caches it. As seen from the `max-age` directive of the 'cache-control` header, this response is valid for 15 seconds. [2019-09-08 12:35:46,800] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 content-length: 27 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:35:46 +0530 [2019-09-08 12:35:46,808] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0x75aee346, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultLastHttpContent(data: PooledSlicedByteBuf(ridx: 0, widx: 27, cap: 27/27, unwrapped: PooledUnsafeDirectByteBuf(ridx: 287, widx: 287, cap: 1024)), decoderResult: success), 27B {\"message\":\"Hello, World!\"}    # The response is sent back to the client. [2019-09-08 12:35:46,814] TRACE {http.tracelog.downstream} - [id: 0x75aee346, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54140] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:35:46 +0530 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # Subsequent requests to the proxy within the next 15 seconds are served from the proxy's cache. As seen here, the backend service is not contacted. [2019-09-08 12:36:00,421] TRACE {http.tracelog.downstream} - [id: 0xa8de466e, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54146] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # Cached response. [2019-09-08 12:36:00,435] TRACE {http.tracelog.downstream} - [id: 0xa8de466e, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54146] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:35:46 +0530 age: 14 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # Another request is sent after remaining idle for a while. [2019-09-08 12:36:11,009] TRACE {http.tracelog.downstream} - [id: 0xc7e78a3e, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54148] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /cache HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */*    # This time, the request is not served from the cache. The backend service is contacted. The `if-none-match` header sends the entity tag of the now stale response, so that the backend service may determine whether this response is still valid. [2019-09-08 12:36:11,022] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0xc7e78a3e, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 if-none-match: c854ce2c if-modified-since: Sun, 8 Sep 2019 12:35:46 +0530 host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive content-length: 0    # The response has not changed. Therefore the backend services respond with a `304 Not Modified` response. Based on this, the proxy will refresh the response, so that it can continue serving the cached response. [2019-09-08 12:36:11,028] TRACE {http.tracelog.upstream} - [id: 0x91bab3cd, correlatedSource: 0xc7e78a3e, host:/127.0.0.1:46172 - remote:localhost/127.0.0.1:8080] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 304 Not Modified etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 cache-control: must-revalidate,public,max-age=15 content-length: 0 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:36:11 +0530    # The cached response is served yet again since the response has not changed. [2019-09-08 12:36:11,039] TRACE {http.tracelog.downstream} - [id: 0xc7e78a3e, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54148] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK content-type: application/json cache-control: must-revalidate,public,max-age=15 date: Sun, 8 Sep 2019 12:36:11 +0530 etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 age: 0 server: ballerina/1.0.0 content-length: 27, 27B {\"message\":\"Hello, World!\"}    # The output for the mock service. ballerina run hello_service.bal --b7a.http.tracelog.console=true ballerina: deploying service(s) in 'hello_service.bal' ballerina: started HTTP/WS listener 0.0.0.0:8080 # For the first request that the caching proxy receives, it sends a request to the hello service. [2019-09-08 12:35:46,758] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:/127.0.0.1:8080 - remote:/127.0.0.1:46172] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Accept: */* host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive    # The service responds with a `200 OK` with the relevant caching headers set. [2019-09-08 12:35:46,792] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 27, cap: 27, components=1)) HTTP/1.1 200 OK etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:35:46 +0530 content-type: application/json cache-control: must-revalidate,public,max-age=15 content-length: 27 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:35:46 +0530, 27B {\"message\":\"Hello, World!\"}    # The backend service only gets another request when the cached response and the proxy have expired and it wants to validate it again. [2019-09-08 12:36:11,024] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 if-none-match: c854ce2c if-modified-since: Sun, 8 Sep 2019 12:35:46 +0530 host: localhost:8080 user-agent: ballerina/1.0.0 connection: keep-alive content-length: 0    # After checking the `if-none-match` header, the service determines that the response is still the same and that the proxy can keep reusing it. [2019-09-08 12:36:11,027] TRACE {http.tracelog.downstream} - [id: 0xfef23c5c, correlatedSource: n/a, host:localhost/127.0.0.1:8080 - remote:localhost/127.0.0.1:46172] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 0, cap: 0, components=1)) HTTP/1.1 304 Not Modified etag: c854ce2c last-modified: Sun, 8 Sep 2019 12:36:11 +0530 cache-control: must-revalidate,public,max-age=15 content-length: 0 server: ballerina/1.0.0 date: Sun, 8 Sep 2019 12:36:11 +0530, 0B    #Run the following curl command to run the client. curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:35:46 +0530 < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:35:46 +0530 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}    curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:35:46 +0530 < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:35:46 +0530 < age: 14 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}    curl -v http://localhost:9090/cache * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /cache HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < cache-control: must-revalidate,public,max-age=15 < date: Sun, 8 Sep 2019 12:36:11 +0530 < etag: c854ce2c < last-modified: Sun, 8 Sep 2019 12:36:11 +0530 < age: 0 < server: ballerina/1.0.0-rc1-SNAPSHOT < content-length: 27 < * Connection #0 to host localhost left intact {\"message\":\"Hello, World!\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-2-0-server-push.html","name":"HTTP 2.0 Server Push","summary":"This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.\n HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.Create an endpoint with port 7090 to accept HTTP requests.\n HTTP version is set to 2.0.Send a Push ...","content":"/  /  /  / HTTP 2.0 Server Push  import ballerina/http; import ballerina/log;  // Create an endpoint with port 7090 to accept HTTP requests. // HTTP version is set to 2.0. listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});  @http:ServiceConfig {  basePath: \"/http2Service\" } service http2Service on http2ServiceEP {   @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller, http:Request req) {   // Send a Push Promise.  http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  err = promiseResponse1);  }   // Send another Push Promise.  http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  err = promiseResponse2);  }   // Send one more Push Promise.  http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  err = promiseResponse3);  }   // Construct the requested resource.  http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);   // Send the requested resource.  var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  err = response);  }   // Construct promised resource1.  http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);   // Push promised resource1.  var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised response1\",  err = pushResponse1);  }   // Construct promised resource2.  http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);   // Push promised resource2.  var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised response2\",  err = pushResponse2);  }   // Construct promised resource3.  http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);   // Push promised resource3.  var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised response3\",  err = pushResponse3);  }  } } import ballerina/http; import ballerina/log;  // Create an HTTP client endpoint that can send HTTP/2 messages. // HTTP version is set to 2.0. http:Client clientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});  public function main() {   http:Request serviceReq = new;  http:HttpFuture httpFuture = new;  // Submit a request.  var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq);   if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  err = submissionResult);  return;  }   http:PushPromise?[] promises = [];  int promiseCount = 0;  // Check if promises exists.  boolean hasPromise = clientEP->hasPromise(httpFuture);   while (hasPromise) {  http:PushPromise pushPromise = new;  // Get the next promise.  var nextPromiseResult = clientEP->getNextPromise(httpFuture);   if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  err = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path);   if (pushPromise.path == \"/resource2\") {  // The client is not interested in receiving `/resource2`.  // Therefore, reject the promise.  clientEP->rejectPromise(pushPromise);   log:printInfo(\"Push promise for resource2 rejected\");  } else {  // Store the required promises.  promises[promiseCount] = pushPromise;   promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  }   http:Response response = new;  // Get the requested resource.  var result = clientEP->getResponse(httpFuture);   if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  err = result);  return;  }   var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  err = responsePayload);  }   // Fetch required promise responses.  foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  err = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" + promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  err = promisedPayload);  }  } }    HTTP 2.0 Server Push  This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.  HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.    import ballerina/http; import ballerina/log;    listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});    Create an endpoint with port 7090 to accept HTTP requests.  HTTP version is set to 2.0.   @http:ServiceConfig {  basePath: \"/http2Service\" } service http2Service on http2ServiceEP {    @http:ResourceConfig {  path: \"/\"  }  resource function http2Resource(http:Caller caller, http:Request req) {    http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  err = promiseResponse1);  }    Send a Push Promise.   http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  err = promiseResponse2);  }    Send another Push Promise.   http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  err = promiseResponse3);  }    Send one more Push Promise.   http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);    Construct the requested resource.   var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  err = response);  }    Send the requested resource.   http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);    Construct promised resource1.   var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised response1\",  err = pushResponse1);  }    Push promised resource1.   http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);    Construct promised resource2.   var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised response2\",  err = pushResponse2);  }    Push promised resource2.   http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);    Construct promised resource3.   var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised response3\",  err = pushResponse3);  }  } }    Push promised resource3.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_2.0_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090    import ballerina/http; import ballerina/log;    http:Client clientEP = new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    Create an HTTP client endpoint that can send HTTP/2 messages.  HTTP version is set to 2.0.   public function main() {    http:Request serviceReq = new;  http:HttpFuture httpFuture = new;    var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq);    Submit a request.   if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  err = submissionResult);  return;  }    http:PushPromise?[] promises = [];  int promiseCount = 0;    boolean hasPromise = clientEP->hasPromise(httpFuture);    Check if promises exists.   while (hasPromise) {  http:PushPromise pushPromise = new;    var nextPromiseResult = clientEP->getNextPromise(httpFuture);    Get the next promise.   if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  err = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path);    if (pushPromise.path == \"/resource2\") {    clientEP->rejectPromise(pushPromise);    The client is not interested in receiving /resource2.  Therefore, reject the promise.   log:printInfo(\"Push promise for resource2 rejected\");  } else {    promises[promiseCount] = pushPromise;    Store the required promises.   promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  }    http:Response response = new;    var result = clientEP->getResponse(httpFuture);    Get the requested resource.   if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  err = result);  return;  }    var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  err = responsePayload);  }    foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  err = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" + promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  err = promisedPayload);  }  } }    Fetch required promise responses.   #Run the `http_client.bal` that contains ballerina client. ballerina run http_client.bal INFO [ballerina/log] - Received a promise for /resource1 INFO [ballerina/log] - Received a promise for /resource2 INFO [ballerina/log] - Push promise for resource2 rejected INFO [ballerina/log] - Received a promise for /resource3 INFO [ballerina/log] - Response : {\"response\":{\"name\":\"main resource\"}} INFO [ballerina/log] - Promised resource : {\"push\":{\"name\":\"resource1\"}} INFO [ballerina/log] - Promised resource : {\"push\":{\"name\":\"resource3\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-client-endpoint.html","name":"Client Endpoint","summary":"The HTTP Client Connector can be used to connect to and interact with an HTTP server.Creates a new client with the backend URL.Sends a GET request to the specified endpoint.Handles the response.Sends a POST request to the specified endpoint.Handles the response.Uses the execute() remote function for custom HTTP verbs.Initializes a ...","content":"/  /  /  / Client Endpoint  import ballerina/http; import ballerina/io;  // Creates a new client with the backend URL. http:Client clientEndpoint = new (\"http://postman-echo.com\");  public function main() {  io:println(\"GET request:\");  // Sends a `GET` request to the specified endpoint.  var response = clientEndpoint->get(\"/get?test=123\");  // Handles the response.  handleResponse(response);   io:println(\"\\nPOST request:\");  // Sends a `POST` request to the specified endpoint.  response = clientEndpoint->post(\"/post\", \"POST: Hello World\");  // Handles the response.  handleResponse(response);   io:println(\"\\nUse custom HTTP verbs:\");  // Uses the `execute()` remote function for custom HTTP verbs.  response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");   // Initializes a request.  http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");  // The `get()`, `head()`, and `options()` can have the optional `message` parameter,  // which will be a request or a payload.  response = clientEndpoint->get(\"/get\", req);  if (response is http:Response) {  string contentType = response.getHeader(\"Content-Type\");  io:println(\"Content-Type: \" + contentType);   int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString());   } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }  //The below function handles the response received from the remote HTTP endpoint. function handleResponse(http:Response|error response) {  if (response is http:Response) {  var msg = response.getJsonPayload();  if (msg is json) {  // Prints the received `json` response.  io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.reason());  }  } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    Client Endpoint  The HTTP Client Connector can be used to connect to and interact with an HTTP server.    import ballerina/http; import ballerina/io;    http:Client clientEndpoint = new (\"http://postman-echo.com\");    Creates a new client with the backend URL.   public function main() {  io:println(\"GET request:\");    var response = clientEndpoint->get(\"/get?test=123\");    Sends a GET request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nPOST request:\");    response = clientEndpoint->post(\"/post\", \"POST: Hello World\");    Sends a POST request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nUse custom HTTP verbs:\");    response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");    Uses the execute() remote function for custom HTTP verbs.   http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");    Initializes a request.   response = clientEndpoint->get(\"/get\", req);  if (response is http:Response) {  string contentType = response.getHeader(\"Content-Type\");  io:println(\"Content-Type: \" + contentType);    The get(), head(), and options() can have the optional message parameter,  which will be a request or a payload.   int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString());    } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {  var msg = response.getJsonPayload();  if (msg is json) {    The below function handles the response received from the remote HTTP endpoint.   io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.reason());  }  } else {  io:println(\"Error when calling the backend: \",  response.detail()?.message);  } }    Prints the received json response.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run http_client_endpoint.bal GET request: {\"args\":{\"test\":\"123\"}, \"headers\":{\"x-forwarded-proto\":\"https\", \"host\":\"postman-echo.com\", \"user-agent\":\"ballerina/1.0.0-beta\", \"x-forwarded-port\":\"80\"}, \"url\":\"https://postman-echo.com/get?test=123\"}    POST request: {\"args\":{}, \"data\":\"POST: Hello World\", \"files\":{}, \"form\":{}, \"headers\":{\"x-forwarded-proto\":\"https\", \"host\":\"postman-echo.com\", \"content-length\":\"17\", \"content-type\":\"text/plain\", \"user-agent\":\"ballerina/1.0.0-beta\", \"x-forwarded-port\":\"80\"}, \"json\":null, \"url\":\"https://postman-echo.com/post\"}    Use custom HTTP verbs: Content-Type: application/json; charset=utf-8 Status code: 200    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-cors.html","name":"CORS","summary":"This sample demonstrates the Ballerina server connector CORS configuration.\nCORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources\nunless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.Service-level CORS headers apply globally to each resource.Resource-level ...","content":"/  /  /  / CORS  import ballerina/http; import ballerina/log;  //Service-level CORS headers apply globally to each `resource`. @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service crossOriginService on new http:Listener(9092) {   //Resource-level CORS headers override the service-level CORS headers.  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/company\",  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function companyInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"type\": \"middleware\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }   //Since there are no resource-level CORS headers defined here, the global  //service-level CORS headers are applied to this resource.  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/lang\"  }  resource function langInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"lang\": \"Ballerina\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    CORS  This sample demonstrates the Ballerina server connector CORS configuration. CORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources unless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service crossOriginService on new http:Listener(9092) {    Service-level CORS headers apply globally to each resource.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/company\",  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function companyInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"type\": \"middleware\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    Resource-level CORS headers override the service-level CORS headers.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/lang\"  }  resource function langInfo(http:Caller caller, http:Request req) {  http:Response res = new;  json responseJson = {\"lang\": \"Ballerina\"};  res.setJsonPayload(responseJson);  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    Since there are no resource-level CORS headers defined here, the global service-level CORS headers are applied to this resource.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_cors.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # Run this curl command to send a CORS simple request. curl -v \"http://localhost:9092/crossOriginService/company\" -H \"Origin:http://www.bbc.com\"    < HTTP/1.1 200 OK < Content-Type: application/json < Access-Control-Allow-Origin: http://www.bbc.com < Access-Control-Allow-Credentials: true < Content-Length: 21 {\"type\":\"middleware\"}    # Run this curl command to send a CORS preflight request. curl -v \"http://localhost:9092/crossOriginService/lang\" -X OPTIONS -H \"Origin:http://www.m3.com\" -H \"Access-Control-Request-Method:POST\"    < HTTP/1.1 200 OK < Access-Control-Allow-Origin: http://www.m3.com < Access-Control-Allow-Methods: POST < Access-Control-Max-Age: 84900 < Content-Length: 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-circuit-breaker.html","name":"Circuit Breaker","summary":"The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.The circuit breaker looks for errors across a rolling time window.\n After the circuit is broken, it does not send requests to\n the backend until the resetTime.Configuration options that control the behavior of ...","content":"/  /  /  / Circuit Breaker  import ballerina/http; import ballerina/log; import ballerina/runtime;  // The circuit breaker looks for errors across a rolling time window. // After the circuit is broken, it does not send requests to // the backend until the `resetTime`. http:Client backendClientEP = new (\"http://localhost:8080\", {  // Configuration options that control the behavior of the circuit  // breaker.  circuitBreaker: {  // Failure calculation window. This is how long the circuit breaker  // keeps the statistics for the operations.  rollingWindow: {   // Time period in milliseconds for which the failure threshold  // is calculated.  timeWindowInMillis: 10000,   // The granularity (in milliseconds) at which the time window  // slides.  // The `RollingWindow` is divided into buckets and slides by  // these increments.  // For an example, if this `timeWindowInMillis` is set to 10000  // milliseconds and `bucketSizeInMillis` 2000, then  // `RollingWindow` breaks into sub windows with 2-second  // buckets. Stats are collected with respect to the buckets. As  // time rolls, a new bucket will be appended to the end of the  // window and the old bucket will be removed.  bucketSizeInMillis: 2000,   // Minimum number of requests in a `RollingWindow` that will  // trip the circuit.  requestVolumeThreshold: 0   },  // The threshold for request failures.  // When this threshold exceeds, the circuit trips.  // This is the ratio between failures and total requests and the  // ratio is considered only within the configured `RollingWindow`.  failureThreshold: 0.2,   // The time period (in milliseconds) to wait before attempting to  // make another request to the upstream service.  // When the failure threshold exceeds, the circuit trips to `OPEN`  // state. Once the circuit is in `OPEN` state circuit breaker waits  // for the time configured in `resetTimeInMillis` and switch the  // circuit to the `HALF_OPEN` state.  resetTimeInMillis: 10000,   // HTTP response status codes that are considered as failures  statusCodes: [400, 404, 500]   },  timeoutInMillis: 2000  } );  // Create an HTTP service bound to the endpoint (circuitBreakerEP). @http:ServiceConfig {  basePath: \"/cb\" } service circuitbreaker on new http:Listener(9090) {  // Create a REST resource within the API.  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  // The parameters include a reference to the caller  // and an object of the request data.  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);  // If the `backendResponse` is an `http:Response`, it is sent back to  // the client. If `backendResponse` is an `http:ClientError`, an  // internal server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }  int counter = 1;  // This sample service is used to mock connection timeouts and service outages. // Mock a service outage by stopping/starting this service. // This should run separately from the `circuitBreakerDemo` service.  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  if (counter % 5 == 0) {  // Delay the response by 5000 milliseconds to  // mimic the network level delays.  runtime:sleep(5000);   var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  } else if (counter % 5 == 3) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(  \"Internal error occurred while processing the request.\");  var result = caller->respond(res);  handleRespondResult(result);  } else {  var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  }  counter = counter + 1;  } }  function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Circuit Breaker  The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    The circuit breaker looks for errors across a rolling time window.  After the circuit is broken, it does not send requests to  the backend until the resetTime.   circuitBreaker: {    Configuration options that control the behavior of the circuit  breaker.   rollingWindow: {    Failure calculation window. This is how long the circuit breaker  keeps the statistics for the operations.   timeWindowInMillis: 10000,    Time period in milliseconds for which the failure threshold  is calculated.   bucketSizeInMillis: 2000,    The granularity (in milliseconds) at which the time window  slides.  The RollingWindow is divided into buckets and slides by  these increments.  For an example, if this timeWindowInMillis is set to 10000  milliseconds and bucketSizeInMillis 2000, then  RollingWindow breaks into sub windows with 2-second  buckets. Stats are collected with respect to the buckets. As  time rolls, a new bucket will be appended to the end of the  window and the old bucket will be removed.   requestVolumeThreshold: 0    Minimum number of requests in a RollingWindow that will  trip the circuit.   },    failureThreshold: 0.2,    The threshold for request failures.  When this threshold exceeds, the circuit trips.  This is the ratio between failures and total requests and the  ratio is considered only within the configured RollingWindow.   resetTimeInMillis: 10000,    The time period (in milliseconds) to wait before attempting to  make another request to the upstream service.  When the failure threshold exceeds, the circuit trips to OPEN  state. Once the circuit is in OPEN state circuit breaker waits  for the time configured in resetTimeInMillis and switch the  circuit to the HALF_OPEN state.   statusCodes: [400, 404, 500]    HTTP response status codes that are considered as failures   },  timeoutInMillis: 2000  } );    @http:ServiceConfig {  basePath: \"/cb\" } service circuitbreaker on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (circuitBreakerEP).   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    The parameters include a reference to the caller  and an object of the request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If the backendResponse is an http:Response, it is sent back to  the client. If backendResponse is an http:ClientError, an  internal server error is returned to the client.   int counter = 1;    This sample service is used to mock connection timeouts and service outages.  Mock a service outage by stopping/starting this service.  This should run separately from the circuitBreakerDemo service.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  if (counter % 5 == 0) {    runtime:sleep(5000);    Delay the response by 5000 milliseconds to  mimic the network level delays.   var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  } else if (counter % 5 == 3) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(  \"Internal error occurred while processing the request.\");  var result = caller->respond(res);  handleRespondResult(result);  } else {  var result = caller->respond(\"Hello World!!!\");  handleRespondResult(result);  }  counter = counter + 1;  } }    function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_circuit_breaker.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 17:08:02,595 INFO [ballerina/http/resiliency] - CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state. 2019-09-04 17:08:12,514 INFO [ballerina/http/resiliency] - CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state. 2019-09-04 17:08:14,993 INFO [ballerina/http/resiliency] - CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state. 2019-09-04 17:08:20,003 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 17:08:22,082 INFO [ballerina/http/resiliency] - CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state. 2019-09-04 17:08:32,755 INFO [ballerina/http/resiliency] - CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state. 2019-09-04 17:08:35,268 INFO [ballerina/http/resiliency] - CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state.    # The first two requests complete without any errors. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:07:58 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:00 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The third request responds with a `500 Internal Server Error` because the # mock service sends a `500` http status code when responding to every third # request. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:00 +0530 < server: ballerina/1.0.0-beta < content-length: 53 < * Connection #0 to host localhost left intact Internal error occurred while processing the request.    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:02 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 8340 milliseconds.    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:04 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 6079 milliseconds.    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:07 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 3475 milliseconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:12 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The fifth request times out because the mock service times out when # responding to every fifth request. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 57 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:17 +0530 < * Connection #0 to host localhost left intact Idle timeout triggered before initiating inbound response    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 17:08:22 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 4917 milliseconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:32 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # Since the immediate request after the timeout expired was successful, the # requests sent after that complete normally. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 17:08:35 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-compression.html","name":"HTTP Compression","summary":"This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server\n compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When\n the particular header is not present or the header value is “identity”, the ...","content":"/  /  /  / HTTP Compression  import ballerina/http; import ballerina/log;  listener http:Listener listenerEndpoint = new (9090);  // Since compression behaviour of the service is set as `COMPRESSION_AUTO`, entity body compression is done according // to the scheme indicated in `Accept-Encoding` request header. Compression is not performed when the header is not // present or the header value is \"identity\". @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service autoCompress on listenerEndpoint {  @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  var result = caller->respond({\"Type\": \"Auto compression\"});   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }  // `COMPRESSION_ALWAYS` guarantees a compressed response entity body. Compression scheme is set to the // value indicated in Accept-Encoding request header. When particular header is not present or the header // value is \"identity\", encoding is done using \"gzip\" scheme. // By default Ballerina compresses any MIME type unless they are mentioned under `contentTypes`. // Compression can be constrained to certain MIME types by specifying them as an array of MIME types. // In this example encoding is applied to \"text/plain\" responses only. @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service alwaysCompress on listenerEndpoint {  // Since compression is only constrained to \"text/plain\" MIME type,  // `getJson` resource does not compress the response entity body.  resource function getJson(http:Caller caller, http:Request req) {  json msg = {\"Type\": \"Always but constrained by content-type\"};  var result = caller->respond(msg);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  // The response entity body is always compressed since MIME type has matched.  resource function getString(http:Caller caller, http:Request req) {  var result = caller->respond(\"Type : This is a string\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }  // The HTTP client can indicate the compression behaviour (\"AUTO\", \"ALWAYS\", \"NEVER\") for content negotiation. // Depending on the compression option values, the `Accept-Encoding` header is sent along with the request. // In this example, the client compression behaviour is set as `COMPRESSION_ALWAYS`. If you have not specified // `Accept-Encoding` header, the client specifies it with \"deflate, gzip\". Alternatively, the existing header is sent. // When compression is specified as `COMPRESSION_AUTO`, only the user specified `Accept-Encoding` header is sent. // If the behaviour is set as `COMPRESSION_NEVER`, the client makes sure not to send the `Accept-Encoding` header. http:Client clientEndpoint = new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );  service passthrough on new http:Listener(9092) {  @http:ResourceConfig {  path: \"/\"  }  resource function getCompressed(http:Caller caller, http:Request req) {  var response = clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  json err = {\"error\": \"error occurred while invoking service\"};  var result = caller->respond(err);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }  // The compression behaviour of the service is inferred by `COMPRESSION_AUTO`, which is the default value // of the compression config service backend on listenerEndpoint {  resource function echo(http:Caller caller, http:Request req) {  http:Response res = new;  if (req.hasHeader(\"accept-encoding\")) {  string value = req.getHeader(\"accept-encoding\");  res.setPayload(\"Backend response was encoded : \" + <@untainted>value);  } else {  res.setPayload(\"Accept-Encoding header is not present\");  }   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    HTTP Compression  This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server  compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When  the particular header is not present or the header value is “identity”, the server does not perform any compression. Compression  is disabled when the option is set to COMPRESSION_NEVER.”    import ballerina/http; import ballerina/log;    listener http:Listener listenerEndpoint = new (9090);    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service autoCompress on listenerEndpoint {  @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  var result = caller->respond({\"Type\": \"Auto compression\"});    Since compression behaviour of the service is set as COMPRESSION_AUTO, entity body compression is done according  to the scheme indicated in Accept-Encoding request header. Compression is not performed when the header is not  present or the header value is “identity”.   if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service alwaysCompress on listenerEndpoint {    COMPRESSION_ALWAYS guarantees a compressed response entity body. Compression scheme is set to the  value indicated in Accept-Encoding request header. When particular header is not present or the header  value is “identity”, encoding is done using “gzip” scheme.  By default Ballerina compresses any MIME type unless they are mentioned under contentTypes.  Compression can be constrained to certain MIME types by specifying them as an array of MIME types.  In this example encoding is applied to “text/plain” responses only.   resource function getJson(http:Caller caller, http:Request req) {  json msg = {\"Type\": \"Always but constrained by content-type\"};  var result = caller->respond(msg);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }    Since compression is only constrained to “text/plain” MIME type,  getJson resource does not compress the response entity body.   resource function getString(http:Caller caller, http:Request req) {  var result = caller->respond(\"Type : This is a string\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    The response entity body is always compressed since MIME type has matched.   http:Client clientEndpoint = new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );    The HTTP client can indicate the compression behaviour (“AUTO”, “ALWAYS”, “NEVER”) for content negotiation.  Depending on the compression option values, the Accept-Encoding header is sent along with the request.  In this example, the client compression behaviour is set as COMPRESSION_ALWAYS. If you have not specified  Accept-Encoding header, the client specifies it with “deflate, gzip”. Alternatively, the existing header is sent.  When compression is specified as COMPRESSION_AUTO, only the user specified Accept-Encoding header is sent.  If the behaviour is set as COMPRESSION_NEVER, the client makes sure not to send the Accept-Encoding header.   service passthrough on new http:Listener(9092) {  @http:ResourceConfig {  path: \"/\"  }  resource function getCompressed(http:Caller caller, http:Request req) {  var response = clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  json err = {\"error\": \"error occurred while invoking service\"};  var result = caller->respond(err);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    service backend on listenerEndpoint {  resource function echo(http:Caller caller, http:Request req) {  http:Response res = new;  if (req.hasHeader(\"accept-encoding\")) {  string value = req.getHeader(\"accept-encoding\");  res.setPayload(\"Backend response was encoded : \" + <@untainted>value);  } else {  res.setPayload(\"Accept-Encoding header is not present\");  }    The compression behaviour of the service is inferred by COMPRESSION_AUTO, which is the default value  of the compression config   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_compression.bal # Service deployment ballerina: started HTTP/WS listener 0.0.0.0:9092 ballerina: started HTTP/WS listener 0.0.0.0:9090    # To invoke the autoCompress Service, use the following curl command. # Here the `Accept-Encoding` header is specified as `deflate`. curl -v --output - http://localhost:9090/autoCompress -H \"Accept-Encoding:deflate\" > GET /autoCompress HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Accept-Encoding:deflate > < HTTP/1.1 200 OK < content-type: application/json < content-encoding: deflate < content-length: 41 < x��V * Connection #0 to host localhost left intact �,HU�Rr,-�WH��-(J-.���S���\u0003��\t�    # To invoke the alwaysCompress Service to get the JSON payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. curl -v --output - http://localhost:9090/alwaysCompress/getJson > GET /alwaysCompress/getJson HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < content-length: 49 < * Connection #0 to host localhost left intact {\"Type\":\"Always but constrained by content-type\"}    # To invoke the alwaysCompress Service to get the String payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. curl -v --output - http://localhost:9090/alwaysCompress/getString > GET /alwaysCompress/getString HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < content-encoding: gzip < content-length: 48 < \u001f� * Connection #0 to host localhost left intact �,HU���,V�D�⒢̼t��\u0003ʴ��\u0017    # To invoke the passthrough Service, use the following curl command. curl -v --output - http://localhost:9092/passthrough/ > GET /passthrough/ HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < transfer-encoding: chunked < * Connection #0 to host localhost left intact Backend response was encoded : deflate, gzip    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-data-binding.html","name":"Data Binding","summary":"HTTP data binding helps access payload through the last resource signature parameter. The parameter name should be\n declared in the resource config under the body annotation. string, json, xml, byte[], record, and record[] are\n supported as parameter types.The body annotation represents the entity body of the inbound request.Accesses the JSON ...","content":"/  /  /  / Data Binding  import ballerina/http; import ballerina/log;  type Student record {  string Name;  int Grade;  map<any> Marks; };  @http:ServiceConfig {} service hello on new http:Listener(9090) {   //The `body` annotation represents the entity body of the inbound request.  @http:ResourceConfig {  methods: [\"POST\"],  body: \"orderDetails\"  }  resource function bindJson(http:Caller caller, http:Request req,  json orderDetails) {  //Accesses the JSON field values.  var details = orderDetails.Details;  http:Response res = new;  if (details is json) {  res.setPayload(<@untainted>details);  } else {  res.statusCode = 400;  res.setPayload(\"Order Details unavailable\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }   //Binds the XML payload of the inbound request to the `store` variable.  @http:ResourceConfig {  methods: [\"POST\"],  body: \"store\",  consumes: [\"application/xml\"]  }  resource function bindXML(http:Caller caller, http:Request req, xml store) {  //Accesses the XML content.  xml city = store.selectDescendants(\"{http://www.test.com}city\");  http:Response res = new;  res.setPayload(<@untainted>city);   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }   //Binds the JSON payload to a custom record. The payload's content should  //match the record.  @http:ResourceConfig {  methods: [\"POST\"],  body: \"student\",  consumes: [\"application/json\"]  }  resource function bindStruct(http:Caller caller, http:Request req,  Student student) {  //Accesses the fields of the `Student` record.  string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untained string>student.Marks[\"English\"];  http:Response res = new;  res.setPayload({Name: name, Grade: grade, English: english});   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    Data Binding  HTTP data binding helps access payload through the last resource signature parameter. The parameter name should be  declared in the resource config under the body annotation. string, json, xml, byte[], record, and record[] are  supported as parameter types.    import ballerina/http; import ballerina/log;    type Student record {  string Name;  int Grade;  map<any> Marks; };    @http:ServiceConfig {} service hello on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"POST\"],  body: \"orderDetails\"  }  resource function bindJson(http:Caller caller, http:Request req,  json orderDetails) {    The body annotation represents the entity body of the inbound request.   var details = orderDetails.Details;  http:Response res = new;  if (details is json) {  res.setPayload(<@untainted>details);  } else {  res.statusCode = 400;  res.setPayload(\"Order Details unavailable\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    Accesses the JSON field values.   @http:ResourceConfig {  methods: [\"POST\"],  body: \"store\",  consumes: [\"application/xml\"]  }  resource function bindXML(http:Caller caller, http:Request req, xml store) {    Binds the XML payload of the inbound request to the store variable.   xml city = store.selectDescendants(\"{http://www.test.com}city\");  http:Response res = new;  res.setPayload(<@untainted>city);    Accesses the XML content.   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  body: \"student\",  consumes: [\"application/json\"]  }  resource function bindStruct(http:Caller caller, http:Request req,  Student student) {    Binds the JSON payload to a custom record. The payload’s content should match the record.   string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untained string>student.Marks[\"English\"];  http:Response res = new;  res.setPayload({Name: name, Grade: grade, English: english});    Accesses the fields of the Student record.   var result = caller->respond(res);  if (result is error) {  log:printError(result.reason(), result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_data_binding.bal #Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the `bindJson` resource, execute the HTTP request below. curl -v http://localhost:9090/hello/bindJson -d '{ \"Details\": { \"ID\": \"77999\", \"Name\": \"XYZ\"} , \"Location\": { \"No\": \"01\", \"City\": \"Colombo\"}}' -H \"Content-Type:application/json\" # Server response: {\"ID\":\"77999\", \"Name\":\"XYZ\"}    # To invoke the `bindXML` resource, execute the HTTP request below. curl -v http://localhost:9090/hello/bindXML -d \"<h:Store id = \\\"AST\\\" xmlns:h=\\\"http://www.test.com\\\"><h:street>Main</h:street><h:city>94</h:city></h:Store>\" -H \"Content-Type:application/xml\" # Server response: <h:city xmlns:h=\"http://www.test.com\">94</h:city>    # To invoke the `bindStruct` resource, execute the HTTP request below. curl -v http://localhost:9090/hello/bindStruct -d '{ \"Name\": \"John\", \"Grade\": 12, \"Marks\": {\"English\" : \"85\", \"IT\" : \"100\"}}' -H \"Content-Type:application/json\" # Server response: {\"Name\":\"John\", \"Grade\":12, \"English\":\"85\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-cookies.html","name":"HTTP Cookies","summary":"This example demonstrates how to handle HTTP cookies in Ballerina service and client.\n For more information on the underlying module,\n see the .Retrieve the JSON payload from the request as it\n contains the login details of a user.Retrieve the username and password.Check the password value.Create a new cookie by setting ...","content":"/  /  /  / HTTP Cookies  import ballerina/http; import ballerina/log;  listener http:Listener serverEP = new (9095);  @http:ServiceConfig {  basePath: \"/cookie-demo\" }  service cookieServer on serverEP {  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/login\"  }  resource function login(http:Caller caller, http:Request req) {  // Retrieve the JSON payload from the request as it  // contains the login details of a user.  json|error details = req.getJsonPayload();   if (details is json) {  // Retrieve the username and password.  json|error name = details.name;  json|error password = details.password;   if (name is json && password is json) {  // Check the password value.  if (password == \"p@ssw0rd\") {   // Create a new cookie by setting `name` as the `username`  // and `value` as the logged-in user's name.  http:Cookie cookie = new(\"username\", name.toString());   // Set the cookies path as `/` to apply it to all the  // resources in the service.  cookie.path = \"/\";   http:Response response = new;   // Add the created cookie to the response.  response.addCookie(cookie);   // Set a message payload to inform that the login has  // been succeeded.  response.setTextPayload(\"Login succeeded\");  var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond\", result);  }  }  }  }  }   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/welcome\"  }  resource function welcome(http:Caller caller, http:Request req) {  // Retrieve cookies from the request.  http:Cookie[] cookies = req.getCookies();   // Get the cookie value of the `username`.  http:Cookie[] usernameCookie = cookies.filter(function  (http:Cookie cookie) returns boolean {  return cookie.name == \"username\";  });   if (usernameCookie.length() > 0) {  string? user = usernameCookie[0].value;  if (user is string) {  // Respond with the username added to the welcome message.  var result = caller->respond(\"Welcome back \" + <@untainted> user);   } else {  // If the user is `nil`, send a login message.  var result = caller->respond(\"Please login\");  }  } else {  // If the `username` cookie is not presented, send a login message.  var result = caller->respond(\"Please login\");  }  } } import ballerina/http; import ballerina/log;  // HTTP client configurations associated with enabling cookies. http:ClientConfiguration clientEPConfig = {  cookieConfig: {  enabled: true  } };  public function main() {  // Create a new HTTP client by giving the URL and the client configuration.  http:Client httpClient = new(\"http://localhost:9095/cookie-demo\",  clientEPConfig);   // Initialize an HTTP request.  http:Request request = new;   // Send a username and a password as a JSON payload to the backend.  json jsonPart = {  name: \"John\",  password: \"p@ssw0rd\"  };  request.setJsonPayload(jsonPart);   // Send an outbound request to the `login` backend resource.  var loginResp = httpClient->post(\"/login\", request);   if (loginResp is http:Response) {  // This response contains the cookies added by the backend server.  // Get the login response message.  string|error loginMessage = loginResp.getTextPayload();   if (loginMessage is error) {  log:printError(\"Login failed\", loginMessage);  } else {  // When the login is successful, make another request to the  // `/welcome` resource of the backend service. // As cookies are enabled in the HTTP client, it automatically handles cookies  // received with the login response and sends the relevant cookies  // to the `welcome` service resource.  var welcomeResp = httpClient->get(\"/welcome\");   if (welcomeResp is http:Response) {  string|error textPayload = welcomeResp.getTextPayload();  if (textPayload is string) {  // A welcome message with the sent username  // will get printed.  log:printInfo(textPayload);  }  }  }  } else {  log:printError(<string>loginResp.detail()[\"message\"]);  } }    HTTP Cookies  This example demonstrates how to handle HTTP cookies in Ballerina service and client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    listener http:Listener serverEP = new (9095);    @http:ServiceConfig {  basePath: \"/cookie-demo\" }    service cookieServer on serverEP {  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/login\"  }  resource function login(http:Caller caller, http:Request req) {    json|error details = req.getJsonPayload();    Retrieve the JSON payload from the request as it  contains the login details of a user.   if (details is json) {    json|error name = details.name;  json|error password = details.password;    Retrieve the username and password.   if (name is json && password is json) {    if (password == \"p@ssw0rd\") {    Check the password value.   http:Cookie cookie = new(\"username\", name.toString());    Create a new cookie by setting name as the username  and value as the logged-in user’s name.   cookie.path = \"/\";    Set the cookies path as / to apply it to all the  resources in the service.   http:Response response = new;    response.addCookie(cookie);    Add the created cookie to the response.   response.setTextPayload(\"Login succeeded\");  var result = caller->respond(response);  if (result is error) {  log:printError(\"Failed to respond\", result);  }  }  }  }  }    Set a message payload to inform that the login has  been succeeded.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/welcome\"  }  resource function welcome(http:Caller caller, http:Request req) {    http:Cookie[] cookies = req.getCookies();    Retrieve cookies from the request.   http:Cookie[] usernameCookie = cookies.filter(function  (http:Cookie cookie) returns boolean {  return cookie.name == \"username\";  });    Get the cookie value of the username.   if (usernameCookie.length() > 0) {  string? user = usernameCookie[0].value;  if (user is string) {    var result = caller->respond(\"Welcome back \" + <@untainted> user);    Respond with the username added to the welcome message.   } else {    var result = caller->respond(\"Please login\");  }  } else {    If the user is nil, send a login message.   var result = caller->respond(\"Please login\");  }  } }    If the username cookie is not presented, send a login message.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run cookie_server.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  cookieConfig: {  enabled: true  } };    HTTP client configurations associated with enabling cookies.   public function main() {    http:Client httpClient = new(\"http://localhost:9095/cookie-demo\",  clientEPConfig);    Create a new HTTP client by giving the URL and the client configuration.   http:Request request = new;    Initialize an HTTP request.   json jsonPart = {  name: \"John\",  password: \"p@ssw0rd\"  };  request.setJsonPayload(jsonPart);    Send a username and a password as a JSON payload to the backend.   var loginResp = httpClient->post(\"/login\", request);    Send an outbound request to the login backend resource.   if (loginResp is http:Response) {    string|error loginMessage = loginResp.getTextPayload();    This response contains the cookies added by the backend server.  Get the login response message.   if (loginMessage is error) {  log:printError(\"Login failed\", loginMessage);  } else {    var welcomeResp = httpClient->get(\"/welcome\");    When the login is successful, make another request to the  /welcome resource of the backend service.  As cookies are enabled in the HTTP client, it automatically handles cookies  received with the login response and sends the relevant cookies  to the welcome service resource.   if (welcomeResp is http:Response) {  string|error textPayload = welcomeResp.getTextPayload();  if (textPayload is string) {    log:printInfo(textPayload);  }  }  }  } else {  log:printError(<string>loginResp.detail()[\"message\"]);  } }    A welcome message with the sent username  will get printed.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run http_client.bal 2020-06-12 15:52:15,513 INFO [] - Welcome back John    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-disable-chunking.html","name":"Disable Chunking","summary":"This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header.\nIf the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.The HTTP client’s chunking behaviour ...","content":"/  /  /  / Disable Chunking  import ballerina/http; import ballerina/log;  //The HTTP client's chunking behaviour can be configured as `CHUNKING_AUTO`, `CHUNKING_ALWAYS`, or `CHUNKING_NEVER`. //In this example, it is set to `CHUNKING_NEVER`, which means that chunking never happens irrespective of how it is specified //in the request. When chunking is set to `CHUNKING_AUTO`, chunking is done as specified in the request.  http:Client clientEndpoint = new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});  service chunkingSample on new http:Listener(9092) {   @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {  //Create a new outbound request and set the payload.  http:Request newReq = new;  newReq.setPayload({\"name\": \"Ballerina\"});  var clientResponse = clientEndpoint->post(\"/echo/\", newReq);  if (clientResponse is http:Response) {  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response errorResponse = new;  json msg = {\"error\": \"An error occurred while invoking the service.\"};  errorResponse.setPayload(msg);  var response = caller->respond(errorResponse);  if (response is error) {  log:printError(\"Error sending response\", response);  }  }  } }  // A sample backend, which responds according to the chunking behaviour. service echo on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  string value;   http:Response res = new;  boolean validationErrorFound = false;  //Set the response according to the request headers.  if (req.hasHeader(\"content-length\")) {  value = req.getHeader(\"content-length\");  value = \"Length-\" + value;  } else if (req.hasHeader(\"Transfer-Encoding\")) {  value = req.getHeader(\"Transfer-Encoding\");  //Perform data validation for transfer-encoding.  if (value != \"chunked\" && value != \"compress\" && value != \"deflate\"  && value != \"gzip\" && value != \"identity\") {  res.statusCode = 400;  res.setPayload(\"Transfer-Encoding contains invalid data\");  validationErrorFound = true;  }  } else {  value =  \"Neither Transfer-Encoding nor content-length header found\";  }   if (!validationErrorFound) {  // Since there is no validation error, mark the `value` as trusted data and set it to the response.  res.setPayload({\"Outbound request content\": <@untainted>value});  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response from echo service\",  err = result);  }  } }  function isValid(boolean|error value) returns boolean {  if (value is boolean) {  return value;  }  return false; }    Disable Chunking  This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header. If the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.    import ballerina/http; import ballerina/log;    The HTTP client’s chunking behaviour can be configured as CHUNKING_AUTO, CHUNKING_ALWAYS, or CHUNKING_NEVER. In this example, it is set to CHUNKING_NEVER, which means that chunking never happens irrespective of how it is specified in the request. When chunking is set to CHUNKING_AUTO, chunking is done as specified in the request.   http:Client clientEndpoint = new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});    service chunkingSample on new http:Listener(9092) {    @http:ResourceConfig {  path: \"/\"  }  resource function invokeEndpoint(http:Caller caller, http:Request req) {    http:Request newReq = new;  newReq.setPayload({\"name\": \"Ballerina\"});  var clientResponse = clientEndpoint->post(\"/echo/\", newReq);  if (clientResponse is http:Response) {  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response errorResponse = new;  json msg = {\"error\": \"An error occurred while invoking the service.\"};  errorResponse.setPayload(msg);  var response = caller->respond(errorResponse);  if (response is error) {  log:printError(\"Error sending response\", response);  }  }  } }    Create a new outbound request and set the payload.   service echo on new http:Listener(9090) {  @http:ResourceConfig {  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  string value;    A sample backend, which responds according to the chunking behaviour.   http:Response res = new;  boolean validationErrorFound = false;    if (req.hasHeader(\"content-length\")) {  value = req.getHeader(\"content-length\");  value = \"Length-\" + value;  } else if (req.hasHeader(\"Transfer-Encoding\")) {  value = req.getHeader(\"Transfer-Encoding\");    Set the response according to the request headers.   if (value != \"chunked\" && value != \"compress\" && value != \"deflate\"  && value != \"gzip\" && value != \"identity\") {  res.statusCode = 400;  res.setPayload(\"Transfer-Encoding contains invalid data\");  validationErrorFound = true;  }  } else {  value =  \"Neither Transfer-Encoding nor content-length header found\";  }    Perform data validation for transfer-encoding.   if (!validationErrorFound) {    res.setPayload({\"Outbound request content\": <@untainted>value});  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response from echo service\",  err = result);  }  } }    Since there is no validation error, mark the value as trusted data and set it to the response.   function isValid(boolean|error value) returns boolean {  if (value is boolean) {  return value;  }  return false; }    # To start the services, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run http_disable_chunking.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    To use the client, execute the cURL command below. curl http://localhost:9092/chunkingSample {\"Outbound request content\":\"Length-20\"}    To enable chunking, change the chunking option of the `clientEndpoint` in the `.bal` file to `http:CHUNKING_ALWAYS`. {\"Outbound request content\":\"chunked\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-failover.html","name":"Failover","summary":"Ballerina users can configure multiple HTTP clients in a given failover group. If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.Create an endpoint with port 8080 for the mock backend services.Define the failover client endpoint to call the backend services.Define a set of HTTP ...","content":"/  /  /  / Failover  import ballerina/http; import ballerina/log; import ballerina/runtime;  // Create an endpoint with port 8080 for the mock backend services. listener http:Listener backendEP = new (8080);  // Define the failover client endpoint to call the backend services. http:FailoverClient foBackendEP = new ({  timeoutInMillis: 5000,  failoverCodes: [501, 502, 503],  intervalInMillis: 5000,  // Define a set of HTTP Clients that are targeted for failover.  targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });  @http:ServiceConfig {  basePath: \"/fo\" } service failoverDemoService on new http:Listener(9090) {  // Create a REST resource within the API.  @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  // Parameters include a reference to the caller and an object with the  // request data.  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = foBackendEP->get(\"/\", <@untainted>request);   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }  // Define the sample service to mock connection timeouts and service outages. @http:ServiceConfig {  basePath: \"/echo\" } service echo on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {  // Delay the response for 30000 milliseconds to mimic network level  // delays.  runtime:sleep(30000);   var result = caller->respond(\"echo Resource is invoked\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }  // Define the sample service to mock a healthy service. @http:ServiceConfig {  basePath: \"/mock\" } service mock on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function mockResource(http:Caller caller, http:Request req) {  var result = caller->respond(\"Mock Resource is Invoked.\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    Failover  Ballerina users can configure multiple HTTP clients in a given failover group. If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.    import ballerina/http; import ballerina/log; import ballerina/runtime;    listener http:Listener backendEP = new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:FailoverClient foBackendEP = new ({  timeoutInMillis: 5000,  failoverCodes: [501, 502, 503],  intervalInMillis: 5000,    Define the failover client endpoint to call the backend services.   targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });    Define a set of HTTP Clients that are targeted for failover.   @http:ServiceConfig {  basePath: \"/fo\" } service failoverDemoService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = foBackendEP->get(\"/\", <@untainted>request);    Parameters include a reference to the caller and an object with the  request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload(<string>backendResponse.detail()?.message);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   @http:ServiceConfig {  basePath: \"/echo\" } service echo on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function echoResource(http:Caller caller, http:Request req) {    Define the sample service to mock connection timeouts and service outages.   runtime:sleep(30000);    Delay the response for 30000 milliseconds to mimic network level  delays.   var result = caller->respond(\"echo Resource is invoked\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    @http:ServiceConfig {  basePath: \"/mock\" } service mock on backendEP {  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function mockResource(http:Caller caller, http:Request req) {  var result = caller->respond(\"Mock Resource is Invoked.\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    Define the sample service to mock a healthy service.   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_failover.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Failover Service, use following curl command. curl -v http://localhost:9090/fo # The `FailoverClient` endpoint is configured with three target services.The first two targets are configured to mimic # failure backends. If one target service goes down, the failover client automatically calls the other targets. # Once you invoke the Failover demo service, the Failover client fails over the request to the configured # target endpoints. In this example, the third target is configured to give a successful response and the following # response is given when the failover demo service is invoked. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:37 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked. # Invoke the Failover Service again using the curl command. curl -v http://localhost:9090/fo # At this point, Ballerina failover client already knows that leading endpoints (in this case the first two targets) # failed in the last invocation and it got the successful response from the third target. So the failover client # resumes the failover from the last successful target. In this case it is the third target and the client will get # the immediate response for subsequent calls. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:41 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/","name":"Ballerina","summary":"Ballerina by Example enables you to have complete coverage over the language, while emphasizing incremental learning. This is a series of commented example programs.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies ...","content":"/  /  / Ballerina by Example  TABLE OF CONTENTS  Ballerina by Example enables you to have complete coverage over the language, while emphasizing incremental learning. This is a series of commented example programs.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-filters.html","name":"HTTP Interceptors/Filters","summary":"HTTP Listener supports intercepting request in the request path.\n Its possible to define a filter with custom logic, engage to a HTTP Listener.\n The request will go through the filter logic before its dispatched to the\n actual resource in the target service.Header name to be set to the request in ...","content":"/  /  /  / HTTP Interceptors/Filters  import ballerina/http; import ballerina/log;  // Header name to be set to the request in the filter. final string filter_name_header = \"X-requestHeader\"; // Header value to be set to the request in the filter. final string filter_name_header_value = \"RequestFilter\";  // The Request filter implementation. It intercepts the request and adds a new // header to request before it is dispatched to the HTTP resource. public type RequestFilter object {  *http:RequestFilter;  // Intercepts the request.  public function filterRequest(http:Caller caller, http:Request request,  http:FilterContext context) returns boolean {  // Set a header to the request inside the filter.  request.setHeader(filter_name_header, filter_name_header_value);  // Return true on success.  return true;  } };  // Create a new RequestFilter. RequestFilter requestFilter = new;  // The response filter implementation. It intercepts the response in response // path and adds a new header to response. public type ResponseFilter object {  *http:ResponseFilter;  // Intercepts the response.  public function filterResponse(http:Response response, http:FilterContext context) returns boolean {  // Set a header to the response inside the filter.  response.setHeader(\"X-responseHeader\", \"ResponseFilter\");  // Return true on success.  return true;  } };  // Create a new ResponseFilter. ResponseFilter responseFilter = new;  // Create an HTTP listener and assign the filters as a config parameter. listener http:Listener echoListener = new http:Listener(9090,  config = {filters: [requestFilter, responseFilter]});  @http:ServiceConfig {  basePath: \"/hello\" } service echo on echoListener {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\"  }  resource function echo(http:Caller caller, http:Request req) {  // Create a new http response.  http:Response res = new;  // Set the `filter_name_header` from the request to the response.  res.setHeader(filter_name_header, req.getHeader(filter_name_header));  res.setPayload(\"Hello, World!\");  var result = caller->respond(<@untainted>res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    HTTP Interceptors/Filters  HTTP Listener supports intercepting request in the request path.  Its possible to define a filter with custom logic, engage to a HTTP Listener.  The request will go through the filter logic before its dispatched to the  actual resource in the target service.    import ballerina/http; import ballerina/log;    final string filter_name_header = \"X-requestHeader\";    Header name to be set to the request in the filter.   final string filter_name_header_value = \"RequestFilter\";    Header value to be set to the request in the filter.   public type RequestFilter object {  *http:RequestFilter;    The Request filter implementation. It intercepts the request and adds a new  header to request before it is dispatched to the HTTP resource.   public function filterRequest(http:Caller caller, http:Request request,  http:FilterContext context) returns boolean {    Intercepts the request.   request.setHeader(filter_name_header, filter_name_header_value);    Set a header to the request inside the filter.   return true;  } };    Return true on success.   RequestFilter requestFilter = new;    Create a new RequestFilter.   public type ResponseFilter object {  *http:ResponseFilter;    The response filter implementation. It intercepts the response in response  path and adds a new header to response.   public function filterResponse(http:Response response, http:FilterContext context) returns boolean {    Intercepts the response.   response.setHeader(\"X-responseHeader\", \"ResponseFilter\");    Set a header to the response inside the filter.   return true;  } };    Return true on success.   ResponseFilter responseFilter = new;    Create a new ResponseFilter.   listener http:Listener echoListener = new http:Listener(9090,  config = {filters: [requestFilter, responseFilter]});    Create an HTTP listener and assign the filters as a config parameter.   @http:ServiceConfig {  basePath: \"/hello\" } service echo on echoListener {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\"  }  resource function echo(http:Caller caller, http:Request req) {    http:Response res = new;    Create a new http response.   res.setHeader(filter_name_header, req.getHeader(filter_name_header));  res.setPayload(\"Hello, World!\");  var result = caller->respond(<@untainted>res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Set the filter_name_header from the request to the response.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_filters.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To build a compiled program file, can use the # \"ballerina build\" command followed by # the service module. ballerina build http_filters.bal    curl -v http://localhost:9090/hello/sayHello * Trying 127.0.0.1... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /hello/sayHello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.61.0 > Accept: */* > < HTTP/1.1 200 OK < X-requestHeader: RequestFilter < content-type: text/plain < X-responseHeader: ResponseFilter < content-length: 13 < server: ballerina/1.0.0-beta < date: Wed, 21 Aug 2019 13:28:12 +0530 < * Connection #0 to host localhost left intact Hello, World!    Invoke the service using “curl”.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-redirects.html","name":"Redirects","summary":"This example demonstrates an HTTP redirect.\n To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect\n to true.Creates an HTTP client to interact with a remote endpoint.Sends a GET request to the specified endpoint.Retrieves the text payload from the response.Sends a redirect response ...","content":"/  /  /  / Redirects  import ballerina/http; import ballerina/log;  // Creates an HTTP client to interact with a remote endpoint. http:Client clientEndpoint = new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );  service hello on new http:Listener(9090) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function myResource(http:Caller caller, http:Request req) {  // Sends a `GET` request to the specified endpoint.  var returnResult = clientEndpoint->get(\"/redirect1\");  if (returnResult is http:Response) {  // Retrieves the text payload from the response.  var payload = returnResult.getTextPayload();  if (payload is string) {  var result = caller->respond(\"Response received : \" + <@untained>payload);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } else {  var result = caller->respond(\"Error in payload : \" + <@untained>payload.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } else {  var result = caller->respond(\"Error in connection : \" + returnResult.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } }  @http:ServiceConfig {  basePath: \"/redirect1\" } service redirect1 on new http:Listener(9092) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect1(http:Caller caller, http:Request req) {  http:Response res = new;  // Sends a redirect response with a location.  error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);  if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  err = result);  }  } }  @http:ServiceConfig {  basePath: \"/redirect2\" } service redirect2 on new http:Listener(9093) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect2(http:Caller caller, http:Request req) {  // Sends a response to the caller.  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Redirects  This example demonstrates an HTTP redirect.  To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect  to true.    import ballerina/http; import ballerina/log;    http:Client clientEndpoint = new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );    Creates an HTTP client to interact with a remote endpoint.   service hello on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function myResource(http:Caller caller, http:Request req) {    var returnResult = clientEndpoint->get(\"/redirect1\");  if (returnResult is http:Response) {    Sends a GET request to the specified endpoint.   var payload = returnResult.getTextPayload();  if (payload is string) {  var result = caller->respond(\"Response received : \" + <@untained>payload);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } else {  var result = caller->respond(\"Error in payload : \" + <@untained>payload.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } else {  var result = caller->respond(\"Error in connection : \" + returnResult.detail()?.message.toString());  if (result is error) {  log:printError(\"Error in responding\", result);  }  }  } }    Retrieves the text payload from the response.   @http:ServiceConfig {  basePath: \"/redirect1\" } service redirect1 on new http:Listener(9092) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect1(http:Caller caller, http:Request req) {  http:Response res = new;    error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);  if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  err = result);  }  } }    Sends a redirect response with a location.   @http:ServiceConfig {  basePath: \"/redirect2\" } service redirect2 on new http:Listener(9093) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function redirect2(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Sends a response to the caller.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run http_redirects.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9093    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-load-balancer.html","name":"Load Balancing","summary":"An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given\n set of target endpoints.Create an endpoint with port 8080 for the mock backend services.Define the load balance client endpoint to call the backend services.Define the set of HTTP clients that need ...","content":"/  /  /  / Load Balancing  import ballerina/http; import ballerina/log;  // Create an endpoint with port 8080 for the mock backend services. listener http:Listener backendEP = new (8080);  // Define the load balance client endpoint to call the backend services. http:LoadBalanceClient lbBackendEP = new ({  // Define the set of HTTP clients that need to be load balanced.  targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],  timeoutInMillis: 5000 });   // Create an HTTP service bound to the endpoint (`loadBalancerEP`). @http:ServiceConfig {  basePath: \"/lb\" } service loadBalancerDemoService on new http:Listener(9090) {  // Create a REST resource within the API.  @http:ResourceConfig {  path: \"/\"  }  resource function roundRobin(http:Caller caller, http:Request req) {  json requestPayload = {\"name\": \"Ballerina\"};  var response = lbBackendEP->post(\"/\", requestPayload);  // If a response is returned, the normal process runs. If the service  // does not get the expected response, the error-handling logic is  // executed.  if (response is http:Response) {  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response outResponse = new;  outResponse.statusCode = 500;  outResponse.setPayload(<string>response.detail()?.message);  var responseToCaller = caller->respond(outResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }  // Define the mock backend services, which are called by the load balancer. @http:ServiceConfig {  basePath: \"/mock1\" } service mock1 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock1Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock1 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }  @http:ServiceConfig {  basePath: \"/mock2\" } service mock2 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock2Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock2 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }  @http:ServiceConfig {  basePath: \"/mock3\" } service mock3 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock3Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock3 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }  // Function to handle respond results function handleRespondResult(http:ListenerError? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Load Balancing  An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given  set of target endpoints.    import ballerina/http; import ballerina/log;    listener http:Listener backendEP = new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:LoadBalanceClient lbBackendEP = new ({    Define the load balance client endpoint to call the backend services.   targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],  timeoutInMillis: 5000 });    Define the set of HTTP clients that need to be load balanced.   @http:ServiceConfig {  basePath: \"/lb\" } service loadBalancerDemoService on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (loadBalancerEP).   @http:ResourceConfig {  path: \"/\"  }  resource function roundRobin(http:Caller caller, http:Request req) {  json requestPayload = {\"name\": \"Ballerina\"};  var response = lbBackendEP->post(\"/\", requestPayload);    Create a REST resource within the API.   if (response is http:Response) {  var responseToCaller = caller->respond(response);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response outResponse = new;  outResponse.statusCode = 500;  outResponse.setPayload(<string>response.detail()?.message);  var responseToCaller = caller->respond(outResponse);  if (responseToCaller is http:ListenerError) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If a response is returned, the normal process runs. If the service  does not get the expected response, the error-handling logic is  executed.   @http:ServiceConfig {  basePath: \"/mock1\" } service mock1 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock1Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock1 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    Define the mock backend services, which are called by the load balancer.   @http:ServiceConfig {  basePath: \"/mock2\" } service mock2 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock2Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock2 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    @http:ServiceConfig {  basePath: \"/mock3\" } service mock3 on backendEP {  @http:ResourceConfig {  path: \"/\"  }  resource function mock3Resource(http:Caller caller, http:Request req) {  var responseToCaller = caller->respond(\"Mock3 resource was invoked.\");  if (responseToCaller is http:ListenerError) {  handleRespondResult(responseToCaller);  }  } }    function handleRespondResult(http:ListenerError? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Function to handle respond results   # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_load_balancer.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Load Balancer Demo Service, use following cURL command. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:57 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked.    # Repeat the same cURL command to invoke the Load Balance Demo Service again. # The request will be load balanced to the second mock service. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:58 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock2 resource was invoked.    # Invoke the Load Balancer Demo Service one more time using the same cURL command. # The request will be load balanced to the third mock service. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:36:59 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock3 resource was invoked.    # Invoke the Load Balancer Demo Service using the same cURL command for the last time. # The request will be load balanced to the first mock service again. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:37:00 +0530 < server: ballerina/1.0.0-beta < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-timeout.html","name":"Timeout","summary":"The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.Timeout configuration.Create an HTTP service bound to the listener endpoint.Create a REST resource within the API.The parameters include a reference to the caller\n endpoint and an object of the request data.If backendResponse is an http:Response, ...","content":"/  /  /  / Timeout  import ballerina/http; import ballerina/log; import ballerina/runtime;  http:Client backendClientEP = new (\"http://localhost:8080\", {  // Timeout configuration.  timeoutInMillis: 10000  });  // Create an HTTP service bound to the listener endpoint. @http:ServiceConfig {  basePath: \"/timeout\" } service timeoutService on new http:Listener(9090) {  // Create a REST resource within the API.  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  // The parameters include a reference to the caller  // endpoint and an object of the request data.  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = <string>backendResponse.detail()?.message;  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }  // This sample service is used to mock connection timeouts. @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  // Delay the response by 15000 milliseconds to  // mimic the network level delays.  runtime:sleep(15000);   var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    Timeout  The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    timeoutInMillis: 10000    Timeout configuration.   });    @http:ServiceConfig {  basePath: \"/timeout\" } service timeoutService on new http:Listener(9090) {    Create an HTTP service bound to the listener endpoint.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    The parameters include a reference to the caller  endpoint and an object of the request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = <string>backendResponse.detail()?.message;  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(8080) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    This sample service is used to mock connection timeouts.   runtime:sleep(15000);    Delay the response by 15000 milliseconds to  mimic the network level delays.   var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\", result);  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_timeout.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2019-09-04 16:21:39,541 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed    curl -v http://localhost:9090/timeout * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /timeout HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 48 < server: ballerina/1.0.0-beta < date: Wed, 4 Sep 2019 16:21:34 +0530 < * Connection #0 to host localhost left intact Request timed out. Please try again in sometime.    Invoke the service using “curl”.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-retry.html","name":"Retry","summary":"The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.Define the endpoint to the call the mockHelloService.Retry configuration options.Initial retry interval in milliseconds.Number of retry attempts before giving up.Multiplier of the retry interval to exponentially increase the\n retry interval.Upper ...","content":"/  /  /  / Retry  import ballerina/http; import ballerina/log; import ballerina/runtime;  // Define the endpoint to the call the `mockHelloService`. http:Client backendClientEP = new (\"http://localhost:8080\", {  // Retry configuration options.  retryConfig: {   // Initial retry interval in milliseconds.  intervalInMillis: 3000,   // Number of retry attempts before giving up.  count: 3,   // Multiplier of the retry interval to exponentially increase the  // retry interval.  backOffFactor: 2.0,   // Upper limit of the retry interval in milliseconds. If  // `intervalInMillis` into `backOffFactor` value exceeded  // `maxWaitIntervalInMillis` interval value.  // `maxWaitIntervalInMillis` will be considered as the retry  // interval.  maxWaitIntervalInMillis: 20000  },  timeoutInMillis: 2000  } );  @http:ServiceConfig {  basePath: \"/retry\" } service retryDemoService on new http:Listener(9090) {  // Create a REST resource within the API.  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  // Parameters include a reference to the caller and an object of the  // request data.  resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errCause = <string>backendResponse.detail()?.message;  response.setPayload(errCause);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }  int counter = 0;  // This sample service is used to mock connection timeouts and service outages. // The service outage is mocked by stopping/starting this service. // This should run separately from the `retryDemoService` service. @http:ServiceConfig {  basePath: \"/hello\" } service mockHelloService on new http:Listener(8080) {   @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");  // Delay the response by 5000 milliseconds to  // mimic network level delays.  runtime:sleep(5000);  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }  function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    Retry  The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.    import ballerina/http; import ballerina/log; import ballerina/runtime;    http:Client backendClientEP = new (\"http://localhost:8080\", {    Define the endpoint to the call the mockHelloService.   retryConfig: {    Retry configuration options.   intervalInMillis: 3000,    Initial retry interval in milliseconds.   count: 3,    Number of retry attempts before giving up.   backOffFactor: 2.0,    Multiplier of the retry interval to exponentially increase the  retry interval.   maxWaitIntervalInMillis: 20000  },  timeoutInMillis: 2000  } );    Upper limit of the retry interval in milliseconds. If  intervalInMillis into backOffFactor value exceeded  maxWaitIntervalInMillis interval value.  maxWaitIntervalInMillis will be considered as the retry  interval.   @http:ServiceConfig {  basePath: \"/retry\" } service retryDemoService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }    Create a REST resource within the API.   resource function invokeEndpoint(http:Caller caller, http:Request request) {  var backendResponse = backendClientEP->forward(\"/hello\", request);    Parameters include a reference to the caller and an object of the  request data.   if (backendResponse is http:Response) {  var responseToCaller = caller->respond(backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errCause = <string>backendResponse.detail()?.message;  response.setPayload(errCause);  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\", responseToCaller);  }  }  } }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   int counter = 0;    @http:ServiceConfig {  basePath: \"/hello\" } service mockHelloService on new http:Listener(8080) {    This sample service is used to mock connection timeouts and service outages.  The service outage is mocked by stopping/starting this service.  This should run separately from the retryDemoService service.   @http:ResourceConfig {  methods: [\"GET\", \"POST\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");    runtime:sleep(5000);  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }    Delay the response by 5000 milliseconds to  mimic network level delays.   function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\", result);  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_retry.bal.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 15:47:25,980 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:30,998 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:31,012 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:36,004 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:39,005 INFO [] - Request received from the client to delayed service. 2019-09-04 15:47:44,007 ERROR [] - Error sending response from mock service : error {ballerina/http}GenericListenerError message=Connection between remote client and host is closed 2019-09-04 15:47:53,016 INFO [] - Request received from the client to healthy service.    # If the request that was sent to the `retryDemoService` fails due to an error, the client tries sending the request again. curl -v http://localhost:9090/retry * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /retry HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:47:53 +0530 < server: ballerina/1.0.0-beta < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-streaming.html","name":"HTTP Streaming","summary":"Ballerina supports HTTP input and output streaming capability through io:ReadableByteChannel.Creates an endpoint for the client.Sets the file as request payload.Sends the request to the client with the file content.Writes the incoming stream to a file. First get the destination\nchannel by providing the file name, the content should be\nwritten to.Sets the ...","content":"/  /  /  / HTTP Streaming  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  // Creates an endpoint for the client. http:Client clientEndpoint = new (\"http://localhost:9090\");  @http:ServiceConfig {  basePath: \"/stream\" } service HTTPStreamingService on new http:Listener(9090) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/fileupload\"  }  resource function handleOutputStream(http:Caller caller,  http:Request clientRequest) {  http:Request request = new;   //Sets the file as request payload.  request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);   //Sends the request to the client with the file content.  var clientResponse = clientEndpoint->post(\"/stream/receiver\", request);   http:Response res = new;  if (clientResponse is http:Response) {  var payload = clientResponse.getTextPayload();  if (payload is string) {  res.setPayload(<@untainted>payload);  } else {  setError(res, payload);  }  } else {  log:printError(\"Error occurred while sending data to the client \",  err = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  err = result);  }  }   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/receiver\"  }  resource function handleInputStream(http:Caller caller,  http:Request clientRequest) {  http:Response res = new;  var payload = clientRequest.getByteChannel();  if (payload is io:ReadableByteChannel) {  //Writes the incoming stream to a file. First get the destination  //channel by providing the file name, the content should be  //written to.  var destinationChannel =  io:openWritableFile(\"./files/ReceivedFile.pdf\");  if (destinationChannel is io:WritableByteChannel) {  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \",  err = result);  }  close(payload);  close(destinationChannel);  }  res.setPayload(\"File Received!\");  } else {  setError(res, payload);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  err = result);  }  } }  //Sets the error to the response. function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message); }  // Copies the content from the source channel to a destination channel. function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {  // The below example shows how to read all the content from  // the source and copy it to the destination.  while (true) {  // The operation attempts to read a maximum of 1000 bytes and returns  // with the available content, which could be < 1000.  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  // The operation writes the given content into the channel.  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }  //Closes the byte channel. function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    HTTP Streaming  Ballerina supports HTTP input and output streaming capability through io:ReadableByteChannel.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEndpoint = new (\"http://localhost:9090\");    Creates an endpoint for the client.   @http:ServiceConfig {  basePath: \"/stream\" } service HTTPStreamingService on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/fileupload\"  }  resource function handleOutputStream(http:Caller caller,  http:Request clientRequest) {  http:Request request = new;    request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);    Sets the file as request payload.   var clientResponse = clientEndpoint->post(\"/stream/receiver\", request);    Sends the request to the client with the file content.   http:Response res = new;  if (clientResponse is http:Response) {  var payload = clientResponse.getTextPayload();  if (payload is string) {  res.setPayload(<@untainted>payload);  } else {  setError(res, payload);  }  } else {  log:printError(\"Error occurred while sending data to the client \",  err = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  err = result);  }  }    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/receiver\"  }  resource function handleInputStream(http:Caller caller,  http:Request clientRequest) {  http:Response res = new;  var payload = clientRequest.getByteChannel();  if (payload is io:ReadableByteChannel) {    var destinationChannel =  io:openWritableFile(\"./files/ReceivedFile.pdf\");  if (destinationChannel is io:WritableByteChannel) {  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \",  err = result);  }  close(payload);  close(destinationChannel);  }  res.setPayload(\"File Received!\");  } else {  setError(res, payload);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  err = result);  }  } }    Writes the incoming stream to a file. First get the destination channel by providing the file name, the content should be written to.   function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted string>err.detail()?.message); }    Sets the error to the response.   function copy(io:ReadableByteChannel src,  io:WritableByteChannel dst) returns error? {    Copies the content from the source channel to a destination channel.   while (true) {    The below example shows how to read all the content from  the source and copy it to the destination.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    The operation attempts to read a maximum of 1000 bytes and returns  with the available content, which could be < 1000.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    The operation writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the byte channel.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run http_streaming.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    #Send a request to the streaming service. curl -X GET http://localhost:9090/stream/fileupload File Received!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-to-websocket-upgrade.html","name":"HTTP To WebSocket Upgrade","summary":"This sample demonstrates how an HTTP endpoint is updated to a WebSocket endpoint using an upgrade resource.This is an HTTP resource.This is an HTTP to WebSocket upgrade resource. This is defined using the WebSocket upgrade resource config.\n Here you have access to the http:Request and to the query and path ...","content":"/  /  /  / HTTP To WebSocket Upgrade  import ballerina/http; import ballerina/io; import ballerina/log;  @http:ServiceConfig {  basePath: \"/hello\" } service httpService on new http:Listener(9090) {   // This is an HTTP resource.  @http:ResourceConfig {  path: \"/world\",  methods: [\"POST\"]  }  resource function httpResource(http:Caller caller, http:Request req) {  http:Response resp = new;  var payload = req.getTextPayload();  if (payload is error) {  log:printError(\"Error sending message\", payload);  resp.setPayload(\"Error in payload\");  resp.statusCode = 500;  } else {  io:println(payload);  resp.setPayload(string `HTTP POST received: ${<@untainted>payload}`);  }   var err = caller->respond(resp);  if (err is error) {  log:printError(\"Error in responding\", err);  }  }   // This is an HTTP to WebSocket upgrade resource. This is defined using the WebSocket upgrade resource config.  // Here you have access to the `http:Request` and to the query and path params where applicable.  @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/ws\",  upgradeService: wsService  }  }  resource function upgrader(http:Caller caller, http:Request req) {   } }   // Note: When a WebSocket upgrade path is defined in HTTP resource configuration. <br> // - Without service configuration for WebSocketService default values are taken for sub protocols, idle timeout etc.<br> // - If `WebSocketServiceConfig` is defined without the path, sub protocols, idle timeout etc. can be configured.<br> // - If path is defined in the `WebSocketServiceConfig` it shall be ignored.<br> // - This service can also be bound to a different `Listener` in which case the path configuration becomes useful. service wsService = @http:WebSocketServiceConfig {subProtocols: [\"xml, json\"]  ,idleTimeoutInSeconds: 20} service {   resource function onOpen(http:WebSocketCaller caller) {  io:println(\"New WebSocket connection: \" + caller.getConnectionId());  }   resource function onText(http:WebSocketCaller caller, string text) {  io:println(text);  var err = caller->pushText(text);  if (err is error) {  log:printError(\"Error sending message\", err);  }  }   resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"Idle timeout: \" + caller.getConnectionId());  } };    HTTP To WebSocket Upgrade  This sample demonstrates how an HTTP endpoint is updated to a WebSocket endpoint using an upgrade resource.    import ballerina/http; import ballerina/io; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service httpService on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/world\",  methods: [\"POST\"]  }  resource function httpResource(http:Caller caller, http:Request req) {  http:Response resp = new;  var payload = req.getTextPayload();  if (payload is error) {  log:printError(\"Error sending message\", payload);  resp.setPayload(\"Error in payload\");  resp.statusCode = 500;  } else {  io:println(payload);  resp.setPayload(string `HTTP POST received: ${<@untainted>payload}`);  }    This is an HTTP resource.   var err = caller->respond(resp);  if (err is error) {  log:printError(\"Error in responding\", err);  }  }    @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/ws\",  upgradeService: wsService  }  }  resource function upgrader(http:Caller caller, http:Request req) {    This is an HTTP to WebSocket upgrade resource. This is defined using the WebSocket upgrade resource config.  Here you have access to the http:Request and to the query and path params where applicable.   } }    service wsService = @http:WebSocketServiceConfig {subProtocols: [\"xml, json\"]  ,idleTimeoutInSeconds: 20} service {    Note: When a WebSocket upgrade path is defined in HTTP resource configuration. - Without service configuration for WebSocketService default values are taken for sub protocols, idle timeout etc.  - If WebSocketServiceConfig is defined without the path, sub protocols, idle timeout etc. can be configured.  - If path is defined in the WebSocketServiceConfig it shall be ignored.  - This service can also be bound to a different Listener in which case the path configuration becomes useful.   resource function onOpen(http:WebSocketCaller caller) {  io:println(\"New WebSocket connection: \" + caller.getConnectionId());  }    resource function onText(http:WebSocketCaller caller, string text) {  io:println(text);  var err = caller->pushText(text);  if (err is error) {  log:printError(\"Error sending message\", err);  }  }    resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"Idle timeout: \" + caller.getConnectionId());  } };    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run http_to_websocket_upgrade.bal    # To check the sample, use the Chrome or Firefox JavaScript console and run the commands given below. <br> # Change \"xml\" to another sub protocol to observe the behavior of the WebSocket server. # This WebSocket sample is configured to have two endpoints. var ws = new WebSocket(\"ws://localhost:9090/hello/ws\", \"xml\", \"my-protocol\");    ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send messages. ws.send(\"hello world\");    #Use the cURL command below to call the HTTP resource. curl -H \"Content-Type: text/plain\" -X POST -d 'Hello World!!' 'http://localhost:9090/hello/world'    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/if-else.html","name":"If/Else","summary":"An if statement provides a way to perform conditional execution.This is a basic if statement.This is an if-else scenario.This is an if-else-if-else scenario.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you ...","content":"/  /  /  / If/Else  import ballerina/io;  public function main() {  int a = 10;  int b = 0;   // This is a basic `if` statement.  if (a == 10) {  io:println(\"a == 10\");  }   // This is an `if-else` scenario.  if (a < b) {  io:println(\"a < b\");  } else {  io:println(\"a >= b\");  }   // This is an `if-else-if-else` scenario.  if (b < 0) {  io:println(\"b < 0\");  } else if (b > 0) {  io:println(\"b > 0\");  } else {  io:println(\"b == 0\");  } }    If/Else  An if statement provides a way to perform conditional execution.    import ballerina/io;    public function main() {  int a = 10;  int b = 0;    if (a == 10) {  io:println(\"a == 10\");  }    This is a basic if statement.   if (a < b) {  io:println(\"a < b\");  } else {  io:println(\"a >= b\");  }    This is an if-else scenario.   if (b < 0) {  io:println(\"b < 0\");  } else if (b > 0) {  io:println(\"b > 0\");  } else {  io:println(\"b == 0\");  } }    This is an if-else-if-else scenario.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run if_else.bal a == 10 a >= b b == 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/https-listener.html","name":"HTTPS Listener","summary":"You can use the HTTPS Listener to connect or interact with an HTTPS client.\n Provide the Secure Socket configuration to the server to expose an HTTPS connection.An HTTP endpoint can be configured to communicate through HTTPS as well.\n To secure an endpoint using HTTPS, the endpoint needs to be configured ...","content":"/  /  /  / HTTPS Listener  import ballerina/config; import ballerina/http; import ballerina/log;  // An HTTP endpoint can be configured to communicate through HTTPS as well. // To secure an endpoint using HTTPS, the endpoint needs to be configured with // a keystore, a certificate, and a private key for the endpoint. http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };  // Create a listener endpoint. listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  // Send the response back to the caller.  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    HTTPS Listener  You can use the HTTPS Listener to connect or interact with an HTTPS client.  Provide the Secure Socket configuration to the server to expose an HTTPS connection.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } };    An HTTP endpoint can be configured to communicate through HTTPS as well.  To secure an endpoint using HTTPS, the endpoint needs to be configured with  a keystore, a certificate, and a private key for the endpoint.   listener http:Listener helloWorldEP = new (9095, config = helloWorldEPConfig);    Create a listener endpoint.   @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on helloWorldEP {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below along with the Ballerina home path as a config. ballerina run https_listener.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    # To invoke the service, execute the cURL command below with the `-k` option. curl -k https://localhost:9095/hello Hello World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/http-trace-logs.html","name":"Trace Logs","summary":"The HTTP trace logs can be used to monitor the HTTP traffic that goes in and out of Ballerina.Create a new http:Client.Forward incoming requests to the remote backend.Respond to the caller.Log the error in case of a failure.This website uses cookies so that we can provide you with the best ...","content":"/  /  /  / Trace Logs  import ballerina/http; import ballerina/log;  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  // Create a new `http:Client`.  http:Client clientEP = new (\"http://httpstat.us\");  // Forward incoming requests to the remote backend.  var resp = clientEP->forward(\"/200\", req);  if (resp is http:Response) {  // Respond to the caller.  var result = caller->respond(resp);  // Log the error in case of a failure.  if (result is error) {  log:printError(\"Failed to respond to caller\", result);  }  } else {  log:printError(\"Failed to fulfill request\", resp);  }  } }    Trace Logs  The HTTP trace logs can be used to monitor the HTTP traffic that goes in and out of Ballerina.    import ballerina/http; import ballerina/log;    @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on new http:Listener(9090) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    http:Client clientEP = new (\"http://httpstat.us\");    Create a new http:Client.   var resp = clientEP->forward(\"/200\", req);  if (resp is http:Response) {    Forward incoming requests to the remote backend.   var result = caller->respond(resp);    Respond to the caller.   if (result is error) {  log:printError(\"Failed to respond to caller\", result);  }  } else {  log:printError(\"Failed to fulfill request\", resp);  }  } }    Log the error in case of a failure.   # Trace logs are logged at `TRACE` level. # To enable trace logs, the log level has to be set to `TRACE` using the runtime argument: <br> `--b7a.http.tracelog.console=true`. <br> # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command with this runtime argument. ballerina run http_trace_logs.bal --b7a.http.tracelog.console=true ballerina: HTTP trace log enabled [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 # In the logs, `http.downstream` refers to the HTTP traffic that flows between the client and Ballerina, # while `http.upstream` refers to the HTTP traffic that flows between Ballerina and the backend. [2019-09-08 13:01:12,693] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9] REGISTERED [2019-09-08 13:01:12,696] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54362] ACTIVE [2019-09-08 13:01:12,745] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:/127.0.0.1:9090 - remote:/127.0.0.1:54362] INBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /hello HTTP/1.1 Host: localhost:9090 User-Agent: curl/7.58.0 Accept: */* [2019-09-08 13:01:12,779] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] INBOUND: EmptyLastHttpContent, 0B [2019-09-08 13:01:12,782] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] READ COMPLETE [2019-09-08 13:01:13,133] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] REGISTERED [2019-09-08 13:01:13,134] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] CONNECT: httpstat.us/23.99.0.12:80, null [2019-09-08 13:01:13,381] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] DEREGISTER [2019-09-08 13:01:13,383] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] ACTIVE [2019-09-08 13:01:13,383] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: n/a, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] UNREGISTERED [2019-09-08 13:01:13,384] TRACE {http.tracelog.upstream} - [id: 0xd79aee99] REGISTERED [2019-09-08 13:01:13,389] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] OUTBOUND: DefaultHttpRequest(decodeResult: success, version: HTTP/1.1) GET /200 HTTP/1.1 Accept: */* host: httpstat.us user-agent: ballerina/1.0.0 connection: keep-alive [2019-09-08 13:01:13,394] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] OUTBOUND: EmptyLastHttpContent, 0B [2019-09-08 13:01:13,395] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] FLUSH [2019-09-08 13:01:13,653] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] INBOUND: DefaultHttpResponse(decodeResult: success, version: HTTP/1.1) HTTP/1.1 200 OK Cache-Control: private Content-Length: 6 Content-Type: text/plain; charset=utf-8 Server: Microsoft-IIS/10.0 X-AspNetMvc-Version: 5.1 Access-Control-Allow-Origin: * X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET Set-Cookie: ARRAffinity=8bb96a9f72e760ea135952440e9c62bbfe3a64e8a577005f68697bfd250722b9;Path=/;HttpOnly;Domain=httpstat.us Date: Sun, 08 Sep 2019 07:31:13 GMT [2019-09-08 13:01:13,685] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] INBOUND: DefaultLastHttpContent(data: PooledSlicedByteBuf(ridx: 0, widx: 6, cap: 6/6, unwrapped: PooledUnsafeDirectByteBuf(ridx: 409, widx: 409, cap: 1024)), decoderResult: success), 6B 200 OK [2019-09-08 13:01:13,689] TRACE {http.tracelog.upstream} - [id: 0xd79aee99, correlatedSource: 0x04eed4c9, host:/10.100.5.32:39044 - remote:httpstat.us/23.99.0.12:80] READ COMPLETE [2019-09-08 13:01:13,697] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] OUTBOUND: DefaultFullHttpResponse(decodeResult: success, version: HTTP/1.1, content: CompositeByteBuf(ridx: 0, widx: 6, cap: 6, components=1)) HTTP/1.1 200 OK Cache-Control: private Content-Type: text/plain; charset=utf-8 X-AspNetMvc-Version: 5.1 Access-Control-Allow-Origin: * X-AspNet-Version: 4.0.30319 X-Powered-By: ASP.NET Set-Cookie: ARRAffinity=8bb96a9f72e760ea135952440e9c62bbfe3a64e8a577005f68697bfd250722b9;Path=/;HttpOnly;Domain=httpstat.us Date: Sun, 08 Sep 2019 07:31:13 GMT server: Microsoft-IIS/10.0 content-length: 6, 6B 200 OK [2019-09-08 13:01:13,698] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] FLUSH [2019-09-08 13:01:13,703] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] READ COMPLETE [2019-09-08 13:01:13,704] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] INACTIVE [2019-09-08 13:01:13,704] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] CLOSE [2019-09-08 13:01:13,708] TRACE {http.tracelog.downstream} - [id: 0x04eed4c9, correlatedSource: n/a, host:localhost/127.0.0.1:9090 - remote:localhost/127.0.0.1:54362] UNREGISTERED    # Invoke the service. curl http://localhost:9090/hello 200 OK    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/immutable-values.html","name":"Immutable Values","summary":"Ballerina allows creating immutable or read-only clones of values.The .cloneReadOnly() method can be called on a value of type anydata to create a clone of the value,\n which is immutable. No changes are done to the original value.\n Calling .cloneReadOnly() on structures would deeply clone the elements and mark them ...","content":"/  /  /  / Immutable Values  import ballerina/io;  public function main() {  // Create an `anydata`-typed `map` with two entries.  map<string|int> m1 = {stringVal: \"str\", intVal: 1};   // Call `.cloneReadOnly()` on the map `m1` and assign the returned value to another variable.  map<string|int> m2 = m1.cloneReadOnly();   // Reference equality checks for `m1` and `m2` should evaluate to false due to a clone being created  // since `m1` is not an immutable value.  io:println(\"m1 === m2: \", m1 === m2);   // Check if `m1` is immutable. This evaluates to false since no changes are done to  // the original value.  io:println(\"m1 is immutable: \", m1.isReadOnly());   // Check if `m2` is immutable. This evaluates to true since the returned clone is  // marked as immutable.  io:println(\"m2 is immutable: \", m2.isReadOnly());   // Attempt to add an entry to the `map` and trap the panic if it results in a panic.  error? updateResult = trap addEntryToMap(m2, \"intValTwo\", 10);  if (updateResult is error) {  // An error should occur since `m2` is frozen.  io:println(\"Error occurred on update: \",  <string>updateResult.detail()?.message);  }   // Now call `.cloneReadOnly()` on the immutable value `m2`.  map<string|int> m3 = m2.cloneReadOnly();   // Reference equality checks for `m2` and `m3` should evaluate to true due to no clones being created  // since `m2` is already an immutable value.  io:println(\"m2 === m3: \", m2 === m3);   // An `is` check for a frozen value becomes an `is like` check.  // In other words, storage type is not considered.  // Define a `map` of the constraint type `string` or `int`, but with  // values of the type `string` only.  map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};  // Make the map immutable. The resultant value would only  // contain values of the type `string` and no values can now be  // added to the map.  var frozenVal = m5.cloneReadOnly();  // Checking if the frozen value is of the type `map<string>` thus  // evaluates to `true`.  if (frozenVal is map<string>) {  io:println(\"frozenVal is map<string>\");  } }  // Function to add an entry to a `map`. function addEntryToMap(map<string|int> m, string key, string|int value) {  m[key] = value; }    Immutable Values  Ballerina allows creating immutable or read-only clones of values.  The .cloneReadOnly() method can be called on a value of type anydata to create a clone of the value,  which is immutable. No changes are done to the original value.  Calling .cloneReadOnly() on structures would deeply clone the elements and mark them as immutable.  Moreover, if the value is already an immutable value, .cloneReadOnly() returns the value itself (no cloning is  done).  The .isReadOnly() method could be used on anydata values to check if they are immutable.  Attempts to modify an immutable/read-only value would cause panicking.    import ballerina/io;    public function main() {    map<string|int> m1 = {stringVal: \"str\", intVal: 1};    Create an anydata-typed map with two entries.   map<string|int> m2 = m1.cloneReadOnly();    Call .cloneReadOnly() on the map m1 and assign the returned value to another variable.   io:println(\"m1 === m2: \", m1 === m2);    Reference equality checks for m1 and m2 should evaluate to false due to a clone being created  since m1 is not an immutable value.   io:println(\"m1 is immutable: \", m1.isReadOnly());    Check if m1 is immutable. This evaluates to false since no changes are done to  the original value.   io:println(\"m2 is immutable: \", m2.isReadOnly());    Check if m2 is immutable. This evaluates to true since the returned clone is  marked as immutable.   error? updateResult = trap addEntryToMap(m2, \"intValTwo\", 10);  if (updateResult is error) {    Attempt to add an entry to the map and trap the panic if it results in a panic.   io:println(\"Error occurred on update: \",  <string>updateResult.detail()?.message);  }    An error should occur since m2 is frozen.   map<string|int> m3 = m2.cloneReadOnly();    Now call .cloneReadOnly() on the immutable value m2.   io:println(\"m2 === m3: \", m2 === m3);    Reference equality checks for m2 and m3 should evaluate to true due to no clones being created  since m2 is already an immutable value.   map<string|int> m5 = {valueType: \"map\", constraint: \"string\"};    An is check for a frozen value becomes an is like check.  In other words, storage type is not considered.  Define a map of the constraint type string or int, but with  values of the type string only.   var frozenVal = m5.cloneReadOnly();    Make the map immutable. The resultant value would only  contain values of the type string and no values can now be  added to the map.   if (frozenVal is map<string>) {  io:println(\"frozenVal is map<string>\");  } }    Checking if the frozen value is of the type map<string> thus  evaluates to true.   function addEntryToMap(map<string|int> m, string key, string|int value) {  m[key] = value; }    Function to add an entry to a map.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run immutable_values.bal m1 === m2: false m1 is immutable: false m2 is immutable: true Error occurred on update: Invalid map insertion: modification not allowed on readonly value m2 === m3: true frozenVal is map<string>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/java-arrays.html","name":"Java Arrays","summary":"Java arrays are represented by the handle type in Ballerina. They can be manipulated using the\n getArrayElement, setArrayElement and getArrayLength methods provided by the ballerina/java module.Convert Ballerina strings to Java strings before passing to Java methods.Invoke an external method, implemented in Java.Access an array element, pass the handle that refers ...","content":"/  /  /  / Java Arrays  import ballerina/io; import ballerina/java; import ballerina/java.arrays as jarrays;  public function splitString(handle receiver, handle regex) returns handle = @java:Method {  name: \"split\",  class: \"java/lang/String\" } external;  public function main() {  // Convert Ballerina strings to Java strings before passing to Java methods.  handle helloString = java:fromString(\"Hello world\");  handle regex = java:fromString(\" \");   // Invoke an external method, implemented in Java.  handle words = splitString(helloString, regex);   int numWords = jarrays:getLength(words);  io:println(numWords);   // Access an array element, pass the handle that refers to the Java array instance as the first argument.  handle secondWord = jarrays:get(words, 1);  io:println(secondWord); }    Java Arrays  Java arrays are represented by the handle type in Ballerina. They can be manipulated using the  getArrayElement, setArrayElement and getArrayLength methods provided by the ballerina/java module.    import ballerina/io; import ballerina/java; import ballerina/java.arrays as jarrays;    public function splitString(handle receiver, handle regex) returns handle = @java:Method {  name: \"split\",  class: \"java/lang/String\" } external;    public function main() {    handle helloString = java:fromString(\"Hello world\");  handle regex = java:fromString(\" \");    Convert Ballerina strings to Java strings before passing to Java methods.   handle words = splitString(helloString, regex);    Invoke an external method, implemented in Java.   int numWords = jarrays:getLength(words);  io:println(numWords);    handle secondWord = jarrays:get(words, 1);  io:println(secondWord); }    Access an array element, pass the handle that refers to the Java array instance as the first argument.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run java_arrays.bal 2 world    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/iterable-objects.html","name":"Iterable Objects","summary":"An object can be made iterable as a sequence of values of type T by providing a method named __iterator which\n returns a value that is a subtype of Iterator<T>. We refer to this type as Iterable<T>. Any subtype\n of abstract object {public next() returns record {| T value; |}?;}, ...","content":"/  /  /  / Iterable Objects  import ballerina/io;  // An object that is a subtype of `Iterator<int>`. type ArrayIterator object {  private int[] integers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34];  private int cursor = -1;   // `next` method which generates the sequence of values of type `int`.  public function next() returns record {|int value;|}? {  self.cursor += 1;  if (self.cursor < self.integers.length()) {  record {|int value;|} nextVal = {value: self.integers[self.cursor]};  return nextVal;  }  return ();  } };  // An object that is a subtype of `Iterable<int>`. type IteratorGenerator object {   // The `__iterator()` method should return a new `Iterator<T>`.  public function __iterator() returns abstract object {  public function next() returns record {|int value;|}?;} {  return new ArrayIterator();  } };  public function main() {  IteratorGenerator itrGen = new;  int i = 0;  foreach var item in itrGen {  i += 1;  io:println(\"Element \", i, \": \", item);  } }    Iterable Objects  An object can be made iterable as a sequence of values of type T by providing a method named __iterator which  returns a value that is a subtype of Iterator<T>. We refer to this type as Iterable<T>. Any subtype  of abstract object {public next() returns record {| T value; |}?;}, is called Iterator. An iterable object can be  iterated over using a foreach loop. In this example, IteratorGenerator is a subtype of Iterable<int> and  ArrayIterator is a subtype of Iterator<int>.    import ballerina/io;    type ArrayIterator object {  private int[] integers = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34];  private int cursor = -1;    An object that is a subtype of Iterator<int>.   public function next() returns record {|int value;|}? {  self.cursor += 1;  if (self.cursor < self.integers.length()) {  record {|int value;|} nextVal = {value: self.integers[self.cursor]};  return nextVal;  }  return ();  } };    next method which generates the sequence of values of type int.   type IteratorGenerator object {    An object that is a subtype of Iterable<int>.   public function __iterator() returns abstract object {  public function next() returns record {|int value;|}?;} {  return new ArrayIterator();  } };    The __iterator() method should return a new Iterator<T>.   public function main() {  IteratorGenerator itrGen = new;  int i = 0;  foreach var item in itrGen {  i += 1;  io:println(\"Element \", i, \": \", item);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run iterable_objects.bal Element 1: 0 Element 2: 1 Element 3: 1 Element 4: 2 Element 5: 3 Element 6: 5 Element 7: 8 Element 8: 13 Element 9: 21 Element 10: 34    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/invoke-java-methods.html","name":"Invoke Java Methods","summary":"The Method annotation in ballerina/java module allows you to link a Java method (static or instance) with a\n Ballerina function with an external function body.Let’s create a Ballerina function to call the static method randomUUID in java.util.UUID class.\n Here the name field is optional if the Ballerina function name is ...","content":"/  /  /  / Invoke Java Methods  import ballerina/io; import ballerina/java;  // Let's create a Ballerina function to call the static method `randomUUID` in `java.util.UUID` class. // Here the `name` field is optional if the Ballerina function name is equal to the Java counterpart. // This method returns a handle value referring to a `java.util.UUID` instance. function createRandomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external;  // The class `java.util.ArrayDeque` is a resizable array that allows you to add or remove an element from both sides. // Here `newArrayDeque` function is linked with the default constructor of the `java.util.ArrayDeque` class. function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  // The `offer` Ballerina function is linked with the instance method `offer` in `java.util.ArrayDeque` class. // This function inserts the element `e` at the end of the queue referred by the parameter `receiver`. function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;  // The `poll` Ballerina function is linked with the instance method `poll` in `java.util.ArrayDeque` class. // This function removes the head element of the queue referred by the parameter `receiver`. function poll(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;  public function main() {  // Create a random UUID instance by invoking the `createRandomUUID` Ballerina function.  // This function demonstrates how you can invoke Java static function in Ballerina.  var uuid = createRandomUUID();   // Create a new `java.util.ArrayDeque` instance.  var arrayDeque = newArrayDeque();   // Ballerina strings are different from Java strings. The `fromString` function in `ballerina/java` module converts  // a Ballerina string value to a Java String representation. Java String is a reference type; hence,  // this method returns a handle value referring to the created to Java string.  _ = offer(arrayDeque, java:fromString(\"John\"));  _ = offer(arrayDeque, java:fromString(\"Jane\"));  _ = offer(arrayDeque, java:fromString(\"Peter\"));   var nextInLineHandle = poll(arrayDeque);  // The `toString` function in `ballerina/java` module creates a Ballerina string  // representation of the Java reference value.  string? nextInLine = java:toString(nextInLineHandle);  io:println(nextInLine); }    Invoke Java Methods  The Method annotation in ballerina/java module allows you to link a Java method (static or instance) with a  Ballerina function with an external function body.    import ballerina/io; import ballerina/java;    function createRandomUUID() returns handle = @java:Method {  name: \"randomUUID\",  class: \"java.util.UUID\" } external;    Let’s create a Ballerina function to call the static method randomUUID in java.util.UUID class.  Here the name field is optional if the Ballerina function name is equal to the Java counterpart.  This method returns a handle value referring to a java.util.UUID instance.   function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The class java.util.ArrayDeque is a resizable array that allows you to add or remove an element from both sides.  Here newArrayDeque function is linked with the default constructor of the java.util.ArrayDeque class.   function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The offer Ballerina function is linked with the instance method offer in java.util.ArrayDeque class.  This function inserts the element e at the end of the queue referred by the parameter receiver.   function poll(handle receiver) returns handle = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The poll Ballerina function is linked with the instance method poll in java.util.ArrayDeque class.  This function removes the head element of the queue referred by the parameter receiver.   public function main() {    var uuid = createRandomUUID();    Create a random UUID instance by invoking the createRandomUUID Ballerina function.  This function demonstrates how you can invoke Java static function in Ballerina.   var arrayDeque = newArrayDeque();    Create a new java.util.ArrayDeque instance.   _ = offer(arrayDeque, java:fromString(\"John\"));  _ = offer(arrayDeque, java:fromString(\"Jane\"));  _ = offer(arrayDeque, java:fromString(\"Peter\"));    Ballerina strings are different from Java strings. The fromString function in ballerina/java module converts  a Ballerina string value to a Java String representation. Java String is a reference type; hence,  this method returns a handle value referring to the created to Java string.   var nextInLineHandle = poll(arrayDeque);    string? nextInLine = java:toString(nextInLineHandle);  io:println(nextInLine); }    The toString function in ballerina/java module creates a Ballerina string  representation of the Java reference value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run invoke-java-methods.bal John    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/java-exceptions.html","name":"Java Exceptions","summary":"In idiomatic Ballerina code, errors should be communicated via explicit return values in functions.\n Java error handling is different from Ballerina. Java constructors and methods throw both\n checked and unchecked exceptions. In Java interoperability design, if a Java method throws an\n unchecked exception then the corresponding Ballerina function invocation panics.\n ...","content":"/  /  /  / Java Exceptions  import ballerina/io; import ballerina/java;  // Let's create a Ballerina function to load Java classes by linking with the `forName` method of // the `java.lang.Class`. It throws a checked exception `java.lang.ClassNotFoundException`. // Therefore the `loadClass` ballerina function should have the `error` type as part of its return signature. function loadClass(handle className) returns handle|error = @java:Method {  name: \"forName\",  class: \"java.lang.Class\" } external;  // The class `java.util.ArrayDeque` is a resizable array that allows you to add or remove an element from both sides. // Here `newArrayDeque` function is linked with the default constructor of the `java.util.ArrayDeque` class. function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;  // The `offer` method in the ArrayDeque class throws a `java.lang.NullPointerException` if the element is null. function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;  public function main() {  // The `loadClass` function returns union of `handle` or `error`.  var classOrError = loadClass(java:fromString(\"a.b.c.z.SomeClass\"));  if classOrError is error {  io:println(classOrError);  }   // Here we are sending a null element to `offer` function. The `createNull` function in `ballerina/java`  // module creates a handle value that refers to Java null.  var arrayDeque = newArrayDeque();  boolean|error e = trap offer(arrayDeque, java:createNull());  if e is error {  io:println(e);  } }    Java Exceptions  In idiomatic Ballerina code, errors should be communicated via explicit return values in functions.  Java error handling is different from Ballerina. Java constructors and methods throw both  checked and unchecked exceptions. In Java interoperability design, if a Java method throws an  unchecked exception then the corresponding Ballerina function invocation panics.  A panic indicates abnormal completions and usually implies that something unexpected has occurred.  If a Java method throws a checked exception, then the corresponding Ballerina function  should have the error type in its return signature.  Let’s look at how to handle Java exceptions in Ballerina.    import ballerina/io; import ballerina/java;    function loadClass(handle className) returns handle|error = @java:Method {  name: \"forName\",  class: \"java.lang.Class\" } external;    Let’s create a Ballerina function to load Java classes by linking with the forName method of  the java.lang.Class. It throws a checked exception java.lang.ClassNotFoundException.  Therefore the loadClass ballerina function should have the error type as part of its return signature.   function newArrayDeque() returns handle = @java:Constructor {  class: \"java.util.ArrayDeque\" } external;    The class java.util.ArrayDeque is a resizable array that allows you to add or remove an element from both sides.  Here newArrayDeque function is linked with the default constructor of the java.util.ArrayDeque class.   function offer(handle receiver, handle e) returns boolean = @java:Method {  class: \"java.util.ArrayDeque\" } external;    The offer method in the ArrayDeque class throws a java.lang.NullPointerException if the element is null.   public function main() {    var classOrError = loadClass(java:fromString(\"a.b.c.z.SomeClass\"));  if classOrError is error {  io:println(classOrError);  }    The loadClass function returns union of handle or error.   var arrayDeque = newArrayDeque();  boolean|error e = trap offer(arrayDeque, java:createNull());  if e is error {  io:println(e);  } }    Here we are sending a null element to offer function. The createNull function in ballerina/java  module creates a handle value that refers to Java null.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run java-exceptions.bal error java.lang.ClassNotFoundException message=a.b.c.z.SomeClass error java.lang.NullPointerException    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/java-varargs.html","name":"Java Varargs","summary":"Let’s look at how to invoke Java varargs functions (both static and instance) in Ballerina.\n If there are overloaded Java methods and you want to remove the ambiguity, the paramTypes field can be used\n to specify the element class type and dimension.Define a Ballerina function with an external function body ...","content":"/  /  /  / Java Varargs  import ballerina/io; import ballerina/java;  // Define a Ballerina function with an external function body whose implementation is provided by a Java method. // When a vararg is used in the Ballerina function signature, corresponding values are wrapped in // a Java array before the invocation. public function asList(int... values) returns handle = @java:Method {  name: \"asList\",  class: \"java.util.Arrays\" } external;  public function main() {  var answer = 42;  // If a method is non-static, the receiver instance has to be provided as the first parameter.  var javaList = asList(1, 2, answer);  io:println(javaList); }    Java Varargs  Let’s look at how to invoke Java varargs functions (both static and instance) in Ballerina.  If there are overloaded Java methods and you want to remove the ambiguity, the paramTypes field can be used  to specify the element class type and dimension.    import ballerina/io; import ballerina/java;    public function asList(int... values) returns handle = @java:Method {  name: \"asList\",  class: \"java.util.Arrays\" } external;    Define a Ballerina function with an external function body whose implementation is provided by a Java method.  When a vararg is used in the Ballerina function signature, corresponding values are wrapped in  a Java array before the invocation.   public function main() {  var answer = 42;    var javaList = asList(1, 2, answer);  io:println(javaList); }    If a method is non-static, the receiver instance has to be provided as the first parameter.   # To run this sample, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run java_varargs.bal [1, 2, 42]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc-client-batch-update.html","name":"JDBC Client Batch Update","summary":"This example demonstrates how to execute batch update using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB\n connection properties as required.Client for the MySQL database. This client can be used with any JDBC\n supported ...","content":"/  /  /  / JDBC Client Batch Update  import ballerina/io; import ballerinax/java.jdbc;  // Client for the MySQL database. This client can be used with any JDBC // supported database by providing the corresponding JDBC URL. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });  // This is the `type` created to represent a data row. type Student record {  int id;  int age;  string name; };  type myBatchType int|string;  public function main() {  // Create a table using the `update` remote function.  io:println(\"The update operation - Creating a table:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");   // This `json` input is used as the input data.  json jsonMsg = [{  \"firstname\": \"Peter\",  \"age\": 10  }, {  \"firstname\": \"John\",  \"age\": 15  }, {  \"firstname\": \"James\",  \"age\": 12  }];   //Prepare the data batch by iterating the `json` array.  myBatchType[][] dataBatch = [];  if (jsonMsg is json[]) {  foreach (var studentData in jsonMsg) {  string name = <string>studentData.firstname;  int age = <int>studentData.age;  myBatchType[] dataRow = [age, name];  dataBatch.push(dataRow);  }  }  // A batch of data can be inserted using the `batchUpdate` remote function.  jdbc:BatchUpdateResult retBatch = testDB->batchUpdate(\"INSERT INTO student \" +  \"(age,name) VALUES (?,?)\", false, ...dataBatch);  error? e = retBatch.returnedError;  if (e is error) {  io:println(\"Batch update operation failed:\", <string>e.detail()?.message);  } else {  // The number of inserted rows for each insert in the batch is returned as  // an array.  io:println(\"Batch 1 update counts: \", retBatch.updatedRowCount[0]);  io:println(\"Batch 2 update counts: \", retBatch.updatedRowCount[1]);  anydata[]? generatedKeys = retBatch.generatedKeys[\"GENERATED_KEY\"];  if (generatedKeys is int[]) {  int key1 = generatedKeys[0];  int key2 = generatedKeys[1];  int key3 = generatedKeys[2];  io:println(\"Generated keys are: \", key1, \", \", key2, \" and \", key3);  }  }  // Check the data in the database.  checkData();  // Delete the tables from the database.  io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }  // Function to handle the return value of the `update` remote function. function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }  // Select data from the table and print. function checkData() {  var dtReturned = testDB->select(\"SELECT * FROM student\", Student);  if (dtReturned is table<record{}>) {  // Iterating data.  io:println(\"Data in students table:\");  foreach var row in dtReturned {  io:println(row.toString());  }  } else {  io:println(\"Select data from student table failed: \",  <string>dtReturned.detail()?.message);  } }    JDBC Client Batch Update  This example demonstrates how to execute batch update using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB  connection properties as required.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    Client for the MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name; };    This is the type created to represent a data row.   type myBatchType int|string;    public function main() {    io:println(\"The update operation - Creating a table:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function.   json jsonMsg = [{  \"firstname\": \"Peter\",  \"age\": 10  }, {  \"firstname\": \"John\",  \"age\": 15  }, {  \"firstname\": \"James\",  \"age\": 12  }];    This json input is used as the input data.   myBatchType[][] dataBatch = [];  if (jsonMsg is json[]) {  foreach (var studentData in jsonMsg) {  string name = <string>studentData.firstname;  int age = <int>studentData.age;  myBatchType[] dataRow = [age, name];  dataBatch.push(dataRow);  }  }    Prepare the data batch by iterating the json array.   jdbc:BatchUpdateResult retBatch = testDB->batchUpdate(\"INSERT INTO student \" +  \"(age,name) VALUES (?,?)\", false, ...dataBatch);  error? e = retBatch.returnedError;  if (e is error) {  io:println(\"Batch update operation failed:\", <string>e.detail()?.message);  } else {    A batch of data can be inserted using the batchUpdate remote function.   io:println(\"Batch 1 update counts: \", retBatch.updatedRowCount[0]);  io:println(\"Batch 2 update counts: \", retBatch.updatedRowCount[1]);  anydata[]? generatedKeys = retBatch.generatedKeys[\"GENERATED_KEY\"];  if (generatedKeys is int[]) {  int key1 = generatedKeys[0];  int key2 = generatedKeys[1];  int key3 = generatedKeys[2];  io:println(\"Generated keys are: \", key1, \", \", key2, \" and \", key3);  }  }    The number of inserted rows for each insert in the batch is returned as  an array.   checkData();    Check the data in the database.   io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }    Delete the tables from the database.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   function checkData() {  var dtReturned = testDB->select(\"SELECT * FROM student\", Student);  if (dtReturned is table<record{}>) {    Select data from the table and print.   io:println(\"Data in students table:\");  foreach var row in dtReturned {  io:println(row.toString());  }  } else {  io:println(\"Select data from student table failed: \",  <string>dtReturned.detail()?.message);  } }    Iterating data.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command below. ballerina run jdbc_client_batch_update.bal The update operation - Creating a table: Create student table status: 0 Batch 1 update counts: 1 Batch 2 update counts: 1 Generated keys are: 1, 2 and 3 Data in students table: id=1 age=10 name=Peter id=2 age=15 name=John id=3 age=12 name=James    The update operation - Drop the student table Drop table student status: 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc-client-call-procedures.html","name":"JDBC Client Call Procedures","summary":"This example demonstrates how to execute stored procedures using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB\n connection properties as required.Client for MySQL database. This client can be used with any JDBC\n supported database ...","content":"/  /  /  / JDBC Client Call Procedures  import ballerina/io; import ballerinax/java.jdbc;  // Client for MySQL database. This client can be used with any JDBC // supported database by providing the corresponding JDBC URL. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });  // This is the `type` created to represent a data row. type Student record {  int id;  int age;  string name; };  public function main() {  // Create a table using the `update` remote function.  io:println(\"The update operation - Creating table and procedures:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");   // Create the stored procedure with IN parameters.  ret = testDB->update(\"CREATE PROCEDURE INSERTDATA(IN pAge INT, \" +  \"IN pName VARCHAR(255)) \" +  \"BEGIN \" +  \"INSERT INTO student(age, name) VALUES (pAge, pName); \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");   // Create the stored procedure with INOUT and OUT parameters.  ret = testDB->update(\"CREATE PROCEDURE GETCOUNT (INOUT pID INT, \" +  \"OUT pCount INT) \" +  \"BEGIN \" +  \"SELECT id INTO pID FROM student WHERE age = pID; \" +  \"SELECT COUNT(*) INTO pCount FROM student \" +  \"WHERE age = 20; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with INOUT/OUT param creation\");   ret = testDB->update(\"CREATE PROCEDURE GETSTUDENTS() \" +  \"BEGIN SELECT * FROM student; END\");  handleUpdate(ret, \"Stored procedure with result set return\");   // The remote function `call` is used to invoke a stored procedure.  // Here the stored procedure with IN parameters is invoked.  io:println(\"\\nThe call operation - With IN params\");  // Invoke the stored procedure with IN type parameters.  var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), 20, \"George\");  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with IN params successful\");  }   // Here stored procedure with OUT and INOUT parameters is invoked.  io:println(\"\\nThe call operation - With INOUT/OUT params\");  // Define the parameters for INOUT arguments.  jdbc:Parameter pId = {  sqlType: jdbc:TYPE_INTEGER,  value: 20,  direction: jdbc:DIRECTION_INOUT  };  jdbc:Parameter pCount = {  sqlType: jdbc:TYPE_INTEGER,  direction: jdbc:DIRECTION_OUT  };  // Invoke the stored procedure.  retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), pId, pCount);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with INOUT and OUT params successful\");  io:println(\"Student ID of the student with age of 20: \", pId.value);  io:println(\"Student count with age of 20: \", pCount.value);  }   // Invoke the stored procedure which returns data.  retCall = testDB->call(\"{CALL GETSTUDENTS()}\", [Student]);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);   } else if retCall is table<record {}>[] {  io:println(\"Data in students table:\");  foreach var row in retCall[0] {  io:println(row);  }  } else {  io:println(\"Call operation is not returning data\");  }   // Drop the table and procedures.  io:println(\"\\nThe update operation - Drop the tables and procedures\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\");   ret = testDB->update(\"DROP PROCEDURE INSERTDATA\");  handleUpdate(ret, \"Drop stored procedure INSERTDATA\");   ret = testDB->update(\"DROP PROCEDURE GETCOUNT\");  handleUpdate(ret, \"Drop stored procedure GETCOUNT\");   ret = testDB->update(\"DROP PROCEDURE GETSTUDENTS\");  handleUpdate(ret, \"Drop stored procedure GETSTUDENTS\"); }  // Function to handle the return value of the `update` remote function. function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    JDBC Client Call Procedures  This example demonstrates how to execute stored procedures using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB  connection properties as required.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name; };    This is the type created to represent a data row.   public function main() {    io:println(\"The update operation - Creating table and procedures:\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function.   ret = testDB->update(\"CREATE PROCEDURE INSERTDATA(IN pAge INT, \" +  \"IN pName VARCHAR(255)) \" +  \"BEGIN \" +  \"INSERT INTO student(age, name) VALUES (pAge, pName); \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");    Create the stored procedure with IN parameters.   ret = testDB->update(\"CREATE PROCEDURE GETCOUNT (INOUT pID INT, \" +  \"OUT pCount INT) \" +  \"BEGIN \" +  \"SELECT id INTO pID FROM student WHERE age = pID; \" +  \"SELECT COUNT(*) INTO pCount FROM student \" +  \"WHERE age = 20; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with INOUT/OUT param creation\");    Create the stored procedure with INOUT and OUT parameters.   ret = testDB->update(\"CREATE PROCEDURE GETSTUDENTS() \" +  \"BEGIN SELECT * FROM student; END\");  handleUpdate(ret, \"Stored procedure with result set return\");    io:println(\"\\nThe call operation - With IN params\");    The remote function call is used to invoke a stored procedure.  Here the stored procedure with IN parameters is invoked.   var retCall = testDB->call(\"{CALL INSERTDATA(?,?)}\", (), 20, \"George\");  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with IN params successful\");  }    Invoke the stored procedure with IN type parameters.   io:println(\"\\nThe call operation - With INOUT/OUT params\");    Here stored procedure with OUT and INOUT parameters is invoked.   jdbc:Parameter pId = {  sqlType: jdbc:TYPE_INTEGER,  value: 20,  direction: jdbc:DIRECTION_INOUT  };  jdbc:Parameter pCount = {  sqlType: jdbc:TYPE_INTEGER,  direction: jdbc:DIRECTION_OUT  };    Define the parameters for INOUT arguments.   retCall = testDB->call(\"{CALL GETCOUNT(?,?)}\", (), pId, pCount);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation with INOUT and OUT params successful\");  io:println(\"Student ID of the student with age of 20: \", pId.value);  io:println(\"Student count with age of 20: \", pCount.value);  }    Invoke the stored procedure.   retCall = testDB->call(\"{CALL GETSTUDENTS()}\", [Student]);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);    Invoke the stored procedure which returns data.   } else if retCall is table<record {}>[] {  io:println(\"Data in students table:\");  foreach var row in retCall[0] {  io:println(row);  }  } else {  io:println(\"Call operation is not returning data\");  }    io:println(\"\\nThe update operation - Drop the tables and procedures\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\");    Drop the table and procedures.   ret = testDB->update(\"DROP PROCEDURE INSERTDATA\");  handleUpdate(ret, \"Drop stored procedure INSERTDATA\");    ret = testDB->update(\"DROP PROCEDURE GETCOUNT\");  handleUpdate(ret, \"Drop stored procedure GETCOUNT\");    ret = testDB->update(\"DROP PROCEDURE GETSTUDENTS\");  handleUpdate(ret, \"Drop stored procedure GETSTUDENTS\"); }    function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command below. ballerina run jdbc_client_call_procedures.bal The update operation - Creating table and procedures: Create student table status: 0 Stored procedure with IN param creation status: 0 Stored procedure with INOUT/OUT param creation status: 0 Stored procedure with result set return status: 0    The call operation - With IN params Call operation with IN params successful    The call operation - With INOUT/OUT params Call operation with INOUT and OUT params successful Student ID of the student with age of 20: 1 Student count with age of 20: 1 Data in students table: id=1 age=20 name=George    The update operation - Drop the tables and procedures Drop table student status: 0 Drop stored procedure INSERTDATA status: 0 Drop stored procedure GETCOUNT status: 0 Drop stored procedure GETSTUDENTS status: 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc-streaming-big-dataset.html","name":"Streaming a Big Dataset","summary":"Ballerina inherently supports streaming large datasets. For example,\n retrieving a large amount of data, converting it to a preferred data format\n (e.g., JSON, XML) and sending it across the network on HTTP, does not require loading\n the entire dataset to memory at once. Data is fetched on demand from the ...","content":"/  /  /  / Streaming a Big Dataset  import ballerina/http; import ballerina/jsonutils; import ballerina/log; import ballerinax/java.jdbc;  // JDBC Client for MySQL database. This client can be used with any JDBC // supported database by providing the corresponding JDBC URL. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });  // Create an HTTP service and bind it to a listener on port 9090. service dataService on new http:Listener(9090) {   resource function getData(http:Caller caller, http:Request req) {  http:Response res = new;   // Invoke `select` remote function on the MySQL database client  // and obtain a large amount of data.  var selectRet = testDB->select(\"SELECT * FROM Data\", ());  if (selectRet is table<record {}>) {  // Convert the obtained data to `json`. Note that this conversion  // does not load all the data into memory.  // The `table` can be converted to `xml` in a similar manner.  json jsonConversionRet = jsonutils:fromTable(selectRet);  // Set the `json` payload to the response. This is streamed  // to the client once the service is invoked.  res.setPayload(<@untainted>jsonConversionRet);  } else {  // Set a payload indicating an error in case the data retrieval  // fails.  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload({\"Error\": \"Error occured while retrieving data \" +  \"from the database\"  });  }   // Respond to the client.  var respondRet = caller->respond(res);  if (respondRet is error) {  log:printError(\"Sending response failed\", respondRet);  }  } } import ballerina/io; import ballerinax/java.jdbc;  public function main() {  jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false}  });   // Create a table for data insertion.  var ret = testDB->update(\"CREATE TABLE Data (id INT, field1 \" +  \"VARCHAR(1024), field2 VARCHAR(1024));\");  handleUpdate(ret, \"Create Data table\");   // Create the stored procedure with row_count IN parameter.  ret = testDB->update(\"CREATE PROCEDURE PopulateData(IN row_count INT) \" +  \"BEGIN \" +  \"DECLARE count INT; \" +  \"DECLARE strDataEntry VARCHAR(1024); \" +  \"SET count = 1; \" +  \"SET strDataEntry = ''; \" +  \"WHILE count <= 1024 DO \" +  \"SET strDataEntry = CONCAT(strDataEntry, 'x'); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SET count = 1; \" +  \"WHILE count <= row_count DO \" +  \"INSERT INTO Data VALUES (count, strDataEntry, strDataEntry); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SELECT strDataEntry; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");   // Call stored procedure. This inserts around 200MB of textual data.  // You can increment the row_count to increase the amount of data.  var retCall = testDB->call(\"CALL PopulateData(?)\", (), 100000);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation is successful\");  } }  // Function to handle the return value of the update remote function. function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Streaming a Big Dataset  Ballerina inherently supports streaming large datasets. For example,  retrieving a large amount of data, converting it to a preferred data format  (e.g., JSON, XML) and sending it across the network on HTTP, does not require loading  the entire dataset to memory at once. Data is fetched on demand from the database  and incrementally converted to JSON/XML and sent to the client.  This example demonstrates streaming a large amount of data through an HTTP service.  Please run data_setup.bal file to setup a database with sufficient amount of data.  It creates a sample database with a table that contains an id field,  and two text fields each having 1KB of data. Here, the row_count parameter of the  PopulateData stored procedure is set to 100000, which would add up to around 200MB  of textual data. You can increase the value of row_count parameter to increase the  amount of data.    import ballerina/http; import ballerina/jsonutils; import ballerina/log; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    JDBC Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   service dataService on new http:Listener(9090) {    Create an HTTP service and bind it to a listener on port 9090.   resource function getData(http:Caller caller, http:Request req) {  http:Response res = new;    var selectRet = testDB->select(\"SELECT * FROM Data\", ());  if (selectRet is table<record {}>) {    Invoke select remote function on the MySQL database client  and obtain a large amount of data.   json jsonConversionRet = jsonutils:fromTable(selectRet);    Convert the obtained data to json. Note that this conversion  does not load all the data into memory.  The table can be converted to xml in a similar manner.   res.setPayload(<@untainted>jsonConversionRet);  } else {    Set the json payload to the response. This is streamed  to the client once the service is invoked.   res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload({\"Error\": \"Error occured while retrieving data \" +  \"from the database\"  });  }    Set a payload indicating an error in case the data retrieval  fails.   var respondRet = caller->respond(res);  if (respondRet is error) {  log:printError(\"Sending response failed\", respondRet);  }  } }    Respond to the client.   # At the command line, navigate to the directory that contains the # `.bal` files and run the `ballerina run` command below. ballerina run data_setup.bal ballerina run big_data_service.bal    curl http://localhost:9090/dataService/getData > /tmp/response-data.txt  % Total % Received % Xferd Average Speed Time Time Time Current  Dload Upload Total Spent Left Speed 100 199M 0 199M 0 0 90.0M 0 --:--:-- 0:00:02 --:--:-- 90.0M    import ballerina/io; import ballerinax/java.jdbc;    public function main() {  jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false}  });    var ret = testDB->update(\"CREATE TABLE Data (id INT, field1 \" +  \"VARCHAR(1024), field2 VARCHAR(1024));\");  handleUpdate(ret, \"Create Data table\");    Create a table for data insertion.   ret = testDB->update(\"CREATE PROCEDURE PopulateData(IN row_count INT) \" +  \"BEGIN \" +  \"DECLARE count INT; \" +  \"DECLARE strDataEntry VARCHAR(1024); \" +  \"SET count = 1; \" +  \"SET strDataEntry = ''; \" +  \"WHILE count <= 1024 DO \" +  \"SET strDataEntry = CONCAT(strDataEntry, 'x'); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SET count = 1; \" +  \"WHILE count <= row_count DO \" +  \"INSERT INTO Data VALUES (count, strDataEntry, strDataEntry); \" +  \"SET count = count + 1; \" +  \"END WHILE; \" +  \"SELECT strDataEntry; \" +  \"END\");  handleUpdate(ret, \"Stored procedure with IN param creation\");    Create the stored procedure with row_count IN parameter.   var retCall = testDB->call(\"CALL PopulateData(?)\", (), 100000);  if (retCall is error) {  io:println(\"Stored procedure call failed: \",  <string>retCall.detail()?.message);  } else {  io:println(\"Call operation is successful\");  } }    Call stored procedure. This inserts around 200MB of textual data.  You can increment the row_count to increase the amount of data.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc-client-crud-operations.html","name":"JDBC Client CRUD Operations","summary":"This example demonstrates how to execute data definition statements, insert/update/delete data\n and select data using JDBC Client.\n This sample uses MySQL DB. Before running the sample, copy the\n MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB connection\n properties as required.JDBC Client for MySQL database. This client can ...","content":"/  /  /  / JDBC Client CRUD Operations  import ballerina/io; import ballerina/jsonutils; import ballerina/time; import ballerinax/java.jdbc;  // JDBC Client for MySQL database. This client can be used with any JDBC // supported database by providing the corresponding JDBC URL. jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });  // This is the `type` created to represent a data row. type Student record {  int id;  int age;  string name;  time:Time insertedTime; };  public function main() {  // Create a table using the `update` remote function. If the DDL  // statement execution is successful, the `update` remote function  // returns 0.  io:println(\"The update operation - Creating a table\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), insertedTime TIMESTAMP DEFAULT \" +  \"CURRENT_TIMESTAMP, PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");   // Insert data to the table using the `update` remote function. If the DML  // statement execution is successful, the `update` remote function returns  // the updated row count. The query parameters are given in the query  // statement itself.  io:println(\"\\nThe update operation - Inserting data to a table\");  ret = testDB->update(\"INSERT INTO student(age, name) values \" +  \"(23, 'john')\");  handleUpdate(ret, \"Insert to student table with no parameters\");   // The query parameters are given as variables for the `update` remote  // function. Only `int`, `float`, `decimal`, `boolean`, `string` and  // `byte[]` values are supported as direct variables any remote function  // of the `java.jdbc` module.  int age = 24;  string name = \"Anne\";  ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  age, name);  handleUpdate(ret, \"Insert to student table with variable parameters\");   // The query parameters can be given as arguments of the type  // `jdbc:Parameter` for the any remote function. This is useful if  // we want to set the SQL type explicitly or for the parameter types  // other than `int`, `float`, `decimal`, `boolean`, `string` or  // `byte[]` (e.g. time). Default direction is IN.  jdbc:Parameter p1 = {sqlType: jdbc:TYPE_INTEGER, value: 25};  jdbc:Parameter p2 = {sqlType: jdbc:TYPE_VARCHAR, value: \"James\"};  jdbc:Parameter p3 = {  sqlType: jdbc:TYPE_TIMESTAMP,  value: time:currentTime()  };  ret = testDB->update(\"INSERT INTO student(age, name, insertedTime) \" +  \"values (?, ?, ?)\", p1, p2, p3);  handleUpdate(ret, \"Insert to student table with jdbc:parameter values\");    // Update data in the table using the `update` remote function.  io:println(\"\\nThe Update operation - Update data in a table\");  ret = testDB->update(\"UPDATE student SET name = 'jane' WHERE age = ?\", 23);  handleUpdate(ret, \"Update a row in student table\");   // Delete data in a table using the `update` remote function.  io:println(\"\\nThe Update operation - Delete data from table\");  ret = testDB->update(\"DELETE FROM student WHERE age = ?\", 24);  handleUpdate(ret, \"Delete a row from student table\");   // The column values generated during the update can be retrieved using the  // `update` remote function. If the table has several auto-generated  // columns other than the auto-incremented key, those column names  // should be given as an array. The values of the auto-incremented  // column and the auto-generated columns are returned as a `string` array.  // Similar to the `update` remote function, the inserted row count is also  // returned.  io:println(\"\\nThe Update operation - Inserting data\");  var retWithKey = testDB->update(\"INSERT INTO student \" +  \"(age, name) values (?, ?)\", 31, \"Kate\");  if (retWithKey is jdbc:UpdateResult) {  io:println(\"Inserted row count: \", retWithKey.updatedRowCount);  io:println(\"Generated key: \",  <int>retWithKey.generatedKeys[\"GENERATED_KEY\"]);  } else {  io:println(\"Insert failed: \", <string>retWithKey.detail()?.message);  }   // Select data using the `select` remote function. The `select` remote  // function returns a `table`.  io:println(\"\\nThe select operation - Select data from a table\");  var selectRet = testDB->select(\"SELECT * FROM student where age < ?\",  Student, 35);  if (selectRet is table<record{}>) {  // `table` can be converted to either `json` or `xml`. The actual  // conversion happens on-demand. When a service client makes a request,  // the result is streamed to the service instead of building the full  // result in the server and returning it. This allows unlimited payload  // sizes in the result and the response is instantaneous to the client.  json jsonConversionRet = jsonutils:fromTable(selectRet);  io:println(\"JSON: \", jsonConversionRet.toJsonString());  } else {  io:println(\"Select data from student table failed: \",  <string>selectRet.detail()?.message);  }   // Drop the table and procedures.  io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }  // Function to handle the return value of the `update` remote function. function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    JDBC Client CRUD Operations  This example demonstrates how to execute data definition statements, insert/update/delete data  and select data using JDBC Client.  This sample uses MySQL DB. Before running the sample, copy the  MySQL JDBC driver to the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder and change the DB connection  properties as required.    import ballerina/io; import ballerina/jsonutils; import ballerina/time; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  dbOptions: {useSSL: false} });    JDBC Client for MySQL database. This client can be used with any JDBC  supported database by providing the corresponding JDBC URL.   type Student record {  int id;  int age;  string name;  time:Time insertedTime; };    This is the type created to represent a data row.   public function main() {    io:println(\"The update operation - Creating a table\");  var ret = testDB->update(\"CREATE TABLE student(id INT AUTO_INCREMENT, \" +  \"age INT, name VARCHAR(255), insertedTime TIMESTAMP DEFAULT \" +  \"CURRENT_TIMESTAMP, PRIMARY KEY (id))\");  handleUpdate(ret, \"Create student table\");    Create a table using the update remote function. If the DDL  statement execution is successful, the update remote function  returns 0.   io:println(\"\\nThe update operation - Inserting data to a table\");  ret = testDB->update(\"INSERT INTO student(age, name) values \" +  \"(23, 'john')\");  handleUpdate(ret, \"Insert to student table with no parameters\");    Insert data to the table using the update remote function. If the DML  statement execution is successful, the update remote function returns  the updated row count. The query parameters are given in the query  statement itself.   int age = 24;  string name = \"Anne\";  ret = testDB->update(\"INSERT INTO student(age, name) values (?, ?)\",  age, name);  handleUpdate(ret, \"Insert to student table with variable parameters\");    The query parameters are given as variables for the update remote  function. Only int, float, decimal, boolean, string and  byte[] values are supported as direct variables any remote function  of the java.jdbc module.   jdbc:Parameter p1 = {sqlType: jdbc:TYPE_INTEGER, value: 25};  jdbc:Parameter p2 = {sqlType: jdbc:TYPE_VARCHAR, value: \"James\"};  jdbc:Parameter p3 = {  sqlType: jdbc:TYPE_TIMESTAMP,  value: time:currentTime()  };  ret = testDB->update(\"INSERT INTO student(age, name, insertedTime) \" +  \"values (?, ?, ?)\", p1, p2, p3);  handleUpdate(ret, \"Insert to student table with jdbc:parameter values\");    The query parameters can be given as arguments of the type  jdbc:Parameter for the any remote function. This is useful if  we want to set the SQL type explicitly or for the parameter types  other than int, float, decimal, boolean, string or  byte[] (e.g. time). Default direction is IN.   io:println(\"\\nThe Update operation - Update data in a table\");  ret = testDB->update(\"UPDATE student SET name = 'jane' WHERE age = ?\", 23);  handleUpdate(ret, \"Update a row in student table\");    Update data in the table using the update remote function.   io:println(\"\\nThe Update operation - Delete data from table\");  ret = testDB->update(\"DELETE FROM student WHERE age = ?\", 24);  handleUpdate(ret, \"Delete a row from student table\");    Delete data in a table using the update remote function.   io:println(\"\\nThe Update operation - Inserting data\");  var retWithKey = testDB->update(\"INSERT INTO student \" +  \"(age, name) values (?, ?)\", 31, \"Kate\");  if (retWithKey is jdbc:UpdateResult) {  io:println(\"Inserted row count: \", retWithKey.updatedRowCount);  io:println(\"Generated key: \",  <int>retWithKey.generatedKeys[\"GENERATED_KEY\"]);  } else {  io:println(\"Insert failed: \", <string>retWithKey.detail()?.message);  }    The column values generated during the update can be retrieved using the  update remote function. If the table has several auto-generated  columns other than the auto-incremented key, those column names  should be given as an array. The values of the auto-incremented  column and the auto-generated columns are returned as a string array.  Similar to the update remote function, the inserted row count is also  returned.   io:println(\"\\nThe select operation - Select data from a table\");  var selectRet = testDB->select(\"SELECT * FROM student where age < ?\",  Student, 35);  if (selectRet is table<record{}>) {    Select data using the select remote function. The select remote  function returns a table.   json jsonConversionRet = jsonutils:fromTable(selectRet);  io:println(\"JSON: \", jsonConversionRet.toJsonString());  } else {  io:println(\"Select data from student table failed: \",  <string>selectRet.detail()?.message);  }    table can be converted to either json or xml. The actual  conversion happens on-demand. When a service client makes a request,  the result is streamed to the service instead of building the full  result in the server and returning it. This allows unlimited payload  sizes in the result and the response is instantaneous to the client.   io:println(\"\\nThe update operation - Drop the student table\");  ret = testDB->update(\"DROP TABLE student\");  handleUpdate(ret, \"Drop table student\"); }    Drop the table and procedures.   function handleUpdate(jdbc:UpdateResult|jdbc:Error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # At the command line, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command below. ballerina run jdbc_client_crud_operations.bal The update operation - Creating a table Create student table status: 0    The update operation - Inserting data to a table Insert to student table with no parameters status: 1 Insert to student table with variable parameters status: 1 Insert to student table with jdbc:parameter values status: 1    The Update operation - Update data in a table Update a row in student table status: 1    The Update operation - Delete data from table Delete a row from student table status: 1    The Update operation - Inserting data Inserted row count: 1 Generated key: 4    The select operation - Select data from a table JSON: [{\"id\":1, \"age\":23, \"name\":\"jane\", \"insertedTime\":\"2019-12-10 17:07:35.0\"}, {\"id\":3, \"age\":25, \"name\":\"James\", \"insertedTime\":\"2019-12-10 17:07:36.0\"}, {\"id\":4, \"age\":31, \"name\":\"Kate\", \"insertedTime\":\"2019-12-10 17:07:35.0\"}]    The update operation - Drop the student table Drop table student status: 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc2-execute-operation.html","name":"JDBC DDL and DML Operations","summary":"This example demonstrates how to use the JDBC client with DDL and\n DML operations. Note that the relevant database driver JAR\n should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default into the Ballerina ...","content":"/  /  /  / JDBC DDL and DML Operations  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;  function initializeTable(jdbc:Client jdbcClient) returns int|string|sql:Error? {  // Execute dropping the table. The `sql:ExecuteResult` is returned upon  // successful execution. An error will be returned in case of a failure.  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }  // Similarly, to drop a table, the `create` table query is executed.  // Here, the `customerId` is an auto-generated column.  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300), \" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, \" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");   // Insert sample data into the table. The result will have  // `affectedRowCount` and `lastInsertedId` with the auto-generated ID of  // the last row.  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country)\" +  \"VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  return result.lastInsertId;  } }  function updateRecord(jdbc:Client jdbcClient, int generatedId) {  // Update the record with the auto-generated ID.  sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Update Customers set creditLimit = 15000.5 \" +  \"where customerId = \" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occurred: \", result);  } else {  io:println(\"Empty result\");  } }  function deleteRecord(jdbc:Client jdbcClient, int generatedId) {  // Delete the record with the auto-generated ID.  sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Delete from Customers where customerId = \" +  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }  public function main() {  // Initialize the JDBC client.  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  // Initialize a table and insert sample data.  int|string|sql:Error? initResult = initializeTable(jdbcClient);  if (initResult is int) {  // Update a record.  updateRecord(jdbcClient, initResult);  // Delete a record.  deleteRecord(jdbcClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed: \", initResult);  }  // Close the JDBC client.  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    JDBC DDL and DML Operations  This example demonstrates how to use the JDBC client with DDL and  DML operations. Note that the relevant database driver JAR  should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default into the Ballerina distribution. Therefore, it is not required to  copy the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function initializeTable(jdbc:Client jdbcClient) returns int|string|sql:Error? {    sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }    Execute dropping the table. The sql:ExecuteResult is returned upon  successful execution. An error will be returned in case of a failure.   result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300), \" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, \" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");    Similarly, to drop a table, the create table query is executed.  Here, the customerId is an auto-generated column.   result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country)\" +  \"VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");    Insert sample data into the table. The result will have  affectedRowCount and lastInsertedId with the auto-generated ID of  the last row.   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  return result.lastInsertId;  } }    function updateRecord(jdbc:Client jdbcClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Update Customers set creditLimit = 15000.5 \" +  \"where customerId = \" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occurred: \", result);  } else {  io:println(\"Empty result\");  } }    Update the record with the auto-generated ID.   function deleteRecord(jdbc:Client jdbcClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  jdbcClient->execute(\"Delete from Customers where customerId = \" +  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Delete the record with the auto-generated ID.   public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {    Initialize the JDBC client.   int|string|sql:Error? initResult = initializeTable(jdbcClient);  if (initResult is int) {    Initialize a table and insert sample data.   updateRecord(jdbcClient, initResult);    Update a record.   deleteRecord(jdbcClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed: \", initResult);  }    Delete a record.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run jdbc2_execute_operation.bal    Drop table executed. affectedRowCount=0 lastInsertId= Rows affected: 1 Generated Customer ID: 1 Updated Row count: 1 Deleted Row count: 1 Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc2-init-options.html","name":"JDBC Client Initialization","summary":"This example demonstrates how to initialize the JDBC client with different\n initialization options. Note that, the relevant database driver JAR\n should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default in the Ballerina distribution. ...","content":"/  /  /  / JDBC Client Initialization  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;  function initializeClients() returns sql:Error? {  // This is a simple JDBC Client for an H2 database with the mandatory  // field - JDBC URL. This client can be used with any database  // by providing the corresponding JDBC URL and placing the relevant database  // driver JAR.  jdbc:Client jdbcClient1 = check new (\"jdbc:h2:file:./target/sample1\");  io:println(\"Simple JDBC client created.\");   // Initialize the JDBC client along by providing the username and password.  jdbc:Client jdbcClient2 = check new (\"jdbc:h2:file:./target/sample2\",  \"rootUser\", \"rootPass\");  io:println(\"JDBC client with user/password created.\");   // Initialize the JDBC client by providing additional  // database properties. The database properties can differ based  // on the specific JDBC datasource implementation of the database.  jdbc:Options h2Options = {  datasourceName: \"org.h2.jdbcx.JdbcDataSource\",  properties: {\"loginTimeout\": \"2000\"}  };  jdbc:Client jdbcClient3 = check new (\"jdbc:h2:file:./target/sample3\",  \"rootUser\", \"rootPass\", h2Options);  io:println(\"JDBC client with database options created.\");   // Connection pool is used to share and use the connections  // to the database efficiently. In the above samples, the global  // connection pool is created and shared  // among all the database clients since the `connectionPool` property  // is not set.  sql:ConnectionPool connPool = {  // Default max number of open connections in the connection pool is 15.  maxOpenConnections: 5,  // Default max life time of a connection in the connection pool is  // 1800 seconds (30 minutes).  maxConnectionLifeTimeInSeconds: 2000.0,  // Default minimum number of idle connections is 15.  minIdleConnections: 5  };   // Initialize the JDBC client with the specific connection pool.  jdbc:Client jdbcClient4 = check new (\"jdbc:h2:file:./target/sample4\",  \"rootUser\", \"rootPass\", h2Options, connPool);  io:println(\"JDBC client with connection pool created.\");   // Other than the JDBC URL, all other properties are optional.  // Hence, named attributes can be used specifically to assign  // the attributes.  jdbc:Client jdbcClient5 = check new (url = \"jdbc:h2:file:./target/sample5\",  user = \"rootUser\", password = \"rootPass\", options = h2Options,  connectionPool = connPool);   // Initialize JDBC Client only with the URL and connection pool.  jdbc:Client jdbcClient6 = check new (url = \"jdbc:h2:file:./target/sample6\",  connectionPool = connPool);  io:println(\"JDBC client with optional params created.\");   // Close the clients to release the resource  // and destroy the connection pool.  check jdbcClient1.close();  check jdbcClient2.close();  check jdbcClient3.close();  check jdbcClient4.close();  check jdbcClient5.close();  check jdbcClient6.close(); }  //Initialize JDBC clients with different options. public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed!\", err);  } else {  io:println(\"Sample executed successfully!\");  } }    JDBC Client Initialization  This example demonstrates how to initialize the JDBC client with different  initialization options. Note that, the relevant database driver JAR  should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default in the Ballerina distribution. Therefore, it is not required to copy  the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function initializeClients() returns sql:Error? {    jdbc:Client jdbcClient1 = check new (\"jdbc:h2:file:./target/sample1\");  io:println(\"Simple JDBC client created.\");    This is a simple JDBC Client for an H2 database with the mandatory  field - JDBC URL. This client can be used with any database  by providing the corresponding JDBC URL and placing the relevant database  driver JAR.   jdbc:Client jdbcClient2 = check new (\"jdbc:h2:file:./target/sample2\",  \"rootUser\", \"rootPass\");  io:println(\"JDBC client with user/password created.\");    Initialize the JDBC client along by providing the username and password.   jdbc:Options h2Options = {  datasourceName: \"org.h2.jdbcx.JdbcDataSource\",  properties: {\"loginTimeout\": \"2000\"}  };  jdbc:Client jdbcClient3 = check new (\"jdbc:h2:file:./target/sample3\",  \"rootUser\", \"rootPass\", h2Options);  io:println(\"JDBC client with database options created.\");    Initialize the JDBC client by providing additional  database properties. The database properties can differ based  on the specific JDBC datasource implementation of the database.   sql:ConnectionPool connPool = {    Connection pool is used to share and use the connections  to the database efficiently. In the above samples, the global  connection pool is created and shared  among all the database clients since the connectionPool property  is not set.   maxOpenConnections: 5,    Default max number of open connections in the connection pool is 15.   maxConnectionLifeTimeInSeconds: 2000.0,    Default max life time of a connection in the connection pool is  1800 seconds (30 minutes).   minIdleConnections: 5  };    Default minimum number of idle connections is 15.   jdbc:Client jdbcClient4 = check new (\"jdbc:h2:file:./target/sample4\",  \"rootUser\", \"rootPass\", h2Options, connPool);  io:println(\"JDBC client with connection pool created.\");    Initialize the JDBC client with the specific connection pool.   jdbc:Client jdbcClient5 = check new (url = \"jdbc:h2:file:./target/sample5\",  user = \"rootUser\", password = \"rootPass\", options = h2Options,  connectionPool = connPool);    Other than the JDBC URL, all other properties are optional.  Hence, named attributes can be used specifically to assign  the attributes.   jdbc:Client jdbcClient6 = check new (url = \"jdbc:h2:file:./target/sample6\",  connectionPool = connPool);  io:println(\"JDBC client with optional params created.\");    Initialize JDBC Client only with the URL and connection pool.   check jdbcClient1.close();  check jdbcClient2.close();  check jdbcClient3.close();  check jdbcClient4.close();  check jdbcClient5.close();  check jdbcClient6.close(); }    Close the clients to release the resource  and destroy the connection pool.   public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed!\", err);  } else {  io:println(\"Sample executed successfully!\");  } }    Initialize JDBC clients with different options.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run jdbc2_init_options.bal    Simple JDBC client created. JDBC client with user/password created. JDBC client with database options created. JDBC client with connection pool created. JDBC client with optional params created. Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-access.html","name":"JSON Access","summary":"Ballerina defines certain types as lax types for which static typing rules are less strict.\n For example, field access (.) and optional field access (?.), which are generally allowed on\n records and objects for fields that are defined in the type descriptors, are also additionally\n allowed on lax types. For ...","content":"/  /  /  / JSON Access  import ballerina/io;  public function main() {  // Define a variable of type `json` that holds a mapping value.  json j1 = {  fname: \"Mary\",  lname: \"Jane\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };   // Field access is allowed on the `json`-typed variable. However, the return  // type would be a union of `json` and `error`. An error will be returned  // either if the value on which the access is done is not a mapping or if  // it is a mapping, but it does not contain the particular key.  json|error r1 = j1.fname;  // `r1` is of type `json` since `j1` is a mapping and contains the field `fname`.  io:println(r1);   // Similarly, chained field access is also allowed for `json`. If an `error`  // is encountered at any point during the evaluation, evaluation stops at  // that point and the result would be an error.  json|error r2 = j1.address.city;  // `r2` is of type `json` since `j1` is a mapping with the field `address`, which in  // turn is a mapping with the field `city`, which will be the resultant value.  io:println(r2);   // Attempting to access a non-existent field would result in an error.  json|error r3 = j1.age.year;  // `r3` is of type `error` since `j1` does not have a field with the key `age`.  io:println(r3);   // Similarly, optional field access is also allowed on lax types.  // The main difference between field and optional field access for lax types  // is that when a key is not found in a mapping, while the former returns  // an `error`, the latter returns `null` (`()`) instead.  // Similar to how errors are lifted with field access, `()` is lifted  // for optional field access allowing chained access.  json|error r4 = j1?.age?.year;  // `r4` is `()` since `j1` does not have a field with the key `age`.  io:println(r4);   // Moreover, when optional field access occurs on `null` (`()`), the result would  // also be `()`, whereas for field access it would have been an `error`.  json j2 = null;  json|error r5 = j2?.name;  // `r5` is `()` since `j2` is `()`.  io:println(r5); }    JSON Access  Ballerina defines certain types as lax types for which static typing rules are less strict.  For example, field access (.) and optional field access (?.), which are generally allowed on  records and objects for fields that are defined in the type descriptors, are also additionally  allowed on lax types. For such operations, some of the type checking is moved from compile time to runtime.  json is defined to be a lax type along with any map<T> where T is a lax type.    import ballerina/io;    public function main() {    json j1 = {  fname: \"Mary\",  lname: \"Jane\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };    Define a variable of type json that holds a mapping value.   json|error r1 = j1.fname;    Field access is allowed on the json-typed variable. However, the return  type would be a union of json and error. An error will be returned  either if the value on which the access is done is not a mapping or if  it is a mapping, but it does not contain the particular key.   io:println(r1);    r1 is of type json since j1 is a mapping and contains the field fname.   json|error r2 = j1.address.city;    Similarly, chained field access is also allowed for json. If an error  is encountered at any point during the evaluation, evaluation stops at  that point and the result would be an error.   io:println(r2);    r2 is of type json since j1 is a mapping with the field address, which in  turn is a mapping with the field city, which will be the resultant value.   json|error r3 = j1.age.year;    Attempting to access a non-existent field would result in an error.   io:println(r3);    r3 is of type error since j1 does not have a field with the key age.   json|error r4 = j1?.age?.year;    Similarly, optional field access is also allowed on lax types.  The main difference between field and optional field access for lax types  is that when a key is not found in a mapping, while the former returns  an error, the latter returns null (()) instead.  Similar to how errors are lifted with field access, () is lifted  for optional field access allowing chained access.   io:println(r4);    r4 is () since j1 does not have a field with the key age.   json j2 = null;  json|error r5 = j2?.name;    Moreover, when optional field access occurs on null (()), the result would  also be (), whereas for field access it would have been an error.   io:println(r5); }    r5 is () since j2 is ().   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_access.bal Mary Colombo 03 error {ballerina/lang.map}KeyNotFound message=Key 'age' not found in JSON mapping    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-arrays.html","name":"JSON Arrays","summary":"JSON array literals are written exactly the same way as Ballerina arrays.\n JSON array values must be of the JSON types: string, number, object, array, boolean, or null.JSON Arrays are arrays with JSON values as members.\n The same could be written as\n json[] j1 = [1, false, null, \"foo\", { ...","content":"/  /  /  / JSON Arrays  import ballerina/io;  public function main() {  // JSON Arrays are arrays with JSON values as members.  // The same could be written as  // `json[] j1 = [1, false, null, \"foo\", { first: \"John\", last: \"Pala\" }];`  json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j1.toJsonString());   // JSON array elements can be accessed by index.  // The `json` value `j1` first needs to be cast to a `json[]` to use member access.  // Alternatively, `j1` could have been defined as a `json[]`.  json[] j2 = <json[]>j1;  json j3 = j2[4];  io:println(j3.toJsonString());   // Similarly, member access could be used with `json[]`-typed variables to add or  // change members in a `json` array.  j2[4] = 8.00;  io:println(j1.toJsonString());   // JSON array in an object literal.  map<json> p = {  fname: \"John\",  lname: \"Stallone\",  family: [  {fname: \"Peter\", lname: \"Stallone\"},  {fname: \"Emma\", lname: \"Stallone\"},  {fname: \"Jena\", lname: \"Stallone\"},  {fname: \"Paul\", lname: \"Stallone\"}  ]  };   json[] family = <json[]>p[\"family\"];  map<json> member2 = <map<json>>family[2];  member2[\"fname\"] = \"Alisha\";  io:println(p.toJsonString());   // Get the length of the JSON array.  int l = family.length();  io:println(\"length of the array: \", l);   // Loop through the array.  int i = 0;  while (i < l) {  io:println(family[i].toJsonString());  i = i + 1;  } }    JSON Arrays  JSON array literals are written exactly the same way as Ballerina arrays.  JSON array values must be of the JSON types: string, number, object, array, boolean, or null.    import ballerina/io;    public function main() {    json j1 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j1.toJsonString());    JSON Arrays are arrays with JSON values as members.  The same could be written as  json[] j1 = [1, false, null, \"foo\", { first: \"John\", last: \"Pala];   json[] j2 = <json[]>j1;  json j3 = j2[4];  io:println(j3.toJsonString());    JSON array elements can be accessed by index.  The json value j1 first needs to be cast to a json[] to use member access.  Alternatively, j1 could have been defined as a json[].   j2[4] = 8.00;  io:println(j1.toJsonString());    Similarly, member access could be used with json[]-typed variables to add or  change members in a json array.   map<json> p = {  fname: \"John\",  lname: \"Stallone\",  family: [  {fname: \"Peter\", lname: \"Stallone\"},  {fname: \"Emma\", lname: \"Stallone\"},  {fname: \"Jena\", lname: \"Stallone\"},  {fname: \"Paul\", lname: \"Stallone\"}  ]  };    JSON array in an object literal.   json[] family = <json[]>p[\"family\"];  map<json> member2 = <map<json>>family[2];  member2[\"fname\"] = \"Alisha\";  io:println(p.toJsonString());    int l = family.length();  io:println(\"length of the array: \", l);    Get the length of the JSON array.   int i = 0;  while (i < l) {  io:println(family[i].toJsonString());  i = i + 1;  } }    Loop through the array.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_arrays.bal [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] {\"first\":\"John\", \"last\":\"Pala\"} [1, false, null, \"foo\", 8.0] {\"fname\":\"John\", \"lname\":\"Stallone\", \"family\":[{\"fname\":\"Peter\", \"lname\":\"Stallone\"}, {\"fname\":\"Emma\", \"lname\":\"Stallone\"}, {\"fname\":\"Alisha\", \"lname\":\"Stallone\"}, {\"fname\":\"Paul\", \"lname\":\"Stallone\"}]} length of the array: 4 {\"fname\":\"Peter\", \"lname\":\"Stallone\"} {\"fname\":\"Emma\", \"lname\":\"Stallone\"} {\"fname\":\"Alisha\", \"lname\":\"Stallone\"} {\"fname\":\"Paul\", \"lname\":\"Stallone\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc2-complex-type-queries.html","name":"JDBC Query with Complex Types","summary":"This example demonstrates how to use the JDBC client with complex data types\n such as arrays, binary, blobs, clob, and date/time fields. Note that the\n relevant database  driver JAR should be placed in the\n <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample is based on an H2\n database and the H2 database ...","content":"/  /  /  / JDBC Query with Complex Types  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql; import ballerina/time;  type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};  type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};  type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};  function queryBinaryType(jdbc:Client jdbcClient) {  io:println(\"------ Query Binary Type -------\");  // Select the rows with binary data types.  // The name and type of the attributes within the record from the  // `resultStream` will be automatically identified based on the column  // name and type of the query result.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from BINARY_TYPES\");   io:println(\"Result 1:\");  // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  // Since the `rowType` is provided as a `BinaryType`, the `resultStream` will  // have `BinaryType` records.  resultStream = jdbcClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream  = <stream<BinaryType, sql:Error>>resultStream;   io:println(\"Result 2:\");  // Iterate the `binaryResultStream`.  e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }   function queryArrayType(jdbc:Client jdbcClient) {  io:println(\"------ Query Array Type -------\");  // Select the rows with array data types.  // The name and type of the attributes within the record from the `  // resultStream` will be automatically identified based on the column  // name and type of the query result.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from ARRAY_TYPES\");   io:println(\"Result 1:\");  // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  // Since the `rowType` is provided as an `ArrayType`, the `resultStream` will  // have `ArrayType` records.  resultStream = jdbcClient->query(\"Select * from ARRAY_TYPES\", ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream;   io:println(\"Result 2:\");  // Iterate the `arrayResultStream`.  e = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }  function queryDateTimeType(jdbc:Client jdbcClient) {  io:println(\"------ Query Date Time Type -------\");  // Select the rows with date/time data types.  // The name and type of the attributes within the record from  // the `resultStream` will be automatically identified based on the  // column name and type of the query result.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from DATE_TIME_TYPES\");   io:println(\"Result 1:\");  // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  // Since the `rowType` is provided as a `DateTimeType`, the `resultStream`  // will have `DateTimeType` records. The Date, Time, DateTime, and  // Timestamp fields of the database table can be mapped to time:Time,  // string, and int types in Ballerina.  resultStream = jdbcClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;   io:println(\"Result 2:\");  // Iterate the `dateResultStream`.  e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }  //Initialize the database table with sample data. function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS BINARY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE BINARY_TYPES (row_id \" +  \"INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024),\" +  \"binary_type BINARY(27), PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO BINARY_TYPES (row_id,\" +  \"blob_type, clob_type, binary_type) VALUES (1, \" +  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT\" +  \"('very long text', CLOB),\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");   result = check jdbcClient->execute(\"DROP TABLE IF EXISTS ARRAY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE ARRAY_TYPES (row_id \" +  \"INTEGER NOT NULL, int_array ARRAY, long_array ARRAY,float_array \" +  \"ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY,\" +  \"PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO ARRAY_TYPES (row_id, \" +  \"int_array, long_array, float_array, double_array, boolean_array, \" +  \"string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, \" +  \"300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, \" +  \"8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))\");   result = check jdbcClient->execute(\"DROP TABLE IF EXISTS DATE_TIME_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE DATE_TIME_TYPES(row_id \" +  \" INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type \" +  \"timestamp, datetime_type datetime, PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"Insert into DATE_TIME_TYPES (row_id,\" +  \" date_type, time_type, timestamp_type, datetime_type) values (1,\" +  \"'2017-05-23','14:15:23','2017-01-25 16:33:55','2017-01-25 16:33:55')\"); }  public function main() {  // Initialize the JDBC client.  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/DATA_TYPES\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Sample data table initialization failed: \", err);  } else {  // Execute the complex data type queries.  queryBinaryType(jdbcClient);  queryArrayType(jdbcClient);  queryDateTimeType(jdbcClient);  io:println(\"Sample executed successfully!\");  }  // Close the JDBC client.  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed: \", jdbcClient);  } }    JDBC Query with Complex Types  This example demonstrates how to use the JDBC client with complex data types  such as arrays, binary, blobs, clob, and date/time fields. Note that the  relevant database driver JAR should be placed in the  <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample is based on an H2  database and the H2 database driver JAR is included by default in the  Ballerina distribution. Therefore, it is not required to copy the driver JAR  for the H2 database.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql; import ballerina/time;    type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};    type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};    type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};    function queryBinaryType(jdbc:Client jdbcClient) {  io:println(\"------ Query Binary Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from BINARY_TYPES\");    Select the rows with binary data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream  = <stream<BinaryType, sql:Error>>resultStream;    Since the rowType is provided as a BinaryType, the resultStream will  have BinaryType records.   io:println(\"Result 2:\");    e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the binaryResultStream.   function queryArrayType(jdbc:Client jdbcClient) {  io:println(\"------ Query Array Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from ARRAY_TYPES\");    Select the rows with array data types.  The name and type of the attributes within the record from the resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from ARRAY_TYPES\", ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream;    Since the rowType is provided as an ArrayType, the resultStream will  have ArrayType records.   io:println(\"Result 2:\");    e = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the arrayResultStream.   function queryDateTimeType(jdbc:Client jdbcClient) {  io:println(\"------ Query Date Time Type -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from DATE_TIME_TYPES\");    Select the rows with date/time data types.  The name and type of the attributes within the record from  the resultStream will be automatically identified based on the  column name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = jdbcClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;    Since the rowType is provided as a DateTimeType, the resultStream  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Time,  string, and int types in Ballerina.   io:println(\"Result 2:\");    e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the dateResultStream.   function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS BINARY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE BINARY_TYPES (row_id \" +  \"INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024),\" +  \"binary_type BINARY(27), PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO BINARY_TYPES (row_id,\" +  \"blob_type, clob_type, binary_type) VALUES (1, \" +  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT\" +  \"('very long text', CLOB),\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");    Initialize the database table with sample data.   result = check jdbcClient->execute(\"DROP TABLE IF EXISTS ARRAY_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE ARRAY_TYPES (row_id \" +  \"INTEGER NOT NULL, int_array ARRAY, long_array ARRAY,float_array \" +  \"ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY,\" +  \"PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"INSERT INTO ARRAY_TYPES (row_id, \" +  \"int_array, long_array, float_array, double_array, boolean_array, \" +  \"string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, \" +  \"300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, \" +  \"8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))\");    result = check jdbcClient->execute(\"DROP TABLE IF EXISTS DATE_TIME_TYPES\");  result = check jdbcClient->execute(\"CREATE TABLE DATE_TIME_TYPES(row_id \" +  \" INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type \" +  \"timestamp, datetime_type datetime, PRIMARY KEY (row_id))\");  result = check jdbcClient->execute(\"Insert into DATE_TIME_TYPES (row_id,\" +  \" date_type, time_type, timestamp_type, datetime_type) values (1,\" +  \"'2017-05-23','14:15:23','2017-01-25 16:33:55','2017-01-25 16:33:55')\"); }    public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/DATA_TYPES\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Sample data table initialization failed: \", err);  } else {    Initialize the JDBC client.   queryBinaryType(jdbcClient);  queryArrayType(jdbcClient);  queryDateTimeType(jdbcClient);  io:println(\"Sample executed successfully!\");  }    Execute the complex data type queries.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed: \", jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run jdbc2_complex_type_queries.bal    ------ Query Binary Type ------- Result 1: ROW_ID=1 BLOB_TYPE=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 CLOB_TYPE=very long text BINARY_TYPE=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 Result 2: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 clob_type=very long text binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 ------ ********* ------- ------ Query Array Type ------- Result 1: ROW_ID=1 INT_ARRAY=1 2 3 LONG_ARRAY=100000000 200000000 300000000 FLOAT_ARRAY=245.23 5559.49 8796.123 DOUBLE_ARRAY=245.23 5559.49 8796.123 BOOLEAN_ARRAY=true false true STRING_ARRAY=Hello Ballerina Result 2: row_id=1 int_array=1 2 3 long_array=100000000 200000000 300000000 float_array=245.23 5559.49 8796.123 double_array=245.23 5559.49 8796.123 boolean_array=true false true string_array=Hello Ballerina ------ ********* ------- ------ Query Date Time Type ------- Result 1: ROW_ID=1 DATE_TYPE=2017-05-23+05:30 TIME_TYPE=19:45:23.000+05:30 TIMESTAMP_TYPE=2017-01-25T22:03:55.000+05:30 DATETIME_TYPE=2017-01-25T22:03:55.000+05:30 Result 2: row_id=1 date_type=2017-05-23+05:30 time_type=51323000 timestamp_type=time=1485362035000 zone=id=UTC offset=0 datetime_type=2017-01-25T22:03:55.000+05:30 ------ ********* ------- Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-csv.html","name":"JSON to CSV Transform","summary":"This sample demonstrates how a json array can be transformed to CSV.Convert a map<json> value to an array of Strings.\n Return the result as a tuple, which contains the headers and fields.Writes json content to CSV.We ignore the result as this would mean a nil returnThe sample json, which will ...","content":"/  /  /  / JSON to CSV Transform  import ballerina/io; import ballerina/log;  // Convert a `map<json>` value to an array of Strings. // Return the result as a tuple, which contains the headers and fields. function getFields(map<json> rec) returns [string[], string[]] {  string[] fields = [];  foreach var recordField in rec {  fields[fields.length()] = recordField.toString();  }  return [rec.keys(), fields]; }  // Writes `json` content to CSV. function writeCsv(json[] content, string path) returns @tainted error? {  io:WritableCSVChannel csvch = check io:openWritableCsvFile(path);  int recIndex = 0;  int recLen = content.length();  while (recIndex < recLen) {  [string[], string[]] result = getFields(<map<json>>content[recIndex]);  var [headers, fields] = result;  if (recIndex == 0) {  //We ignore the result as this would mean a `nil` return  check csvch.write(headers);  }  check csvch.write(fields);  recIndex = recIndex + 1;  } }  public function main() {  // The sample `json`, which will be written.  json sample = {  \"employees\": {  \"employee\": [  {  \"id\": \"1\",  \"firstName\": \"Tom\",  \"lastName\": \"Cruise\",  \"photo\": \"https://ballerina-team/profile/3737.jpg\"  },  {  \"id\": \"2\",  \"firstName\": \"Maria\",  \"lastName\": \"Sharapova\",  \"photo\": \"https://ballerina-team/profile/5676.jpg\"  },  {  \"id\": \"3\",  \"firstName\": \"James\",  \"lastName\": \"Bond\",  \"photo\": \"https://ballerina-team/profile/6776.jpg\"  }  ]  }  };  // Writes JSON into a CSV.  string path = \"./files/sample.csv\";  // Specifies the JSON array, which should be transformed into CSV.  // Also, provides the location the CSV should be written.  var result = writeCsv(<json[]>sample.employees.employee, path);  if (result is error) {  log:printError(\"Error occurred while writing csv record :\",  err = result);  } else {  io:println(\"json record successfully transformed to a csv, file could\" +  \" be found in \" + path);  } }    JSON to CSV Transform  This sample demonstrates how a json array can be transformed to CSV.    import ballerina/io; import ballerina/log;    function getFields(map<json> rec) returns [string[], string[]] {  string[] fields = [];  foreach var recordField in rec {  fields[fields.length()] = recordField.toString();  }  return [rec.keys(), fields]; }    Convert a map<json> value to an array of Strings.  Return the result as a tuple, which contains the headers and fields.   function writeCsv(json[] content, string path) returns @tainted error? {  io:WritableCSVChannel csvch = check io:openWritableCsvFile(path);  int recIndex = 0;  int recLen = content.length();  while (recIndex < recLen) {  [string[], string[]] result = getFields(<map<json>>content[recIndex]);  var [headers, fields] = result;  if (recIndex == 0) {    Writes json content to CSV.   check csvch.write(headers);  }  check csvch.write(fields);  recIndex = recIndex + 1;  } }    We ignore the result as this would mean a nil return   public function main() {    json sample = {  \"employees\": {  \"employee\": [  {  \"id\": \"1\",  \"firstName\": \"Tom\",  \"lastName\": \"Cruise\",  \"photo\": \"https://ballerina-team/profile/3737.jpg\"  },  {  \"id\": \"2\",  \"firstName\": \"Maria\",  \"lastName\": \"Sharapova\",  \"photo\": \"https://ballerina-team/profile/5676.jpg\"  },  {  \"id\": \"3\",  \"firstName\": \"James\",  \"lastName\": \"Bond\",  \"photo\": \"https://ballerina-team/profile/6776.jpg\"  }  ]  }  };    The sample json, which will be written.   string path = \"./files/sample.csv\";    Writes JSON into a CSV.   var result = writeCsv(<json[]>sample.employees.employee, path);  if (result is error) {  log:printError(\"Error occurred while writing csv record :\",  err = result);  } else {  io:println(\"json record successfully transformed to a csv, file could\" +  \" be found in \" + path);  } }    Specifies the JSON array, which should be transformed into CSV.  Also, provides the location the CSV should be written.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_csv.bal json record successfully transformed to a csv, file could be found in ./files/sample.csv    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-io.html","name":"JSON I/O","summary":"This sample demonstrates how to read JSON content from a file and write JSON content\n to a file using the character channel, readJson(), and writeJson() of the I/O API.Closes a readable channel.Closes a writable channel.Writes the provided json to the specified path.Creates a writable byte channel from the given path.Derives ...","content":"/  /  /  / JSON I/O  import ballerina/io; import ballerina/log;  // Closes a readable channel. function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }  // Closes a writable channel. function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }  // Writes the provided `json` to the specified path. function write(json content, string path) returns @tainted error? {  // Creates a writable byte channel from the given path.  io:WritableByteChannel wbc = check io:openWritableFile(path);  // Derives the character channel from the byte channel.  io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeJson(content);  closeWc(wch);  return result; }  // Reads a `json` value from the specified path. function read(string path) returns @tainted json|error {  // Creates a readable byte channel from the given path.  io:ReadableByteChannel rbc = check io:openReadableFile(path);  // Derives the character channel from the byte channel.  io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  var result = rch.readJson();  closeRc(rch);  return result; }  public function main() {  string filePath = \"./files/sample.json\";  // Creates the`json` content from the `string`.  json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  io:println(\"Preparing to write json file\");  // Writes the `json` content.  var wResult = write(j1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing json: \", wResult);  } else {  io:println(\"Preparing to read the content written\");  // Reads the `json` content.  var rResult = read(filePath);  if (rResult is error) {  log:printError(\"Error occurred while reading json: \",  err = rResult);  } else {  io:println(rResult.toJsonString());  }  } }    JSON I/O  This sample demonstrates how to read JSON content from a file and write JSON content  to a file using the character channel, readJson(), and writeJson() of the I/O API.    import ballerina/io; import ballerina/log;    function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a readable channel.   function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a writable channel.   function write(json content, string path) returns @tainted error? {    Writes the provided json to the specified path.   io:WritableByteChannel wbc = check io:openWritableFile(path);    Creates a writable byte channel from the given path.   io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeJson(content);  closeWc(wch);  return result; }    Derives the character channel from the byte channel.   function read(string path) returns @tainted json|error {    Reads a json value from the specified path.   io:ReadableByteChannel rbc = check io:openReadableFile(path);    Creates a readable byte channel from the given path.   io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  var result = rch.readJson();  closeRc(rch);  return result; }    Derives the character channel from the byte channel.   public function main() {  string filePath = \"./files/sample.json\";    json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  io:println(\"Preparing to write json file\");    Creates thejson content from the string.   var wResult = write(j1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing json: \", wResult);  } else {  io:println(\"Preparing to read the content written\");    Writes the json content.   var rResult = read(filePath);  if (rResult is error) {  log:printError(\"Error occurred while reading json: \",  err = rResult);  } else {  io:println(rResult.toJsonString());  }  } }    Reads the json content.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_io.bal Preparing to write json file Preparing to read the content written {\"Store\":{\"@id\":\"AST\", \"name\":\"Anne\", \"address\":{\"street\":\"Main\", \"city\":\"94\"}, \"codes\":[\"4\", \"8\"]}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jdbc2-query-operation.html","name":"JDBC Select Query Operations","summary":"This example demonstrates how to use the JDBC client select query operations\n with the stream return type. Note that the relevant database driver JAR\n should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample\n is based on an H2 database and the H2 database driver JAR is included by\n default ...","content":"/  /  /  / JDBC Select Query Operations  import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;  function simpleQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Simple Query -------\");  // Select the rows in the database table via the query remote operation.  // The result is returned as a stream and the elements of the stream can  // be either a record or an error.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\");   // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  io:println(\"Customer first name: \", result[\"FIRSTNAME\"]);  io:println(\"Customer last name: \", result[\"LASTNAME\"]);  });  // Check and handle the error during the SQL query  // or iteration of the result stream.  if (e is error) {  io:println(\"ForEach operation on the stream failed!\");  io:println(e);  }   // In general cases, the stream will be closed automatically  // when the stream is fully consumed or any error is encountered.  // However, in case if the stream is not fully consumed, the stream  // should be closed specifically.  e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }  function countRows(jdbc:Client jdbcClient) {  io:println(\"------ Start Count Total Rows -------\");  // The result of the count operation is provided as a record stream.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select count(*) as total from Customers\");   // Since the above count query will return only a single row,  // the `next()` operation is sufficient to retrieve the data.  record {|record {} value;|}|error? result = resultStream.next();   // Check the result and retrieve the value for total.  if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed. \", result);  } else {  io:println(\"Customer table is empty\");  }  // Close the stream.  error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }  // Define a record to load the query result schema as shown below in the // 'typedQuery' function. In this example, all columns of the customer table // will be loaded. Therefore, the `Customer` record will be created with all // the columns. The column name of the result and the defined field name of // the record will be matched case insensitively. type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};  function typedQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Query With Type Description -------\");  // The result is returned as a Customer record stream and the elements  // of the stream can be either a Customer record or an error.  stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\", Customer);   // Cast the generic record type to the Customer stream type.  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;   // Iterate the customer stream.  error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }   // Close the stream.  e = resultStream.close();  io:println(\"------ End Query With Type Description -------\"); }  //Initialize the database table with sample data. function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers(\" +  \"customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300),\" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE,\" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit,country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country) VALUES ('Dan', 'Brown',\" +  \"2, 10000, 'UK')\"); }  public function main() {  // Initialize the JDBC client.  jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Customer table initialization failed!\", err);  } else {  // Execute the select queries in different options.  simpleQuery(jdbcClient);  countRows(jdbcClient);  typedQuery(jdbcClient);  io:println(\"Queried the database successfully!\");  }  // Close the JDBC client.  sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    JDBC Select Query Operations  This example demonstrates how to use the JDBC client select query operations  with the stream return type. Note that the relevant database driver JAR  should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib folder. However, this sample  is based on an H2 database and the H2 database driver JAR is included by  default in the Ballerina distribution. Therefore, it is not required to copy  the driver JAR for H2 databases.    import ballerina/io; import ballerina/java.jdbc; import ballerina/sql;    function simpleQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Simple Query -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\");    Select the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  io:println(\"Customer first name: \", result[\"FIRSTNAME\"]);  io:println(\"Customer last name: \", result[\"LASTNAME\"]);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed!\");  io:println(e);  }    Check and handle the error during the SQL query  or iteration of the result stream.   e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream  should be closed specifically.   function countRows(jdbc:Client jdbcClient) {  io:println(\"------ Start Count Total Rows -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select count(*) as total from Customers\");    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream.next();    Since the above count query will return only a single row,  the next() operation is sufficient to retrieve the data.   if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed. \", result);  } else {  io:println(\"Customer table is empty\");  }    Check the result and retrieve the value for total.   error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }    Close the stream.   type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Define a record to load the query result schema as shown below in the  ‘typedQuery’ function. In this example, all columns of the customer table  will be loaded. Therefore, the Customer record will be created with all  the columns. The column name of the result and the defined field name of  the record will be matched case insensitively.   function typedQuery(jdbc:Client jdbcClient) {  io:println(\"------ Start Query With Type Description -------\");    stream<record{}, error> resultStream =  jdbcClient->query(\"Select * from Customers\", Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;    Cast the generic record type to the Customer stream type.   error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }    Iterate the customer stream.   e = resultStream.close();  io:println(\"------ End Query With Type Description -------\"); }    Close the stream.   function initializeTable(jdbc:Client jdbcClient) returns sql:Error? {  sql:ExecuteResult? result =  check jdbcClient->execute(\"DROP TABLE IF EXISTS Customers\");  result = check jdbcClient->execute(\"CREATE TABLE IF NOT EXISTS Customers(\" +  \"customerId INTEGER NOT NULL IDENTITY, firstName VARCHAR(300),\" +  \"lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE,\" +  \"country VARCHAR(300), PRIMARY KEY (customerId))\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit,country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  result = check jdbcClient->execute(\"INSERT INTO Customers (firstName, \" +  \"lastName,registrationID,creditLimit,country) VALUES ('Dan', 'Brown',\" +  \"2, 10000, 'UK')\"); }    Initialize the database table with sample data.   public function main() {    jdbc:Client|sql:Error jdbcClient = new (\"jdbc:h2:file:./target/customers\",  \"rootUser\", \"rootPass\");  if (jdbcClient is jdbc:Client) {  sql:Error? err = initializeTable(jdbcClient);  if (err is sql:Error) {  io:println(\"Customer table initialization failed!\", err);  } else {    Initialize the JDBC client.   simpleQuery(jdbcClient);  countRows(jdbcClient);  typedQuery(jdbcClient);  io:println(\"Queried the database successfully!\");  }    Execute the select queries in different options.   sql:Error? e = jdbcClient.close();  } else {  io:println(\"Initialization failed!!\");  io:println(jdbcClient);  } }    Close the JDBC client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run jdbc2_query_operation.bal    ------ Start Simple Query ------- Full Customer details: CUSTOMERID=1 FIRSTNAME=Peter LASTNAME=Stuart REGISTRATIONID=1 CREDITLIMIT=5000.75 COUNTRY=USA Customer first name: Peter Customer last name: Stuart Full Customer details: CUSTOMERID=2 FIRSTNAME=Dan LASTNAME=Brown REGISTRATIONID=2 CREDITLIMIT=10000.0 COUNTRY=UK Customer first name: Dan Customer last name: Brown ------ End Simple Query ------- ------ Start Count Total Rows ------- Total rows in customer table : 2 ------ End Count Total Rows ------- ------ Start Query With Type Description ------- customerId=1 firstName=Peter lastName=Stuart registrationId=1 creditLimit=5000.75 country=USA customerId=2 firstName=Dan lastName=Brown registrationId=2 creditLimit=10000.0 country=UK ------ End Query With Type Description ------- Queried the database successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-objects.html","name":"JSON Objects","summary":"JSON objects are represented as maps of JSON in Ballerina.\n JSON object members could be of any JSON type: string, number, object, array, boolean, or null.Create a JSON object. A JSON object in Ballerina is equivalent to a map<json>.\n Thus, the same can be written as\n map<json> j = { ...","content":"/  /  /  / JSON Objects  import ballerina/io;  public function main() {  // Create a JSON object. A JSON object in Ballerina is equivalent to a `map<json>`.  // Thus, the same can be written as  // `map<json> j = { name: \"apple\", color: \"red\", price: j2 };`  json j = {name: \"apple\", color: \"red\", price: 100};  io:println(j.toJsonString());   // Since a JSON object is a `map<json>`, this type test evaluates to true.  io:println(\"j is map<json>: \", j is map<json>);   // Create an empty JSON object. This is equivalent to an empty `map<json>`.  json empty = {};   int age = 30;  // Create a JSON object. Keys can be defined with or without quotes.  // Values can be any `json` expression.  json p = {fname: \"John\", lname: \"Stallone\", \"age\": age};  io:println(p.toJsonString());   // You can add or change JSON object values using member access (i.e., the `[expr]` operator).  // In order to change fields of an object value, it needs to be accessed  // as a `map<json>`. This is done by casting `p` to `map<json>`.  // Alternatively, `p` could have been defined as a `map<json>`.  map<json> mp = <map<json>>p;  mp[\"age\"] = 31;  io:println(p.toJsonString());   // Create a nested JSON object.  // This could also be defined as a `json` variable instead of `map<json>`.  map<json> p2 = {  fname: \"Peter\",  lname: \"Stallone\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };  io:println(p2.toJsonString());   // Member access expressions with `string` keys can be used to access fields of a  // mapping of `json`.  json lastName = p2[\"lname\"];  io:println(lastName); }    JSON Objects  JSON objects are represented as maps of JSON in Ballerina.  JSON object members could be of any JSON type: string, number, object, array, boolean, or null.    import ballerina/io;    public function main() {    json j = {name: \"apple\", color: \"red\", price: 100};  io:println(j.toJsonString());    Create a JSON object. A JSON object in Ballerina is equivalent to a map<json>.  Thus, the same can be written as  map<json> j = { name: \"apple\", color: \"red\", price: j2 };   io:println(\"j is map<json>: \", j is map<json>);    Since a JSON object is a map<json>, this type test evaluates to true.   json empty = {};    Create an empty JSON object. This is equivalent to an empty map<json>.   int age = 30;    json p = {fname: \"John\", lname: \"Stallone\", \"age\": age};  io:println(p.toJsonString());    Create a JSON object. Keys can be defined with or without quotes.  Values can be any json expression.   map<json> mp = <map<json>>p;  mp[\"age\"] = 31;  io:println(p.toJsonString());    You can add or change JSON object values using member access (i.e., the [expr] operator).  In order to change fields of an object value, it needs to be accessed  as a map<json>. This is done by casting p to map<json>.  Alternatively, p could have been defined as a map<json>.   map<json> p2 = {  fname: \"Peter\",  lname: \"Stallone\",  address: {  line: \"20 Palm Grove\",  city: \"Colombo 03\",  country: \"Sri Lanka\"  }  };  io:println(p2.toJsonString());    Create a nested JSON object.  This could also be defined as a json variable instead of map<json>.   json lastName = p2[\"lname\"];  io:println(lastName); }    Member access expressions with string keys can be used to access fields of a  mapping of json.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_objects.bal {\"name\":\"apple\", \"color\":\"red\", \"price\":100} j is map<json>: true {\"fname\":\"John\", \"lname\":\"Stallone\", \"age\":30} {\"fname\":\"John\", \"lname\":\"Stallone\", \"age\":31} {\"fname\":\"Peter\", \"lname\":\"Stallone\", \"address\":{\"line\":\"20 Palm Grove\", \"city\":\"Colombo 03\", \"country\":\"Sri Lanka\"}} Stallone    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-record-map-conversion.html","name":"JSON/Record/Map Conversion","summary":"Ballerina records, maps, and JSON objects are used to hold records.\n Records are collections of fields and each field value is accessed by a key.\n Converting from one type to another is very useful in certain situations.This is a Ballerina record definition.This example shows how you can convert a record ...","content":"/  /  /  / JSON/Record/Map Conversion  import ballerina/io;  // This is a Ballerina record definition. type Person record {  string fname;  string lname;  int age; };  type Movie record {  string title;  string year;  string released;  Person writer; };  public function main() {  Movie theRevenant = {  title: \"The Revenant\",  year: \"2015\",  released: \"08 Jan 2016\",  writer: {  fname: \"Michael\",  lname: \"Punke\",  age: 30  }  };  // This example shows how you can convert a record to a JSON object.  // This conversion could return an error because it may not be possible  // to convert some data types that are defined in the record to JSON.  json|error j = json.constructFrom(theRevenant);  if (j is json) {  io:println(j.toJsonString());  io:println(j.writer.lname);  }   // Similarly, you can convert a record to a map.  map<anydata>|error movieMap = map<anydata>.constructFrom(theRevenant);  if (movieMap is map<anydata>) {  Person|error writer = Person.constructFrom(movieMap[\"writer\"]);  if (writer is Person) {  io:println(writer.age);  }  }   // This example shows how you can convert a JSON object to a record.  // This conversion could return an error because the field names and // types are unknown until they are evaluated at runtime.  json inceptionJ = {  title: \"Inception\",  year: \"2010\",  released: \"16 Jul 2010\",  writer: {  fname: \"Christopher\",  lname: \"Nolan\",  age: 30  }  };  Movie|error inception = Movie.constructFrom(inceptionJ);  if (inception is Movie) {  io:println(inception);  } }    JSON/Record/Map Conversion  Ballerina records, maps, and JSON objects are used to hold records.  Records are collections of fields and each field value is accessed by a key.  Converting from one type to another is very useful in certain situations.    import ballerina/io;    type Person record {  string fname;  string lname;  int age; };    This is a Ballerina record definition.   type Movie record {  string title;  string year;  string released;  Person writer; };    public function main() {  Movie theRevenant = {  title: \"The Revenant\",  year: \"2015\",  released: \"08 Jan 2016\",  writer: {  fname: \"Michael\",  lname: \"Punke\",  age: 30  }  };    json|error j = json.constructFrom(theRevenant);  if (j is json) {  io:println(j.toJsonString());  io:println(j.writer.lname);  }    This example shows how you can convert a record to a JSON object.  This conversion could return an error because it may not be possible  to convert some data types that are defined in the record to JSON.   map<anydata>|error movieMap = map<anydata>.constructFrom(theRevenant);  if (movieMap is map<anydata>) {  Person|error writer = Person.constructFrom(movieMap[\"writer\"]);  if (writer is Person) {  io:println(writer.age);  }  }    Similarly, you can convert a record to a map.   json inceptionJ = {  title: \"Inception\",  year: \"2010\",  released: \"16 Jul 2010\",  writer: {  fname: \"Christopher\",  lname: \"Nolan\",  age: 30  }  };  Movie|error inception = Movie.constructFrom(inceptionJ);  if (inception is Movie) {  io:println(inception);  } }    This example shows how you can convert a JSON object to a record.  This conversion could return an error because the field names and  types are unknown until they are evaluated at runtime.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_record_map_conversion.bal {\"title\":\"The Revenant\", \"year\":\"2015\", \"released\":\"08 Jan 2016\", \"writer\":{\"fname\":\"Michael\", \"lname\":\"Punke\", \"age\":30}} Punke 30 title=Inception year=2010 released=16 Jul 2010 writer=fname=Christopher lname=Nolan age=30    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json-to-xml-conversion.html","name":"JSON to XML Conversion","summary":"JSON to XML conversions can be done using the xmlutils:fromJSON() function.\n This function takes a xmlutils:JsonOptions record as an argument.\n The JsonOptions record has two fields: the attributePrefix and the arrayEntryTag.\n The attributePrefix is a prefix that is used to identify the XML attributes.\n The default value of the attributePrefix ...","content":"/  /  /  / JSON to XML Conversion  import ballerina/io; import ballerina/xmlutils;  public function main() {  // Creates a JSON object.  json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  // Converts the JSON object to XML using the default `attributePrefix`  // and the default `arrayEntryTag`.  var x1 = xmlutils:fromJSON(j1);  io:println(x1);   json j2 = {  \"Store\": {  \"#id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };  // Converts the JSON object to XML using a custom `attributePrefix` (i.e., the `#` character)  // and the custom `arrayEntryTag` (i.e., `wrapper`).  var x2 = xmlutils:fromJSON(j2, {attributePrefix: \"#\", arrayEntryTag: \"wrapper\"});  io:println(x2); }    JSON to XML Conversion  JSON to XML conversions can be done using the xmlutils:fromJSON() function.  This function takes a xmlutils:JsonOptions record as an argument.  The JsonOptions record has two fields: the attributePrefix and the arrayEntryTag.  The attributePrefix is a prefix that is used to identify the XML attributes.  The default value of the attributePrefix option is @.  The arrayEntryTag is the name of the tag that is to be added to each entry of  the JSON array. The default value of the arrayEntryTag option is root.    import ballerina/io; import ballerina/xmlutils;    public function main() {    json j1 = {  \"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };    Creates a JSON object.   var x1 = xmlutils:fromJSON(j1);  io:println(x1);    Converts the JSON object to XML using the default attributePrefix  and the default arrayEntryTag.   json j2 = {  \"Store\": {  \"#id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }  };    var x2 = xmlutils:fromJSON(j2, {attributePrefix: \"#\", arrayEntryTag: \"wrapper\"});  io:println(x2); }    Converts the JSON object to XML using a custom attributePrefix (i.e., the # character)  and the custom arrayEntryTag (i.e., wrapper).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json_to_xml_conversion.bal <Store id=\"AST\"><name>Anne</name><address><street>Main</street><city>94</city></address><codes><root>4</root><root>8</root></codes></Store> <Store id=\"AST\"><name>Anne</name><address><street>Main</street><city>94</city></address><codes><wrapper>4</wrapper><wrapper>8</wrapper></codes></Store>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/jwt-issue-validate.html","name":"JWT Issue/Validate","summary":"This example demonstrates how to issue and validate a JWT.Defines the keystore.Defines the JWT keystore configurations.Defines the JWT header and sets the values.Defines the JWT payload and sets the values.Issues a JWT based on the provided header, payload and config.Defines the truststore.Defines the JWT validator configurations.Validates the created JWT.This website ...","content":"/  /  /  / JWT Issue/Validate  import ballerina/config; import ballerina/crypto; import ballerina/io; import ballerina/jwt; import ballerina/time;  public function main() {   // Defines the keystore.  crypto:KeyStore keyStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  };   // Defines the JWT keystore configurations.  jwt:JwtKeyStoreConfig keyStoreConfig = {  keyStore: keyStore,  keyAlias: \"ballerina\",  keyPassword: \"ballerina\"  };   // Defines the JWT header and sets the values.  jwt:JwtHeader header = {};  header.alg = jwt:RS256;  header.typ = \"JWT\";   // Defines the JWT payload and sets the values.  jwt:JwtPayload payload = {};  payload.sub = \"John\";  payload.iss = \"wso2\";  payload.jti = \"100078234ba23\";  payload.aud = [\"ballerina\", \"ballerinaSamples\"];  payload.exp = time:currentTime().time/1000 + 600;   // Issues a JWT based on the provided header, payload and config.  string|jwt:Error jwt = jwt:issueJwt(header, payload, keyStoreConfig);  if (jwt is string) {  io:println(\"Issued JWT: \", jwt);  } else {  io:println(\"An error occurred while issuing the JWT: \",  jwt.detail()?.message);  }   // Defines the truststore.  crypto:TrustStore trustStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  };   // Defines the JWT validator configurations.  jwt:JwtValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"ballerina\",  clockSkewInSeconds: 60,  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: trustStore  }  };   // Validates the created JWT.  jwt:JwtPayload|jwt:Error result = jwt:validateJwt(<string>jwt, validatorConfig);  if (result is jwt:JwtPayload) {  io:println(\"Validated JWT Payload: \", result);  } else {  io:println(\"An error occurred while validating the JWT: \",  result.detail()?.message);  } }    JWT Issue/Validate  This example demonstrates how to issue and validate a JWT.    import ballerina/config; import ballerina/crypto; import ballerina/io; import ballerina/jwt; import ballerina/time;    public function main() {    crypto:KeyStore keyStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  };    Defines the keystore.   jwt:JwtKeyStoreConfig keyStoreConfig = {  keyStore: keyStore,  keyAlias: \"ballerina\",  keyPassword: \"ballerina\"  };    Defines the JWT keystore configurations.   jwt:JwtHeader header = {};  header.alg = jwt:RS256;  header.typ = \"JWT\";    Defines the JWT header and sets the values.   jwt:JwtPayload payload = {};  payload.sub = \"John\";  payload.iss = \"wso2\";  payload.jti = \"100078234ba23\";  payload.aud = [\"ballerina\", \"ballerinaSamples\"];  payload.exp = time:currentTime().time/1000 + 600;    Defines the JWT payload and sets the values.   string|jwt:Error jwt = jwt:issueJwt(header, payload, keyStoreConfig);  if (jwt is string) {  io:println(\"Issued JWT: \", jwt);  } else {  io:println(\"An error occurred while issuing the JWT: \",  jwt.detail()?.message);  }    Issues a JWT based on the provided header, payload and config.   crypto:TrustStore trustStore = {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  };    Defines the truststore.   jwt:JwtValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"ballerina\",  clockSkewInSeconds: 60,  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: trustStore  }  };    Defines the JWT validator configurations.   jwt:JwtPayload|jwt:Error result = jwt:validateJwt(<string>jwt, validatorConfig);  if (result is jwt:JwtPayload) {  io:println(\"Validated JWT Payload: \", result);  } else {  io:println(\"An error occurred while validating the JWT: \",  result.detail()?.message);  } }    Validates the created JWT.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run jwt_issue_validate.bal --b7a.home=<ballerina_home_path> Issued JWT: eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ.eyJzdWIiOiJKb2huIiwgImlzcyI6IndzbzIiLCAiZXhwIjoxNTg2NDM3MzgwLCAianRpIjoiMTAwMDc4MjM0YmEyMyIsICJhdWQiOlsiYmFsbGVyaW5hIiwgImJhbGxlcmluYVNhbXBsZXMiXX0.H67rsDKLmZJacI1NKMlYl6cCROS-rsLfW3Z2INvvDyHrntNau0P8FFoIc98D_c7UPe_L1_uV3no0nWweoWvzqQB8wfvduB6wKNxb1KGprIUF0ilxveQN1Vzab2Mvd7SJCJ19tf6OcKort38C7ES0am5vsm0495OyaNVDAq3ixFP8WRacQW53b0ELc25QCYJJBLhjFBdXLpnx1boSjgS2vhTrg8bY8zlkoV3pJULfHmjS3JX0a_FBqqeB1yQqbIp1RxGrWzGg4nA6kPjGC1GwYvxjcCVQjY5PWWsd9GAeCnnvmFE_Xy6Xenq5lfL2RWWO4H3yF8x_8hcLS9XidERGWQ Validated JWT Payload: iss=wso2 sub=John aud=ballerina ballerinaSamples jti=100078234ba23 exp=1586437380 customClaims=    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/json.html","name":"JSON","summary":"JSON is a textual format for representing a collection of values:\n a simple value (string, number, “true”, “false”, “null”), an array of values, or an object.\n Ballerina has a single type named json that can represent any JSON value.\n Thus, json is a built-in union type in Ballerina that can ...","content":"/  /  /  / JSON  import ballerina/io;  public function main() {  // Create a JSON string value.  json j1 = \"Apple\";  io:println(j1);   // Create a JSON number value.  json j2 = 5.36;  io:println(j2);   // Create a JSON true value.  json j3 = true;  io:println(j3);   // Create a JSON false value.  json j4 = false;  io:println(j4);   // Create a JSON null value.  json j5 = null;   // Creates a JSON Object. This is equivalent to a `map<json>`.  json j6 = {name: \"apple\", color: \"red\", price: j2};  io:println(j6);   // The `.toJsonString()` defined for `json` values returns a `string` that  // represents the value in JSON format.  io:println(j6.toJsonString());   // Create a JSON Array. This is equivalent to a `json[]`.  json j7 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j7.toJsonString());   // The `.mergeJson()` method can be used to merge two `json` values.  // If either of the two values is `null`, the result of `.mergeJson()` is  // the other value.  json j8 = checkpanic j5.mergeJson(j7);  io:println(j8.toJsonString());   // `.mergeJson()` can also be used to merge two JSON objects.  // Where both `json` values are mappings, for each entry in the second,  // if an entry is not present in the first by the same key, the entry  // is added to the first mapping. If there is already a field by the same  // key in the first mapping, `.mergeJson()` is called recursively.  json j9 = {name: \"Anne\", age: null, marks: {math: 90, language: 95}};  json j10 = {name: (), age: 20, marks: {physics: 85}};  json j11 = checkpanic j9.mergeJson(j10);  io:println(j11.toJsonString());   // Reference equality checks between `j9` and `j11` evaluate to true since  // the `j9` itself is updated and returned if the merge is successful.  io:println(j9 === j11);   // `.mergeJson()` returns an `error` if the values cannot be merged.  // For example, attempting to merge a mapping value with a non-mapping value  // or two non-mapping values where neither is `null`.  json|error j12 = j2.mergeJson(j3);  io:println(j12);   // The `.fromJsonString()` defined on `string` values attempts parsing the  // string expected to be in the JSON format and returns the represented JSON value // if successful. This method returns an error if the string cannot be parsed.  string s = j6.toJsonString();  json j13 = checkpanic s.fromJsonString();  io:println(j13.toJsonString());   // The value would be equal to the original value from which the string  // was created.  io:println(j6 == j13); }    JSON  JSON is a textual format for representing a collection of values:  a simple value (string, number, “true”, “false”, “null”), an array of values, or an object.  Ballerina has a single type named json that can represent any JSON value.  Thus, json is a built-in union type in Ballerina that can contain values of the types  nil (as the null value), boolean, int, float, decimal, string, json[], and map<json>.    import ballerina/io;    public function main() {    json j1 = \"Apple\";  io:println(j1);    Create a JSON string value.   json j2 = 5.36;  io:println(j2);    Create a JSON number value.   json j3 = true;  io:println(j3);    Create a JSON true value.   json j4 = false;  io:println(j4);    Create a JSON false value.   json j5 = null;    Create a JSON null value.   json j6 = {name: \"apple\", color: \"red\", price: j2};  io:println(j6);    Creates a JSON Object. This is equivalent to a map<json>.   io:println(j6.toJsonString());    The .toJsonString() defined for json values returns a string that  represents the value in JSON format.   json j7 = [1, false, null, \"foo\", {first: \"John\", last: \"Pala\"}];  io:println(j7.toJsonString());    Create a JSON Array. This is equivalent to a json[].   json j8 = checkpanic j5.mergeJson(j7);  io:println(j8.toJsonString());    The .mergeJson() method can be used to merge two json values.  If either of the two values is null, the result of .mergeJson() is  the other value.   json j9 = {name: \"Anne\", age: null, marks: {math: 90, language: 95}};  json j10 = {name: (), age: 20, marks: {physics: 85}};  json j11 = checkpanic j9.mergeJson(j10);  io:println(j11.toJsonString());    .mergeJson() can also be used to merge two JSON objects.  Where both json values are mappings, for each entry in the second,  if an entry is not present in the first by the same key, the entry  is added to the first mapping. If there is already a field by the same  key in the first mapping, .mergeJson() is called recursively.   io:println(j9 === j11);    Reference equality checks between j9 and j11 evaluate to true since  the j9 itself is updated and returned if the merge is successful.   json|error j12 = j2.mergeJson(j3);  io:println(j12);    .mergeJson() returns an error if the values cannot be merged.  For example, attempting to merge a mapping value with a non-mapping value  or two non-mapping values where neither is null.   string s = j6.toJsonString();  json j13 = checkpanic s.fromJsonString();  io:println(j13.toJsonString());    The .fromJsonString() defined on string values attempts parsing the  string expected to be in the JSON format and returns the represented JSON value  if successful. This method returns an error if the string cannot be parsed.   io:println(j6 == j13); }    The value would be equal to the original value from which the string  was created.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run json.bal Apple 5.36 true false name=apple color=red price=5.36 {\"name\":\"apple\", \"color\":\"red\", \"price\":5.36} [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] [1, false, null, \"foo\", {\"first\":\"John\", \"last\":\"Pala\"}] {\"name\":\"Anne\", \"age\":20, \"marks\":{\"math\":90, \"language\":95, \"physics\":85}} true error {ballerina/lang.value}MergeJsonError message=Cannot merge JSON values of types 'float' and 'boolean' {\"name\":\"apple\", \"color\":\"red\", \"price\":5.36} true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-authentication-sasl-plain-consumer.html","name":"SASL Authentication - Consumer","summary":"Here, is an example of a Kafka consumer using SASL/PLAIN authentication.\n For this example to work properly, an active Kafka server must be present\n and it should be configured to use the SASL/PLAIN authentication mechanism.The kafka:AuthenticationConfiguration is used to provide authentication-related details.Provide the authentication mechanism used by the Kafka server.Username ...","content":"/  /  /  / SASL Authentication - Consumer  import ballerina/kafka; import ballerina/log;  // The `kafka:AuthenticationConfiguration` is used to provide authentication-related details. kafka:AuthenticationConfiguration authConfig = {  // Provide the authentication mechanism used by the Kafka server.  mechanism: kafka:AUTH_SASL_PLAIN,  // Username and password should be set here in order to authenticate the consumer.  // Check Ballerina `config` APIs to see how to use encrypted values instead of plain text values here.  username: \"ballerina\",  password: \"ballerina-secret\" };  kafka:ConsumerConfiguration consumerConfig = {  bootstrapServers:\"localhost:9092\",  groupId:\"test-group\",  clientId: \"sasl-consumer\",  offsetReset:\"earliest\",  topics:[\"topic-sasl\"],  valueDeserializerType: kafka:DES_STRING,  // Provide the relevant authentication configuration record to authenticate the consumer.  authenticationConfiguration: authConfig };  listener kafka:Consumer consumer = new(consumerConfig);  service KafkaService on consumer {  resource function onMessage(kafka:Consumer consumer, kafka:ConsumerRecord[] records) {  foreach var consumerRecord in records {  string value = <string> consumerRecord.value;  log:printInfo(value);  }  } }    SASL Authentication - Consumer  Here, is an example of a Kafka consumer using SASL/PLAIN authentication.  For this example to work properly, an active Kafka server must be present  and it should be configured to use the SASL/PLAIN authentication mechanism.    import ballerina/kafka; import ballerina/log;    kafka:AuthenticationConfiguration authConfig = {    The kafka:AuthenticationConfiguration is used to provide authentication-related details.   mechanism: kafka:AUTH_SASL_PLAIN,    Provide the authentication mechanism used by the Kafka server.   username: \"ballerina\",  password: \"ballerina-secret\" };    Username and password should be set here in order to authenticate the consumer.  Check Ballerina config APIs to see how to use encrypted values instead of plain text values here.   kafka:ConsumerConfiguration consumerConfig = {  bootstrapServers:\"localhost:9092\",  groupId:\"test-group\",  clientId: \"sasl-consumer\",  offsetReset:\"earliest\",  topics:[\"topic-sasl\"],  valueDeserializerType: kafka:DES_STRING,    authenticationConfiguration: authConfig };    Provide the relevant authentication configuration record to authenticate the consumer.   listener kafka:Consumer consumer = new(consumerConfig);    service KafkaService on consumer {  resource function onMessage(kafka:Consumer consumer, kafka:ConsumerRecord[] records) {  foreach var consumerRecord in records {  string value = <string> consumerRecord.value;  log:printInfo(value);  }  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_authentication_sasl_plain_consumer.bal    # The following lines will be printed in the Console when consumer starts. # If the consumer connected successfully, it will start to receive messages # from the subscribed topic(s). [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: topic-sasl [ballerina/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-authentication-sasl-plain-producer.html","name":"SASL Authentication - Producer","summary":"Here, is an example of a Kafka producer using SASL/PLAIN authentication.\n For this example to work properly, an active Kafka server must be present\n and it should be configured to use the SASL/PLAIN authentication mechanism.The kafka:AuthenticationConfiguration is used to provide authentication-related details.Provide the authentication mechanism used by the Kafka server.Username ...","content":"/  /  /  / SASL Authentication - Producer  import ballerina/io; import ballerina/kafka;  // The `kafka:AuthenticationConfiguration` is used to provide authentication-related details. kafka:AuthenticationConfiguration authConfig = {  // Provide the authentication mechanism used by the Kafka server.  mechanism: kafka:AUTH_SASL_PLAIN,  // Username and password should be set here in order to authenticate the producer.  // Check Ballerina `config` APIs to see how to use encrypted values instead of plain text values here.  username: \"ballerina\",  password: \"ballerina-secret\" };  kafka:ProducerConfiguration producerConfigs = {  bootstrapServers: \"localhost:9092\",  valueSerializerType: kafka:SER_STRING,  // Provide the relevant authentication configuration record to authenticate the producer.  authenticationConfiguration: authConfig };  kafka:Producer kafkaProducer = new (producerConfigs);  public function main() {  var result = kafkaProducer->send(\"Hello from Ballerina\", \"topic-sasl\");  if (result is error) {  io:println(result);  } else {  io:println(\"success\");  } }    SASL Authentication - Producer  Here, is an example of a Kafka producer using SASL/PLAIN authentication.  For this example to work properly, an active Kafka server must be present  and it should be configured to use the SASL/PLAIN authentication mechanism.    import ballerina/io; import ballerina/kafka;    kafka:AuthenticationConfiguration authConfig = {    The kafka:AuthenticationConfiguration is used to provide authentication-related details.   mechanism: kafka:AUTH_SASL_PLAIN,    Provide the authentication mechanism used by the Kafka server.   username: \"ballerina\",  password: \"ballerina-secret\" };    Username and password should be set here in order to authenticate the producer.  Check Ballerina config APIs to see how to use encrypted values instead of plain text values here.   kafka:ProducerConfiguration producerConfigs = {  bootstrapServers: \"localhost:9092\",  valueSerializerType: kafka:SER_STRING,    authenticationConfiguration: authConfig };    Provide the relevant authentication configuration record to authenticate the producer.   kafka:Producer kafkaProducer = new (producerConfigs);    public function main() {  var result = kafkaProducer->send(\"Hello from Ballerina\", \"topic-sasl\");  if (result is error) {  io:println(result);  } else {  io:println(\"success\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_authentication_sasl_plain_producer.bal    # If the producer is authenticated and the message sent successfully, # following message will be printed in the console. Message successfully sent.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-consumer-client.html","name":"Consumer Client","summary":"This is an example on how to use a kafka:Consumer as a simple record\n consumer. The records from a subscribed topic can be retrieved using the\n poll() function.\n This consumer uses the builtin byte array deserializer for both the key and\n the value, which is the default deserializer in the ...","content":"/  /  /  / Consumer Client  import ballerina/io; import ballerina/kafka; import ballerina/lang.'string; import ballerina/log;  kafka:ConsumerConfiguration consumerConfiguration = {  // The `bootstrapServers` is the list of remote server endpoints of the  // Kafka brokers.  bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  offsetReset: \"earliest\",  // Subscribes to the topic `test-kafka-topic`.  topics: [\"test-kafka-topic\"] };  kafka:Consumer consumer = new (consumerConfiguration);  public function main() {  // Poll the consumer for messages.  var results = consumer->poll(1000);  if (results is error) {  log:printError(\"Error occurred while polling \", results);  }  kafka:ConsumerRecord[] records = <kafka:ConsumerRecord[]>results;  foreach var kafkaRecord in records {  anydata serializedMessage = kafkaRecord.value;  if (serializedMessage is byte[]) {  // Converts byte[] to string.  string|error message = 'string:fromBytes(serializedMessage);  if (message is string) {  // Prints the retrieved Kafka record.  io:println(\"Topic: \", kafkaRecord.topic, \" Received Message: \",  message);  } else {  log:printError(\"Error occurred while converting message data\",  message);  }  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  }  } }    Consumer Client  This is an example on how to use a kafka:Consumer as a simple record  consumer. The records from a subscribed topic can be retrieved using the  poll() function.  This consumer uses the builtin byte array deserializer for both the key and  the value, which is the default deserializer in the kafka:Consumer. For  this example to work properly, an active Kafka broker should be present.    import ballerina/io; import ballerina/kafka; import ballerina/lang.'string; import ballerina/log;    kafka:ConsumerConfiguration consumerConfiguration = {    bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  offsetReset: \"earliest\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   topics: [\"test-kafka-topic\"] };    Subscribes to the topic test-kafka-topic.   kafka:Consumer consumer = new (consumerConfiguration);    public function main() {    var results = consumer->poll(1000);  if (results is error) {  log:printError(\"Error occurred while polling \", results);  }  kafka:ConsumerRecord[] records = <kafka:ConsumerRecord[]>results;  foreach var kafkaRecord in records {  anydata serializedMessage = kafkaRecord.value;  if (serializedMessage is byte[]) {    Poll the consumer for messages.   string|error message = 'string:fromBytes(serializedMessage);  if (message is string) {    Converts byte[] to string.   io:println(\"Topic: \", kafkaRecord.topic, \" Received Message: \",  message);  } else {  log:printError(\"Error occurred while converting message data\",  message);  }  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  }  } }    Prints the retrieved Kafka record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_message_consumer_simple.bal    # Then it will print the following lines in the Console, and the # received messages if there's any. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-group-service.html","name":"Consumer Groups","summary":"Here, is an example of a kafka consumer used as a listener to listen to a\n given topic/topics. The listener uses a group of concurrent consumers within\n the service. This consumer uses the builtin string deserializer for the\n values. For this example to work properly, an active Kafka broker should ...","content":"/  /  /  / Consumer Groups  import ballerina/kafka; import ballerina/log;  kafka:ConsumerConfiguration consumerConfigs = {  // The `bootstrapServers` is the list of remote server endpoints of the  // Kafka brokers.  bootstrapServers: \"localhost:9092\",  // Using two concurrent consumers to work as a group.  concurrentConsumers: 2,  groupId: \"group-id\",  // Subscribes to the topic `test-kafka-topic`.  topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,  // Uses the default string deserializer to deserialize the Kafka value.  valueDeserializerType: kafka:DES_STRING };  listener kafka:Consumer consumer = new (consumerConfigs);  service kafkaService on consumer {  // This resource executes when a message or a set of messages are published  // to the subscribed topic/topics.  resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {  // The set of Kafka records dispatched to the service are processed one  // by one.  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }  function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata message = kafkaRecord.value;  if (message is string) {  // Prints the retrieved Kafka record.  log:printInfo(\"Topic: \" + kafkaRecord.topic + \" Partition: \" +  kafkaRecord.partition.toString() + \" Received Message: \" + message);  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  } }    Consumer Groups  Here, is an example of a kafka consumer used as a listener to listen to a  given topic/topics. The listener uses a group of concurrent consumers within  the service. This consumer uses the builtin string deserializer for the  values. For this example to work properly, an active Kafka broker should be  present.    import ballerina/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {    bootstrapServers: \"localhost:9092\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   concurrentConsumers: 2,  groupId: \"group-id\",    Using two concurrent consumers to work as a group.   topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,    Subscribes to the topic test-kafka-topic.   valueDeserializerType: kafka:DES_STRING };    Uses the default string deserializer to deserialize the Kafka value.   listener kafka:Consumer consumer = new (consumerConfigs);    service kafkaService on consumer {    resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {    This resource executes when a message or a set of messages are published  to the subscribed topic/topics.   foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }    The set of Kafka records dispatched to the service are processed one  by one.   function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata message = kafkaRecord.value;  if (message is string) {    log:printInfo(\"Topic: \" + kafkaRecord.topic + \" Partition: \" +  kafkaRecord.partition.toString() + \" Received Message: \" + message);  } else {  log:printError(\"Error occurred while retrieving message data;\" +  \"Unexpected type\");  } }    Prints the retrieved Kafka record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_message_consumer_group_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic [ballerina/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-consumer-service.html","name":"Consumer Service","summary":"Here, is an example in which we create a Kafka consumer used as a listener\n to a service with manual offset commits.\n This consumer uses the builtin int deserializer for the keys and the\n builtin string deserializer for the values. For this example to work\n properly, an active Kafka broker ...","content":"/  /  /  / Consumer Service  import ballerina/kafka; import ballerina/log;  kafka:ConsumerConfiguration consumerConfigs = {  // The `bootstrapServers` is the list of remote server endpoints of the  // Kafka brokers.  bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",  // Subscribes to the topic `test-kafka-topic`.  topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,  // Uses the default int deserializer for the keys.  keyDeserializerType: kafka:DES_INT,  // Uses the default string deserializer for the values.  valueDeserializerType: kafka:DES_STRING,  // Set `autoCommit` to false, so that the records should be committed  // manually.  autoCommit: false };  listener kafka:Consumer consumer = new (consumerConfigs);  service kafkaService on consumer {  // This resource will be executed when a message is published to the  // subscribed topic/topics.  resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {  // The set of Kafka records dispatched to the service are processed one  // by one.  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  // Commit offsets for returned records by marking them as consumed.  var commitResult = kafkaConsumer->commit();  if (commitResult is error) {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", commitResult);  }  } }  function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata value = kafkaRecord.value;  anydata key = kafkaRecord.key;  // The value should be a `string`, since the string deserializer is used  // for the value.  if (value is string) {  // The key should be an `int`, since the int deserializer is used for  // the key.  if (key is int) {  // Prints the received Kafka record.  log:printInfo(\"Topic: \" + kafkaRecord.topic);  log:printInfo(\"Partition: \" + kafkaRecord.partition.toString());  log:printInfo(\"Key: \" + key.toString());  log:printInfo(\"Value: \" + value);  } else {  log:printError(\"Invalid key type received\");  }  } else {  log:printError(\"Invalid value type received\");  } }    Consumer Service  Here, is an example in which we create a Kafka consumer used as a listener  to a service with manual offset commits.  This consumer uses the builtin int deserializer for the keys and the  builtin string deserializer for the values. For this example to work  properly, an active Kafka broker should be present.    import ballerina/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {    bootstrapServers: \"localhost:9092\",  groupId: \"group-id\",    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   topics: [\"test-kafka-topic\"],  pollingIntervalInMillis: 1000,    Subscribes to the topic test-kafka-topic.   keyDeserializerType: kafka:DES_INT,    Uses the default int deserializer for the keys.   valueDeserializerType: kafka:DES_STRING,    Uses the default string deserializer for the values.   autoCommit: false };    Set autoCommit to false, so that the records should be committed  manually.   listener kafka:Consumer consumer = new (consumerConfigs);    service kafkaService on consumer {    resource function onMessage(kafka:Consumer kafkaConsumer,  kafka:ConsumerRecord[] records) {    This resource will be executed when a message is published to the  subscribed topic/topics.   foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }    The set of Kafka records dispatched to the service are processed one  by one.   var commitResult = kafkaConsumer->commit();  if (commitResult is error) {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", commitResult);  }  } }    Commit offsets for returned records by marking them as consumed.   function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  anydata value = kafkaRecord.value;  anydata key = kafkaRecord.key;    if (value is string) {    The value should be a string, since the string deserializer is used  for the value.   if (key is int) {    The key should be an int, since the int deserializer is used for  the key.   log:printInfo(\"Topic: \" + kafkaRecord.topic);  log:printInfo(\"Partition: \" + kafkaRecord.partition.toString());  log:printInfo(\"Key: \" + key.toString());  log:printInfo(\"Value: \" + value);  } else {  log:printError(\"Invalid key type received\");  }  } else {  log:printError(\"Invalid value type received\");  } }    Prints the received Kafka record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_message_consumer_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerina/kafka] kafka servers: localhost:9092 [ballerina/kafka] subscribed topics: test-kafka-topic [ballerina/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-producer-transactional.html","name":"Transactional Producer","summary":"This example shows you how to do transactional message producing by sending\n messages to kafka brokers atomically using the kafka:Producer object. For\n this example to work properly, an active Kafka broker should be present.The bootstrapServers is the list of remote server endpoints of the\n Kafka brokers.The enableIdempotence should set to ...","content":"/  /  /  / Transactional Producer  import ballerina/io; import ballerina/kafka;  kafka:ProducerConfiguration producerConfigs = {  // The `bootstrapServers` is the list of remote server endpoints of the  // Kafka brokers.  bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  // The `enableIdempotence` should set to `true` to make a producer  // transactional.  enableIdempotence: true,  // A `transactionalId` must be provided to make a producer transactional.  transactionalId: \"test-transactional-id\" };  kafka:Producer kafkaProducer = new (producerConfigs);  public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();   // Here, we create a producer config with optional parameters.  // transactional.id - enable transactional message production.  kafkaAdvancedTransactionalProduce(serializedMessage); }  function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\",  partition = 0);  if (sendResult is error) {  io:println(\"Kafka producer failed to send first message\",  sendResult.toString());  }  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    Transactional Producer  This example shows you how to do transactional message producing by sending  messages to kafka brokers atomically using the kafka:Producer object. For  this example to work properly, an active Kafka broker should be present.    import ballerina/io; import ballerina/kafka;    kafka:ProducerConfiguration producerConfigs = {    bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   enableIdempotence: true,    The enableIdempotence should set to true to make a producer  transactional.   transactionalId: \"test-transactional-id\" };    A transactionalId must be provided to make a producer transactional.   kafka:Producer kafkaProducer = new (producerConfigs);    public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();    kafkaAdvancedTransactionalProduce(serializedMessage); }    Here, we create a producer config with optional parameters.  transactional.id - enable transactional message production.   function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\",  partition = 0);  if (sendResult is error) {  io:println(\"Kafka producer failed to send first message\",  sendResult.toString());  }  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run --experimental kafka_message_producer_transactional.bal    # If the producer successfully sent the message, the following will be printed # in the Console. 2020-03-26 13:57:29,129 INFO [ballerina/transactions] - Created transaction: 6cfac3a7-a8a2-4220-944e-dfbd6d27910f 2020-03-26 13:57:29,184 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 6cfac3a7-a8a2-4220-944e-dfbd6d27910f:$anon$.$0 Transaction committed    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kafka-producer.html","name":"Producer","summary":"This is an example on how to send messages to a Kafka topic using a\n kafka:Producer object. The producer is configured to send string\n values and int keys. For this example to work properly, an active Kafka\n broker should be present.The bootstrapServers is the list of remote server endpoints of ...","content":"/  /  /  / Producer  import ballerina/io; import ballerina/kafka;  kafka:ProducerConfiguration producerConfiguration = {  // The `bootstrapServers` is the list of remote server endpoints of the  // Kafka brokers.  bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  // Uses the builtin string serializer for the values.  valueSerializerType: kafka:SER_STRING,  // Uses the builtin int serializer for the keys.  keySerializerType: kafka:SER_INT };  kafka:Producer kafkaProducer = new (producerConfiguration);  public function main() {  string message = \"Hello World, Ballerina\";  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\", key = 1);  if (sendResult is error) {  io:println(\"Error occurred while sending data: \" + sendResult.toString());  } else {  io:println(\"Message sent successfully.\");  }  var flushResult = kafkaProducer->flushRecords();  if (flushResult is error) {  io:println(\"Error occurred while flishing the data: \" + flushResult.toString());  } else {  io:println(\"Records were flushed successfully.\");  } }    Producer  This is an example on how to send messages to a Kafka topic using a  kafka:Producer object. The producer is configured to send string  values and int keys. For this example to work properly, an active Kafka  broker should be present.    import ballerina/io; import ballerina/kafka;    kafka:ProducerConfiguration producerConfiguration = {    bootstrapServers: \"localhost:9092\",  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,    The bootstrapServers is the list of remote server endpoints of the  Kafka brokers.   valueSerializerType: kafka:SER_STRING,    Uses the builtin string serializer for the values.   keySerializerType: kafka:SER_INT };    Uses the builtin int serializer for the keys.   kafka:Producer kafkaProducer = new (producerConfiguration);    public function main() {  string message = \"Hello World, Ballerina\";  var sendResult = kafkaProducer->send(message, \"test-kafka-topic\", key = 1);  if (sendResult is error) {  io:println(\"Error occurred while sending data: \" + sendResult.toString());  } else {  io:println(\"Message sent successfully.\");  }  var flushResult = kafkaProducer->flushRecords();  if (flushResult is error) {  io:println(\"Error occurred while flishing the data: \" + flushResult.toString());  } else {  io:println(\"Records were flushed successfully.\");  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run kafka_message_producer_simple.bal    # If the producer successfully sent the message, the following will be printed # in the Console. Message sent successfully. Records were flushed successfully.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/knative-deployment.html","name":"Knative Deployment","summary":"Ballerina supports generating Knative Serivces artifacts based on annotations.\nArtifacts will be generated by adding the @knative:Service annotation to the HTTP service.Add the @knative:Service to a Ballerina service to generate a Knative Service artifact and push the Docker image to Docker Hub.Enable pushing the Docker image.Set the name of the Docker ...","content":"/  /  /  / Knative Deployment  import ballerina/http; import ballerina/knative; import ballerina/log;  //Add the `@knative:Service` to a Ballerina service to generate a Knative Service artifact and push the Docker image to Docker Hub. @knative:Service {  //Enable pushing the Docker image.  push: true,  //Set the name of the Docker image.  name: \"hello-world-knative\",  //Sets the username credential to push the Docker image using the `DOCKER_USERNAME` environment variable.  username: \"$env{DOCKER_USERNAME}\",  //Sets the password credential to push the Docker image using the `DOCKER_PASSWORD` environment variable.  password: \"$env{DOCKER_PASSWORD}\",  //Setting the registry URL.  registry: \"index.docker.io/$env{DOCKER_USERNAME}\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on new http:Listener(8080) {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello, World from service helloWorld ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }    Knative Deployment  Ballerina supports generating Knative Serivces artifacts based on annotations. Artifacts will be generated by adding the @knative:Service annotation to the HTTP service.    import ballerina/http; import ballerina/knative; import ballerina/log;    @knative:Service {    Add the @knative:Service to a Ballerina service to generate a Knative Service artifact and push the Docker image to Docker Hub.   push: true,    Enable pushing the Docker image.   name: \"hello-world-knative\",    Set the name of the Docker image.   username: \"$env{DOCKER_USERNAME}\",    Sets the username credential to push the Docker image using the DOCKER_USERNAME environment variable.   password: \"$env{DOCKER_PASSWORD}\",    Sets the password credential to push the Docker image using the DOCKER_PASSWORD environment variable.   registry: \"index.docker.io/$env{DOCKER_USERNAME}\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on new http:Listener(8080) {  resource function sayHello(http:Caller outboundEP, http:Request request) {  http:Response response = new;  response.setTextPayload(\"Hello, World from service helloWorld ! \\n\");  var responseResult = outboundEP->respond(response);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }    Setting the registry URL.   # Build the Ballerina program. $ ballerina build knative_deployment.bal Compiling source \tknative_deployment.bal    Generating executables \tknative_deployment.jar    Generating Knative artifacts...    @knative:Service - complete 1/1 \t@knative:Docker - complete 3/3    Run the following command to deploy the Knative artifacts: \tkubectl apply -f ./kubernetes    Run the following command to install the application using Helm: \thelm install --name hello-world-knative ./kubernetes/hello-world-knative    # Verify if the Docker image is generated. $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE knative_deployment latest 85933f1c05b0 3 minutes ago 133MB    # Apply the Knative artifacts. $ kubectl apply -f ./kubernetes/ service.serving.knative.dev/hello-world-knative created    # Wait for the `hello-world-knative` route to be ready. $ watch -n 1 kubectl get pod,revision,route NAME READY STATUS RESTARTS AGE pod/hello-world-knative-dd6nk-deployment-5694769c7d-nzvts 2/2 Running 0 12s    NAME CONFIG NAME K8S SERVICE NAME GENERATION READY REASON revision.serving.knative.dev/hello-world-knative-dd6nk hello-world-knative hello-world-knative-dd6nk 1 True    NAME URL READY REASON route.serving.knative.dev/hello-world-knative http://hello-world-knative.default.example.com True    # Add DNS mapping for the `hello-world-knative` route's URL. $ sudo vim /etc/hosts 127.0.0.1 hello-world-knative.default.example.com    # Access the service. $ curl -kv http://hello-world-knative.default.example.com/helloWorld/sayHello Hello, World from service helloWorld !    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/kubernetes-deployment.html","name":"Kubernetes Deployment","summary":"Ballerina supports generating Kubernetes artifacts based on annotations.\nA single Ballerina module is mapped to a single Kubernetes deployment.\nMinikube or Docker for Mac/Windows should be configured and\nKubernetes should be enabled to run the example.\nThis example deploys an HTTPS service, which retrieves values from a config file to Kubernetes.\nBefore running the sample, ...","content":"/  /  /  / Kubernetes Deployment  import ballerina/config; import ballerina/http; import ballerina/log; import ballerina/kubernetes;  //Add the `@kubernetes:Service` to a listener endpoint to expose the endpoint as a Kubernetes Service. @kubernetes:Service {  //Service type is `NodePort`.  serviceType: \"NodePort\" } //Add the `@kubernetes:Ingress` to a listener endpoint to expose the endpoint as a Kubernetes Ingress. @kubernetes:Ingress {  //Hostname of the service is `abc.com`.  hostname: \"abc.com\" } listener http:Listener helloWorldEP = new(9090, config = {  //Ballerina automatically creates Kubernetes secrets for the keystore and truststore when the `@kubernetes:Service`  //annotation is added to the endpoint.  secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: \"./security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  //Add the `@kubernetes:ConfigMap` annotation to a Ballerina service to mount configs to the container. @kubernetes:ConfigMap {  //Path to the ballerina.conf file.  //If a releative path is provided, the path should be releative to where the `ballerina build` command is executed.  conf: \"./ballerina.conf\" } //Add the `@kubernetes:Deployment` annotation to a Ballerna service to generate Kuberenetes Deployment for a Ballerina module. @kubernetes:Deployment {  //Enable Kubernetes liveness probe to this service.  livenessProbe: true,  //Generate a Docker image with the name `kubernetes:v1.0`.  image: \"kubernetes:v.1.0\"  //If you are using minikube, uncomment and change the following values accordingly.  ////dockerHost:\"tcp://<minikube IP>:2376\",  ////dockerCertPath:\"<HOME_DIRECTORY>/.minikube/certs\" } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/config/{user}\"  }  resource function getConfig(http:Caller outboundEP, http:Request request, string user) {  string userId = getConfigValue(user, \"userid\");  string groups = getConfigValue(user, \"groups\");  json payload = {  userId: userId,  groups: groups  };  var responseResult = outboundEP->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }  function getConfigValue(string instanceId, string property) returns (string) {  string key = <@untainted string> (instanceId + \".\" + property);  return config:getAsString(key, \"Invalid User\"); }    Kubernetes Deployment  Ballerina supports generating Kubernetes artifacts based on annotations. A single Ballerina module is mapped to a single Kubernetes deployment. Minikube or Docker for Mac/Windows should be configured and Kubernetes should be enabled to run the example. This example deploys an HTTPS service, which retrieves values from a config file to Kubernetes. Before running the sample, create a directory named security inside current working directory from where the ballerina build command will be issued. Then, copy the to the security folder. For more information, see the .    import ballerina/config; import ballerina/http; import ballerina/log; import ballerina/kubernetes;    @kubernetes:Service {    Add the @kubernetes:Service to a listener endpoint to expose the endpoint as a Kubernetes Service.   serviceType: \"NodePort\" }    Service type is NodePort.   @kubernetes:Ingress {    Add the @kubernetes:Ingress to a listener endpoint to expose the endpoint as a Kubernetes Ingress.   hostname: \"abc.com\" } listener http:Listener helloWorldEP = new(9090, config = {    Hostname of the service is abc.com.   secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: \"./security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    Ballerina automatically creates Kubernetes secrets for the keystore and truststore when the @kubernetes:Service annotation is added to the endpoint.   @kubernetes:ConfigMap {    Add the @kubernetes:ConfigMap annotation to a Ballerina service to mount configs to the container.   conf: \"./ballerina.conf\" }    Path to the ballerina.conf file. If a releative path is provided, the path should be releative to where the ballerina build command is executed.   @kubernetes:Deployment {    Add the @kubernetes:Deployment annotation to a Ballerna service to generate Kuberenetes Deployment for a Ballerina module.   livenessProbe: true,    Enable Kubernetes liveness probe to this service.   image: \"kubernetes:v.1.0\"    Generate a Docker image with the name kubernetes:v1.0.   } @http:ServiceConfig {  basePath: \"/helloWorld\" } service helloWorld on helloWorldEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/config/{user}\"  }  resource function getConfig(http:Caller outboundEP, http:Request request, string user) {  string userId = getConfigValue(user, \"userid\");  string groups = getConfigValue(user, \"groups\");  json payload = {  userId: userId,  groups: groups  };  var responseResult = outboundEP->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    If you are using minikube, uncomment and change the following values accordingly. //dockerHost:“tcp://:2376”, //dockerCertPath:”/.minikube/certs”   function getConfigValue(string instanceId, string property) returns (string) {  string key = <@untainted string> (instanceId + \".\" + property);  return config:getAsString(key, \"Invalid User\"); }    # Create a `ballerina.conf` file with the following content in the same directory, which contains the kubernetes_deployment.bal file. [john] userid=\"john@ballerina.com\" groups=\"apim,esb\" [jane] userid=\"jane3@ballerina.com\" groups=\"esb\"    # Build the ballerina program $ ballerina build kubernetes_deployment.bal Compiling source \tkubernetes_deployment.bal Generating executables \tkubernetes_deployment.jar    Generating artifacts...    @kubernetes:Service - complete 1/1 \t@kubernetes:Ingress - complete 1/1 \t@kubernetes:ConfigMap - complete 1/1 \t@kubernetes:Deployment - complete 1/1 \t@kubernetes:Docker - complete 2/2 @kubernetes:Helm - complete 1/1    Run the following command to deploy the Kubernetes artifacts: kubectl apply -f ./kubernetes    Run the following command to install the application using Helm: helm install --name kubernetes-deployment-deployment ./kubernetes/kubernetes-deployment-deployment    # Verify the Docker image is generated $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE kubernetes v1.0 6c0a26a62545 2 seconds ago 127MB    # Apply the Kubernetes artifacts. $ kubectl apply -f ./kubernetes/ service/helloworldep-svc created ingress.extensions/helloworldep-ingress created secret/helloworldep-secure-socket created configmap/helloworld-ballerina-conf-config-map created deployment.extensions/kubernetes-deployment-deployment created    # Verify if the service, pods, & config-maps are deployed $ kubectl get pods NAME READY STATUS RESTARTS AGE kubernetes-deployment-5858fd78d4-lnz8n 1/1 Running 0 20s    $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE helloworldep-svc NodePort 10.109.125.193 <none> 9090:32417/TCP 1m    $ kubectl get cm NAME DATA AGE helloworld-ballerina-conf-config-map 1 5m    # Access the service # Change the port <32417> to Nodeport of the service. $ curl https://localhost:<32417>/helloWorld/config/jane -k {userId: jane3@ballerina.com, groups: esb}    $ curl https://localhost:<32417>/helloWorld/config/john -k {userId: john@ballerina.com, groups: apim,esb}    # If you are using minikube, IP address should be changed according to the output of the `minikube ip` command. $ minikube ip 192.168.99.100    $ curl https://192.168.99.100:<32417>/helloWorld/config/jane -k {userId: jane3@ballerina.com, groups: esb}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/length.html","name":"Length","summary":"Ballerina provides a .length() method for strings, arrays, tuples, maps, records, and xml,\n which returns the length/size of the given value.Create an integer array with several integer elements.Print the length of the created integer array. The length is\n retrieved using the .length() method.Create a JSON array with several JSON elements.Print ...","content":"/  /  /  / Length  import ballerina/io;  public function main() {  // Create an integer array with several integer elements.  int[] intArray = [1, 2, 3];  int length;   // Print the length of the created integer array. The length is  // retrieved using the `.length()` method.  length = intArray.length();  io:println(\"Integer array size: \", length);   // Create a JSON array with several JSON elements.  json[] jsonArray = [  {\"name\": \"John\", \"age\": 31},  {\"name\": \"Neal\", \"age\": 22}  ];   // Print the length of the created JSON array.  length = jsonArray.length();  io:println(\"JSON array size: \", length);   // Create an `int`-constrained `map`.  map<int> strMap = {};  strMap[\"A\"] = 1;  strMap[\"B\"] = 2;  strMap[\"C\"] = 3;   // Print the length of the created `map`.  length = strMap.length();  io:println(\"Map size: \", length);   // Define a `string`.  string myStr = \"My name is Peter Parker\";  // Print the length of the string.  length = myStr.length();  io:println(\"String size: \", length);   // Create an XML element.  xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;   // Print the number of content items in the XML element.  length = (x1/<*>).length();  io:println(\"XML child elements size: \", length);   // Define a tuple with two members.  [int, string] tupleVar = [10, \"John\"];   // Print the size of the tuple (i.e., the number of members in the tuple).  length = tupleVar.length();  io:println(\"Tuple size: \", length);   // Create a record of the `Student` type.  Student stu = {id: 1, fname: \"John\", lname: \"Doe\", age: 17};   // Print the number of fields in the created `Student` record.  length = stu.length();  io:println(\"Field size in `Student` record: \", length); }  type Student record {|  int id;  string fname;  string lname;  int age;  string...; |};    Length  Ballerina provides a .length() method for strings, arrays, tuples, maps, records, and xml,  which returns the length/size of the given value.    import ballerina/io;    public function main() {    int[] intArray = [1, 2, 3];  int length;    Create an integer array with several integer elements.   length = intArray.length();  io:println(\"Integer array size: \", length);    Print the length of the created integer array. The length is  retrieved using the .length() method.   json[] jsonArray = [  {\"name\": \"John\", \"age\": 31},  {\"name\": \"Neal\", \"age\": 22}  ];    Create a JSON array with several JSON elements.   length = jsonArray.length();  io:println(\"JSON array size: \", length);    Print the length of the created JSON array.   map<int> strMap = {};  strMap[\"A\"] = 1;  strMap[\"B\"] = 2;  strMap[\"C\"] = 3;    Create an int-constrained map.   length = strMap.length();  io:println(\"Map size: \", length);    Print the length of the created map.   string myStr = \"My name is Peter Parker\";  Define a string.   length = myStr.length();  io:println(\"String size: \", length);    Print the length of the string.   xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;    Create an XML element.   length = (x1/<*>).length();  io:println(\"XML child elements size: \", length);    Print the number of content items in the XML element.   [int, string] tupleVar = [10, \"John\"];    Define a tuple with two members.   length = tupleVar.length();  io:println(\"Tuple size: \", length);    Print the size of the tuple (i.e., the number of members in the tuple).   Student stu = {id: 1, fname: \"John\", lname: \"Doe\", age: 17};    Create a record of the Student type.   length = stu.length();  io:println(\"Field size in `Student` record: \", length); }    Print the number of fields in the created Student record.   type Student record {|  int id;  string fname;  string lname;  int age;  string...; |};    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run length.bal Integer array size: 3 JSON array size: 2 Map size: 3 String size: 23 XML child elements size: 2 Tuple size: 2 Field size in `Student` record: 4    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/let-expression.html","name":"Let Expression","summary":"A let expression binds variables and then evaluates an expression with those variables in-scope.This is a simple let expression, which involves only a single\n variable declaration.Declare multiple variables in a let expression.The scope of a variable declared in a let expression is from\n the point of declaration to the end ...","content":"/  /  /  / Let Expression  import ballerina/io;  public function main() {   // This is a simple let expression, which involves only a single  // variable declaration.  int a = let int b = 1 in b * 2;  io:println(\"a: \", a);   // Declare multiple variables in a let expression.  string greeting = let string hello = \"Hello \",  string ballerina = \"Ballerina!\"  in hello + ballerina;  io:println(\"greeting: \", greeting);   // The scope of a variable declared in a let expression is from  // the point of declaration to the end of the let expression.  int three = let int one = getInt(), int two = one + one in one + two;  io:println(\"three: \", three);   // Declare variables using the keyword `var` in a let expression.  int length = let var num = 10, var txt = \"four\" in num + txt.length();  io:println(\"length: \", length);   [int, int] v1 = [10, 20];  // Let variable declarations can include binding patterns.  int tupleBindingResult = let [int, int] [d1, d2] = v1,  int d3 = d1 + d2  in d3 * 2;  io:println(\"tuple binding result: \", tupleBindingResult);   int age = let Person {  name: firstName,  age: personAge,  ...otherDetails  } = getPerson()  in personAge;  io:println(\"age: \", age);   var fatal = let var error(reason, ...params) = getSampleError()  in params[\"fatal\"];  io:println(\"fatal: \", fatal); }  public function getInt() returns int => 1;  type Person record {  string name;  int age;  string country; };  function getPerson() returns Person => {  name: \"John\",  age: 31,  country: \"USA\",  \"occupation\": \"Lawyer\" };  function getSampleError() returns error {  return error(\"SampleError\", message = \"Detail message\", fatal = true); }    Let Expression  A let expression binds variables and then evaluates an expression with those variables in-scope.    import ballerina/io;    public function main() {    int a = let int b = 1 in b * 2;  io:println(\"a: \", a);    This is a simple let expression, which involves only a single  variable declaration.   string greeting = let string hello = \"Hello \",  string ballerina = \"Ballerina!\"  in hello + ballerina;  io:println(\"greeting: \", greeting);    Declare multiple variables in a let expression.   int three = let int one = getInt(), int two = one + one in one + two;  io:println(\"three: \", three);    The scope of a variable declared in a let expression is from  the point of declaration to the end of the let expression.   int length = let var num = 10, var txt = \"four\" in num + txt.length();  io:println(\"length: \", length);    Declare variables using the keyword var in a let expression.   [int, int] v1 = [10, 20];    int tupleBindingResult = let [int, int] [d1, d2] = v1,  int d3 = d1 + d2  in d3 * 2;  io:println(\"tuple binding result: \", tupleBindingResult);    Let variable declarations can include binding patterns.   int age = let Person {  name: firstName,  age: personAge,  ...otherDetails  } = getPerson()  in personAge;  io:println(\"age: \", age);    var fatal = let var error(reason, ...params) = getSampleError()  in params[\"fatal\"];  io:println(\"fatal: \", fatal); }    public function getInt() returns int => 1;    type Person record {  string name;  int age;  string country; };    function getPerson() returns Person => {  name: \"John\",  age: 31,  country: \"USA\",  \"occupation\": \"Lawyer\" };    function getSampleError() returns error {  return error(\"SampleError\", message = \"Detail message\", fatal = true); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run let_expression.bal a: 2 greeting: Hello Ballerina! three: 3 length: 14 tuple binding result: 60 age: 31 fatal: true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/local-transactions-with-participants.html","name":"Local Transactions with participants","summary":"A Ballerina transaction is a series of data manipulation statements\n that must either fully complete or fully fail, thereby, leaving the\n system in a consistent state. This example demonstrates the usage of\n transactions with local participants. If the participant panics even when it\n is trapped and if the initiator completes, ...","content":"/  /  /  / Local Transactions with participants  import ballerina/io; // Import the `ballerina/transactions` module to use the // `@transactions:Participant` annotation. import ballerina/transactions;   public function main() {  // The `transaction` block initiates the transaction. Thus, it is called the initiator.  transaction {  // Invokes the local participant.  var res = trap localTransactionParticipant();  if (res is error) {  // The local participant gets panicked.  io:println(\"Local participant panicked.\");  }  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }  // The `@transactions:Participant` annotation from the // `transactions` module is used to indicate the function as a local participant. @transactions:Participant {  oncommit: participantOnCommit } function localTransactionParticipant() {  io:println(\"Invoke local participant function.\");  error er = error(\"Simulated Failure\");  panic er; }  function participantOnCommit(string transactionId) {  io:println(\"Local participant committed function handler...\"); }    Local Transactions with participants  A Ballerina transaction is a series of data manipulation statements  that must either fully complete or fully fail, thereby, leaving the  system in a consistent state. This example demonstrates the usage of  transactions with local participants. If the participant panics even when it  is trapped and if the initiator completes, the transaction is considered as a failure.  Ballerina transactions are at the experimental stage.  Hence, use the –experimental flag to enable them.    import ballerina/io;    import ballerina/transactions;    Import the ballerina/transactions module to use the  @transactions:Participant annotation.   public function main() {    transaction {    The transaction block initiates the transaction. Thus, it is called the initiator.   var res = trap localTransactionParticipant();  if (res is error) {    Invokes the local participant.   io:println(\"Local participant panicked.\");  }  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  } }    The local participant gets panicked.   @transactions:Participant {  oncommit: participantOnCommit } function localTransactionParticipant() {  io:println(\"Invoke local participant function.\");  error er = error(\"Simulated Failure\");  panic er; }    The @transactions:Participant annotation from the  transactions module is used to indicate the function as a local participant.   function participantOnCommit(string transactionId) {  io:println(\"Local participant committed function handler...\"); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below with the --experimental option. ballerina run --experimental local_transactions_with_participants.bal    2020-03-18 11:57:09,328 INFO [ballerina/transactions] - Created transaction: bf592603-4639-4c16-9daf-605b8e131470 2020-03-18 11:57:09,343 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:bf592603-4639-4c16-9daf-605b8e131470 2020-03-18 11:57:09,344 INFO [ballerina/transactions] - participant registered: bf592603-4639-4c16-9daf-605b8e131470 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,350 INFO [ballerina/transactions] - Running 2-phase commit for transaction: bf592603-4639-4c16-9daf-605b8e131470:$anon$.$0 2020-03-18 11:57:09,350 INFO [ballerina/transactions] - Local prepare failed, aborting.. Retrying transaction 2020-03-18 11:57:09,359 INFO [ballerina/transactions] - Created transaction: 371da573-8e4f-436e-99b3-adc2b9e911a4 2020-03-18 11:57:09,360 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:371da573-8e4f-436e-99b3-adc2b9e911a4 2020-03-18 11:57:09,361 INFO [ballerina/transactions] - participant registered: 371da573-8e4f-436e-99b3-adc2b9e911a4 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,362 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 371da573-8e4f-436e-99b3-adc2b9e911a4:$anon$.$0 2020-03-18 11:57:09,364 INFO [ballerina/transactions] - Local prepare failed, aborting.. Retrying transaction 2020-03-18 11:57:09,366 INFO [ballerina/transactions] - Created transaction: 9a792401-17fd-4486-bb8e-2fb0a79a04a8 2020-03-18 11:57:09,366 INFO [ballerina/transactions] - Registered local participant: 5ca42804-876c-4a69-9b34-8bc537c8d87a:$anon$.$1 for transaction:9a792401-17fd-4486-bb8e-2fb0a79a04a8 2020-03-18 11:57:09,367 INFO [ballerina/transactions] - participant registered: 9a792401-17fd-4486-bb8e-2fb0a79a04a8 Invoke local participant function. Local participant panicked. 2020-03-18 11:57:09,367 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 9a792401-17fd-4486-bb8e-2fb0a79a04a8:$anon$.$0 2020-03-18 11:57:09,368 INFO [ballerina/transactions] - Local prepare failed, aborting.. Transaction aborted [ballerina/http] started HTTP/WS listener 172.17.0.1:35909 [ballerina/http] stopped HTTP/WS listener 172.17.0.1:35909    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/local-transactions.html","name":"Local Transactions","summary":"A Ballerina transaction is a series of data manipulation statements\n that must either fully complete or fully fail, thereby, leaving the\n system in a consistent state. This sample uses an H2 database, which is\n created when running the sample. Prior to running this sample,\n the DB connection properties need to ...","content":"/  /  /  / Local Transactions  import ballerina/io; import ballerinax/java.jdbc;  // JDBC Client for H2 database. jdbc:Client testDB = new ({  url: \"jdbc:h2:file:./local-transactions/testdb\",  username: \"test\",  password: \"test\" });  public function main() {  // Create the tables that are required for the transaction.  var ret = testDB->update(\"CREATE TABLE CUSTOMER (ID INTEGER, NAME \" +  \"VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");   // Populate table with data.  ret = testDB->update(\"CREATE TABLE SALARY (ID INTEGER, MON_SALARY FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");   // This is a `transaction` block. If you do not explicitly `abort` or  // `retry` a returned error, the transaction will be automatically  // retried until the retry count is reached and aborted.  // The retry count that is given via `retries` is the number of times the  // transaction is retried before it being aborted and the default value is 3.  transaction with retries = 4 {  // Any transacted action within the `transaction` block may return  // errors such as backend DB errors, connection pool errors etc.  // The user can decide whether to `abort` or `retry` based on the  // returned error.  // This is the first remote function participant of the transaction.  ret = testDB->update(\"INSERT INTO CUSTOMER(ID,NAME) \" +  \"VALUES (1, 'Anne')\");  // This is the second remote function participant of the transaction.  ret = testDB->update(\"INSERT INTO SALARY (ID, MON_SALARY) \" +  \"VALUES (1, 2500)\");  if (ret is jdbc:UpdateResult) {  io:println(\"Inserted count: \", ret.updatedRowCount);  // If the transaction is forced to abort, it will roll back the transaction  // and exit the transaction block without retrying.  if (ret.updatedRowCount == 0) {  abort;  }  } else {  // If the transaction is forced to retry, it will roll back the transaction,  // go to the `onretry` block, and retry from the beginning until the defined  // retry count is reached.  retry;  }  // The end curly bracket marks the end of the transaction and the transaction will  // be committed or rolled back at this point.  } onretry {  // The `onretry` block will be executed whenever the transaction is retried until it  // reaches the retry count. A transaction could be retried if it fails due to an  // exception or throw statement or from an explicit retry statement.  io:println(\"Retrying transaction\");  } committed {  // Any action that needs to be performed after the transaction is  // committed should be added here.  io:println(\"Transaction committed\");  } aborted {  // If the transaction is aborted, any action that needs to perform after  // the abortion should be added here.  io:println(\"Transaction aborted\");  }   // Drop the tables.  ret = testDB->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop table CUSTOMER\");   ret = testDB->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop table SALARY\"); }  // Function to handle the return value of the `update` remote function. function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message + \" status: \", returned.updatedRowCount);  } else {  io:println(message + \" failed: \", <string>returned.detail()?.message);  } }    Local Transactions  A Ballerina transaction is a series of data manipulation statements  that must either fully complete or fully fail, thereby, leaving the  system in a consistent state. This sample uses an H2 database, which is  created when running the sample. Prior to running this sample,  the DB connection properties need to be changed as required.  Ballerina transactions are at the experimental stage,  Thus, use the –experimental flag to enable them.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB = new ({  url: \"jdbc:h2:file:./local-transactions/testdb\",  username: \"test\",  password: \"test\" });    JDBC Client for H2 database.   public function main() {    var ret = testDB->update(\"CREATE TABLE CUSTOMER (ID INTEGER, NAME \" +  \"VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");    Create the tables that are required for the transaction.   ret = testDB->update(\"CREATE TABLE SALARY (ID INTEGER, MON_SALARY FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");    Populate table with data.   transaction with retries = 4 {    This is a transaction block. If you do not explicitly abort or  retry a returned error, the transaction will be automatically  retried until the retry count is reached and aborted.  The retry count that is given via retries is the number of times the  transaction is retried before it being aborted and the default value is 3.   ret = testDB->update(\"INSERT INTO CUSTOMER(ID,NAME) \" +  \"VALUES (1, 'Anne')\");    Any transacted action within the transaction block may return  errors such as backend DB errors, connection pool errors etc.  The user can decide whether to abort or retry based on the  returned error.  This is the first remote function participant of the transaction.   ret = testDB->update(\"INSERT INTO SALARY (ID, MON_SALARY) \" +  \"VALUES (1, 2500)\");  if (ret is jdbc:UpdateResult) {  io:println(\"Inserted count: \", ret.updatedRowCount);    This is the second remote function participant of the transaction.   if (ret.updatedRowCount == 0) {  abort;  }  } else {    If the transaction is forced to abort, it will roll back the transaction  and exit the transaction block without retrying.   retry;  }    If the transaction is forced to retry, it will roll back the transaction,  go to the onretry block, and retry from the beginning until the defined  retry count is reached.   } onretry {    The end curly bracket marks the end of the transaction and the transaction will  be committed or rolled back at this point.   io:println(\"Retrying transaction\");  } committed {    The onretry block will be executed whenever the transaction is retried until it  reaches the retry count. A transaction could be retried if it fails due to an  exception or throw statement or from an explicit retry statement.   io:println(\"Transaction committed\");  } aborted {    Any action that needs to be performed after the transaction is  committed should be added here.   io:println(\"Transaction aborted\");  }    If the transaction is aborted, any action that needs to perform after  the abortion should be added here.   ret = testDB->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop table CUSTOMER\");    Drop the tables.   ret = testDB->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop table SALARY\"); }    function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message + \" status: \", returned.updatedRowCount);  } else {  io:println(message + \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # Before running this sample, change the H2 DB connection properties as required.    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run --experimental local_transactions.bal [ballerina/http] started HTTP/WS listener 172.17.0.1:49479 Create CUSTOMER table status: 0 Create SALARY table status: 0 2020-03-18 12:36:26,983 INFO [ballerina/transactions] - Created transaction: 17130bbc-28e0-414d-b0a0-e20efccdacec Inserted count: 1 2020-03-18 12:36:26,999 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 17130bbc-28e0-414d-b0a0-e20efccdacec:$anon$.$0 Transaction committed Drop table CUSTOMER status: 0 Drop table SALARY status: 0 [ballerina/http] started HTTP/WS listener 192.168.1.3:63458 [ballerina/http] stopped HTTP/WS listener 192.168.1.3:63458    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/locks.html","name":"Lock","summary":"Ballerina locks are used for concurrency management. The encapsulating block of statements will acquire\n the locks for each global or service level variable reference that is used within the block or for any\n field access of an object or a record. When there is nested field access (e.g., a record ...","content":"/  /  /  / Lock  import ballerina/io;  // The `counter` variable will be shared among multiple workers. int counter = 0;  public function main() {  process();  io:println(\"final counter value - \", counter);  io:println(\"final count field value - \", counterObj.count); }  type Counter object {  int count = 0;   public function update() {  foreach var i in 1 ... 1000 {  lock {  // Locks the `count` field variable and increments the `count`.  // The `count` field of the same object instance will be locked.  self.count = self.count + 1;  }  }  } }; // The `counterObj` object instance will be shared among multiple workers. Counter counterObj = new;  function process() {  worker w1 {  counterObj.update();  // Locks the shared `counter` variable and increments the `counter`.  foreach var i in 1 ... 1000 {  lock {  // Locks the shared `counter` variable and increments the `counter`.  counter = counter + 1;  }  }  }  worker w2 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  // Locks the shared `counter` variable and increments the `counter`.  counter = counter + 1;  }  }  }  worker w3 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  // Locks the shared `counter` variable and increments the `counter`.  counter = counter + 1;  }  }  }  worker w4 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {  // Locks the shared `counter` variable and increments the `counter`.  counter = counter + 1;  }  }  }  // Waits for all workers to complete.  var result = wait {w1, w2, w3, w4}; }    Lock  Ballerina locks are used for concurrency management. The encapsulating block of statements will acquire  the locks for each global or service level variable reference that is used within the block or for any  field access of an object or a record. When there is nested field access (e.g., a record within a record),  all the field accesses of the records will be locked.  Locks in Ballerina are currently an experimental feature.  Thus, use the –experimental flag to enable them.    import ballerina/io;    int counter = 0;    The counter variable will be shared among multiple workers.   public function main() {  process();  io:println(\"final counter value - \", counter);  io:println(\"final count field value - \", counterObj.count); }    type Counter object {  int count = 0;    public function update() {  foreach var i in 1 ... 1000 {  lock {    self.count = self.count + 1;  }  }  } };    Locks the count field variable and increments the count.  The count field of the same object instance will be locked.   Counter counterObj = new;    The counterObj object instance will be shared among multiple workers.   function process() {  worker w1 {  counterObj.update();    foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w2 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w3 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }  worker w4 {  counterObj.update();  foreach var i in 1 ... 1000 {  lock {    Locks the shared counter variable and increments the counter.   counter = counter + 1;  }  }  }    Locks the shared counter variable and increments the counter.   var result = wait {w1, w2, w3, w4}; }    Waits for all workers to complete.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run locks.bal final counter value - 4000 final count field value - 4000    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/log-api.html","name":"Log","summary":"The ballerina/log module contains the Ballerina-log-handling functions including ‘DEBUG’, ‘ERROR’, ‘INFO’, ‘TRACE’,\n‘WARN’, ‘OFF’, and ‘ALL’.The Ballerina log API provides functions to log at five levels, which are\n DEBUG, ERROR, INFO, TRACE, and WARN. By default, all log\n messages are logged to the console at the INFO level. In addition to\n ...","content":"/  /  /  / Log  import ballerina/io; import ballerina/log;  public function main() {  error e = error(\"error occurred\");   // The Ballerina log API provides functions to log at five levels, which are  // `DEBUG`, `ERROR`, `INFO`, `TRACE`, and `WARN`. By default, all log  // messages are logged to the console at the `INFO` level. In addition to  // these log levels, there are 2 additional levels named `OFF` and `ALL`.  // `OFF` turns off logging and `ALL` enables all the log levels. The log  // level can be configured via a Ballerina configuration file or CLI  // parameters.  log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printError(\"error log with cause\", e);  log:printInfo(\"info log\");  log:printTrace(\"trace log\");  log:printWarn(\"warn log\");  // To set the log level of the API, use the following CLI parameter: <br>  // `--b7a.log.level=[LOG_LEVEL]`  //  // To configure using a configuration file, place the entry given below in  // the file:  //  // ```  // [b7a.log]  // level=\"[LOG_LEVEL]\"  // ```   // Each module can also be assigned its own log level. To assign a  // log level to a module, provide the following configuration  // `<MODULE_NAME>.loglevel`.  //  // E.g., `--foo.loglevel=DEBUG`  Fruit apple = new (\"Apple\");  Fruit orange = new (\"Orange\");   log:printDebug(\"Name of the fruit is Strawberry.\");  log:printDebug(io:sprintf(\"Names of the fruits are %s, %s.\", apple.getName(), orange.getName()));  // Logic constructing log messages with expensive operations can alternatively be passed as a function  // pointer implementation. The function will be executed if and only if that particular log level is enabled.  log:printDebug(function() returns string {  return io:sprintf(\"Name of the fruit is is %s\", apple.getName());  }); }  public type Fruit object {  string name;  public function __init(string name) {  self.name = name;  }  function getName() returns string {  return self.name;  } };    Log  The ballerina/log module contains the Ballerina-log-handling functions including ‘DEBUG’, ‘ERROR’, ‘INFO’, ‘TRACE’, ‘WARN’, ‘OFF’, and ‘ALL’.    import ballerina/io; import ballerina/log;    public function main() {  error e = error(\"error occurred\");    log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printError(\"error log with cause\", e);  log:printInfo(\"info log\");  log:printTrace(\"trace log\");  log:printWarn(\"warn log\");    The Ballerina log API provides functions to log at five levels, which are  DEBUG, ERROR, INFO, TRACE, and WARN. By default, all log  messages are logged to the console at the INFO level. In addition to  these log levels, there are 2 additional levels named OFF and ALL.  OFF turns off logging and ALL enables all the log levels. The log  level can be configured via a Ballerina configuration file or CLI  parameters.   To set the log level of the API, use the following CLI parameter: --b7a.log.level=[LOG_LEVEL]  To configure using a configuration file, place the entry given below in  the file:   [b7a.log]  level=\"[LOG_LEVEL]\"    Fruit apple = new (\"Apple\");  Fruit orange = new (\"Orange\");    Each module can also be assigned its own log level. To assign a  log level to a module, provide the following configuration  <MODULE_NAME>.loglevel.  E.g., --foo.loglevel=DEBUG   log:printDebug(\"Name of the fruit is Strawberry.\");  log:printDebug(io:sprintf(\"Names of the fruits are %s, %s.\", apple.getName(), orange.getName()));    log:printDebug(function() returns string {  return io:sprintf(\"Name of the fruit is is %s\", apple.getName());  }); }    Logic constructing log messages with expensive operations can alternatively be passed as a function  pointer implementation. The function will be executed if and only if that particular log level is enabled.   public type Fruit object {  string name;  public function __init(string name) {  self.name = name;  }  function getName() returns string {  return self.name;  } };    # As shown in the output, only the `INFO` and higher level logs are logged by default. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run log_api.bal 2019-08-09 11:47:07,334 ERROR [ballerina/log] - error log 2019-08-09 11:47:07,340 ERROR [ballerina/log] - error log with cause : error error occurred 2019-08-09 11:47:07,341 INFO [ballerina/log] - info log 2019-08-09 11:47:07,342 WARN [ballerina/log] - warn log    # If the log level is set to `TRACE`, logs of all log levels are logged. ballerina run log_api.bal --b7a.log.level=TRACE 2019-08-09 11:48:04,411 DEBUG [ballerina/log] - debug log 2019-08-09 11:48:04,415 ERROR [ballerina/log] - error log 2019-08-09 11:48:04,416 ERROR [ballerina/log] - error log with cause : error error occurred 2019-08-09 11:48:04,416 INFO [ballerina/log] - info log 2019-08-09 11:48:04,417 TRACE [ballerina/log] - trace log 2019-08-09 11:48:04,421 WARN [ballerina/log] - warn log 2019-08-09 12:17:35,946 DEBUG [ballerina/log] - Name of the fruit is Strawberry. 2019-08-09 12:17:35,947 DEBUG [ballerina/log] - Names of the fruits are Apple, Orange. 2019-08-09 12:17:35,947 DEBUG [ballerina/log] - Name of the fruit is is Apple.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/match.html","name":"Match","summary":"A match statement is a value-switching construct that allows selective code execution based on\n matching the value of the expression that is being matched against the pattern.The value of the counter variable is matched against the given value match patterns.The value match can also be used with binary OR expression.The ...","content":"/  /  /  / Match  import ballerina/io;  public function main() {   int[5] intArray = [0, 1, 2, 3, 4];   foreach var counter in intArray {   // The value of the `counter` variable is matched against the given value match patterns.  match counter {  0 => {  io:println(\"value is: 0\");  }  1 => {  io:println(\"value is: 1\");  }  2 => {  io:println(\"value is: 2\");  }  3 => {  io:println(\"value is: 3\");  }  4 => {  io:println(\"value is: 4\");  }  5 => {  io:println(\"value is: 5\");  }  }  }   string[] animals = [\"Cat\", \"Canine\", \"Mouse\", \"Horse\"];   foreach string animal in animals {   // The value match can also be used with binary OR expression.  match animal {  \"Mouse\" => {  io:println(\"Mouse\");  }  \"Dog\"|\"Canine\" => {  io:println(\"Dog\");  }  \"Cat\"|\"Feline\" => {  io:println(\"Cat\");  }  // The pattern `_` can be used as the final static value match pattern, which will be matched against all values.  _ => {  io:println(\"Match All\");  }  }  } }    Match  A match statement is a value-switching construct that allows selective code execution based on  matching the value of the expression that is being matched against the pattern.    import ballerina/io;    public function main() {    int[5] intArray = [0, 1, 2, 3, 4];    foreach var counter in intArray {    match counter {  0 => {  io:println(\"value is: 0\");  }  1 => {  io:println(\"value is: 1\");  }  2 => {  io:println(\"value is: 2\");  }  3 => {  io:println(\"value is: 3\");  }  4 => {  io:println(\"value is: 4\");  }  5 => {  io:println(\"value is: 5\");  }  }  }    The value of the counter variable is matched against the given value match patterns.   string[] animals = [\"Cat\", \"Canine\", \"Mouse\", \"Horse\"];    foreach string animal in animals {    match animal {  \"Mouse\" => {  io:println(\"Mouse\");  }  \"Dog\"|\"Canine\" => {  io:println(\"Dog\");  }  \"Cat\"|\"Feline\" => {  io:println(\"Cat\");  }    The value match can also be used with binary OR expression.   _ => {  io:println(\"Match All\");  }  }  } }    The pattern _ can be used as the final static value match pattern, which will be matched against all values.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run match.bal value is: 0 value is: 1 value is: 2 value is: 3 value is: 4 Cat Dog Mouse Match All    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/math-functions.html","name":"Math","summary":"The Ballerina Math API contains methods to perform various numerical operations.This returns the absolute value of a float value.This returns the absolute value of an int value.This returns the arc cosine of a value.This returns the arc sine of a value.This returns the arc tangent of a value.This returns the ...","content":"/  /  /  / Math  import ballerina/io; import ballerina/math;  public function main() {   io:println(\"Value of PI : \", math:PI);  io:println(\"Value of E : \", math:E);   //This returns the absolute value of a `float` value.  float absoluteFloatValue = math:absFloat(-152.2544);  io:println(\"Absolute value of -152.2544 : \", absoluteFloatValue);   //This returns the absolute value of an `int` value.  int absoluteIntValue = math:absInt(-152);  io:println(\"Absolute value of -152 : \", absoluteIntValue);   //This returns the arc cosine of a value.  float acosValue = math:acos(0.027415567780803774);  io:println(\"Arc cosine of 0.027415567780803774 : \", acosValue);   //This returns the arc sine of a value.  float arcSineValue = math:asin(0.027415567780803774);  io:println(\"Arc sine of 0.027415567780803774 : \", arcSineValue);   //This returns the arc tangent of a value.  float arcTangent = math:atan(0.027415567780803774);  io:println(\"Arc tangent of 0.027415567780803774 : \", arcTangent);   //This returns the cube root of a `float` value.  float cubeRoot = math:cbrt(-27.0);  io:println(\"Cube root of -27.0 : \", cubeRoot);   //There are over 40 methods in the ballerina math API that can be used to perform numeric operations.  //You can find them in the `ballerina/math` module. }    Math  The Ballerina Math API contains methods to perform various numerical operations.    import ballerina/io; import ballerina/math;    public function main() {    io:println(\"Value of PI : \", math:PI);  io:println(\"Value of E : \", math:E);    float absoluteFloatValue = math:absFloat(-152.2544);  io:println(\"Absolute value of -152.2544 : \", absoluteFloatValue);    This returns the absolute value of a float value.   int absoluteIntValue = math:absInt(-152);  io:println(\"Absolute value of -152 : \", absoluteIntValue);    This returns the absolute value of an int value.   float acosValue = math:acos(0.027415567780803774);  io:println(\"Arc cosine of 0.027415567780803774 : \", acosValue);    This returns the arc cosine of a value.   float arcSineValue = math:asin(0.027415567780803774);  io:println(\"Arc sine of 0.027415567780803774 : \", arcSineValue);    This returns the arc sine of a value.   float arcTangent = math:atan(0.027415567780803774);  io:println(\"Arc tangent of 0.027415567780803774 : \", arcTangent);    This returns the arc tangent of a value.   float cubeRoot = math:cbrt(-27.0);  io:println(\"Cube root of -27.0 : \", cubeRoot);    This returns the cube root of a float value.   }    There are over 40 methods in the ballerina math API that can be used to perform numeric operations. You can find them in the ballerina/math module.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run math_functions.bal Value of PI : 3.141592653589793 Value of E : 2.718281828459045 Absolute value of -152.2544 : 152.2544 Absolute value of -152 : 152 Arc cosine of 0.027415567780803774 : 1.5433773235341761 Arc sine of 0.027415567780803774 : 0.02741900326072046 Arc tangent of 0.027415567780803774 : 0.0274087022410345 Cube root of -27.0 : -3.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/maps.html","name":"Maps","summary":"The map type in Ballerina defines a mutable mapping from keys (that are strings) to values of the type specified as\n the map’s constraint type.Declare a map constrained by the type string.You can also declare and initialize a map with a mapping constructor\n expression.A field can be specified as a ...","content":"/  /  /  / Maps  import ballerina/io;  public function main() {  // Declare a `map` constrained by the type `string`.  map<string> m;   string city = \"Colombo\";  string country = \"Sri Lanka\";  string codeLiteral = \"code\";   // You can also declare and initialize a `map` with a mapping constructor  // expression.  map<string> addrMap = {  // A field can be specified as a key-value pair.  line1: \"No. 20\",  line2: \"Palm Grove\",  // The value in a key-value pair can be any expression, which evaluates  // to a value of a type that belongs to the constraint type of the map.  city: \"Colombo 03\",  // A field can also be just a variable reference, which would result  // in the variable name being the field name and the variable itself  // being the value expression.  // This is equivalent to saying `country: country`.  country,  // The key in a key-value pair can also be a computed key.  // A computed key is defined by specifying the key expression within  // brackets. The key expression must belong to type `string`.  // For a computed key, the key expression is evaluated at runtime and  // the resulting value is used as the key.  [codeLiteral]: \"00300\"  };  io:println(addrMap);   // Member access can be used to retrieve a value from a map.  // Member access returns the value if a field exists in the map with the  // specified key. Else, it returns `()` if a field does not exist with the specified key.  // Thus, the type of a member access expression for a map is the union of  // the constraint type and the nil type.  string? countryValue = addrMap[\"country\"];   if (countryValue is string) {  io:println(countryValue);  } else {  io:println(\"key 'country' not found\");  }   // Retrieve a value using the `.get()` method.  // If the map has a field with the specified key, `.get()` returns the value.  // Else, it panics if the map does not have a field with the specified key.  // Thus, the return type of `.get()` when invoked on a map is the map's constraint type.  string line2Value = addrMap.get(\"line2\");  io:println(line2Value);   // The `.hasKey()` function checks if a map contains the specified key.  boolean hasPostalCode = addrMap.hasKey(\"postalCode\");  io:println(hasPostalCode);   // Member access expressions can be used on the left hand side of an assignment  // to add fields to a map or update an already-existing field in the map.  addrMap[\"postalCode\"] = \"00300\";  io:println(addrMap);   // The `.keys()` method returns the keys of the map as an array.  io:println(addrMap.keys());   // Print the number of fields in the map.  io:println(addrMap.length());   // Fields can be removed using the `.remove()` method.  string removedElement = addrMap.remove(\"code\");  io:println(addrMap);   // Maps support functional iteration.  addrMap.forEach(function (string value) {  io:println(value);  });   map<int> marks = {sam: 50, jon: 60};   // Calling the `.entries()` method on a map will return the key-value pairs as  // an array of tuples.  map<int> modifiedMarks = marks.entries().map(function ([string, int] pair)  returns int {  var [name, score] = pair;  io:println(io:sprintf(\"%s scored: %d\", name, score));  return score + 10;  }  );  io:println(modifiedMarks);   // A mapping constructor expression can also include a spread field  // referring to another mapping value. When a spread field is specified,  // all the fields of the relevant mapping value are added to the new  // mapping value being created.  // A spread field is used with `modifiedMarks` to include all the entries  // in `modifiedMarks` when creating `allMarks`.  map<int> allMarks = {jane: 100, ...modifiedMarks, amy: 75};  io:println(allMarks); }    Maps  The map type in Ballerina defines a mutable mapping from keys (that are strings) to values of the type specified as  the map’s constraint type.    import ballerina/io;    public function main() {    map<string> m;    Declare a map constrained by the type string.   string city = \"Colombo\";  string country = \"Sri Lanka\";  string codeLiteral = \"code\";    map<string> addrMap = {    You can also declare and initialize a map with a mapping constructor  expression.   line1: \"No. 20\",  line2: \"Palm Grove\",    A field can be specified as a key-value pair.   city: \"Colombo 03\",    The value in a key-value pair can be any expression, which evaluates  to a value of a type that belongs to the constraint type of the map.   country,    A field can also be just a variable reference, which would result  in the variable name being the field name and the variable itself  being the value expression.  This is equivalent to saying country: country.   [codeLiteral]: \"00300\"  };  io:println(addrMap);    The key in a key-value pair can also be a computed key.  A computed key is defined by specifying the key expression within  brackets. The key expression must belong to type string.  For a computed key, the key expression is evaluated at runtime and  the resulting value is used as the key.   string? countryValue = addrMap[\"country\"];    Member access can be used to retrieve a value from a map.  Member access returns the value if a field exists in the map with the  specified key. Else, it returns () if a field does not exist with the specified key.  Thus, the type of a member access expression for a map is the union of  the constraint type and the nil type.   if (countryValue is string) {  io:println(countryValue);  } else {  io:println(\"key 'country' not found\");  }    string line2Value = addrMap.get(\"line2\");  io:println(line2Value);    Retrieve a value using the .get() method.  If the map has a field with the specified key, .get() returns the value.  Else, it panics if the map does not have a field with the specified key.  Thus, the return type of .get() when invoked on a map is the map’s constraint type.   boolean hasPostalCode = addrMap.hasKey(\"postalCode\");  io:println(hasPostalCode);    The .hasKey() function checks if a map contains the specified key.   addrMap[\"postalCode\"] = \"00300\";  io:println(addrMap);    Member access expressions can be used on the left hand side of an assignment  to add fields to a map or update an already-existing field in the map.   io:println(addrMap.keys());    The .keys() method returns the keys of the map as an array.   io:println(addrMap.length());    Print the number of fields in the map.   string removedElement = addrMap.remove(\"code\");  io:println(addrMap);    Fields can be removed using the .remove() method.   addrMap.forEach(function (string value) {  io:println(value);  });    Maps support functional iteration.   map<int> marks = {sam: 50, jon: 60};    map<int> modifiedMarks = marks.entries().map(function ([string, int] pair)  returns int {  var [name, score] = pair;  io:println(io:sprintf(\"%s scored: %d\", name, score));  return score + 10;  }  );  io:println(modifiedMarks);    Calling the .entries() method on a map will return the key-value pairs as  an array of tuples.   map<int> allMarks = {jane: 100, ...modifiedMarks, amy: 75};  io:println(allMarks); }    A mapping constructor expression can also include a spread field  referring to another mapping value. When a spread field is specified,  all the fields of the relevant mapping value are added to the new  mapping value being created.  A spread field is used with modifiedMarks to include all the entries  in modifiedMarks when creating allMarks.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run maps.bal line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka code=00300 Sri Lanka Palm Grove false line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka code=00300 postalCode=00300 line1 line2 city country code postalCode 6 line1=No. 20 line2=Palm Grove city=Colombo 03 country=Sri Lanka postalCode=00300 No. 20 Palm Grove Colombo 03 Sri Lanka 00300 sam scored: 50 jon scored: 60 sam=60 jon=70 jane=100 sam=60 jon=70 amy=75    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/modules.html","name":"Modules","summary":"Ballerina program files have the .bal extension and the file names do not have semantics.\n These source files can be grouped into modules. The code within a module can refer to any module-level symbol (name) declared\n in the same module. Module names can only contain alphanumerics, underscores, and periods and ...","content":"/  /  /  / Modules  // This example imports a module. You can only refer to the public symbols of // an imported module. import ballerina/math;  // Declare an explicit prefix. import ballerina/io as console;  public function main() {   // Refer symbols of another module.  // `math:PI` is a qualified identifier. Note the usage of the module prefix.  float piValue = math:PI;   // Use the explicit prefix `console` to invoke a function defined in the `ballerina/io` module.  console:println(piValue); }    Modules  Ballerina program files have the .bal extension and the file names do not have semantics.  These source files can be grouped into modules. The code within a module can refer to any module-level symbol (name) declared  in the same module. Module names can only contain alphanumerics, underscores, and periods and the maximum length is 256 characters.  By default, the last element of the module name becomes a prefix that is used to refer to the symbols of the imported module.  If the module name has periods, then the word after the last period becomes the prefix.    import ballerina/math;    This example imports a module. You can only refer to the public symbols of  an imported module.   import ballerina/io as console;    Declare an explicit prefix.   public function main() {    float piValue = math:PI;    Refer symbols of another module.  math:PI is a qualified identifier. Note the usage of the module prefix.   console:println(piValue); }    Use the explicit prefix console to invoke a function defined in the ballerina/io module.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run modules.bal 3.141592653589793    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/mutual-ssl.html","name":"Mutual SSL","summary":"Ballerina supports mutual SSL, which is a certificate-based authentication process where two parties (client and\nserver) authenticate each other by verifying the digital certificates. It ensures that both parties are assured of\neach other’s identity.Create an HTTP listener configuration, which will configure a listener to\n accept new connections that are secured via ...","content":"/  /  /  / Mutual SSL  import ballerina/config; import ballerina/http; import ballerina/log;  // Create an HTTP listener configuration, which will configure a listener to // accept new connections that are secured via mutual SSL. http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  // Enable the preferred SSL protocol and its versions.  protocol: {  name: \"TLS\",  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },  // Configure the preferred ciphers.  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"],  // Enable mutual SSL.  sslVerifyClient: \"require\"  } };  // Create a listener endpoint. listener http:Listener helloWorldEP = new (9095, helloWorldEPConfig);  @http:ServiceConfig {  basePath: \"/hello\" } // Bind the service to the listener endpoint that you declared earlier. service helloWorld on helloWorldEP {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  // Send the response to the caller.  var result = caller->respond(\"Successful\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } } import ballerina/config; import ballerina/http; import ballerina/log;  // Create a client configuration to be passed to the client endpoint. // Configure the `keyStoreFile`, `keyStorePassword`, `trustStoreFile`, and // the`trustStorePassword`, which are required to enable mutual SSL. http:ClientConfiguration clientEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  protocol: {  name: \"TLS\"  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } };  public function main() {  // Create an HTTP client to interact with the created listener endpoint.  http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);  // Send a GET request to the listener.  var resp = clientEP->get(\"/hello\");  if (resp is http:Response) {  // If the request is successful, retrieve the text payload from the  // response.  var payload = resp.getTextPayload();  if (payload is string) {  // Log the retrieved text payload.  log:printInfo(payload);  } else {  // If an error occurs while retrieving the text payload, log  // the error.  log:printError(<string>payload.detail()[\"message\"]);  }  } else {  // If an error occurs while getting the response, log the error.  log:printError(<string>resp.detail()[\"message\"]);  } }    Mutual SSL  Ballerina supports mutual SSL, which is a certificate-based authentication process where two parties (client and server) authenticate each other by verifying the digital certificates. It ensures that both parties are assured of each other’s identity.    import ballerina/config; import ballerina/http; import ballerina/log;    http:ListenerConfiguration helloWorldEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },    Create an HTTP listener configuration, which will configure a listener to  accept new connections that are secured via mutual SSL.   protocol: {  name: \"TLS\",  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },    Enable the preferred SSL protocol and its versions.   ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"],    Configure the preferred ciphers.   sslVerifyClient: \"require\"  } };    Enable mutual SSL.   listener http:Listener helloWorldEP = new (9095, helloWorldEPConfig);    Create a listener endpoint.   @http:ServiceConfig {  basePath: \"/hello\" }    service helloWorld on helloWorldEP {    Bind the service to the listener endpoint that you declared earlier.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {    var result = caller->respond(\"Successful\");  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Send the response to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below along with the Ballerina home path as a config. ballerina run mutual_ssl_service.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9095    import ballerina/config; import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  },  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  },  protocol: {  name: \"TLS\"  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } };    Create a client configuration to be passed to the client endpoint.  Configure the keyStoreFile, keyStorePassword, trustStoreFile, and  thetrustStorePassword, which are required to enable mutual SSL.   public function main() {    http:Client clientEP = new(\"https://localhost:9095\", clientEPConfig);    Create an HTTP client to interact with the created listener endpoint.   var resp = clientEP->get(\"/hello\");  if (resp is http:Response) {    Send a GET request to the listener.   var payload = resp.getTextPayload();  if (payload is string) {    If the request is successful, retrieve the text payload from the  response.   log:printInfo(payload);  } else {    Log the retrieved text payload.   log:printError(<string>payload.detail()[\"message\"]);  }  } else {    If an error occurs while retrieving the text payload, log  the error.   log:printError(<string>resp.detail()[\"message\"]);  } }    If an error occurs while getting the response, log the error.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below along with the Ballerina home path as a config. ballerina run ssl_client.bal --b7a.home=<ballerina_home_path> INFO [] - Successful    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/mysql-execute-operation.html","name":"MySQL DDL and DML Operations","summary":"This example demonstrates how to use the JDBC client with the DDL and  DML\n operations. Note that the MySQL database driver JAR should be placed in\n the<BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses database\n properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL driver version ...","content":"/  /  /  / MySQL DDL and DML Operations  import ballerina/io; import ballerina/mysql; import ballerina/sql;  // Username and password of the MySQL database. This is used in the below // examples when initializing the MySQL connector. You need to change these // based on your setup if you try locally. string dbUser = \"root\"; string dbPassword = \"Test@123\"; string dbName = \"MYSQL_BBE_EXEC\";  function initializeDatabase() returns sql:Error? {  // Initialize the client without any database to create the database.  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  // Create database if it does not exist. If any error occurred,  // the error will be returned.  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS \" + dbName);  io:println(\"Database created. \");  // Close the MySQL client.  check mysqlClient.close(); }  function initializeTable(mysql:Client mysqlClient)  returns int|string|sql:Error? {  // Execute dropping the table. The `sql:ExecuteResult` is returned upon  // successful execution. An error will be returned in case of a failure.  sql:ExecuteResult? result =  check mysqlClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }  // Similarly, to drop a table, the `create` table query is executed.  // Here, the `customerId` is an auto-generated column.  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300)\" +  \",lastName VARCHAR(300), registrationID INTEGER,\" +  \"creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))\");   // Insert sample data into the table. The result will have  // `affectedRowCount` and `lastInsertedId` with the auto-generated ID of  // the last row.  result = check mysqlClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit, country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  int|string? generatedId = ();   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  generatedId = result.lastInsertId;  }  return generatedId; }  function updateRecord(mysql:Client mysqlClient, int generatedId) {  // Update the record with the auto-generated ID.  string query = string ` ${generatedId}`;  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Update Customers set creditLimit = 15000.5 \"+  \"where customerId =\" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }  function deleteRecord(mysql:Client mysqlClient, int generatedId) {  // Delete the record with the auto-generated ID.  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Delete from Customers where customerId = \"+  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }  public function main() {  // Initialize the database.  sql:Error? err = initializeDatabase();  if (err is ()) {  // Initialize the MySQL client to be used for the rest of the DDL  // and DML operations.  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = dbName);  if (mysqlClient is mysql:Client) {  // Initialize a table and insert data.  int|string|sql:Error? initResult = initializeTable(mysqlClient);  if (initResult is int) {  // Update a record.  updateRecord(mysqlClient, initResult);  // Delete a record.  deleteRecord(mysqlClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed!\", initResult);  }  // Close the MySQL client.  sql:Error? e = mysqlClient.close();  } else {  io:println(\"Table initialization failed!!\", mysqlClient);  }  } else {  io:println(\"Database initialization failed!!\", err);  } }    MySQL DDL and DML Operations  This example demonstrates how to use the JDBC client with the DDL and DML  operations. Note that the MySQL database driver JAR should be placed in  the<BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses database  properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\"; string dbName = \"MYSQL_BBE_EXEC\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup if you try locally.   function initializeDatabase() returns sql:Error? {    mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);    Initialize the client without any database to create the database.   sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS \" + dbName);  io:println(\"Database created. \");    Create database if it does not exist. If any error occurred,  the error will be returned.   check mysqlClient.close(); }    Close the MySQL client.   function initializeTable(mysql:Client mysqlClient)  returns int|string|sql:Error? {    sql:ExecuteResult? result =  check mysqlClient->execute(\"DROP TABLE IF EXISTS Customers\");  if (result is sql:ExecuteResult) {  io:println(\"Drop table executed. \", result);  }    Execute dropping the table. The sql:ExecuteResult is returned upon  successful execution. An error will be returned in case of a failure.   result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS Customers\" +  \"(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300)\" +  \",lastName VARCHAR(300), registrationID INTEGER,\" +  \"creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))\");    Similarly, to drop a table, the create table query is executed.  Here, the customerId is an auto-generated column.   result = check mysqlClient->execute(\"INSERT INTO Customers (firstName,\" +  \"lastName,registrationID,creditLimit, country) VALUES ('Peter', \" +  \"'Stuart', 1, 5000.75, 'USA')\");  int|string? generatedId = ();    Insert sample data into the table. The result will have  affectedRowCount and lastInsertedId with the auto-generated ID of  the last row.   if (result is sql:ExecuteResult) {  io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId);  generatedId = result.lastInsertId;  }  return generatedId; }    function updateRecord(mysql:Client mysqlClient, int generatedId) {    string query = string ` ${generatedId}`;  sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Update Customers set creditLimit = 15000.5 \"+  \"where customerId =\" + generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Updated Row count: \", result?.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Update the record with the auto-generated ID.   function deleteRecord(mysql:Client mysqlClient, int generatedId) {    sql:ExecuteResult|sql:Error? result =  mysqlClient->execute(\"Delete from Customers where customerId = \"+  generatedId.toString());  if (result is sql:ExecuteResult) {  io:println(\"Deleted Row count: \", result.affectedRowCount);  } else if (result is sql:Error) {  io:println(\"Error occured: \", result);  } else {  io:println(\"Empty result\");  } }    Delete the record with the auto-generated ID.   public function main() {    sql:Error? err = initializeDatabase();  if (err is ()) {    Initialize the database.   mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = dbName);  if (mysqlClient is mysql:Client) {    Initialize the MySQL client to be used for the rest of the DDL  and DML operations.   int|string|sql:Error? initResult = initializeTable(mysqlClient);  if (initResult is int) {    Initialize a table and insert data.   updateRecord(mysqlClient, initResult);    Update a record.   deleteRecord(mysqlClient, initResult);  io:println(\"Sample executed successfully!\");  } else if (initResult is sql:Error) {  io:println(\"Customer table initialization failed!\", initResult);  }    Delete a record.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"Table initialization failed!!\", mysqlClient);  }  } else {  io:println(\"Database initialization failed!!\", err);  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run mysql_execute_operation.bal    Database created. Drop table executed. affectedRowCount=0 lastInsertId= Rows affected: 1 Generated Customer ID: 1 Updated Row count: 1 Deleted Row count: 1 Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/mysql-complex-type-queries.html","name":"MySQL Query with Complex Types","summary":"This example demonstrates how to use the MySQL client with complex data types\n such as binary, blobs, and date/time fields. Note that the MySQL database\n driver JAR should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The\n MySQL connector uses some database properties from MySQL version 8.0.x\n onwards. Therefore, it is recommended ...","content":"/  /  /  / MySQL Query with Complex Types  import ballerina/io; import ballerina/mysql; import ballerina/sql; import ballerina/time;  // Username and password of the MySQL database. This is used in below examples // when initializing the MySQL connector. You need to change these based on // your setup if you are trying locally. string dbUser = \"root\"; string dbPassword = \"Test@123\";  // Define the record types to be used in the below examples. type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};  type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};  function queryBinaryType(mysql:Client mysqlClient) {  io:println(\"------ Query Binary Type -------\");  // Select the rows with binary data types.  // The name and type of the attributes within the record from the  // `resultStream` will be automatically identified based on the column  // name and type of the query result.  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from BINARY_TYPES\");   io:println(\"Result 1:\");  // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  // Since the `rowType` is provided as a `BinaryType`, the `resultStream` will  // have `BinaryType` records.  resultStream = mysqlClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream =  <stream<BinaryType, sql:Error>>resultStream;   io:println(\"Result 2:\");  // Iterate the `binaryResultStream`.  e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }  function queryDateTimeType(mysql:Client mysqlClient) {  io:println(\"------ Query Date Time Type -------\");  // Select the rows with date/time data types.  // The name and type of the attributes within the record from the  // `resultStream` will be automatically identified based on the column  // name and type of the query result.  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from DATE_TIME_TYPES\");   io:println(\"Result 1:\");  // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  // Since the `rowType` is provided as a `DateTimeType`, the `resultStream`  // will have `DateTimeType` records. The Date, Time, DateTime, and  // Timestamp fields of the database table can be mapped to time:Time,  // string and int types in Ballerina.  resultStream = mysqlClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;   io:println(\"Result 2:\");  // Iterate the `dateResultStream`.  e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }  // Initialize the database table with sample data. function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result = check  mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");   result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.BINARY_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE MYSQL_BBE.BINARY_TYPES\"+  \"(row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type \"+  \"BINARY (27), PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.BINARY_TYPES \"+  \"(row_id, blob_type, binary_type) VALUES (1, \"+  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E',\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");   result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.DATE_TIME_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE \"+  \"MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL,\" +  \"date_type DATE, time_type TIME, timestamp_type timestamp, \"+  \"datetime_type datetime, PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"Insert into \" +  \"MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, \"+  \"timestamp_type, datetime_type) values (1,'2017-05-23','14:15:23',\"+  \"'2017-01-25 16:33:55','2017-01-25 16:33:55')\");   check mysqlClient.close(); }  public function main() {  // Initialize the MySQL client.  sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\", err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {  // Execute the complex data type queries.  queryBinaryType(mysqlClient);  queryDateTimeType(mysqlClient);  io:println(\"Sample executed successfully!\");   // Close the MySQL client.  sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for querying data\" +  \"failed!!\", mysqlClient);  }  } }    MySQL Query with Complex Types  This example demonstrates how to use the MySQL client with complex data types  such as binary, blobs, and date/time fields. Note that the MySQL database  driver JAR should be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The  MySQL connector uses some database properties from MySQL version 8.0.x  onwards. Therefore, it is recommended to use a MySQL driver version greater  than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql; import ballerina/time;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in below examples  when initializing the MySQL connector. You need to change these based on  your setup if you are trying locally.   type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};    Define the record types to be used in the below examples.   type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Time timestamp_type;  string datetime_type; |};    function queryBinaryType(mysql:Client mysqlClient) {  io:println(\"------ Query Binary Type -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from BINARY_TYPES\");    Select the rows with binary data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = mysqlClient->query(\"Select * from BINARY_TYPES\", BinaryType);  stream<BinaryType, sql:Error> binaryResultStream =  <stream<BinaryType, sql:Error>>resultStream;    Since the rowType is provided as a BinaryType, the resultStream will  have BinaryType records.   io:println(\"Result 2:\");    e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the binaryResultStream.   function queryDateTimeType(mysql:Client mysqlClient) {  io:println(\"------ Query Date Time Type -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from DATE_TIME_TYPES\");    Select the rows with date/time data types.  The name and type of the attributes within the record from the  resultStream will be automatically identified based on the column  name and type of the query result.   io:println(\"Result 1:\");    error? e = resultStream.forEach(function(record {} result) {  io:println(result);  });  if (e is error) {  io:println(e);  }    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   resultStream = mysqlClient->query(\"Select * from DATE_TIME_TYPES\",  DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream;    Since the rowType is provided as a DateTimeType, the resultStream  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Time,  string and int types in Ballerina.   io:println(\"Result 2:\");    e = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });  if (e is error) {  io:println(e);  }  io:println(\"------ ********* -------\"); }    Iterate the dateResultStream.   function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result = check  mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");    Initialize the database table with sample data.   result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.BINARY_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE MYSQL_BBE.BINARY_TYPES\"+  \"(row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type \"+  \"BINARY (27), PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.BINARY_TYPES \"+  \"(row_id, blob_type, binary_type) VALUES (1, \"+  \"X'77736F322062616C6C6572696E6120626C6F6220746573742E',\" +  \"X'77736F322062616C6C6572696E612062696E61727920746573742E')\");    result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \" +  \"MYSQL_BBE.DATE_TIME_TYPES\");  result = check mysqlClient->execute(\"CREATE TABLE \"+  \"MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL,\" +  \"date_type DATE, time_type TIME, timestamp_type timestamp, \"+  \"datetime_type datetime, PRIMARY KEY (row_id))\");  result = check mysqlClient->execute(\"Insert into \" +  \"MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, \"+  \"timestamp_type, datetime_type) values (1,'2017-05-23','14:15:23',\"+  \"'2017-01-25 16:33:55','2017-01-25 16:33:55')\");    check mysqlClient.close(); }    public function main() {    sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\", err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {    Initialize the MySQL client.   queryBinaryType(mysqlClient);  queryDateTimeType(mysqlClient);  io:println(\"Sample executed successfully!\");    Execute the complex data type queries.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for querying data\" +  \"failed!!\", mysqlClient);  }  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run mysql-complex-type-queries.bal    ------ Query Binary Type ------- Result 1: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 Result 2: row_id=1 blob_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 108 111 98 32 116 101 115 116 46 binary_type=119 115 111 50 32 98 97 108 108 101 114 105 110 97 32 98 105 110 97 114 121 32 116 101 115 116 46 ------ ********* ------- ------ Query Date Time Type ------- Result 1: row_id=1 date_type=2017-05-23+05:30 time_type=19:45:23.000+05:30 timestamp_type=2017-01-25T22:03:55.000+05:30 datetime_type=2017-01-25T22:03:55.000+05:30 Result 2: row_id=1 date_type=2017-05-23+05:30 time_type=51323000 timestamp_type=time=1485362035000 zone=id=UTC offset=0 datetime_type=2017-01-25T22:03:55.000+05:30 ------ ********* ------- Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-basic-client.html","name":"Basic Publisher and Subscriber","summary":"The NATS client is used either to produce a message to a subject or consume a message from a subject.\n In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.\n For instructions on installing the NATS ...","content":"/  /  /  / Basic Publisher and Subscriber  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");  // Initializes a producer.  nats:Connection connection = new ();  nats:Producer producer = new (connection);  while (message != ESCAPE) {  message = io:readln(\"Message : \");  // Produces a message to the specified subject.  nats:Error? result = producer->publish(subject, <@untainted>message);  if (result is nats:Error) {  io:println(\"Error occurred while producing the message.\");  } else {  io:println(\"Message published successfully.\");  }  }  // Closes the publisher connection.  nats:Error? result = producer.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the logical connection\",  result);  }   result = connection.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the connection\", result);  } } import ballerina/log; import ballerina/nats;  // Initializes a connection. nats:Connection connection = new;  // Initializes the NATS listener. listener nats:Listener subscription = new (connection);  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:SubscriptionConfig {  subject: \"demo\" } service demo on subscription {   resource function onMessage(nats:Message msg, string data) {  // Prints the incoming message in the console.  log:printInfo(\"Received message : \" + data);  }   resource function onError(nats:Message msg, nats:Error err) {  log:printError(\"Error occurred in data binding\", err);  } }    Basic Publisher and Subscriber  The NATS client is used either to produce a message to a subject or consume a message from a subject.  In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.  For instructions on installing the NATS server,  go to .    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection connection = new ();  nats:Producer producer = new (connection);  while (message != ESCAPE) {  message = io:readln(\"Message : \");    Initializes a producer.   nats:Error? result = producer->publish(subject, <@untainted>message);  if (result is nats:Error) {  io:println(\"Error occurred while producing the message.\");  } else {  io:println(\"Message published successfully.\");  }  }    Produces a message to the specified subject.   nats:Error? result = producer.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the logical connection\",  result);  }    Closes the publisher connection.   result = connection.close();  if (result is nats:Error) {  log:printError(\"Error occurred while closing the connection\", result);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo Message : Hello Ballerina! GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/log; import ballerina/nats;    nats:Connection connection = new;    Initializes a connection.   listener nats:Listener subscription = new (connection);    Initializes the NATS listener.   @nats:SubscriptionConfig {  subject: \"demo\" } service demo on subscription {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   resource function onMessage(nats:Message msg, string data) {    log:printInfo(\"Received message : \" + data);  }    Prints the incoming message in the console.   resource function onError(nats:Message msg, nats:Error err) {  log:printError(\"Error occurred in data binding\", err);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run subscriber.bal Received message : Hello Ballerina!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-streaming-client.html","name":"Basic Streaming Publisher and Subscriber","summary":"This sample demonstrates the basic usage of the NATS Streaming client\n to publish data to a subject and consume data from that subject.\n In order to run this sample, a NATS Streaming server should be\n running on the corresponding port used in the sample.Represents the escape character.Produces a message to ...","content":"/  /  /  / Basic Streaming Publisher and Subscriber  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");   nats:Connection conn = new;   nats:StreamingProducer publisher = new (conn);   while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  // Produces a message to the specified subject.  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  // Closes the connection.  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } } import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;  // Creates a NATS connection. nats:Connection conn = new;  // Initializes the NATS Streaming listener. listener nats:StreamingListener lis = new (conn);  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Basic Streaming Publisher and Subscriber  This sample demonstrates the basic usage of the NATS Streaming client  to publish data to a subject and consume data from that subject.  In order to run this sample, a NATS Streaming server should be  running on the corresponding port used in the sample.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo Message : Hello Ballerina! GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run subscriber.bal Received message : Hello Ballerina!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/mysql-init-options.html","name":"MySQL Client Initialization","summary":"This example demonstrates how to initialize the MySQL client with different\n initialization options. Note that, the MySQL database driver JAR should be\n placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses\n database properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL driver version greater than ...","content":"/  /  /  / MySQL Client Initialization  import ballerina/io; import ballerina/mysql; import ballerina/sql;  // Username and password of the MySQL database. This is used in the below // examples when initializing the MySQL connector. You need to change these // based on your setup to try locally. string dbUser = \"root\"; string dbPassword = \"Test@123\";  function initializeClients() returns sql:Error? {  // Initialize the MySQL Client without any parameters. In that case,  // all parameters will be using the default values:`localhost` for host,  // `3306` for port, and `()` for user, password, and database.  mysql:Client|sql:Error mysqlClient1 = new ();  if (mysqlClient1 is sql:Error) {  io:println(\"Error when initializing the MySQL client without any \" +  \"params. \", mysqlClient1);  } else {  io:println(\"Simple MySQL client created successfully\");  check mysqlClient1.close();  }   // Initialize the MySQL client by providing the username and password.  mysql:Client mysqlClient2 = check new (\"localhost\", dbUser, dbPassword);  io:println(\"MySQL client with user and password created.\");   // Initialize the MySQL client by providing the username, password,  // and default host.  mysql:Client mysqlClient3 = check new (user = dbUser,  password = dbPassword);  io:println(\"MySQL client with user and password created \" +  \"with default host.\");   // Initialize the MySQL client by providing the host, username,  // password, database, and port.  mysql:Client mysqlClient4 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306);  io:println(\"MySQL client with host, user, password, database and \" +  \"port created.\");   // Initialize the MySQL client by providing additional  // MySQL database properties.  mysql:Options mysqlOptions = {  // SSL is enabled by default and the default mode is  // `sql:SSL_PREFERRED`. SSL will be disabled, if `ssl` is assigned to  // `()`.  ssl: {  // Possible options for mode are `sql:SSL_PREFERRED`,  // `sql:SSL_REQUIRED`, `sql:SSL_VERIFY_CERT`, and  // `sql:SSL_VERIFY_IDENTITY`. For details on each mode, go to  // the MySQL reference (https://dev.mysql.com/doc/refman/8.0/en/using-encrypted-connections.html).  mode: mysql:SSL_PREFERRED  },  connectTimeoutInSeconds: 10  };  // Initialize the MySQL client with MySQL database options.  mysql:Client mysqlClient5 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions);  io:println(\"MySQL client with database options created.\");   // Connection pool is used to share and use the database connections  // efficiently. In the above samples, the global connection pool is  // created and shared among all the database clients since the  // `connectionPool` property is not set.  sql:ConnectionPool connPool = {  // Default max number of open connections in the connection pool is 15.  maxOpenConnections: 5,  // Default max life time of a connection in the connection pool is  // 1800 seconds (30 minutes).  maxConnectionLifeTimeInSeconds: 2000.0,  // Default minimum number of idle connections is 15.  minIdleConnections: 5  };   // Initialize the MySQL client with the specific connection pool.  mysql:Client mysqlClient6 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions, connectionPool = connPool);  io:println(\"MySQL client with connection pool created.\");   // Initialize the MySQL client with all the parameters.  mysql:Client mysqlClient7 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306, mysqlOptions, connPool);   // All properties are optional.  // Hence, named attributes can be used specifically to assign  // the attributes.  mysql:Client mysqlClient8 = check new (host = \"localhost\",  user = dbUser, password = dbPassword, database =  \"information_schema\", port = 3306, options = mysqlOptions,  connectionPool = connPool);   // Close the clients to release the resource  // and destroy the connection pool.  check mysqlClient2.close();  check mysqlClient3.close();  check mysqlClient4.close();  check mysqlClient5.close();  check mysqlClient6.close();  check mysqlClient7.close();  check mysqlClient8.close(); }  //Initialize MySQL clients with different options. public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed! \", err);  } else {  io:println(\"Sample executed successfully!\");  } }    MySQL Client Initialization  This example demonstrates how to initialize the MySQL client with different  initialization options. Note that, the MySQL database driver JAR should be  placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses  database properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup to try locally.   function initializeClients() returns sql:Error? {    mysql:Client|sql:Error mysqlClient1 = new ();  if (mysqlClient1 is sql:Error) {  io:println(\"Error when initializing the MySQL client without any \" +  \"params. \", mysqlClient1);  } else {  io:println(\"Simple MySQL client created successfully\");  check mysqlClient1.close();  }    Initialize the MySQL Client without any parameters. In that case,  all parameters will be using the default values:localhost for host,  3306 for port, and () for user, password, and database.   mysql:Client mysqlClient2 = check new (\"localhost\", dbUser, dbPassword);  io:println(\"MySQL client with user and password created.\");    Initialize the MySQL client by providing the username and password.   mysql:Client mysqlClient3 = check new (user = dbUser,  password = dbPassword);  io:println(\"MySQL client with user and password created \" +  \"with default host.\");    Initialize the MySQL client by providing the username, password,  and default host.   mysql:Client mysqlClient4 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306);  io:println(\"MySQL client with host, user, password, database and \" +  \"port created.\");    Initialize the MySQL client by providing the host, username,  password, database, and port.   mysql:Options mysqlOptions = {    Initialize the MySQL client by providing additional  MySQL database properties.   ssl: {    SSL is enabled by default and the default mode is  sql:SSL_PREFERRED. SSL will be disabled, if ssl is assigned to  ().   mode: mysql:SSL_PREFERRED  },  connectTimeoutInSeconds: 10  };    Possible options for mode are sql:SSL_PREFERRED,  sql:SSL_REQUIRED, sql:SSL_VERIFY_CERT, and  sql:SSL_VERIFY_IDENTITY. For details on each mode, go to  the MySQL reference ().   mysql:Client mysqlClient5 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions);  io:println(\"MySQL client with database options created.\");    Initialize the MySQL client with MySQL database options.   sql:ConnectionPool connPool = {    Connection pool is used to share and use the database connections  efficiently. In the above samples, the global connection pool is  created and shared among all the database clients since the  connectionPool property is not set.   maxOpenConnections: 5,    Default max number of open connections in the connection pool is 15.   maxConnectionLifeTimeInSeconds: 2000.0,    Default max life time of a connection in the connection pool is  1800 seconds (30 minutes).   minIdleConnections: 5  };    Default minimum number of idle connections is 15.   mysql:Client mysqlClient6 = check new (user = dbUser, password = dbPassword,  options = mysqlOptions, connectionPool = connPool);  io:println(\"MySQL client with connection pool created.\");    Initialize the MySQL client with the specific connection pool.   mysql:Client mysqlClient7 = check new (\"localhost\", dbUser, dbPassword,  \"information_schema\", 3306, mysqlOptions, connPool);    Initialize the MySQL client with all the parameters.   mysql:Client mysqlClient8 = check new (host = \"localhost\",  user = dbUser, password = dbPassword, database =  \"information_schema\", port = 3306, options = mysqlOptions,  connectionPool = connPool);    All properties are optional.  Hence, named attributes can be used specifically to assign  the attributes.   check mysqlClient2.close();  check mysqlClient3.close();  check mysqlClient4.close();  check mysqlClient5.close();  check mysqlClient6.close();  check mysqlClient7.close();  check mysqlClient8.close(); }    Close the clients to release the resource  and destroy the connection pool.   public function main() {  sql:Error? err = initializeClients();  if (err is sql:Error) {  io:println(\"Error occured, initialization failed! \", err);  } else {  io:println(\"Sample executed successfully!\");  } }    Initialize MySQL clients with different options.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run mysql_init_options.bal    Error when initializing the MySQL client without any params. error {ballerina/sql}ApplicationError message=error in sql connector configuration: Failed to initialize pool: Access denied for user ''@'localhost' (using password: NO) Caused by :Access denied for user ''@'localhost' (using password: NO) MySQL client with user and password created. MySQL client with user and password created with default host. MySQL client with host, user, password, database and port created. MySQL client with database options created. MySQL client with connection pool created. Sample executed successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-streaming-consumer-with-data-binding.html","name":"Streaming Publisher and Subscriber With Data Binding","summary":"This sample demonstrates the usage of NATS subscriber\n services to bind the data in the incoming message to\n a user-provided compatible type.Represents the escape character.Produces a message to a subject in the NATS sever.Produces a message to the specified subject.Closes the connection.Creates a NATS connection.Initializes the NATS Streaming listener.Binds the ...","content":"/  /  /  / Streaming Publisher and Subscriber With Data Binding  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");   nats:Connection conn = new;   nats:StreamingProducer publisher = new (conn, \"p0\", \"test-cluster\");   while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  // Produces a message to the specified subject.  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  // Closes the connection.  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } } import ballerina/log; import ballerina/nats;  // Creates a NATS connection. nats:Connection conn = new;  // Initializes the NATS Streaming listener. listener nats:StreamingListener lis = new (conn);  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message, json data) {  // Converts JSON data to string.  string|error val = data.toJsonString();  if (val is string) {  // Prints the incoming message in the console.  log:printInfo(\"Message Received: \" + val);  } else {  log:printError(\"Error occurred during json to string conversion\",  err = val);  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Streaming Publisher and Subscriber With Data Binding  This sample demonstrates the usage of NATS subscriber  services to bind the data in the incoming message to  a user-provided compatible type.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn, \"p0\", \"test-cluster\");    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo [ballerina/nats] Connection established with server nats://localhost:4222 Message : \"{ Hello : World }\" GUID PXbFl6Mlx6cewaL8oXwnn1 received for the produced message.    import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message, json data) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error val = data.toJsonString();  if (val is string) {    Converts JSON data to string.   log:printInfo(\"Message Received: \" + val);  } else {  log:printError(\"Error occurred during json to string conversion\",  err = val);  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run subscriber.bal Message Received: { Hello : World }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/mysql-query-operation.html","name":"MySQL Select Query Operations","summary":"This example demonstrates how to use the JDBC client select query operations\n with the stream return type. Note that the MySQL database driver JAR should\n be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses\n database properties from MySQL version 8.0.x onwards. Therefore, it is\n recommended to use a MySQL ...","content":"/  /  /  / MySQL Select Query Operations  import ballerina/io; import ballerina/mysql; import ballerina/sql;  // Username and password of the MySQL database. This is used in the below // examples when initializing the MySQL connector. You need to change these // based on your setup to try locally. string dbUser = \"root\"; string dbPassword = \"Test@123\";  function simpleQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Simple Query -------\");  // Select the rows in the database table via the query remote operation.  // The result is returned as a stream and the elements of the stream can  // be either a record or an error.  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\");   // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Customer full details: \", result);  io:println(\"Customer first name: \", result[\"FirstName\"]);  io:println(\"Customer last name: \", result[\"LastName\"]);  });   // Check and handle the error during the SQL query  // or iteration of the result stream.  if (e is error) {  io:println(\"ForEach operation on the stream failed!\", e);  }   // In general cases, the stream will be closed automatically  // when the stream is fully consumed or any error is encountered.  // However, in case if the stream is not fully consumed, the stream should be  // closed specifically.  e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }  function countRows(mysql:Client mysqlClient) {  io:println(\"------ Start Count Total Rows -------\");  // The result of the count operation is provided as a record stream.  stream<record{}, error> resultStream =  mysqlClient->query(\"Select count(*) as Total from Customers\");   // Since the above count query will return only a single row, the  // `next()` operation is sufficient to retrieve the data.  record {|record {} value;|}|error? result = resultStream.next();   // Check the result and retrieve the value for total.  if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"Total\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed!\", result);  } else {  io:println(\"Customer table is empty\");  }  // Close the stream.  error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }  //Define a record to load the query result schema as shown in the 'typedQuery' function. //In this example, all columns of the customer table will be loaded. //Therefore, a `Customer` record will be created with all the columns. The name of the result column //and the defined field name of the record will be matched case insensitively. type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};  function typedQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Query With Type Description -------\");  // The result is returned as a Customer record stream and the elements  // of the stream can be either a Customer record or an error.  stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\", Customer);   // Cast the generic record type to the Customer stream type.  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;   // Iterate the customer stream.  error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }   // Close the stream.  e = resultStream.close();   io:println(\"------ End Query With Type Description -------\"); }  //Initialize the database table with sample data. function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");  result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \"+  \"MYSQL_BBE.Customers\");  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS \" +  \"MYSQL_BBE.Customers(customerId INTEGER \" +  \"NOT NULL AUTO_INCREMENT, FirstName VARCHAR(300), LastName \" +  \"VARCHAR(300), RegistrationID INTEGER,\" +  \"CreditLimit DOUBLE, Country VARCHAR(300), PRIMARY KEY (CustomerId))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Dan', 'Brown', 2, 10000, 'UK')\");  check mysqlClient.close(); }  public function main() {  // Initialize the MySQL client.  sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\");  io:println(err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {  // Execute the `select` queries in different options.  simpleQuery(mysqlClient);  countRows(mysqlClient);  typedQuery(mysqlClient);  io:println(\"Queried the database successfully!\");   // Close the MySQL client.  sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for \" +  \"querying data failed!\", mysqlClient);  }  } }    MySQL Select Query Operations  This example demonstrates how to use the JDBC client select query operations  with the stream return type. Note that the MySQL database driver JAR should  be placed in the <BALLERINA_HOME>/bre/lib/distributions/jballerina-<VERSION>/bre/lib directory. The MySQL connector uses  database properties from MySQL version 8.0.x onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.x.    import ballerina/io; import ballerina/mysql; import ballerina/sql;    string dbUser = \"root\"; string dbPassword = \"Test@123\";    Username and password of the MySQL database. This is used in the below  examples when initializing the MySQL connector. You need to change these  based on your setup to try locally.   function simpleQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Simple Query -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\");    Select the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Customer full details: \", result);  io:println(\"Customer first name: \", result[\"FirstName\"]);  io:println(\"Customer last name: \", result[\"LastName\"]);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed!\", e);  }    Check and handle the error during the SQL query  or iteration of the result stream.   e = resultStream.close();  io:println(\"------ End Simple Query -------\"); }    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream should be  closed specifically.   function countRows(mysql:Client mysqlClient) {  io:println(\"------ Start Count Total Rows -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select count(*) as Total from Customers\");    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream.next();    Since the above count query will return only a single row, the  next() operation is sufficient to retrieve the data.   if (result is record {|record {} value;|}) {  io:println(\"Total rows in customer table : \", result.value[\"Total\"]);  } else if (result is error) {  io:println(\"Next operation on the stream failed!\", result);  } else {  io:println(\"Customer table is empty\");  }    Check the result and retrieve the value for total.   error? e = resultStream.close();  io:println(\"------ End Count Total Rows -------\"); }    Close the stream.   type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Define a record to load the query result schema as shown in the ‘typedQuery’ function. In this example, all columns of the customer table will be loaded. Therefore, a Customer record will be created with all the columns. The name of the result column and the defined field name of the record will be matched case insensitively.   function typedQuery(mysql:Client mysqlClient) {  io:println(\"------ Start Query With Type Description -------\");    stream<record{}, error> resultStream =  mysqlClient->query(\"Select * from Customers\", Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream;    Cast the generic record type to the Customer stream type.   error? e = customerStream.forEach(function(Customer customer) {  io:println(customer);  });  if (e is error) {  io:println(e);  }    Iterate the customer stream.   e = resultStream.close();    Close the stream.   io:println(\"------ End Query With Type Description -------\"); }    function initializeTable() returns sql:Error? {  mysql:Client mysqlClient = check new (user = dbUser, password = dbPassword);  sql:ExecuteResult? result =  check mysqlClient->execute(\"CREATE DATABASE IF NOT EXISTS MYSQL_BBE\");  result = check mysqlClient->execute(\"DROP TABLE IF EXISTS \"+  \"MYSQL_BBE.Customers\");  result = check mysqlClient->execute(\"CREATE TABLE IF NOT EXISTS \" +  \"MYSQL_BBE.Customers(customerId INTEGER \" +  \"NOT NULL AUTO_INCREMENT, FirstName VARCHAR(300), LastName \" +  \"VARCHAR(300), RegistrationID INTEGER,\" +  \"CreditLimit DOUBLE, Country VARCHAR(300), PRIMARY KEY (CustomerId))\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Peter', 'Stuart', 1, 5000.75, 'USA')\");  result = check mysqlClient->execute(\"INSERT INTO MYSQL_BBE.Customers \"+  \"(FirstName,LastName,RegistrationID,\" +  \"CreditLimit,Country) VALUES ('Dan', 'Brown', 2, 10000, 'UK')\");  check mysqlClient.close(); }    Initialize the database table with sample data.   public function main() {    sql:Error? err = initializeTable();  if (err is sql:Error) {  io:println(\"Sample data initialization failed!\");  io:println(err);  } else {  mysql:Client|sql:Error mysqlClient = new (user = dbUser,  password = dbPassword, database = \"MYSQL_BBE\");  if (mysqlClient is mysql:Client) {    Initialize the MySQL client.   simpleQuery(mysqlClient);  countRows(mysqlClient);  typedQuery(mysqlClient);  io:println(\"Queried the database successfully!\");    Execute the select queries in different options.   sql:Error? e = mysqlClient.close();  } else {  io:println(\"MySQL Client initialization for \" +  \"querying data failed!\", mysqlClient);  }  } }    Close the MySQL client.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run mysql_query_operation.bal    ------ Start Simple Query ------- Customer full details: customerId=1 FirstName=Peter LastName=Stuart RegistrationID=1 CreditLimit=5000.75 Country=USA Customer first name: Peter Customer last name: Stuart Customer full details: customerId=2 FirstName=Dan LastName=Brown RegistrationID=2 CreditLimit=10000.0 Country=UK Customer first name: Dan Customer last name: Brown ------ End Simple Query ------- ------ Start Count Total Rows ------- Total rows in customer table : 2 ------ End Count Total Rows ------- ------ Start Query With Type Description ------- customerId=1 firstName=Peter lastName=Stuart registrationId=1 creditLimit=5000.75 country=USA customerId=2 firstName=Dan lastName=Brown registrationId=2 creditLimit=10000.0 country=UK ------ End Query With Type Description ------- Queried the database successfully!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-streaming-durable-subscriptions.html","name":"Durable Subscriptions","summary":"This sample demonstrates creating a durable subscription\n in the NATS Streaming server. Regular subscriptions remember\n their position while the client is connected. If the client\n disconnects, the position is lost. Durable subscriptions\n remember their position even if the client is disconnected.Represents the escape character.Produces a message to a subject in ...","content":"/  /  /  / Durable Subscriptions  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");   nats:Connection conn = new;   nats:StreamingProducer publisher = new (conn);   while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  // Produces a message to the specified subject.  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  // Closes the connection.  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } } import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;  // Creates a NATS connection. nats:Connection conn = new;  // Initializes the NATS Streaming listener. listener nats:StreamingListener lis = new (conn, clientId = \"c0\");  // Binds the consumer to listen to the messages published to the 'demo' subject. @nats:StreamingSubscriptionConfig {  subject: \"demo\",  durableName: \"sample-name\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Durable Subscriptions  This sample demonstrates creating a durable subscription  in the NATS Streaming server. Regular subscriptions remember  their position while the client is connected. If the client  disconnects, the position is lost. Durable subscriptions  remember their position even if the client is disconnected.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo Message : First Message GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn, clientId = \"c0\");    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\",  durableName: \"sample-name\" } service demoService on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received: \" + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run subscriber.bal Received message : First Message    # Stop the subscriber and publish some messages while it is stopped. # Run the subscriber again. # All messages which had been published while the subscriber # wasn't running should be received.    ballerina run subscriber.bal Received message : Second Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/object-assignability.html","name":"Object Assignability","summary":"An object is assignable to another object type if they are structurally equivalent. There are rules that need to\n be satisfied for objects to be structurally equivalent. The following are the general equivalency rules\n that are applicable for objects.Defines an object called Person with public fields and a method.Defines an ...","content":"/  /  /  / Object Assignability  import ballerina/io;  // Defines an object called `Person` with public fields and a method. public type Person object {  public int age = 0;  public string name = \"\";   public function getName() returns string {  return self.name;  } };  // Defines an object called `Employee` with public fields, methods, and the initializer. public type Employee object {  public int age;  public string name;  public string address;   public function __init(int age, string name, string address) {  self.age = age;  self.name = name;  self.address = address;  }   public function getName() returns string {  return self.name + \" Doe\";  }   public function getAge() returns int {  return self.age;  } };  public function main() {  // Creates an object of the type `Employee` and assigns that to a variable of the type `Person`.  Person p1 = new Employee(50, \"John\", \"street1\");   io:println(p1.getName()); }    Object Assignability  An object is assignable to another object type if they are structurally equivalent. There are rules that need to  be satisfied for objects to be structurally equivalent. The following are the general equivalency rules  that are applicable for objects.   Both objects should have the same access modifier (i.e., either both should be public or both should be private). If both objects are private, they should be in the same package. The right hand side (RHS) object type should at least have all the fields as well as the methods of the left hand side (LHS) type. If the objects are public object types, all the fields and methods must be public as well. The field types of the RHS object should be assignable to the field types of the LHS object. The method signatures of the RHS object type should match the method signatures of the LHS object type. The parameters and return types of the RHS object type should also be the same types or subtypes of the corresponding parameters and return types of the LHS object type.     import ballerina/io;    public type Person object {  public int age = 0;  public string name = \"\";    Defines an object called Person with public fields and a method.   public function getName() returns string {  return self.name;  } };    public type Employee object {  public int age;  public string name;  public string address;    Defines an object called Employee with public fields, methods, and the initializer.   public function __init(int age, string name, string address) {  self.age = age;  self.name = name;  self.address = address;  }    public function getName() returns string {  return self.name + \" Doe\";  }    public function getAge() returns int {  return self.age;  } };    public function main() {    Person p1 = new Employee(50, \"John\", \"street1\");    Creates an object of the type Employee and assigns that to a variable of the type Person.   io:println(p1.getName()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run object_assignability.bal John Doe    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/object-methods.html","name":"Object Methods","summary":"Objects can have functions associated with them. These associated functions are known as methods.\n Methods can be defined inside or outside the object. To define a method outside the object,\n first declare the method signature inside the object.Defines an object called Person.The object initializer.A method returning the full name value ...","content":"/  /  /  / Object Methods  import ballerina/io;  // Defines an object called `Person`. type Person object {  public int age;  public string firstName;  public string lastName;   // The object initializer.  function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }   // A method returning the full name value of the `Person` object.  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }  };  public function main() {  // Initializes a `Person` object.  Person p1 = new (5, \"John\", \"Doe\");   io:println(p1.getFullName()); }    Object Methods  Objects can have functions associated with them. These associated functions are known as methods.  Methods can be defined inside or outside the object. To define a method outside the object,  first declare the method signature inside the object.    import ballerina/io;    type Person object {  public int age;  public string firstName;  public string lastName;    Defines an object called Person.   function __init(int age, string firstName, string lastName) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  }    The object initializer.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    A method returning the full name value of the Person object.   };    public function main() {    Person p1 = new (5, \"John\", \"Doe\");    Initializes a Person object.   io:println(p1.getFullName()); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run object_methods.bal John Doe    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-streaming-queue-group.html","name":"Queue Groups","summary":"This sample demonstrates leveraging the NATS built-in load balancing\n feature called “distributed queues”. All subscribers with the\n same queue name form the queue group.  As messages on the registered\n subject are published, one member of the group is chosen randomly\n to receive the message. Although queue groups have multiple ...","content":"/  /  /  / Queue Groups  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");   nats:Connection conn = new;   nats:StreamingProducer publisher = new (conn);   while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  // Produces a message to the specified subject.  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  // Closes the connection.  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } } import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;  // Creates a NATS connection. nats:Connection conn = new;  // Initializes the NATS Streaming listeners. listener nats:StreamingListener lis = new (conn);   // Binds the consumer to listen to the messages published to the 'demo' subject. // Belongs to the queue group named \"sample-queue-group\" @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service firstQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }   // Binds the consumer to listen to the messages published to the 'demo' subject. // Belongs to the queue group named \"sample-queue-group\" @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service secondQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }   // Binds the consumer to listen to the messages published to the 'demo' subject. // Belongs to the queue group named \"sample-queue-group\" @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service thridQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Queue Groups  This sample demonstrates leveraging the NATS built-in load balancing  feature called “distributed queues”. All subscribers with the  same queue name form the queue group. As messages on the registered  subject are published, one member of the group is chosen randomly  to receive the message. Although queue groups have multiple subscribers,  each message is consumed by only one.    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo Message : First Message GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listeners.   @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service firstQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service secondQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  queueName: \"sample-queue-group\" } service thridQueueGroupMember on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. # `queue-group.bal` contains three services belonging to the same # queue group. # When several messages are published, it can be noticed that # each message is received by only one queue group member. ballerina run queue-group.bal Message Received to third queue group member: First Message Message Received to second queue group member: Second Message Message Received to first queue group member: Third Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/object-initializer.html","name":"Object Initializer","summary":"In Ballerina, objects can have a method named __init(), which is used to initialize the object when creating a\n new object. This method can have parameters as in any other method. However, the return type of the __init() method\n should be a subtype of error|(), which includes (). If an ...","content":"/  /  /  / Object Initializer  import ballerina/io;  // Defines an object called `Person`. Each object has its own `__init()` method, which gets // invoked when creating the objects. You can place the logic for initializing the fields of the // object within the body of the `__init()` method. type Person object {   public string name;  private int age;   function __init(string name, int age) returns error? {  self.name = name;  self.age = check validateAge(age);  } };  function validateAge(int age) returns int|error {  if (age > 0 && age < 100) {  return age;  }   error invalidAge = error(\"The age should be between 0-100\");  return invalidAge; }  public function main() {  // Since the `__init()` method potentially returns an `error`, the `p1` variable should  // be of the type `Person|error`.  Person|error p1 = new(\"John\", 25);  if (p1 is Person) {  io:println(p1.name);  } else {  io:println(p1.reason());  }   // `p2` will be an error since the name does not conform to the expected format.  Person|error p2 = new(\"Sam\", -20);  if (p2 is Person) {  io:println(p2.name);  } else {  io:println(p2.reason());  } }    Object Initializer  In Ballerina, objects can have a method named __init(), which is used to initialize the object when creating a  new object. This method can have parameters as in any other method. However, the return type of the __init() method  should be a subtype of error|(), which includes (). If an explicit definition for the __init() method  is not specified, there will be an implicit __init() method, which does not accept any parameters and returns ().    import ballerina/io;    type Person object {    Defines an object called Person. Each object has its own __init() method, which gets  invoked when creating the objects. You can place the logic for initializing the fields of the  object within the body of the __init() method.   public string name;  private int age;    function __init(string name, int age) returns error? {  self.name = name;  self.age = check validateAge(age);  } };    function validateAge(int age) returns int|error {  if (age > 0 && age < 100) {  return age;  }    error invalidAge = error(\"The age should be between 0-100\");  return invalidAge; }    public function main() {    Person|error p1 = new(\"John\", 25);  if (p1 is Person) {  io:println(p1.name);  } else {  io:println(p1.reason());  }    Since the __init() method potentially returns an error, the p1 variable should  be of the type Person|error.   Person|error p2 = new(\"Sam\", -20);  if (p2 is Person) {  io:println(p2.name);  } else {  io:println(p2.reason());  } }    p2 will be an error since the name does not conform to the expected format.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run object_initializer.bal John The age should be between 0-100    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/nats-streaming-start-position.html","name":"Historical Message Replay","summary":"This sample demonstrates leveraging the historical\n message replay feature of Streaming NATS.\n New subscriptions may specify a starting position in the stream of\n messages stored for the channel of the subscribed subject.\n Message delivery may begin at:\n 1. The earliest message stored for this subject\n 2. The most recently stored ...","content":"/  /  /  / Historical Message Replay  import ballerina/io; import ballerina/log; import ballerina/nats;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS sever. public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");   nats:Connection conn = new;   nats:StreamingProducer publisher = new (conn);   while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {  // Produces a message to the specified subject.  var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }  // Closes the connection.  var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } } import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;  // Creates a NATS connection. nats:Connection conn = new;  // Initializes the NATS Streaming listener. listener nats:StreamingListener lis = new (conn);  // Binds the consumer to listen to the messages published to the 'demo' subject. // By default, only new messages are received. @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service receiveNewOnly on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }  // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives all messages from the beginning. @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:FIRST } service receiveFromBegining on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }  // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages starting from the last received message. @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:LAST_RECEIVED } service receiveFromLastReceived on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromLastReceived: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }  [nats:SEQUENCE_NUMBER, int] sequenceNo = [nats:SEQUENCE_NUMBER, 3]; // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages starting from the provided sequence number. @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: sequenceNo } service receiveFromGivenIndex on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }  [nats:TIME_DELTA_START, int] timeDelta = [nats:TIME_DELTA_START, 5]; // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages since the provided historical time delta. @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: timeDelta } service receiveSinceTimeDelta on lis {  resource function onMessage(nats:StreamingMessage message) {  // Prints the incoming message in the console.  string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    Historical Message Replay  This sample demonstrates leveraging the historical  message replay feature of Streaming NATS.  New subscriptions may specify a starting position in the stream of  messages stored for the channel of the subscribed subject.  Message delivery may begin at:  1. The earliest message stored for this subject  2. The most recently stored message for this subject  prior to the start of the current subscription.  3. A historical offset from the current server date/time  (e.g., the last 30 seconds).  4. A specific message sequence number    import ballerina/io; import ballerina/log; import ballerina/nats;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() {  string message = \"\";  string subject = io:readln(\"Subject : \");    Produces a message to a subject in the NATS sever.   nats:Connection conn = new;    nats:StreamingProducer publisher = new (conn);    while (message != ESCAPE) {  message = io:readln(\"Message : \");  if (message != ESCAPE) {    var result = publisher->publish(subject, <@untainted>message);  if (result is nats:Error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } else {  log:printInfo(\"GUID \" + result  + \" received for the produced message.\");  }  }  }    Produces a message to the specified subject.   var result = conn.close();  if (result is error) {  error e = result;  log:printError(\"Error occurred while closing the connection\", e);  } }    Closes the connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run publisher.bal Subject : demo [ballerina/nats] Connection established with server nats://localhost:4222 Message : First Message GUID UBMEgrERHdxZRqUBP05PtD received for the produced message. Message : Second Message GUID UBMEgrERHdxZRqUBP05Puz received for the produced message. Message : Third Message GUID UBMEgrERHdxZRqUBP05Pwl received for the produced message. Message : Forth Message GUID UBMEgrERHdxZRqUBP05PyX received for the produced message.    import ballerina/lang.'string as strings; import ballerina/log; import ballerina/nats;    nats:Connection conn = new;    Creates a NATS connection.   listener nats:StreamingListener lis = new (conn);    Initializes the NATS Streaming listener.   @nats:StreamingSubscriptionConfig {  subject: \"demo\" } service receiveNewOnly on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  By default, only new messages are received.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:FIRST } service receiveFromBegining on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives all messages from the beginning.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: nats:LAST_RECEIVED } service receiveFromLastReceived on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the last received message.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromLastReceived: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    [nats:SEQUENCE_NUMBER, int] sequenceNo = [nats:SEQUENCE_NUMBER, 3];    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: sequenceNo } service receiveFromGivenIndex on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the provided sequence number.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    [nats:TIME_DELTA_START, int] timeDelta = [nats:TIME_DELTA_START, 5];    @nats:StreamingSubscriptionConfig {  subject: \"demo\",  startPosition: timeDelta } service receiveSinceTimeDelta on lis {  resource function onMessage(nats:StreamingMessage message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages since the provided historical time delta.   string|error messageData = strings:fromBytes(message.getData());  if (messageData is string) {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  } else {  log:printError(\"Error occurred while obtaining message data\");  }  }    Prints the incoming message in the console.   resource function onError(nats:StreamingMessage message, nats:Error errorVal) {  error e = errorVal;  log:printError(\"Error occurred: \", e);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. # When you start the subscriber after publishing several messages, # You'll notice that, # 1. `receiveSinceTimeDelta` service receives the messages if # the messages were sent within a historical offset of 5 seconds # from the current server date/time # 2. `receiveFromGivenIndex` service receives services messages # starting from the third message published. # 3. `receiveFromLastReceived` service receives messages starting # from the last published message. # 4. `receiveFromBeginning` service receives all messages ever # published # 5. `receiveNewOnly` service receives only the messages, which are # published after the subscriber starts.    ballerina run subscriber.bal    [ballerina/nats] Connection established with server nats://localhost:4222 Message Received to service receiveSinceTimeDelta: Third Message Message Received to service receiveFromGivenIndex: Third Message Message Received to service receiveFromLastReceived: Third Message Message Received to service receiveFromBeginning: First Message Message Received to service receiveFromBeginning: Second Message Message Received to service receiveFromBeginning: Third Message Message Received to service receiveFromGivenIndex: Forth Message Message Received to service receiveFromLastReceived: Forth Message Message Received to service receiveNewOnly: Forth Message Message Received to service receiveSinceTimeDelta: Forth Message Message Received to service receiveFromBeginning: Forth Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/openapi-to-ballerina.html","name":"OpenAPI To Ballerina","summary":"If you already have an OpenApi Specification(OAS)-3 document for your service(s),\n you can use that contract to generate a Ballerina source code.\n Currently, Ballerina supports two types of code generation.\n ‘gen-service’ generates a mock version of the Ballerina service for a provided OAS definition.\n ballerina openapi gen-service <module-name>:<service-name> <openapi-contract>\n ‘gen-client’ ...","content":"/  /  /  / OpenAPI To Ballerina  OpenAPI To Ballerina  If you already have an OpenApi Specification(OAS)-3 document for your service(s),  you can use that contract to generate a Ballerina source code.  Currently, Ballerina supports two types of code generation.  ‘gen-service’ generates a mock version of the Ballerina service for a provided OAS definition.  ballerina openapi gen-service <module-name>:<service-name> <openapi-contract>  ‘gen-client’ generates a Ballerina client endpoint for a provided OAS definition.  ballerina openapi gen-client [<module>:]<client-name> <openapi-file> [-o=<outputFileName>]    openapi: \"3.0.0\" info:  version: 1.0.0  title: OpenApi Petstore  license:  name: MIT servers:  - url: http://localhost:9090/petstore/v1 paths:  /pets:  get:  summary: List all pets  operationId: listPets  tags:  - pets  parameters:  - name: limit  in: query  description: How many items to return at one time (max 100)  required: false  schema:  type: integer  format: int32  responses:  '200':  description: An paged array of pets  headers:  x-next:  description: A link to the next page of responses  schema:  type: string  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  post:  summary: Create a pet  operationId: createPets  tags:  - pets  responses:  '201':  description: Null response  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\"  /pets/{petId}:  get:  summary: Info for a specific pet  operationId: showPetById  tags:  - pets  parameters:  - name: petId  in: path  required: true  description: The id of the pet to retrieve  schema:  type: string  responses:  '200':  description: Expected response to a valid request  content:  application/json:  schema:  $ref: \"#/components/schemas/Pets\"  default:  description: unexpected error  content:  application/json:  schema:  $ref: \"#/components/schemas/Error\" components:  schemas:  Pet:  required:  - id  - name  properties:  id:  type: integer  format: int64  name:  type: string  tag:  type: string  Pets:  type: array  items:  $ref: \"#/components/schemas/Pet\"  Error:  required:  - code  - message  properties:  code:  type: integer  format: int32  message:  type: string    # Run the following command in a Ballerina project to generate the service from OpenAPI contract. ballerina openapi gen-service petStore:petService openapi_to_ballerina.yaml Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Service generated successfully and the OpenApi contract is copied to petStore/resources. this location will be referenced throughout the ballerina project. Following files were created. src/ - petStore -- petservice.bal -- schema.bal    # Run the following command in a Ballerina project to generate the service client from OpenAPI contract. ballerina openapi gen-client petservice_client openapi_to_ballerina.yaml Note: This is an Experimental tool ship under ballerina hence this will only support limited set of functionality. Client generated successfully. Following files were created. src/ - client -- openapi_petstore.bal -- schema.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/objects.html","name":"Object","summary":"Objects are a behaviourial type. An object is a combination of public, private, and module-level visible fields along with a\n set of associated functions (called methods) that can be used to manipulate the fields. This allows you\n to define custom-behavioural data types.Defines an object called Person. It contains public, private, ...","content":"/  /  /  / Object  import ballerina/io;  // Defines an object called `Person`. It contains `public`, `private`, and module-level visible fields along with their types. // For fields, the default value must be specified if an explicit object initializer method is not defined. type Person object {  public string name = \"\";  public int age = 0;  // If you need to have a field with its own type, you need to make that field defaultable  // (i.e., able to specify a default value).  // Here, the `parent` field is made defaultable by allowing it to have nil as a value.  public Person? parent = ();  // Private fields are only visible within the object and its functions.  private string email = \"default@abc.com\";  // Protected fields (i.e., no access modifiers) are visible only within the same module.  string address = \"No 20, Palm grove\"; };  public function main() {  // There are three ways to initialize a `Person` object.  Person p1 = new;  io:println(p1.age);   Person p2 = new ();  io:println(p2.age);   // This type of initialization is useful when you cannot determine the type of the object to be  // created based on the context (e.g., when the left hand side is a union of object types).  Person p3 = new Person();  io:println(p3.age); }    Object  Objects are a behaviourial type. An object is a combination of public, private, and module-level visible fields along with a  set of associated functions (called methods) that can be used to manipulate the fields. This allows you  to define custom-behavioural data types.    import ballerina/io;    type Person object {  public string name = \"\";  public int age = 0;    Defines an object called Person. It contains public, private, and module-level visible fields along with their types.  For fields, the default value must be specified if an explicit object initializer method is not defined.   public Person? parent = ();    If you need to have a field with its own type, you need to make that field defaultable  (i.e., able to specify a default value).  Here, the parent field is made defaultable by allowing it to have nil as a value.   private string email = \"default@abc.com\";    Private fields are only visible within the object and its functions.   string address = \"No 20, Palm grove\"; };    Protected fields (i.e., no access modifiers) are visible only within the same module.   public function main() {    Person p1 = new;  io:println(p1.age);    There are three ways to initialize a Person object.   Person p2 = new ();  io:println(p2.age);    Person p3 = new Person();  io:println(p3.age); }    This type of initialization is useful when you cannot determine the type of the object to be  created based on the context (e.g., when the left hand side is a union of object types).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run objects.bal 0 0 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/object-type-reference.html","name":"Object Type Reference","summary":"Object type references provide a way to copy the members from an abstract\n object into another object. It is equivalent to specifying the members\n explicitly within the new object, thus, eliminating redundancy. An object can have\n zero or more type references and may have chained references as well.Defines an abstract ...","content":"/  /  /  / Object Type Reference  import ballerina/io;  // Defines an abstract object called `Person`. It should only contain fields and the // method declarations. type Person abstract object {  public int age;  public string firstName;  public string lastName;   // Method declarations can be within the object. However, the method cannot  // have a body.  function getFullName() returns string;  };  // Defines another abstract object called `Employee`, which references the `Person` object. type Employee abstract object {  // Add a reference to the `Person` object type. Only abstract objects can be referred.  // All the member fields and member methods will be copied from the `Person` object.  *Person;  public float salary;   function getSalary() returns float; };  type Owner abstract object {  public string status; };  type Manager object {  // Type references can be chained by adding a reference to the `Employee` object, which  // again has a reference to the `Employee` object. This will copy all the members from  // the `Employee` object. It will be same as defining each of those members within this object.  *Employee;   // It is possible to have more than one type reference as well.  *Owner;   public string dpt;   // All the fields referenced through the type reference can be accessed within this object.  function __init(int age, string firstName, string lastName, string status) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  self.status = status;  self.salary = 2000;  self.dpt = \"HR\";  }   // The member methods coming from the referenced type should be defined within the object.  function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }   function getSalary() returns float {  return self.salary;  } };  public function main() {  Manager p = new Manager(5, \"John\", \"Doe\", \"Senior\");   // Accessing the fields that are coming from the referenced type.  io:println(p.age);  io:println(p.dpt);   // Invoking the methods that are coming from the referenced type.  io:println(p.getFullName());  io:println(p.getSalary()); }    Object Type Reference  Object type references provide a way to copy the members from an abstract  object into another object. It is equivalent to specifying the members  explicitly within the new object, thus, eliminating redundancy. An object can have  zero or more type references and may have chained references as well.    import ballerina/io;    type Person abstract object {  public int age;  public string firstName;  public string lastName;    Defines an abstract object called Person. It should only contain fields and the  method declarations.   function getFullName() returns string;    Method declarations can be within the object. However, the method cannot  have a body.   };    type Employee abstract object {    Defines another abstract object called Employee, which references the Person object.   *Person;  public float salary;    Add a reference to the Person object type. Only abstract objects can be referred.  All the member fields and member methods will be copied from the Person object.   function getSalary() returns float; };    type Owner abstract object {  public string status; };    type Manager object {    *Employee;    Type references can be chained by adding a reference to the Employee object, which  again has a reference to the Employee object. This will copy all the members from  the Employee object. It will be same as defining each of those members within this object.   *Owner;    It is possible to have more than one type reference as well.   public string dpt;    function __init(int age, string firstName, string lastName, string status) {  self.age = age;  self.firstName = firstName;  self.lastName = lastName;  self.status = status;  self.salary = 2000;  self.dpt = \"HR\";  }    All the fields referenced through the type reference can be accessed within this object.   function getFullName() returns string {  return self.firstName + \" \" + self.lastName;  }    The member methods coming from the referenced type should be defined within the object.   function getSalary() returns float {  return self.salary;  } };    public function main() {  Manager p = new Manager(5, \"John\", \"Doe\", \"Senior\");    io:println(p.age);  io:println(p.dpt);    Accessing the fields that are coming from the referenced type.   io:println(p.getFullName());  io:println(p.getSalary()); }    Invoking the methods that are coming from the referenced type.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run object_type_reference.bal 5 HR John Doe 2000.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/openshift-deployment.html","name":"OpenShift Deployment","summary":"Ballerina supports generating the OpenShift Route, BuildConfig, and ImageStream artifacts based on annotations.\nDocker image of the Ballerina service is built using the BuildConfig, which then can be used by the generated Kubernetes Deployment.\nA generated OpenShift Route exposes the Kubernetes Service of the Ballerina Service.\nThis example deploys an HTTP service, which ...","content":"/  /  /  / OpenShift Deployment  import ballerina/http; import ballerina/log; import ballerina/kubernetes; import ballerina/openshift;  //Add the `@kubernetes:Service` to a listener endpoint to expose the endpoint as a Kubernetes Service. @kubernetes:Service {} //Add the `@openshift:Route` to expose the Kubernetes Service through an OpenShift Route. @openshift:Route {  host: \"www.oc-example.com\" } listener http:Listener helloEP = new(9090);  //Add the `@kubernetes:Deployment` annotation to a Ballerina service to generate a Kuberenetes Deployment for a Ballerina module. @kubernetes:Deployment {  //OpenShift project name.  namespace: \"hello-api\",  //IP and port of the OpenShift docker registry. If you are using minishift, use the `minishift openshift registry` to find the Docker registry.  registry: \"172.30.1.1:5000\",  //Generate a Docker image with the name `172.30.1.1:5000/hello-api/hello-service:v1.0`.  image: \"hello-service:v1.0\",  //Disable the image being built by default so that the OpenShift BuildConfig can build it.  buildImage: false,  //Generate the OpenShift BuildConfig for building the Docker image.  buildExtension: openshift:BUILD_EXTENSION_OPENSHIFT } @http:ServiceConfig {  basePath: \"/hello\" } service hello on helloEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{user}\"  }  resource function sayHello(http:Caller caller, http:Request request, string user) {  string payload = string `Hello ${<@untainted string> user}!`;  var responseResult = caller->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    OpenShift Deployment  Ballerina supports generating the OpenShift Route, BuildConfig, and ImageStream artifacts based on annotations. Docker image of the Ballerina service is built using the BuildConfig, which then can be used by the generated Kubernetes Deployment. A generated OpenShift Route exposes the Kubernetes Service of the Ballerina Service. This example deploys an HTTP service, which responses “Hello” followed by a name.    import ballerina/http; import ballerina/log; import ballerina/kubernetes; import ballerina/openshift;    @kubernetes:Service {}    Add the @kubernetes:Service to a listener endpoint to expose the endpoint as a Kubernetes Service.   @openshift:Route {  host: \"www.oc-example.com\" } listener http:Listener helloEP = new(9090);    Add the @openshift:Route to expose the Kubernetes Service through an OpenShift Route.   @kubernetes:Deployment {    Add the @kubernetes:Deployment annotation to a Ballerina service to generate a Kuberenetes Deployment for a Ballerina module.   namespace: \"hello-api\",    OpenShift project name.   registry: \"172.30.1.1:5000\",    IP and port of the OpenShift docker registry. If you are using minishift, use the minishift openshift registry to find the Docker registry.   image: \"hello-service:v1.0\",    Generate a Docker image with the name 172.30.1.1:5000/hello-api/hello-service:v1.0.   buildImage: false,    Disable the image being built by default so that the OpenShift BuildConfig can build it.   buildExtension: openshift:BUILD_EXTENSION_OPENSHIFT } @http:ServiceConfig {  basePath: \"/hello\" } service hello on helloEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{user}\"  }  resource function sayHello(http:Caller caller, http:Request request, string user) {  string payload = string `Hello ${<@untainted string> user}!`;  var responseResult = caller->respond(payload);  if (responseResult is error) {  error err = responseResult;  log:printError(\"Error sending response\", err);  }  } }    Generate the OpenShift BuildConfig for building the Docker image.   # Build the Ballerina program. $ ballerina build openshift_deployment.bal Compiling source \topenshift_deployment.bal    Generating executables. \topenshift_deployment.jar    Generating artifacts...    @kubernetes:Service - complete 1/1 \t@kubernetes:Deployment - complete 1/1 \t@kubernetes:Docker - complete 1/1 \t@kubernetes:Helm - complete 1/1 \t@openshift:BuildConfig - complete 1/1 \t@openshift:ImageStream - complete 1/1 \t@openshift:Route - complete 1/1    Run the following command to deploy the OpenShift artifacts: \toc apply -f ./kubernetes/openshift    Run the following command to start a build: \toc start-build bc/openshift-openshift-bc-openshift-bc --from-dir=. --follow    Run the following command to deploy the Kubernetes artifacts: \tkubectl apply -f ./kubernetes    # Create a new OpenShift project $ oc new-project hello-api    # Deploy the OpenShift artifacts $ oc apply -f ./kubernetes/openshift buildconfig.build.openshift.io/openshift-openshift-bc-openshift-bc created imagestream.image.openshift.io/hello-service created route.route.openshift.io/helloep-openshift-route created    # Trigger a build to create the Docker image. $ oc start-build bc/openshift-openshift-bc-openshift-bc --from-dir=. --follow Uploading directory \".\" as binary input for the build ... .. Uploading finished build.build.openshift.io/openshift-openshift-bc-openshift-bc-1 started Receiving source from STDIN as archive ... Pulling image ballerina/jre8:v1 ... Pulled 3/4 layers, 92% complete Pulled 4/4 layers, 100% complete Extracting Step 1/10 : FROM ballerina/jre8:v1  ---> 6953736bfaaa Step 2/10 : LABEL maintainer \"dev@ballerina.io\"  ---> Running in e77dfb0dfe3c  ---> e3ae9b17b0b7 Removing intermediate container e77dfb0dfe3c Step 3/10 : RUN addgroup troupe && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina && apk add --update --no-cache bash && chown -R ballerina:troupe /usr/bin/java && rm -rf /var/cache/apk/*  ---> Running in eaa889f617e6 fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.9/community/x86_64/APKINDEX.tar.gz (1/5) Installing ncurses-terminfo-base (6.1_p20190105-r0) (2/5) Installing ncurses-terminfo (6.1_p20190105-r0) (3/5) Installing ncurses-libs (6.1_p20190105-r0) (4/5) Installing readline (7.0.003-r1) (5/5) Installing bash (4.4.19-r1) Executing bash-4.4.19-r1.post-install Executing busybox-1.29.3-r10.trigger OK: 93 MiB in 58 packages  ---> c49c36916288 Removing intermediate container eaa889f617e6 Step 4/10 : WORKDIR /home/ballerina  ---> a701b8eae0d9 Removing intermediate container 50703b9e9269 Step 5/10 : COPY openshift_deployment.jar /home/ballerina  ---> 991deed81242 Removing intermediate container ce1ec590569b Step 6/10 : EXPOSE 9090  ---> Running in 854b6576d5d6  ---> d00ae6c70a05 Removing intermediate container 854b6576d5d6 Step 7/10 : USER ballerina  ---> Running in c56759363d0a  ---> 2fc8a5b56b1b Removing intermediate container c56759363d0a Step 8/10 : CMD java -jar openshift_deployment.jar  ---> Running in 0c2eb5f6f61b  ---> 1cf62f598ef2 Removing intermediate container 0c2eb5f6f61b Step 9/10 : ENV \"OPENSHIFT_BUILD_NAME\" \"openshift-openshift-bc-openshift-bc-1\" \"OPENSHIFT_BUILD_NAMESPACE\" \"hello-api2\"  ---> Running in 1aeed538f9bc  ---> 35657b171b0a Removing intermediate container 1aeed538f9bc Step 10/10 : LABEL \"io.openshift.build.name\" \"openshift-openshift-bc-openshift-bc-1\" \"io.openshift.build.namespace\" \"hello-api2\"  ---> Running in a48523992d84  ---> 104517906bb2 Removing intermediate container a48523992d84 Successfully built 104517906bb2 Pushing image 172.30.1.1:5000/hello-api2/hello-service:v1.0 ... Pushed 0/6 layers, 7% complete Pushed 1/6 layers, 28% complete Pushed 2/6 layers, 50% complete Pushed 3/6 layers, 60% complete Pushed 4/6 layers, 70% complete Pushed 5/6 layers, 87% complete Pushed 6/6 layers, 100% complete Push successful    # Deploy the Kubernetes artifacts $ kubectl apply -f ./kubernetes service/helloep-svc created deployment.apps/openshift-deployment-deployment created    # Check if pods are running $ oc get pods NAME READY STATUS RESTARTS AGE openshift-deployment-deployment-865d564bc9-5rh78 1/1 Running 0 35m    # Invoke the service. If you are using minikube, go to www.oc-example.com to get the minikube IP. Use the `minikube ip` command to find the IP. $ curl --resolve www.oc-example.com:80:192.168.99.101 http://www.oc-example.com/hello/john Hello john!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/optional-type.html","name":"Optional Type","summary":"One of the design principles of the type system of Ballerina is to eliminate null reference errors.\n Over the years, null reference errors have caused numerous system crashes, security vulnerabilities etc.\n Optional types in Ballerina allow developers to identify where the value or the function\n is of type T optionally, ...","content":"/  /  /  / Optional Type  import ballerina/io;  // This function (optionally) returns a `string` value. In this example, `string?` is equivalent to `string|()`. function getValue(string key) returns string? {  if (key == \"string\") {  return \"hello world\";  }   // In Ballerina, the `nil` type that is provided as `()` contains a single value named \"nil\". This is used  // to represent the absence of any other value.  // The `nil` value is written as `()`.  // `null` is syntactic sugar for \"nil\" that is to be used with JSON values because JSON uses `null`.  // `return ();` here is the same as `return;`. Not having a return statement at the end is also the same as  // explicitly returning `()`.  return (); }  public function main() {  // It is optional for `getValue()` to return a value of type `string`. Thus, the value could be either  // of type `string` or of type `()` and needs to be handled explicitly.  // The statement `string s = getValue(\"string\");` produces a compilation error.  string? s = getValue(\"string\");   // The type test can then be used to check if the value is in fact a `string` and then operate on it.  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  }   // A value of type `string` or `()` can be assigned to `s`.  s = ();  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  } }    Optional Type  One of the design principles of the type system of Ballerina is to eliminate null reference errors.  Over the years, null reference errors have caused numerous system crashes, security vulnerabilities etc.  Optional types in Ballerina allow developers to identify where the value or the function  is of type T optionally, for any T. You can syntactically represent this as T? or T|()`.    import ballerina/io;    function getValue(string key) returns string? {  if (key == \"string\") {  return \"hello world\";  }    This function (optionally) returns a string value. In this example, string? is equivalent to string|().   return (); }    In Ballerina, the nil type that is provided as () contains a single value named “nil”. This is used  to represent the absence of any other value.  The nil value is written as ().  null is syntactic sugar for “nil” that is to be used with JSON values because JSON uses null.  return (); here is the same as return;. Not having a return statement at the end is also the same as  explicitly returning ().   public function main() {    string? s = getValue(\"string\");    It is optional for getValue() to return a value of type string. Thus, the value could be either  of type string or of type () and needs to be handled explicitly.  The statement string s = getValue(\"string\"); produces a compilation error.   if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  }    The type test can then be used to check if the value is in fact a string and then operate on it.   s = ();  if (s is string) {  io:println(\"Length of the string: \", s.length());  } else {  io:println(\"s is ()\");  } }    A value of type string or () can be assigned to s.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run optional_type.bal Length of the string: 11 s is ()    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/overloaded-methods-constructors.html","name":"Overloaded Methods/Constructors","summary":"Let’s look at how to specify the exact Java constructor or Java method when they are overloaded.\n If and only if the Java constructor or the method of interest is overloaded with the same number of\n parameters, then you need to specify the parameter types of the exact constructor or ...","content":"/  /  /  / Overloaded Methods/Constructors  import ballerina/io; import ballerina/java;  // This Ballerina function invokes the `java.lang.StringBuffer` constructor that takes a // `java.lang.String` as an argument. The `java.lang.StringBuffer` class has other overloaded // constructors that take a single parameter. Therefore you need to specify the parameter types here. function newStringBuffer(handle str) returns handle = @java:Constructor {  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;  // The `append` method in `java.lang.StringBuffer` is overloaded many methods that take a single parameter. // In this example, let's use two of those methods. The `appendString` function is linked with the Java `append` // method that takes a `java.lang.String` as an argument. function appendString(handle receiver, handle str) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;  // This `appendStringBuffer` function is linked with the Java `append` method that takes a // `java.lang.StringBuffer` as an argument. function appendStringBuffer(handle receiver, handle strBuffer) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.StringBuffer\"] } external;  public function main() {  // Create a new `java.lang.StringBuffer` by passing a Java string as an argument.  var strBuffer = newStringBuffer(java:fromString(\"Ballerina is \"));  _ = appendString(strBuffer, java:fromString(\"awesome \"));   var strBufferToAppend = newStringBuffer(java:fromString(\"and \"));  _ = appendString(strBufferToAppend, java:fromString(\"fun.\"));   // Append an instance of a `java.lang.StringBuffer` to another `java.lang.StringBuffer` instance.  _ = appendStringBuffer(strBuffer, strBufferToAppend);   string? text = java:toString(strBuffer);  io:println(text); }    Overloaded Methods/Constructors  Let’s look at how to specify the exact Java constructor or Java method when they are overloaded.  If and only if the Java constructor or the method of interest is overloaded with the same number of  parameters, then you need to specify the parameter types of the exact constructor or the method using the  paramTypes annotation field.    import ballerina/io; import ballerina/java;    function newStringBuffer(handle str) returns handle = @java:Constructor {  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;    This Ballerina function invokes the java.lang.StringBuffer constructor that takes a  java.lang.String as an argument. The java.lang.StringBuffer class has other overloaded  constructors that take a single parameter. Therefore you need to specify the parameter types here.   function appendString(handle receiver, handle str) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.String\"] } external;    The append method in java.lang.StringBuffer is overloaded many methods that take a single parameter.  In this example, let’s use two of those methods. The appendString function is linked with the Java append  method that takes a java.lang.String as an argument.   function appendStringBuffer(handle receiver, handle strBuffer) returns handle = @java:Method {  name: \"append\",  class: \"java.lang.StringBuffer\",  paramTypes: [\"java.lang.StringBuffer\"] } external;    This appendStringBuffer function is linked with the Java append method that takes a  java.lang.StringBuffer as an argument.   public function main() {    var strBuffer = newStringBuffer(java:fromString(\"Ballerina is \"));  _ = appendString(strBuffer, java:fromString(\"awesome \"));    Create a new java.lang.StringBuffer by passing a Java string as an argument.   var strBufferToAppend = newStringBuffer(java:fromString(\"and \"));  _ = appendString(strBufferToAppend, java:fromString(\"fun.\"));    _ = appendStringBuffer(strBuffer, strBufferToAppend);    Append an instance of a java.lang.StringBuffer to another java.lang.StringBuffer instance.   string? text = java:toString(strBuffer);  io:println(text); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run overloaded-methods-constructors.bal Ballerina is awesome and fun.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/optional-field-access.html","name":"Optional Field Access","summary":"The optional field access operator can be used to access record fields including optional fields.\n The Optional Type example demonstrates how to eliminate null reference errors by using optional types in Ballerina.\n Further, it demonstrates how to operate on optional-typed variables.\n E.g., the + operator cannot operate on values of ...","content":"/  /  /  / Optional Field Access  import ballerina/io;  type Address record {  string line01;  string line02;  string city;  string state;  string zipcode; };  // According to the `Person` record type descriptor, the `addr` field could either hold an `Address` record or the value // nil (`()`). Moreover, the `age` field is an optional field that may or may not be specified. type Person record {  string name;  int age?;  Address? addr; };  // This function optionally returns a `Person` value. function getPerson(string name, int age) returns Person? {  if (name == \"\" || age == 0) {  return;  } else {  // Defines a `Person` record.  Person p = {  name: name,  age: age,  addr: {  line01: \"No. 61\",  line02: \"Brandon street\",  city: \"Santa Clara\",  state: \"CA\",  zipcode: \"95134\"  }  };  return p;  } }  public function main() {   // Create a `Person` value without specifying the `age` field.  Person p1 = {name: \"Anne\", addr: ()};  // The optional field `age` can be accessed using the optional field access operator.  // The return type will be the union of the type of the field and `()`.  // If the value is present, the value will be returned.  // If not, `()` will be returned.  // `()` is returned here since `age` is not set.  int? age = p1?.age;  io:println(\"Age: \", age);   // Create a `Person` value with the `age` field.  p1 = {name: \"Anne\", age: 24, addr: ()};  // Now, `age` will be the `int` value that is set.  age = p1?.age;  io:println(\"Age: \", age);   Person? p2 = getPerson(\"John\", 30);  io:println(p2);   // The optional field access operator is a lifted operator in Ballerina.  // Both `p2` and `p2.addr` are optional record types.  // If the type of either `p2` or `p2.addr` is `()` at runtime, `()` would  // be assigned to the `city1` variable. Else, the `string` value of the `city` field  // of the `address` field of the `Person` record `p2` would be assigned.  string? city1 = p2?.addr?.city;  // The value \"Santa Clara\" is displayed in the console.  io:println(city1);   // Invoking `getPerson()` as follows will result in `()` being assigned to `p3`.  Person? p3 = getPerson(\"\", 0);  // Thus, the `city2` variable will contain `()` as the value.  string? city2 = p3?.addr?.city;  io:println(city2);   // Now, assign a `Person` record to `p3` setting the `address` field to `()`.  p3 = {name: \"George\", age: 20, addr: ()};  // Again, the `city2` variable will contain `()`, since the value of the `address` field is `()`.  city2 = p3?.addr?.city;  io:println(city2);   // In this example, the Elvis operator is used to eliminate `nil`.  // If the value of the first expression is not `nil`, the Elvis operator returns that value.  // If the value of the first expression is `nil`, the operator returns the value of the second expression.  string defaultCity = \"San Jose\";  string city = city2 ?: defaultCity;  io:println(city); }    Optional Field Access  The optional field access operator can be used to access record fields including optional fields.  The Optional Type example demonstrates how to eliminate null reference errors by using optional types in Ballerina.  Further, it demonstrates how to operate on optional-typed variables.  E.g., the + operator cannot operate on values of the int? type. However, the optional field access operator can  be applied on optional record types and lax types.    import ballerina/io;    type Address record {  string line01;  string line02;  string city;  string state;  string zipcode; };    type Person record {  string name;  int age?;  Address? addr; };    According to the Person record type descriptor, the addr field could either hold an Address record or the value  nil (()). Moreover, the age field is an optional field that may or may not be specified.   function getPerson(string name, int age) returns Person? {  if (name == \"\" || age == 0) {  return;  } else {    This function optionally returns a Person value.   Person p = {  name: name,  age: age,  addr: {  line01: \"No. 61\",  line02: \"Brandon street\",  city: \"Santa Clara\",  state: \"CA\",  zipcode: \"95134\"  }  };  return p;  } }    Defines a Person record.   public function main() {    Person p1 = {name: \"Anne\", addr: ()};    Create a Person value without specifying the age field.   int? age = p1?.age;  io:println(\"Age: \", age);    The optional field age can be accessed using the optional field access operator.  The return type will be the union of the type of the field and ().  If the value is present, the value will be returned.  If not, () will be returned.  () is returned here since age is not set.   p1 = {name: \"Anne\", age: 24, addr: ()};    Create a Person value with the age field.   age = p1?.age;  io:println(\"Age: \", age);    Now, age will be the int value that is set.   Person? p2 = getPerson(\"John\", 30);  io:println(p2);    string? city1 = p2?.addr?.city;    The optional field access operator is a lifted operator in Ballerina.  Both p2 and p2.addr are optional record types.  If the type of either p2 or p2.addr is () at runtime, () would  be assigned to the city1 variable. Else, the string value of the city field  of the address field of the Person record p2 would be assigned.   io:println(city1);    The value “Santa Clara” is displayed in the console.   Person? p3 = getPerson(\"\", 0);    Invoking getPerson() as follows will result in () being assigned to p3.   string? city2 = p3?.addr?.city;  io:println(city2);    Thus, the city2 variable will contain () as the value.   p3 = {name: \"George\", age: 20, addr: ()};    Now, assign a Person record to p3 setting the address field to ().   city2 = p3?.addr?.city;  io:println(city2);    Again, the city2 variable will contain (), since the value of the address field is ().   string defaultCity = \"San Jose\";  string city = city2 ?: defaultCity;  io:println(city); }    In this example, the Elvis operator is used to eliminate nil.  If the value of the first expression is not nil, the Elvis operator returns that value.  If the value of the first expression is nil, the operator returns the value of the second expression.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run optional_field_access.bal Age: Age: 24 name=John age=30 addr=line01=No. 61 line02=Brandon street city=Santa Clara state=CA zipcode=95134 Santa Clara    San Jose    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/panic.html","name":"Panic","summary":"In Ballerina, panic indicates abnormal completion and usually implies that something unexpected has occurred\n (i.e., something that should not have occurred during the normal operation). A panic causes\n the call stack to unwind until it is trapped, or if not trapped results in the termination of the program.Ballerina discourages the ...","content":"/  /  /  / Panic  import ballerina/io;  type Record record {  int id;  string name; };  function readRecord(Record? value) {  if (value is Record) {  io:println(\"Record ID: \", value.id, \", value: \", value.name);  } else {  // Panics if `value` is `()`.  error err = error(\"Record is nil\");  panic err;  } }  public function main() {  Record r1 = {  id: 1,  name: \"record1\"  };  readRecord(r1);   // `r2` is `()`.  Record? r2 = ();  // Since `r2` is `()`, `readRecord()` will panic.  readRecord(r2);   // The following lines of code will not be executed.  Record r3 = {  id: 3,  name: \"record3\"  };  readRecord(r3); }    Panic  In Ballerina, panic indicates abnormal completion and usually implies that something unexpected has occurred  (i.e., something that should not have occurred during the normal operation). A panic causes  the call stack to unwind until it is trapped, or if not trapped results in the termination of the program.  Ballerina discourages the use of panic to handle program-related  errors such as “header not found”, “data mismatch”, etc.). However,  panic can be used in scenarios such as “Connection Closed/Timeout” and “OutOfMemory”  where the program cannot handle the error by itself.    import ballerina/io;    type Record record {  int id;  string name; };    function readRecord(Record? value) {  if (value is Record) {  io:println(\"Record ID: \", value.id, \", value: \", value.name);  } else {    error err = error(\"Record is nil\");  panic err;  } }    Panics if value is ().   public function main() {  Record r1 = {  id: 1,  name: \"record1\"  };  readRecord(r1);    Record? r2 = ();    r2 is ().   readRecord(r2);    Since r2 is (), readRecord() will panic.   Record r3 = {  id: 3,  name: \"record3\"  };  readRecord(r3); }    The following lines of code will not be executed.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run panic.bal Record ID: 1, value: record1 error: Record is nil  at panic:readRecord(panic.bal:13)  panic:main(panic.bal:28)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/passthrough.html","name":"Passthrough","summary":"The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify\n which HTTP methods are allowed.When forward() is called on the backend client endpoint, it forwards the ...","content":"/  /  /  / Passthrough  import ballerina/http; import ballerina/log;  http:Client clientEP = new (\"http://localhost:9092/hello\");  service passthrough on new http:Listener(9090) {   // The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify  // which HTTP methods are allowed.  @http:ResourceConfig {  path: \"/\"  }  resource function passthrough(http:Caller caller, http:Request req) {  // When `forward()` is called on the backend client endpoint, it forwards the request that the passthrough  // resource received to the backend. When forwarding, the request is made using the same HTTP method that was  // used to invoke the passthrough resource. The `forward()` function returns the response from the backend if  // there are no errors.  var clientResponse = clientEP->forward(\"/\", req);   // `forward()` can return an HTTP response or an error.  if (clientResponse is http:Response) {  // If the request was successful, an HTTP response is returned.  // Here, the received response is forwarded to the client through the outbound endpoint.  var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  // If there was an error, the 500 error response is constructed and sent back to the client.  http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }  // Sample hello world service. service hello on new http:Listener(9092) {   // The `helloResource` only accepts requests made using the specified HTTP methods.  @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function helloResource(http:Caller caller, http:Request req) {  // Send the response back to the caller.  var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Passthrough  The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.    import ballerina/http; import ballerina/log;    http:Client clientEP = new (\"http://localhost:9092/hello\");    service passthrough on new http:Listener(9090) {    @http:ResourceConfig {  path: \"/\"  }  resource function passthrough(http:Caller caller, http:Request req) {    The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify  which HTTP methods are allowed.   var clientResponse = clientEP->forward(\"/\", req);    When forward() is called on the backend client endpoint, it forwards the request that the passthrough  resource received to the backend. When forwarding, the request is made using the same HTTP method that was  used to invoke the passthrough resource. The forward() function returns the response from the backend if  there are no errors.   if (clientResponse is http:Response) {    forward() can return an HTTP response or an error.   var result = caller->respond(clientResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {    If the request was successful, an HTTP response is returned.  Here, the received response is forwarded to the client through the outbound endpoint.   http:Response res = new;  res.statusCode = 500;  res.setPayload(<string>clientResponse.detail()?.message);  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    If there was an error, the 500 error response is constructed and sent back to the client.   service hello on new http:Listener(9092) {    Sample hello world service.   @http:ResourceConfig {  methods: [\"POST\", \"PUT\", \"GET\"],  path: \"/\"  }  resource function helloResource(http:Caller caller, http:Request req) {    The helloResource only accepts requests made using the specified HTTP methods.   var result = caller->respond(\"Hello World!\");  if (result is error) {  log:printError(\"Error sending response\", result);  }  } }    Send the response back to the caller.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run passthrough.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/passthrough -X POST Hello World! curl http://localhost:9090/passthrough -X GET Hello World! curl http://localhost:9090/passthrough -X PUT Hello World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/proto-to-ballerina.html","name":"Proto To Ballerina","summary":"If you already have protocol buffer file for your service(s) you can use that to autogenerate Ballerina source code.\n Currently, Ballerina supports two types of code generation. service generation generates a mock version of the\n Ballerina service for an input proto definition.  client generation generates a Ballerina client endpoint ...","content":"/  /  /  / Proto To Ballerina  Proto To Ballerina  If you already have protocol buffer file for your service(s) you can use that to autogenerate Ballerina source code.  Currently, Ballerina supports two types of code generation. service generation generates a mock version of the  Ballerina service for an input proto definition. client generation generates a Ballerina client endpoint for an  input proto definition.  The Ballerina code generator supports the following parameters:  --input The path of the .proto file. This is a mandatory parameter.  --output The file location in which the Ballerina client/service and the stub must be generated. This is an optional parameter.  If no value is specified for this parameter and proto definition doesn’t contain package value,  the Ballerina client/service and the stub files are generated inside temp directory in the current location.  This path must be a project directory.  --mode The mode (client or server) to generate code samples.  If no value is specified for this parameter, only the stub file will be generated.    syntax = \"proto3\";    service helloWorld {  rpc hello(HelloRequest) returns (HelloResponse);  rpc bye(ByeRequest) returns (ByeResponse); }    message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; } message ByeRequest { \tstring greet = 1; } message ByeResponse { \tstring say = 1; }    # Execute the command below in the Ballerina tools distribution to generate the mock service. ballerina grpc --input proto_to_ballerina.proto --mode service --output service    # Execute the command below in the Ballerina tools distribution to generate the client endpoint and the stub file. ballerina grpc --input proto_to_ballerina.proto --mode client --output client    # Execute the command below in the Ballerina tools distribution to generate the stub file. ballerina grpc --input proto_to_ballerina.proto    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/query-action.html","name":"Query Action","summary":"Like a query-expression, a query-action can be used with a value that is iterable with any error type.\n The result of the query-action is the termination value of the iterator.\n Thus, if the source type is infallibly iterable, the result will be () and can be ignored.\n This is a ...","content":"/  /  /  / Query Action  import ballerina/io;  type Student record {  string firstName;  string lastName;  float score; };  type FullName record {|  string firstName;  string lastName; |};  public function main() {  Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};   Student[] studentList = [s1, s2, s3];   FullName[] nameList = [];  //`query-action` works similarly to a `foreach` statement.  //It can be used to iterate through any iterable value.  //The result of the query-action is the termination value of the iterable value.  //It can be either an error or ().  var e = from var student in studentList  // The block inside the `do` clause is executed for each iteration.  do {  FullName fullName = {firstName: student.firstName, lastName: student.lastName};  nameList.push(fullName);  };   foreach var name in nameList {  io:println(name);  } }    Query Action  Like a query-expression, a query-action can be used with a value that is iterable with any error type.  The result of the query-action is the termination value of the iterator.  Thus, if the source type is infallibly iterable, the result will be () and can be ignored.  This is a preview feature.    import ballerina/io;    type Student record {  string firstName;  string lastName;  float score; };    type FullName record {|  string firstName;  string lastName; |};    public function main() {  Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};    Student[] studentList = [s1, s2, s3];    FullName[] nameList = [];    var e = from var student in studentList    query-action works similarly to a foreach statement. It can be used to iterate through any iterable value. The result of the query-action is the termination value of the iterable value. It can be either an error or ().   do {  FullName fullName = {firstName: student.firstName, lastName: student.lastName};  nameList.push(fullName);  };    The block inside the do clause is executed for each iteration.   foreach var name in nameList {  io:println(name);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run query_action.bal    firstName=Alex lastName=George firstName=Ranjan lastName=Fonseka firstName=John lastName=David    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/query-expression.html","name":"Query Expression","summary":"A query expression is a list comprehension, which can be used with a value that is iterable with any error type.\n It consists of four kinds of clauses: from, let, where, and select.\n The first clause must be a from clause and the last clause must be a select.\n The ...","content":"/  /  /  / Query Expression  import ballerina/io;  type Student record {  string firstName;  string lastName;  int intakeYear;  float score; };  type Report record {  string name;  string degree;  int expectedGradYear; };  public function main() {   Student s1 = {firstName: \"Alex\", lastName: \"George\", intakeYear: 2020, score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", intakeYear: 2020, score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", intakeYear: 2022, score: 1.2};   Student[] studentList = [s1, s2, s3];   //The `from` clause works similarly to a `foreach` statement.  //It can be used to iterate any iterable value.  //The `outputStudentList` is the result of the `query` expression.  Report[] reportList = from var student in studentList  //The `where` clause provides a way to perform conditional execution and works similarly to an `if` condition.  //It can refer to variables bound by the from clause.  //When the `where` condition evaluates to false, the iteration skips following the clauses.  where student.score >= 1  //The `let` clause binds the variables.  let string degreeName = \"Bachelor of Medicine\",  int graduationYear = calGraduationYear(student.intakeYear)  //The `select` clause is evaluated for each iteration.  //The result of the query expression is a list(`reportList`) whose members are the result of the `select` clause.  select {  name: student.firstName,  degree: degreeName,  expectedGradYear: graduationYear  };   foreach var report in reportList {  io:println(report);  } }  function calGraduationYear(int year) returns int {  return year + 5; }    Query Expression  A query expression is a list comprehension, which can be used with a value that is iterable with any error type.  It consists of four kinds of clauses: from, let, where, and select.  The first clause must be a from clause and the last clause must be a select.  The result of the query expression is a list.  This is a preview feature.    import ballerina/io;    type Student record {  string firstName;  string lastName;  int intakeYear;  float score; };    type Report record {  string name;  string degree;  int expectedGradYear; };    public function main() {    Student s1 = {firstName: \"Alex\", lastName: \"George\", intakeYear: 2020, score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", intakeYear: 2020, score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", intakeYear: 2022, score: 1.2};    Student[] studentList = [s1, s2, s3];    Report[] reportList = from var student in studentList    The from clause works similarly to a foreach statement. It can be used to iterate any iterable value. The outputStudentList is the result of the query expression.   where student.score >= 1    The where clause provides a way to perform conditional execution and works similarly to an if condition. It can refer to variables bound by the from clause. When the where condition evaluates to false, the iteration skips following the clauses.   let string degreeName = \"Bachelor of Medicine\",  int graduationYear = calGraduationYear(student.intakeYear)    The let clause binds the variables.   select {  name: student.firstName,  degree: degreeName,  expectedGradYear: graduationYear  };    The select clause is evaluated for each iteration. The result of the query expression is a list(reportList) whose members are the result of the select clause.   foreach var report in reportList {  io:println(report);  } }    function calGraduationYear(int year) returns int {  return year + 5; }    # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run query_expression.bal    name=Alex degree=Bachelor of Medicine expectedGradYear=2025 name=John degree=Bachelor of Medicine expectedGradYear=2027    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/quoted-identifiers.html","name":"Quoted Identifiers","summary":"Ballerina supports quoted identifiers, making it possible to use arbitrary non-empty strings as identifiers,\n including those that are not generally allowed as identifiers (e.g., reserved keywords).\n Quoted identifiers are defined and referenced by prefixing the identifier with the ' character.Use the reserved keyword function as the name of the function.Use ...","content":"/  /  /  / Quoted Identifiers  import ballerina/io;  // Use the reserved keyword `function` as the name of the function. function 'function(int val) returns int {  return val + 1; }  public function main() {   // Use the reserved keyword `int` as the name of the variable.  int 'int = 1;   // Invoke the function named `function` with the variable named `int`.  // The quoted identifier syntax is used to refer to both the function and  // the variable.  int i = 'function('int);  io:println(i);   // Define a variable where the variable name starts with a digit.  int '1PlusI = 1 + i;  io:println('1PlusI); }    Quoted Identifiers  Ballerina supports quoted identifiers, making it possible to use arbitrary non-empty strings as identifiers,  including those that are not generally allowed as identifiers (e.g., reserved keywords).  Quoted identifiers are defined and referenced by prefixing the identifier with the ' character.    import ballerina/io;    function 'function(int val) returns int {  return val + 1; }    Use the reserved keyword function as the name of the function.   public function main() {    int 'int = 1;    Use the reserved keyword int as the name of the variable.   int i = 'function('int);  io:println(i);    Invoke the function named function with the variable named int.  The quoted identifier syntax is used to refer to both the function and  the variable.   int '1PlusI = 1 + i;  io:println('1PlusI); }    Define a variable where the variable name starts with a digit.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run quoted_identifiers.bal 2 3    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/query-path-matrix-param.html","name":"Query Path Matrix Param","summary":"Ballerina supports extracting values using the PathParam, QueryParam and MatrixParam parameters.The PathParam and QueryParam parameters extract values from the request URI.Get the QueryParam value for a given parameter key.Get the MatrixParams.Create a JSON payload with the extracted values.A util method to set the JSON payload to the response message.Send a ...","content":"/  /  /  / Query Path Matrix Param  import ballerina/http; import ballerina/log;  service sample on new http:Listener(9090) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/path/{foo}\"  }  // The `PathParam` and `QueryParam` parameters extract values from the request URI.  resource function params(http:Caller caller, http:Request req,  string foo) {  // Get the `QueryParam` value for a given parameter key.  var bar = req.getQueryParamValue(\"bar\");   // Get the `MatrixParams`.  map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};   // Create a JSON payload with the extracted values.  json responseJson = {  \"pathParam\": foo,  \"queryParam\": bar,  \"matrix\": matrixJson  };  http:Response res = new;  // A util method to set the JSON payload to the response message.  res.setJsonPayload(<@untainted>responseJson);  // Send a response to the client.  var result = caller->respond(res);   if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    Query Path Matrix Param  Ballerina supports extracting values using the PathParam, QueryParam and MatrixParam parameters.    import ballerina/http; import ballerina/log;    service sample on new http:Listener(9090) {    @http:ResourceConfig {  methods: [\"GET\"],  path: \"/path/{foo}\"  }    resource function params(http:Caller caller, http:Request req,  string foo) {    The PathParam and QueryParam parameters extract values from the request URI.   var bar = req.getQueryParamValue(\"bar\");    Get the QueryParam value for a given parameter key.   map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};    Get the MatrixParams.   json responseJson = {  \"pathParam\": foo,  \"queryParam\": bar,  \"matrix\": matrixJson  };  http:Response res = new;    Create a JSON payload with the extracted values.   res.setJsonPayload(<@untainted>responseJson);    A util method to set the JSON payload to the response message.   var result = caller->respond(res);    Send a response to the client.   if (result is error) {  log:printError(\"Error when responding\", result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run query_path_matrix_param.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Run this curl command below to invoke the service. curl \"http://localhost:9090/sample/path;a=4;b=5/value1;x=10;y=15?bar=value2\" {\"pathParam\":\"value1\", \"queryParam\":\"value2\", \"matrix\":{\"path\":\"a=4, b=5\", \"foo\":\"x=10, y=15\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/rabbitmq-consumer-with-client-acknowledgement.html","name":"Client Acknowledgements","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The received messages are acknowledged manually.\n By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge\n all messages once consumed.Creates a ballerina RabbitMQ connection that allows re-usability if necessary.The consumer service listens to ...","content":"/  /  /  / Client Acknowledgements  import ballerina/log; import ballerina/rabbitmq;  // Creates a ballerina RabbitMQ connection that allows re-usability if necessary. rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});  listener rabbitmq:Listener channelListener = new (connection);  // The consumer service listens to the \"MyQueue\" queue. // ackMode is by default rabbitmq:AUTO_ACK which will automatically acknowledge // all messages once consumed. @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK } // Attaches the service to the listener. service rabbitmqConsumerAck on channelListener {   // Gets triggered when a message is received by the queue.  resource function onMessage(rabbitmq:Message message) {   // Retrieves the text content of the message.  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }   // Positively acknowledges a single message.  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    Client Acknowledgements  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The received messages are acknowledged manually.  By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge  all messages once consumed.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK }    The consumer service listens to the “MyQueue” queue.  ackMode is by default rabbitmq:AUTO_ACK which will automatically acknowledge  all messages once consumed.   service rabbitmqConsumerAck on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Retrieves the text content of the message.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    Positively acknowledges a single message.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_client_acknowledgement.bal' file and issue the 'ballerina run' command as follows.    ballerina run rabbitmq_consumer_with_client_acknowledgement.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/rabbitmq-consumer-with-data-binding.html","name":"Data Binding","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The messages can be accessed using the rabbitmq:Message object and also\n the second parameter of the resource function.\n string, json, xml, byte[], record, float and int are\n supported as parameter types.Creates a ballerina ...","content":"/  /  /  / Data Binding  import ballerina/log; import ballerina/rabbitmq;  // Creates a ballerina RabbitMQ connection that allows re-usability if necessary. rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});  listener rabbitmq:Listener channelListener = new (connection);  @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK } // Attaches the service to the listener. service dataBindingConsumer on channelListener {   // Gets triggered when a message is received by the queue.  resource function onMessage(rabbitmq:Message message, string stringMessage) {  // Retrieves the text content of the message.  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }   // Message content can be accessed using the second parameter  // of the resource function.  log:printInfo(\"The message received from data binding: \" + stringMessage);   // Acknowledges a single message positively.  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  }   // Gets triggered when an error is encountered.  resource function onError(rabbitmq:Message message, error err) {  log:printError(\"Error from connector: \" + err.reason() + \" - \"  + <string>err.detail()?.message);  } }    Data Binding  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The messages can be accessed using the rabbitmq:Message object and also  the second parameter of the resource function.  string, json, xml, byte[], record, float and int are  supported as parameter types.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK }    service dataBindingConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message, string stringMessage) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Retrieves the text content of the message.   log:printInfo(\"The message received from data binding: \" + stringMessage);    Message content can be accessed using the second parameter  of the resource function.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  }    Acknowledges a single message positively.   resource function onError(rabbitmq:Message message, error err) {  log:printError(\"Error from connector: \" + err.reason() + \" - \"  + <string>err.detail()?.message);  } }    Gets triggered when an error is encountered.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_data_binding.bal' file, and issue the 'ballerina run' command as follows.    ballerina run rabbitmq_consumer_with_data_binding.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-06-13 13:15:35,611 INFO [] - The message received: Hello from Ballerina 2019-06-13 13:15:35,612 INFO [] - The message received from data binding: Hello from Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/rabbitmq-consumer-with-qos-settings.html","name":"QoS Settings","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener,\n requesting specific “quality of service” settings.\n These settings (i.e., prefetchCount and prefetchSize) impose limits on the amount\n of data the server will deliver to consumers before requiring acknowledgements.\n Thus, they provide a means ...","content":"/  /  /  / QoS Settings  import ballerina/log; import ballerina/rabbitmq;  // Creates a ballerina RabbitMQ connection that allows reusability if necessary. rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});  listener rabbitmq:Listener channelListener = new (connection);  // The consumer service listens to the \"MyQueue\" queue. // Quality of service settings(prefetchCount and prefetchSize) can be // set at the listener initialization globally or per consumer service. // These settings impose limits on the amount of data the server // will deliver to consumers before requiring acknowledgements. // Thus they provide a means of consumer-initiated flow control. @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK,  prefetchCount: 10 } // Attaches the service to the listener. service QosConsumer on channelListener {   // Gets triggered when a message is received by the queue.  resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  // The consumer will continue to receive messages from the server  // once a total of 10(prefetchCount) messages are being acknowledged.  var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    QoS Settings  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener,  requesting specific “quality of service” settings.  These settings (i.e., prefetchCount and prefetchSize) impose limits on the amount  of data the server will deliver to consumers before requiring acknowledgements.  Thus, they provide a means of consumer-initiated flow control.  prefetchSize is the maximum amount of content (measured in octets)  that the server will deliver.  If the prefetchSize is given as 0, it will be considered unlimited.  prefetchCount is the maximum number of messages that the server will deliver.  If the prefetchCount is given as 0, it will be considered unlimited.  If the settings are specified at the listener initialization, they will be  applied for the entire connection as a global setting.  To apply the settings per consumer service, they should be specified in the  service config annotation.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows reusability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  },  ackMode: rabbitmq:CLIENT_ACK,  prefetchCount: 10 }    The consumer service listens to the “MyQueue” queue.  Quality of service settings(prefetchCount and prefetchSize) can be  set at the listener initialization globally or per consumer service.  These settings impose limits on the amount of data the server  will deliver to consumers before requiring acknowledgements.  Thus they provide a means of consumer-initiated flow control.   service QosConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }    Gets triggered when a message is received by the queue.   var result = message->basicAck();  if (result is error) {  log:printError(\"Error occurred while acknowledging the message.\");  }  } }    The consumer will continue to receive messages from the server  once a total of 10(prefetchCount) messages are being acknowledged.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_qos_settings.bal' file and issue the 'ballerina run' command as follows..    ballerina run rabbitmq_consumer_with_qos_settings.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/rabbitmq-consumer.html","name":"Consumer","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The Ballerina RabbitMQ connection used here can be re-used to create\n multiple channels.\n Multiple services consuming messages from the same queue or from\n different queues can be attached to the same Listener.Creates a ...","content":"/  /  /  / Consumer  import ballerina/log; import ballerina/rabbitmq;  // Creates a ballerina RabbitMQ connection that allows re-usability if necessary. rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});  listener rabbitmq:Listener channelListener = new (connection);  // The consumer service listens to the \"MyQueue\" queue. // The `ackMode` is by default rabbitmq:AUTO_ACK where messages are acknowledged // immediately after consuming. @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  } } // Attaches the service to the listener. service rabbitmqConsumer on channelListener {   // Gets triggered when a message is received by the queue.  resource function onMessage(rabbitmq:Message message) {   // Retrieves the text content of the message.  var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  } }    Consumer  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The Ballerina RabbitMQ connection used here can be re-used to create  multiple channels.  Multiple services consuming messages from the same queue or from  different queues can be attached to the same Listener.    import ballerina/log; import ballerina/rabbitmq;    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   listener rabbitmq:Listener channelListener = new (connection);    @rabbitmq:ServiceConfig {  queueConfig: {  queueName: \"MyQueue\"  } }    The consumer service listens to the “MyQueue” queue.  The ackMode is by default rabbitmq:AUTO_ACK where messages are acknowledged  immediately after consuming.   service rabbitmqConsumer on channelListener {    Attaches the service to the listener.   resource function onMessage(rabbitmq:Message message) {    Gets triggered when a message is received by the queue.   var messageContent = message.getTextContent();  if (messageContent is string) {  log:printInfo(\"The message received: \" + messageContent);  } else {  log:printError(\"Error occurred while retrieving the message content.\");  }  } }    Retrieves the text content of the message.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer.bal' file, and issue the 'ballerina run' command as follows..    ballerina run rabbitmq_consumer.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    2019-03-29 12:11:18,194 INFO [] - The message received: Hello from Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/rabbitmq-producer.html","name":"Producer","summary":"In this example, messages are sent to two different queues,\n to one queue using the same channel and to the other using two different channels.Creates a ballerina RabbitMQ connection that allows re-usability if necessary.Creates multiple ballerina RabbitMQ channels.Declares the queue, MyQueue1.Declares the queue, MyQueue2.Publishing messages to an exchange using a ...","content":"/  /  /  / Producer  import ballerina/io; import ballerina/rabbitmq;  public function main() {  // Creates a ballerina RabbitMQ connection that allows re-usability if necessary.  rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});   // Creates multiple ballerina RabbitMQ channels.  rabbitmq:Channel newChannel1 = new (connection);  rabbitmq:Channel newChannel2 = new (connection);   // Declares the queue, MyQueue1.  var queueResult1 = newChannel1->queueDeclare({queueName: \"MyQueue1\"});  if (queueResult1 is error) {  io:println(\"An error occurred while creating the MyQueue1 queue.\");  }   // Declares the queue, MyQueue2.  var queueResult2 = newChannel2->queueDeclare({queueName: \"MyQueue2\"});  if (queueResult2 is error) {  io:println(\"An error occurred while creating the MyQueue2 queue.\");  }   // Publishing messages to an exchange using a routing key.  // Publishes the message using newChannel1 and the routing key named MyQueue1.  worker w1 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel1.\");  }  }   // Publishing messages to the same routing key using a different channel.  // Publishes the message using newChannel2 and the same routing key named MyQueue1.  worker w2 {  var sendResult = newChannel2->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel2.\");  }  }   // Publishing messages to different routing keys using the same channel.  // Publishes the message using newChannel1 to a different routing key named MyQueue2.  worker w3 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue2\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue2 using newChannel1.\");  }  }  _ = wait {w1, w2, w3}; }    Producer  In this example, messages are sent to two different queues,  to one queue using the same channel and to the other using two different channels.    import ballerina/io; import ballerina/rabbitmq;    public function main() {    rabbitmq:Connection connection = new ({host: \"localhost\", port: 5672});    Creates a ballerina RabbitMQ connection that allows re-usability if necessary.   rabbitmq:Channel newChannel1 = new (connection);  rabbitmq:Channel newChannel2 = new (connection);    Creates multiple ballerina RabbitMQ channels.   var queueResult1 = newChannel1->queueDeclare({queueName: \"MyQueue1\"});  if (queueResult1 is error) {  io:println(\"An error occurred while creating the MyQueue1 queue.\");  }    Declares the queue, MyQueue1.   var queueResult2 = newChannel2->queueDeclare({queueName: \"MyQueue2\"});  if (queueResult2 is error) {  io:println(\"An error occurred while creating the MyQueue2 queue.\");  }    Declares the queue, MyQueue2.   worker w1 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel1.\");  }  }    Publishing messages to an exchange using a routing key.  Publishes the message using newChannel1 and the routing key named MyQueue1.   worker w2 {  var sendResult = newChannel2->basicPublish(\"Hello from Ballerina\",  \"MyQueue1\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue1 using newChannel2.\");  }  }    Publishing messages to the same routing key using a different channel.  Publishes the message using newChannel2 and the same routing key named MyQueue1.   worker w3 {  var sendResult = newChannel1->basicPublish(\"Hello from Ballerina\",  \"MyQueue2\");  if (sendResult is error) {  io:println(\"An error occurred while sending the message to \" +  \"MyQueue2 using newChannel1.\");  }  }  _ = wait {w1, w2, w3}; }    Publishing messages to different routing keys using the same channel.  Publishes the message using newChannel1 to a different routing key named MyQueue2.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_producer.bal' file, and issue the 'ballerina run' command as follows.    ballerina run rabbitmq_producer.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/range-expressions.html","name":"Range Expressions","summary":"Range expressions result in iterable objects that allow iterating over a sequence of integers in increasing order.\n Range expressions are mainly expected to be used in foreach statements but could be used anywhere.A range expression x ... y can be used to iterate integers\n from x to y including x ...","content":"/  /  /  / Range Expressions  import ballerina/io;  public function main() {  // A range expression `x ... y` can be used to iterate integers  // from `x` to `y` including `x` and `y` in ascending order.  io:println(\"foreach for 25 ... 28\");  foreach int i in 25 ... 28 {  io:println(i);  }   // A range expression `x ..< y` can be used to iterate integers  // from `x` to `y` including `x` but excluding `y` in ascending order.  io:println(\"\\nforeach for 25 ..< 28\");  foreach int i in 25 ..< 28 {  io:println(i);  }   // The result of a range expression can also be used by assigning it to  // an object belonging to the abstract object type `Iterable<int>`.  abstract object {  public function __iterator() returns  abstract object {  public function next() returns record {|int value;|}?;  };  } iterableObj = 25 ..< 28;   abstract object {  public function next() returns (record {|int value;|}?);  } iterator = iterableObj.__iterator();   io:println(\"\\niterable object for 25 ..< 28\");  while (true) {  record {|int value;|}? r = iterator.next();  if (r is record {|int value;|}) {  io:println(r.value);  } else {  // `r` is `()` implying the end of the iteration.  break;  }  } }    Range Expressions  Range expressions result in iterable objects that allow iterating over a sequence of integers in increasing order.  Range expressions are mainly expected to be used in foreach statements but could be used anywhere.    import ballerina/io;    public function main() {    io:println(\"foreach for 25 ... 28\");  foreach int i in 25 ... 28 {  io:println(i);  }    A range expression x ... y can be used to iterate integers  from x to y including x and y in ascending order.   io:println(\"\\nforeach for 25 ..< 28\");  foreach int i in 25 ..< 28 {  io:println(i);  }    A range expression x ..< y can be used to iterate integers  from x to y including x but excluding y in ascending order.   abstract object {  public function __iterator() returns  abstract object {  public function next() returns record {|int value;|}?;  };  } iterableObj = 25 ..< 28;    The result of a range expression can also be used by assigning it to  an object belonging to the abstract object type Iterable<int>.   abstract object {  public function next() returns (record {|int value;|}?);  } iterator = iterableObj.__iterator();    io:println(\"\\niterable object for 25 ..< 28\");  while (true) {  record {|int value;|}? r = iterator.next();  if (r is record {|int value;|}) {  io:println(r.value);  } else {    break;  }  } }    r is () implying the end of the iteration.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run range_expressions.bal foreach for 25 ... 28 25 26 27 28    foreach for 25 ..< 28 25 26 27    iterable object for 25 ..< 28 25 26 27    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-destructure-binding-pattern.html","name":"Record Destructure Binding Pattern","summary":"Record destructure binding patterns are used to destructure and assign the values of each field in the destructed record to variable references.\n The record destructuring binding patterns will be used to refer to existing variables as a record, destructure\n the given value on the right hand side, and assign the ...","content":"/  /  /  / Record Destructure Binding Pattern  import ballerina/io;  type Person record {  string name;  int age;  string country; };  type Country record {  string name;  Capital capital; };  type Capital record {|  string name; |};  public function main() {   string firstName;  int personAge;  map<anydata|error> otherDetails = {};  // This record destructure binding pattern will destructure a `record` of the type `Person` and assign the values  // to three variable references as follows:  // The value of the field `name` in the `Person` record will be assigned to the variable `firstName`.  // The value of the field `age` in the `Person` record will be assigned to the variable `personAge`.  // `...otherDetails` is a rest parameter. Since `Person` is an open record, the remaining field values that have  // not been matched in the record binding pattern will be assigned as a `map<anydata|error>` to the variable  // `otherDetails`.  {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);   string name;  int age;  // If no variable name is given for a field, the value of the field will be assigned to a variable reference of the  // same name as the field.  // i.e., {name, age} is same as {name: name, age: age}.  // Since a rest parameter is not given, all remaining fields are ignored.  {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);   string countryName;  string capitalName;  // Binding patterns are recursive in nature. `capital`, which is a field of type `Capital` in `Country` can also be  // destructured as follows:  {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }  function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }  function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    Record Destructure Binding Pattern  Record destructure binding patterns are used to destructure and assign the values of each field in the destructed record to variable references.  The record destructuring binding patterns will be used to refer to existing variables as a record, destructure  the given value on the right hand side, and assign the values to each individual variable of the record during the runtime.    import ballerina/io;    type Person record {  string name;  int age;  string country; };    type Country record {  string name;  Capital capital; };    type Capital record {|  string name; |};    public function main() {    string firstName;  int personAge;  map<anydata|error> otherDetails = {};    {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);    This record destructure binding pattern will destructure a record of the type Person and assign the values  to three variable references as follows:  The value of the field name in the Person record will be assigned to the variable firstName.  The value of the field age in the Person record will be assigned to the variable personAge.  ...otherDetails is a rest parameter. Since Person is an open record, the remaining field values that have  not been matched in the record binding pattern will be assigned as a map<anydata|error> to the variable  otherDetails.   string name;  int age;    {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);    If no variable name is given for a field, the value of the field will be assigned to a variable reference of the  same name as the field.  i.e., {name, age} is same as {name: name, age: age}.  Since a rest parameter is not given, all remaining fields are ignored.   string countryName;  string capitalName;    {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }    Binding patterns are recursive in nature. capital, which is a field of type Capital in Country can also be  destructured as follows:   function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }    function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_destructure_binding_pattern.bal Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Name: Peter Age: 28 Country Name: Sri Lanka Capital Name: Colombo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-io.html","name":"Record I/O","summary":"This example demonstrates how to read and write records using I/O APIs.This function returns a ReadableTextRecordChannel from a given file location.\n The encoding is a character representation (i.e., UTF-8 ASCCI) of the\n content in the file. The rs parameter defines a record separator\n (e.g., a new line) and the fs ...","content":"/  /  /  / Record I/O  import ballerina/io; import ballerina/log;  // This function returns a `ReadableTextRecordChannel` from a given file location. // The encoding is a character representation (i.e., UTF-8 ASCCI) of the // content in the file. The `rs` parameter defines a record separator // (e.g., a new line) and the `fs` parameter is a field separator // (e.g., a comma). function getReadableRecordChannel(string filePath, string encoding,  string rs, string fs)  returns @tainted io:ReadableTextRecordChannel|error {  io:ReadableByteChannel byteChannel = check io:openReadableFile(filePath);  // Creates a readable character channel  // from the readable byte channel to read the content as text.  io:ReadableCharacterChannel characterChannel = new (byteChannel, encoding);  // Converts the readable character channel to a readable record channel  // to read the content as records.  io:ReadableTextRecordChannel delimitedRecordChannel = new (characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }  // This function returns a `WritableTextRecordChannel` from a given file location. // The encoding is a character representation (i.e., UTF-8 ASCCI) of the // content in the file. The `rs` parameter defines a record separator // (e.g., a new line) and the `fs` parameter is a field separator // (e.g., a comma). function getWritableRecordChannel(string filePath, string encoding, string rs,  string fs)  returns @tainted io:WritableTextRecordChannel|error {  io:WritableByteChannel byteChannel = check io:openWritableFile(filePath);  // Creates a writable character channel  // from the writable byte channel to read the content as text.  io:WritableCharacterChannel characterChannel = new (byteChannel, encoding);  // Converts the writable character channel to a writable record channel  // to read the content as records.  io:WritableTextRecordChannel delimitedRecordChannel = new(characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }  // This function processes the `.CSV` file and // writes the content back as text with the `|` delimiter. function process(io:ReadableTextRecordChannel srcRecordChannel,  io:WritableTextRecordChannel dstRecordChannel)  returns @tainted error? {  // Reads all the records from the provided file until there are  // no more records.  while (srcRecordChannel.hasNext()) {  // Reads the records.  string[] records = check srcRecordChannel.getNext();  // Writes the records.  var result = check dstRecordChannel.write(records);  }  return; }  // Closes the readable text record channel. function closeRc(io:ReadableTextRecordChannel rc) {  var closeResult = rc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }  // Closes the writable channel. function closeWc(io:WritableTextRecordChannel wc) {  var closeResult = wc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }  //Specifies the location of the `.CSV` file and the text file. public function main() {  string srcFileName = \"./files/sample.csv\";  string dstFileName = \"./files/sampleResponse.txt\";   // The record separator of the `.CSV` file is a  // new line and the field separator is a comma (,).  io:ReadableTextRecordChannel srcRecordChannel;  var readableChannel = getReadableRecordChannel(srcFileName,  \"UTF-8\", \"\\\\r?\\\\n\", \",\");  if (readableChannel is error) {  log:printError(\"An error occurred while creating readable record channel. \",  readableChannel);  return;  } else {  srcRecordChannel = readableChannel;  }   //The record separator of the text file  //is a new line and the field separator is a pipe (|).  io:WritableTextRecordChannel dstRecordChannel;  var writableChannel = getWritableRecordChannel(dstFileName,  \"UTF-8\", \"\\r\\n\", \"|\");  if (writableChannel is error) {  log:printError(\"An error occurred while creating writable record channel. \",  writableChannel);  return;  } else {  dstRecordChannel = writableChannel;  }   io:println(\"Start processing the CSV file from \" + srcFileName +  \" to the text file in \" + dstFileName);  var result = process(srcRecordChannel, dstRecordChannel);  if (result is error) {  log:printError(\"An error occurred while processing the records: \", result);  } else {  io:println(\"Processing completed. The processed file is located in \",  dstFileName);  }  // Closes the channels.  closeRc(srcRecordChannel);  closeWc(dstRecordChannel); }    Record I/O  This example demonstrates how to read and write records using I/O APIs.    import ballerina/io; import ballerina/log;    function getReadableRecordChannel(string filePath, string encoding,  string rs, string fs)  returns @tainted io:ReadableTextRecordChannel|error {  io:ReadableByteChannel byteChannel = check io:openReadableFile(filePath);    This function returns a ReadableTextRecordChannel from a given file location.  The encoding is a character representation (i.e., UTF-8 ASCCI) of the  content in the file. The rs parameter defines a record separator  (e.g., a new line) and the fs parameter is a field separator  (e.g., a comma).   io:ReadableCharacterChannel characterChannel = new (byteChannel, encoding);    Creates a readable character channel  from the readable byte channel to read the content as text.   io:ReadableTextRecordChannel delimitedRecordChannel = new (characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }    Converts the readable character channel to a readable record channel  to read the content as records.   function getWritableRecordChannel(string filePath, string encoding, string rs,  string fs)  returns @tainted io:WritableTextRecordChannel|error {  io:WritableByteChannel byteChannel = check io:openWritableFile(filePath);    This function returns a WritableTextRecordChannel from a given file location.  The encoding is a character representation (i.e., UTF-8 ASCCI) of the  content in the file. The rs parameter defines a record separator  (e.g., a new line) and the fs parameter is a field separator  (e.g., a comma).   io:WritableCharacterChannel characterChannel = new (byteChannel, encoding);    Creates a writable character channel  from the writable byte channel to read the content as text.   io:WritableTextRecordChannel delimitedRecordChannel = new(characterChannel,  rs = rs,  fs = fs);  return delimitedRecordChannel; }    Converts the writable character channel to a writable record channel  to read the content as records.   function process(io:ReadableTextRecordChannel srcRecordChannel,  io:WritableTextRecordChannel dstRecordChannel)  returns @tainted error? {    This function processes the .CSV file and  writes the content back as text with the | delimiter.   while (srcRecordChannel.hasNext()) {    Reads all the records from the provided file until there are  no more records.   string[] records = check srcRecordChannel.getNext();    Reads the records.   var result = check dstRecordChannel.write(records);  }  return; }    Writes the records.   function closeRc(io:ReadableTextRecordChannel rc) {  var closeResult = rc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }    Closes the readable text record channel.   function closeWc(io:WritableTextRecordChannel wc) {  var closeResult = wc.close();  if (closeResult is error) {  log:printError(\"Error occurred while closing the channel: \", closeResult);  } }    Closes the writable channel.   public function main() {  string srcFileName = \"./files/sample.csv\";  string dstFileName = \"./files/sampleResponse.txt\";    Specifies the location of the .CSV file and the text file.   io:ReadableTextRecordChannel srcRecordChannel;  var readableChannel = getReadableRecordChannel(srcFileName,  \"UTF-8\", \"\\\\r?\\\\n\", \",\");  if (readableChannel is error) {  log:printError(\"An error occurred while creating readable record channel. \",  readableChannel);  return;  } else {  srcRecordChannel = readableChannel;  }    The record separator of the .CSV file is a  new line and the field separator is a comma (,).   io:WritableTextRecordChannel dstRecordChannel;  var writableChannel = getWritableRecordChannel(dstFileName,  \"UTF-8\", \"\\r\\n\", \"|\");  if (writableChannel is error) {  log:printError(\"An error occurred while creating writable record channel. \",  writableChannel);  return;  } else {  dstRecordChannel = writableChannel;  }    The record separator of the text file is a new line and the field separator is a pipe (|).   io:println(\"Start processing the CSV file from \" + srcFileName +  \" to the text file in \" + dstFileName);  var result = process(srcRecordChannel, dstRecordChannel);  if (result is error) {  log:printError(\"An error occurred while processing the records: \", result);  } else {  io:println(\"Processing completed. The processed file is located in \",  dstFileName);  }    closeRc(srcRecordChannel);  closeWc(dstRecordChannel); }    Closes the channels.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_io.bal Start processing the CSV file from ./files/sample.csv to the text file in ./files/sampleResponse.txt Processing completed. The processed file is located in ./files/sampleResponse.txt    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-optional-fields.html","name":"Optional Fields","summary":"Fields of a record can be marked as optional. These fields can be omitted when creating a record.\n Such fields can be accessed via optional field access (e.g., p?.name) or member access (e.g., p[“name”])\n which will both return () if the field is not present in the record.This is a ...","content":"/  /  /  / Optional Fields  import ballerina/io;  type Gender \"male\"|\"female\";  type Person record {  // This is a required field without an explicit default value.  // The compiler will not assign default values. Therefore, a value should be specified  // for this field when creating the record.  string fname;  // This is a required field with an explicit default value specified.  string lname = \"\";   Gender gender;  // Adding `?` following the identifier marks the field as an optional field.  int age?; };  public function main() {  // The required fields `fname` and `gender` are not given default values in the record type descriptor.  // Therefore, values must be specified for `fname` and `gender` when creating the record.  Person john = {fname: \"John\", gender: \"male\"};   // The `age` field is not present in the record since it is an optional field.  io:println(\"Person with the non-defaultable required field set: \", john);   // Optional fields of the record can be accessed using the `?.` operator.  // This returns the value if the field is present in the record. Returns `()` if not.  // Since the `age` field is not set, optional field access returns `()` here.  int? age = john?.age;  io:println(\"Age before setting: \", age);   // Now set a value for the `age` field. Field access can be used to set the value since  // `age` is a field defined in the type descriptor for `Person`.  john.age = 25;  // Since the `age` field is set, optional field access returns the `int`-typed value.  age = john?.age;  io:println(\"Age after setting: \", age);   // Create a `Person`-typed value specifying a value for the defaultable field `lname`.  Person jane = {fname: \"Jane\", lname: \"Doe\", gender: \"female\"};   // Field values provided when creating a record takes highest precedence.  io:println(\"Person with values assigned to required fields: \", jane); }    Optional Fields  Fields of a record can be marked as optional. These fields can be omitted when creating a record.  Such fields can be accessed via optional field access (e.g., p?.name) or member access (e.g., p[“name”])  which will both return () if the field is not present in the record.    import ballerina/io;    type Gender \"male\"|\"female\";    type Person record {    string fname;    This is a required field without an explicit default value.  The compiler will not assign default values. Therefore, a value should be specified  for this field when creating the record.   string lname = \"\";    This is a required field with an explicit default value specified.   Gender gender;    int age?; };    Adding ? following the identifier marks the field as an optional field.   public function main() {    Person john = {fname: \"John\", gender: \"male\"};    The required fields fname and gender are not given default values in the record type descriptor.  Therefore, values must be specified for fname and gender when creating the record.   io:println(\"Person with the non-defaultable required field set: \", john);    The age field is not present in the record since it is an optional field.   int? age = john?.age;  io:println(\"Age before setting: \", age);    Optional fields of the record can be accessed using the ?. operator.  This returns the value if the field is present in the record. Returns () if not.  Since the age field is not set, optional field access returns () here.   john.age = 25;    Now set a value for the age field. Field access can be used to set the value since  age is a field defined in the type descriptor for Person.   age = john?.age;  io:println(\"Age after setting: \", age);    Since the age field is set, optional field access returns the int-typed value.   Person jane = {fname: \"Jane\", lname: \"Doe\", gender: \"female\"};    Create a Person-typed value specifying a value for the defaultable field lname.   io:println(\"Person with values assigned to required fields: \", jane); }    Field values provided when creating a record takes highest precedence.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_optional_fields.bal Person with the non-defaultable required field set: fname=John lname= gender=male Age before setting: Age after setting: 25 Person with values assigned to required fields: fname=Jane lname=Doe gender=female    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-typed-binding-pattern.html","name":"Record-Typed Binding Pattern","summary":"Record typed binding patterns are used in declaring and defining new variables by destructuring fields in a record variable.\n The record type binding pattern statement must have an assignment expression on the right hand side.This record type binding pattern will destructure a record of the type Person and create three ...","content":"/  /  /  / Record-Typed Binding Pattern  import ballerina/io;  type Person record {  string name;  int age;  string country; };  type Country record {  string name;  Capital capital; };  type Capital record {|  string name; |};  public function main() {  // This record type binding pattern will destructure a `record` of the type `Person` and create three variables as follows:  // The value of the field `name` in the `Person` record will be set to a new `string` variable `firstName`.  // The value of the field `age` in the `Person` record will be set to a new `int` variable `personAge`.  // `...otherDetails` is a rest parameter. Since `Person` is an open record, a new `map<anydata|error>` variable  // `otherDetails` will be created (with the remaining fields that have not been matched) in the record binding pattern.  Person {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);   // If a variable name is not given for a field, a variable will be created with the same name as the field.  // i.e, `Person {name, age}` is same as Person `{name: name, age: age}`.  // Since a rest parameter is not given, all remaining fields are ignored.  Person {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);   // Record type binding patterns can be used with `var` to infer the type from the right hand side.  // Since the types of the new variables are based on the type of the type binding pattern, using `var` will  // infer the types from the right hand side.  var {name: vFirstName, age: vPersonAge, ...vOtherDetails} = getPerson();  // The type of `vFirstName` is inferred as `string`.  io:println(\"Name: \", vFirstName);  // The type of `vPersonAge` is inferred as `int`.  io:println(\"Age: \", vPersonAge);  // The type of `vOtherDetails` will be `map<anydata|error>`.  io:println(\"Other Details: \", vOtherDetails);   // Binding patterns are recursive in nature. `capital`, which is a field of the type `Capital` in `Country` can also be  // destructured as follows:  var {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }  function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }  function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    Record-Typed Binding Pattern  Record typed binding patterns are used in declaring and defining new variables by destructuring fields in a record variable.  The record type binding pattern statement must have an assignment expression on the right hand side.    import ballerina/io;    type Person record {  string name;  int age;  string country; };    type Country record {  string name;  Capital capital; };    type Capital record {|  string name; |};    public function main() {    Person {name: firstName, age: personAge, ...otherDetails} = getPerson();  io:println(\"Name: \", firstName);  io:println(\"Age: \", personAge);  io:println(\"Other Details: \", otherDetails);    This record type binding pattern will destructure a record of the type Person and create three variables as follows:  The value of the field name in the Person record will be set to a new string variable firstName.  The value of the field age in the Person record will be set to a new int variable personAge.  ...otherDetails is a rest parameter. Since Person is an open record, a new map<anydata|error> variable  otherDetails will be created (with the remaining fields that have not been matched) in the record binding pattern.   Person {name, age} = getPerson();  io:println(\"Name: \", name);  io:println(\"Age: \", age);    If a variable name is not given for a field, a variable will be created with the same name as the field.  i.e, Person {name, age} is same as Person {name: name, age: age}.  Since a rest parameter is not given, all remaining fields are ignored.   var {name: vFirstName, age: vPersonAge, ...vOtherDetails} = getPerson();    Record type binding patterns can be used with var to infer the type from the right hand side.  Since the types of the new variables are based on the type of the type binding pattern, using var will  infer the types from the right hand side.   io:println(\"Name: \", vFirstName);    The type of vFirstName is inferred as string.   io:println(\"Age: \", vPersonAge);    The type of vPersonAge is inferred as int.   io:println(\"Other Details: \", vOtherDetails);    The type of vOtherDetails will be map<anydata|error>.   var {name: countryName, capital: {name: capitalName}} = getCountry();  io:println(\"Country Name: \", countryName);  io:println(\"Capital Name: \", capitalName); }    Binding patterns are recursive in nature. capital, which is a field of the type Capital in Country can also be  destructured as follows:   function getPerson() returns Person {  Person person = {  name: \"Peter\",  age: 28,  country: \"Sri Lanka\",  \"occupation\": \"Software Engineer\"  };  return person; }    function getCountry() returns Country {  Capital capital = {name: \"Colombo\"};  Country country = {name: \"Sri Lanka\", capital: capital};  return country; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_type_binding_pattern.bal Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Name: Peter Age: 28 Name: Peter Age: 28 Other Details: country=Sri Lanka occupation=Software Engineer Country Name: Sri Lanka Capital Name: Colombo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-match-statement.html","name":"Record Match","summary":"The match statement in Ballerina will support value-based match patterns only. There are static and structured\n based match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Record binding pattern is one of the structured binding patterns that can be ...","content":"/  /  /  / Record Match  import ballerina/io;  type RecordOne record {  string var1; };  type RecordTwo record {|  string var1;  int var2; |};  type RecordThree record {  string var1;  RecordTwo var2; };  public function main() {  RecordOne rec1 = {var1: \"Hello\", \"var2\": 150};  RecordOne rec2 = {var1: \"Hello\", \"var2\": true};  RecordOne rec3 = {var1: \"Hello\", \"var2\": 150, \"var3\": true};  RecordOne rec4 = {var1: \"Hello\"};   basicMatch(rec1);  basicMatch(rec2);  basicMatch(rec3);  basicMatch(rec4);   RecordTwo tRec1 = {var1: \"Ballerina\", var2: 500};  RecordThree tRec2 = {var1: \"Language\", var2: tRec1};   matchWithTypeGuard(tRec1);  matchWithTypeGuard(tRec2);  matchWithTypeGuard(true); }  // This method uses structured record match patterns with different fields. The given `match` expression will // be checked for \"isLike\" relationship and will be matched at runtime. function basicMatch(any a) {  match a {  // This pattern checks for a mapping value with three fields `var1`, `var2` and `var3` and types will  // be `any` in the pattern block.  var {var1, var2, var3} => {  io:println(\"Matched with three vars : \", var1, \", \", var2, \", \", var3);  }  // This pattern checks for a mapping value with two fields `var1`, `var2` and types will be `any` in  // the pattern block.  var {var1, var2} => {  io:println(\"Matched with two vars : \", var1, \", \", var2);  }  // This pattern checks for a mapping value with single field `var1` and type will be `any` in the pattern block.  var {var1} => {  io:println(\"Matched with single var : \", var1);  }  } }  // This method uses structured record match patterns with different fields // along with type guards. The expression used with match will be evaluated to // check if it \"is like\" any of the match patterns. For a successful match, an additional // check will also be performed against the specified type guard. function matchWithTypeGuard(any matchExpr) {  // All the patterns except the last one will check for a mapping value with two fields `var1` and `var2`  // with a given type guard.  match matchExpr {  // This pattern will only match if `var2` is of the type `string`.  var {var1, var2} if var2 is string => {  io:println(\"Matched with string typeguard\");  }  // This pattern will only match if `var1` is of the type `int` and `var2` is of the type `int`.  var {var1, var2} if (var1 is int && var2 is int) => {  io:println(\"Matched with int and int typeguard : \", var1);  }  // This pattern will only match if `var1` is of the type `string` and `var2` is of the type `int`.  var {var1, var2} if (var1 is string && var2 is int) => {  io:println(\"Matched with string and int typeguard : \", var1);  }  // This pattern will only match if `var1` is of the type `int` and `var2` is of the type `RecordTwo`.  var {var1, var2} if (var1 is int && var2 is RecordTwo) => {  io:println(\"Matched with int and RecordTwo typeguard : \", var1);  }  // This pattern will only match if `var1` is of the type `string` and `var2` is of the type `RecordTwo`.  var {var1, var2} if (var1 is string && var2 is RecordTwo) => {  io:println(\"Matched with string and RecordTwo typeguard : \", var2.var1);  }  // A pattern with a single identifier can be used as the last match pattern and all values will  // be matched to this.  var x => {  io:println(\"Matched with Default\");  }  } }    Record Match  The match statement in Ballerina will support value-based match patterns only. There are static and structured  based match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Record binding pattern is one of the structured binding patterns that can be used  with the match. The value will be checked for “isLike” relationship with the pattern to match at runtime.  The match pattern clauses can also have additional type guard conditions as strong match conditions.    import ballerina/io;    type RecordOne record {  string var1; };    type RecordTwo record {|  string var1;  int var2; |};    type RecordThree record {  string var1;  RecordTwo var2; };    public function main() {  RecordOne rec1 = {var1: \"Hello\", \"var2\": 150};  RecordOne rec2 = {var1: \"Hello\", \"var2\": true};  RecordOne rec3 = {var1: \"Hello\", \"var2\": 150, \"var3\": true};  RecordOne rec4 = {var1: \"Hello\"};    basicMatch(rec1);  basicMatch(rec2);  basicMatch(rec3);  basicMatch(rec4);    RecordTwo tRec1 = {var1: \"Ballerina\", var2: 500};  RecordThree tRec2 = {var1: \"Language\", var2: tRec1};    matchWithTypeGuard(tRec1);  matchWithTypeGuard(tRec2);  matchWithTypeGuard(true); }    function basicMatch(any a) {  match a {    This method uses structured record match patterns with different fields. The given match expression will  be checked for “isLike” relationship and will be matched at runtime.   var {var1, var2, var3} => {  io:println(\"Matched with three vars : \", var1, \", \", var2, \", \", var3);  }    This pattern checks for a mapping value with three fields var1, var2 and var3 and types will  be any in the pattern block.   var {var1, var2} => {  io:println(\"Matched with two vars : \", var1, \", \", var2);  }    This pattern checks for a mapping value with two fields var1, var2 and types will be any in  the pattern block.   var {var1} => {  io:println(\"Matched with single var : \", var1);  }  } }    This pattern checks for a mapping value with single field var1 and type will be any in the pattern block.   function matchWithTypeGuard(any matchExpr) {    This method uses structured record match patterns with different fields  along with type guards. The expression used with match will be evaluated to  check if it “is like” any of the match patterns. For a successful match, an additional  check will also be performed against the specified type guard.   match matchExpr {    All the patterns except the last one will check for a mapping value with two fields var1 and var2  with a given type guard.   var {var1, var2} if var2 is string => {  io:println(\"Matched with string typeguard\");  }    This pattern will only match if var2 is of the type string.   var {var1, var2} if (var1 is int && var2 is int) => {  io:println(\"Matched with int and int typeguard : \", var1);  }    This pattern will only match if var1 is of the type int and var2 is of the type int.   var {var1, var2} if (var1 is string && var2 is int) => {  io:println(\"Matched with string and int typeguard : \", var1);  }    This pattern will only match if var1 is of the type string and var2 is of the type int.   var {var1, var2} if (var1 is int && var2 is RecordTwo) => {  io:println(\"Matched with int and RecordTwo typeguard : \", var1);  }    This pattern will only match if var1 is of the type int and var2 is of the type RecordTwo.   var {var1, var2} if (var1 is string && var2 is RecordTwo) => {  io:println(\"Matched with string and RecordTwo typeguard : \", var2.var1);  }    This pattern will only match if var1 is of the type string and var2 is of the type RecordTwo.   var x => {  io:println(\"Matched with Default\");  }  } }    A pattern with a single identifier can be used as the last match pattern and all values will  be matched to this.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_match_statement.bal Matched with two vars : Hello, 150 Matched with two vars : Hello, true Matched with three vars : Hello, 150, true Matched with single var : Hello Matched with string and int typeguard : Ballerina Matched with string and RecordTwo typeguard : Ballerina Matched with Default    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/record-type-reference.html","name":"Record Type Reference","summary":"Record type referencing provides a convenient way to copy the fields defined in a record type descriptor\n to another record type descriptor. It is equivalent to explicitly defining those fields in the new type descriptor.\n If the record being type-referenced has fields with explicitly-assigned default values, those values would also ...","content":"/  /  /  / Record Type Reference  import ballerina/io;  type Person record {|  string name;  int age = 25; |};  type Employee record {|  // References the `Person` record.  *Person;  string company?;  string designation; |};  type Manager record {  Employee[] team?;  // References the `Employee` record. Since `Employee` references `Person`,  // `Manager` will have the fields of `Person` and the additional fields  // in `Employee`.  *Employee; };  public function main() {  // `Employee` has all the fields of `Person`.  Employee john = {name: \"John Doe\", designation: \"Software Engineer\"};  Employee jane = {name: \"Jane Doe\", designation: \"UX Engineer\"};   // Type referencing copies the fields including their properties  // (e.g., type, default value, optional status). As it can be seen  // by printing an `Employee` record, the optional field company  // is not included in the record.  io:println(john);  io:println(jane);   Manager mgr = {name: \"Mark\", age: 35, designation: \"Engineering Manager\"};  mgr.team = [john, jane];  mgr.company = \"XYZ Inc.\";   io:println(mgr); }    Record Type Reference  Record type referencing provides a convenient way to copy the fields defined in a record type descriptor  to another record type descriptor. It is equivalent to explicitly defining those fields in the new type descriptor.  If the record being type-referenced has fields with explicitly-assigned default values, those values would also be  copied. A record type descriptor can have multiple type references as well as chained-type references.  Type referencing applies to both open and closed records. In open records, the rest field is not considered for  type referencing in open records.    import ballerina/io;    type Person record {|  string name;  int age = 25; |};    type Employee record {|    *Person;  string company?;  string designation; |};    References the Person record.   type Manager record {  Employee[] team?;    *Employee; };    References the Employee record. Since Employee references Person,  Manager will have the fields of Person and the additional fields  in Employee.   public function main() {    Employee john = {name: \"John Doe\", designation: \"Software Engineer\"};  Employee jane = {name: \"Jane Doe\", designation: \"UX Engineer\"};    Employee has all the fields of Person.   io:println(john);  io:println(jane);    Type referencing copies the fields including their properties  (e.g., type, default value, optional status). As it can be seen  by printing an Employee record, the optional field company  is not included in the record.   Manager mgr = {name: \"Mark\", age: 35, designation: \"Engineering Manager\"};  mgr.team = [john, jane];  mgr.company = \"XYZ Inc.\";    io:println(mgr); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run record_type_reference.bal designation=Software Engineer name=John Doe age=25 designation=UX Engineer name=Jane Doe age=25 team=designation=Software Engineer name=John Doe age=25 designation=UX Engineer name=Jane Doe age=25 company=XYZ Inc. designation=Engineering Manager name=Mark age=35    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/records.html","name":"Record","summary":"In Ballerina, records are a mapping type. However, the keys (fields) are named and their types define the\n types of values that are allowed for the fields. If the set of fields is fixed, the record is called a “closed record”.\n If the set of fields is not fixed, the ...","content":"/  /  /  / Record  import ballerina/io;  // Define an open record type named `Student`. The `{` and `}` delimiters indicate that in addition to the defined fields, // this record type allows additional fields with `anydata` values. // The descriptor `record { }` is equivalent to `record {| anydata...; |}`. type Student record {  string name;  int age;  Grades grades; };  // Define a closed record type named `Address`. The `{|` and `|}` delimiters indicate that this record type // allows mapping values, which contain only the described fields. type Address record {|  string city;  string country; |};  // Define an open record type named `Grades`. Although it is defined using the `{|` and `|}` delimiters, it has // an `int` rest field as well. Therefore, this is an open record type. type Grades record {|  int maths;  int physics;  int chemistry;  // This is a rest field of the type`int`. All additional fields should be of the type or a subtype of the rest field.  int...; |};   public function main() {   int age = 17;   // This creates a `Student` record. Since all the fields are required and none of the fields  // have explicit default values assigned to them, values must be specified for all the fields  // when creating the record.  Student john = {  // A field can be specified as a key-value pair.  name: \"John Doe\",  // A variable reference can also be used to define a field.  // The name of the variable will be used as the key while  // the variable reference itself will be used as the value  // expression.  // This is equivalent to `age: age`.  age,  grades: {  maths: 80,  physics: 75,  chemistry: 65  }  };  io:println(john);   // This is an example of field-based access of record fields. The return type of this expression is the  // type of the field. Field access is only allowed for required fields in a record.  io:println(john.name);   // This is an example of member access of record fields. Where the type of the field is `T`, the type of  // this expression is `T` if the field is a required field or has a default value. If the field is an optional  // field or a rest field, the type of this expression is `T?`.  // If it is a closed record, accessing an undefined key will result in a compilation error.  io:println(john[\"name\"]);   // This fetches a field of a nested record.  io:println(john.grades.maths);   Student peter = {  name: \"Peter\",  age: 19,  grades: {  maths: 40,  physics: 35,  chemistry: 35  }  };  // This modifies the value of the `age` field.  // Field access is allowed with assignment only for fields defined in the record type descriptor.  peter.age = 16;   io:println(peter);  io:println(john);   // Member access can be used to assign to fields that are not defined in the record type descriptor.  // An attempt to add additional fields to a closed record results in compile errors.  Address address = {city: \"Colombo\", country: \"Sri Lanka\"};  peter[\"address\"] = address;  io:println(peter);   // Create a `Grades` record adding additional fields for the `int`-typed rest field.  // The `english` field is not specified in the record, but is allowed since `Grades` is an  // open record with an `int`-typed rest field.  // Keys for such field should either be `string` literals or expressions (i.e., they  // cannot be identifiers).  Grades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 90};  io:println(grades);   // Similarly, only member access can be used to access the fields that are possibly  // added for the rest field. An `int` value is returned if the field is present in the  // record, else `()` is returned.  int? english = grades[\"english\"];  io:println(english);   // A mapping constructor expression used when creating a record value  // can also include a spread field referring to another mapping value.  // When a spread field is specified, all the fields of the relevant  // mapping value are added to the new record value being created.  // A spread field is used with the `address` to include the individual address  // entries in `address` when creating `anne`.  Student anne = {  name: \"Anne\",  age: 18,  grades: {  maths: 70,  physics: 80,  chemistry: 55  },  ...address  };  io:println(anne);   // Using a mapping constructor expression with `var` (i.e., no contextually-expected  // type) results in a mapping value where the inferred type is a record type based  // on the fields specified in the mapping constructor expression.  var rec = {name: \"Amy\", age: 18, ...address};  io:println(rec);   // The record type inferred for `rec` is  // `record {| string name; int age; string city; string country; |}`.  // Thus, field access can be used to access the fields.  io:println(rec.name); }    Record  In Ballerina, records are a mapping type. However, the keys (fields) are named and their types define the  types of values that are allowed for the fields. If the set of fields is fixed, the record is called a “closed record”.  If the set of fields is not fixed, the record is called an “open record”.    import ballerina/io;    type Student record {  string name;  int age;  Grades grades; };    Define an open record type named Student. The { and } delimiters indicate that in addition to the defined fields,  this record type allows additional fields with anydata values.  The descriptor record { } is equivalent to record {| anydata...; |}.   type Address record {|  string city;  string country; |};    Define a closed record type named Address. The {| and |} delimiters indicate that this record type  allows mapping values, which contain only the described fields.   type Grades record {|  int maths;  int physics;  int chemistry;    Define an open record type named Grades. Although it is defined using the {| and |} delimiters, it has  an int rest field as well. Therefore, this is an open record type.   int...; |};    This is a rest field of the typeint. All additional fields should be of the type or a subtype of the rest field.   public function main() {    int age = 17;    Student john = {    This creates a Student record. Since all the fields are required and none of the fields  have explicit default values assigned to them, values must be specified for all the fields  when creating the record.   name: \"John Doe\",    A field can be specified as a key-value pair.   age,  grades: {  maths: 80,  physics: 75,  chemistry: 65  }  };  io:println(john);    A variable reference can also be used to define a field.  The name of the variable will be used as the key while  the variable reference itself will be used as the value  expression.  This is equivalent to age: age.   io:println(john.name);    This is an example of field-based access of record fields. The return type of this expression is the  type of the field. Field access is only allowed for required fields in a record.   io:println(john[\"name\"]);    This is an example of member access of record fields. Where the type of the field is T, the type of  this expression is T if the field is a required field or has a default value. If the field is an optional  field or a rest field, the type of this expression is T?.  If it is a closed record, accessing an undefined key will result in a compilation error.   io:println(john.grades.maths);    This fetches a field of a nested record.   Student peter = {  name: \"Peter\",  age: 19,  grades: {  maths: 40,  physics: 35,  chemistry: 35  }  };    peter.age = 16;    This modifies the value of the age field.  Field access is allowed with assignment only for fields defined in the record type descriptor.   io:println(peter);  io:println(john);    Address address = {city: \"Colombo\", country: \"Sri Lanka\"};  peter[\"address\"] = address;  io:println(peter);    Member access can be used to assign to fields that are not defined in the record type descriptor.  An attempt to add additional fields to a closed record results in compile errors.   Grades grades = {maths: 80, physics: 75, chemistry: 65, \"english\": 90};  io:println(grades);    Create a Grades record adding additional fields for the int-typed rest field.  The english field is not specified in the record, but is allowed since Grades is an  open record with an int-typed rest field.  Keys for such field should either be string literals or expressions (i.e., they  cannot be identifiers).   int? english = grades[\"english\"];  io:println(english);    Similarly, only member access can be used to access the fields that are possibly  added for the rest field. An int value is returned if the field is present in the  record, else () is returned.   Student anne = {  name: \"Anne\",  age: 18,  grades: {  maths: 70,  physics: 80,  chemistry: 55  },  ...address  };  io:println(anne);    A mapping constructor expression used when creating a record value  can also include a spread field referring to another mapping value.  When a spread field is specified, all the fields of the relevant  mapping value are added to the new record value being created.  A spread field is used with the address to include the individual address  entries in address when creating anne.   var rec = {name: \"Amy\", age: 18, ...address};  io:println(rec);    Using a mapping constructor expression with var (i.e., no contextually-expected  type) results in a mapping value where the inferred type is a record type based  on the fields specified in the mapping constructor expression.   io:println(rec.name); }    The record type inferred for rec is  record {| string name; int age; string city; string country; |}.  Thus, field access can be used to access the fields.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run records.bal name=John Doe age=17 grades=maths=80 physics=75 chemistry=65 John Doe John Doe 80 name=Peter age=16 grades=maths=40 physics=35 chemistry=35 name=John Doe age=17 grades=maths=80 physics=75 chemistry=65 name=Peter age=16 grades=maths=40 physics=35 chemistry=35 address=city=Colombo country=Sri Lanka maths=80 physics=75 chemistry=65 english=90 90 name=Anne age=18 grades=maths=70 physics=80 chemistry=55 city=Colombo country=Sri Lanka name=Amy age=18 city=Colombo country=Sri Lanka Amy    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/restrict-by-media-type.html","name":"Restrict By Media Type","summary":"You can configure resources of HTTP services to restrict the types of media they consume and produce.\n This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.The consumes and produces annotations contain MIME types as an\n array of strings. The resource ...","content":"/  /  /  / Restrict By Media Type  import ballerina/http; import ballerina/log;  service infoService on new http:Listener(9092) {  // The `consumes` and `produces` annotations contain MIME types as an  // array of strings. The resource can only consume/accept `text/json` and  // `application/json` media types. Therefore, the `Content-Type` header  // of the request must be in one of these two types. The resource can produce  // `application/xml` payloads. Therefore, you need to set the `Accept` header accordingly.  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/\",  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function student(http:Caller caller, http:Request req) {  // Get the JSON payload from the request message.  http:Response res = new;  var msg = req.getJsonPayload();  if (msg is json) {  // Get the `string` value, which is relevant to the key \"name\".  string nameString = <string>msg.name;  // Create the XML payload and send back a response.  xml name = xml `<name>${nameString}</name>`;  res.setXmlPayload(<@untained>name);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>msg.detail()?.message);  }   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    Restrict By Media Type  You can configure resources of HTTP services to restrict the types of media they consume and produce.  This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.    import ballerina/http; import ballerina/log;    service infoService on new http:Listener(9092) {    @http:ResourceConfig {  methods: [\"POST\"],  path: \"/\",  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function student(http:Caller caller, http:Request req) {    The consumes and produces annotations contain MIME types as an  array of strings. The resource can only consume/accept text/json and  application/json media types. Therefore, the Content-Type header  of the request must be in one of these two types. The resource can produce  application/xml payloads. Therefore, you need to set the Accept header accordingly.   http:Response res = new;  var msg = req.getJsonPayload();  if (msg is json) {    Get the JSON payload from the request message.   string nameString = <string>msg.name;    Get the string value, which is relevant to the key “name”.   xml name = xml `<name>${nameString}</name>`;  res.setXmlPayload(<@untained>name);  } else {  res.statusCode = 500;  res.setPayload(<@untainted string>msg.detail()?.message);  }    Create the XML payload and send back a response.   var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding\", result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run restrict_by_media_type.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # To invoke the service, execute the following cURL request. curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' # The server response. < HTTP/1.1 200 OK < content-type: application/xml < content-length: 22 < * Connection #0 to host localhost left intact <name>Ballerina</name>    # To invoke the service using unsupported media type, execute the following cURL request. The content type of the # request is not listed under the `consumes` resource configuration. curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:text/plain\" -d \"Hello ballerina\" # The server response. < HTTP/1.1 415 Unsupported Media Type < content-type: text/plain < content-length: 0 < * Connection #0 to host localhost left intact    # To invoke the service with a media type that is not acceptable, execute the following cURL request. The media type mentioned # in the Accept header is not listed under the `produces` resource configuration. curl -v http://localhost:9092/infoService -H \"Accept:text/html\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' # The server response. < HTTP/1.1 406 Not Acceptable < content-type: text/plain < content-length: 0 < * Connection #0 to host localhost left intact    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/request-with-multiparts.html","name":"Request With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in http requests along with nested parts.\n When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).\n You can loop through this array and handle the received body parts according to your requirement.Binds ...","content":"/  /  /  / Request With Multiparts  import ballerina/http; import ballerina/log; import ballerina/mime;  http:Client clientEP = new (\"http://localhost:9090\");  @http:ServiceConfig {  basePath: \"/multiparts\" } //Binds the listener to the service. service multipartDemoService on new http:Listener(9090) {   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/decode\"  }  resource function multipartReceiver(http:Caller caller, http:Request  request) {  http:Response response = new;  // Extracts bodyparts from the request.  var bodyParts = request.getBodyParts();  if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  } else {  log:printError(<string>bodyParts.reason());  response.setPayload(\"Error in decoding multiparts!\");  response.statusCode = 500;  }  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode\"  }  resource function multipartSender(http:Caller caller, http:Request req) {  //Create a json body part.  mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});  //Create an `xml` body part as a file upload.  mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));  // This file path is relative to where the ballerina is running.  // If your file is located outside, please  // give the absolute file path instead.  xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);  // Create an array to hold all the body parts.  mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;  // Set the body parts to the request.  // Here the content-type is set as multipart form data.  // This also works with any other multipart media type.  // eg:- `multipart/mixed`, `multipart/related` etc.  // You need to pass the content type that suit your requirement.  request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  var returnResponse = clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  var result = caller->respond(returnResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response response = new;  response.setPayload(\"Error occurred while sending multipart \" +  \"request!\");  response.statusCode = 500;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }  // The content logic that handles the body parts vary based on your requirement. function handleContent(mime:Entity bodyPart) {  var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  //Extracts `xml` data from the body part.  var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:APPLICATION_JSON == baseType) {  //Extracts `json` data from the body part.  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:TEXT_PLAIN == baseType) {  //Extracts text data from the body part.  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail().message);  }  }  } }  function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    Request With Multiparts  Ballerina supports encoding and decoding multipart content in http requests along with nested parts.  When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).  You can loop through this array and handle the received body parts according to your requirement.    import ballerina/http; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9090\");    @http:ServiceConfig {  basePath: \"/multiparts\" }    service multipartDemoService on new http:Listener(9090) {    Binds the listener to the service.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/decode\"  }  resource function multipartReceiver(http:Caller caller, http:Request  request) {  http:Response response = new;    var bodyParts = request.getBodyParts();  if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  } else {  log:printError(<string>bodyParts.reason());  response.setPayload(\"Error in decoding multiparts!\");  response.statusCode = 500;  }  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }    Extracts bodyparts from the request.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode\"  }  resource function multipartSender(http:Caller caller, http:Request req) {    mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});    Create a json body part.   mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));    Create an xml body part as a file upload.   xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);    This file path is relative to where the ballerina is running.  If your file is located outside, please  give the absolute file path instead.   mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;    Create an array to hold all the body parts.   request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  var returnResponse = clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  var result = caller->respond(returnResponse);  if (result is error) {  log:printError(\"Error sending response\", result);  }  } else {  http:Response response = new;  response.setPayload(\"Error occurred while sending multipart \" +  \"request!\");  response.statusCode = 500;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error sending response\", result);  }  }  } }    Set the body parts to the request.  Here the content-type is set as multipart form data.  This also works with any other multipart media type.  eg:- multipart/mixed, multipart/related etc.  You need to pass the content type that suit your requirement.   function handleContent(mime:Entity bodyPart) {  var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    The content logic that handles the body parts vary based on your requirement.   var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:APPLICATION_JSON == baseType) {    Extracts xml data from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(<string>payload.detail().message);  }  } else if (mime:TEXT_PLAIN == baseType) {    Extracts json data from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(<string>payload.detail().message);  }  }  } }    Extracts text data from the body part.   function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run request_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Start multipartDemoService # The cURL command, which you need to execute to decode a multipart request curl -F \"part1={\\\"name\\\":\\\"ballerina\\\"};type=application/json\" http://localhost:9090/multiparts/decode -H \"Content-Type: multipart/mixed\" -H 'Expect:' --ac4875939cf6b158 content-type: application/json content-disposition: form-data;name=\"part1\" content-id: 0    {\"name\":\"ballerina\"} --ac4875939cf6b158--    # The cURL command, which you need to execute to encode the parts of the body and send a multipart request via the Ballerina service curl -v http://localhost:9090/multiparts/encode < HTTP/1.1 200 OK < content-type: multipart/form-data; boundary=3bbfa10811dcdee6 < date: Thu, 14 Jun 2018 15:22:21 +0530 < server: ballerina/0.982.1-SNAPSHOT < content-length: 398 < --3bbfa10811dcdee6 content-type: application/json content-disposition: form-data;name=\"json part\" content-id: 0    {\"name\":\"wso2\"} --3bbfa10811dcdee6 content-type: application/xml content-disposition: form-data;name=\"xml file part\" content-id: 1    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --3bbfa10811dcdee6--    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-client-with-jwt-auth.html","name":"Secured Client with JWT Auth","summary":"A secured client, which is secured  with JWT authentication should be used\n to connect to a service, which is secured with JWT authentication.\n The jwt:OutboundJWTAuthProvider is initialized with/without passing\n the JWT issuer configurations as a record. If the JWT issuer configurations\n are passed, a new JWT will be issued ...","content":"/  /  /  / Secured Client with JWT Auth  import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;  // Defines the JWT auth client endpoint to call the backend services. // JWT authentication is enabled by creating a `jwt:OutboundJWTAuthProvider` // with/without passing the JWT issuer configurations as a record. // If the JWT issuer configurations are not passed, a JWT will be searched // in `runtime:AuthenticationContext` and it will be used for the outbound // authentication. jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new ({  username: \"ballerina\",  issuer: \"ballerina\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  customClaims: {\"scope\": \"hello\"},  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  // Create a Bearer Auth handler with the created JWT Auth provider. http:BearerAuthHandler outboundJwtAuthHandler = new (outboundJwtAuthProvider);  http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  public function main() {  // Sends a `GET` request to the specified endpoint.  var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } } import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;  // Defines the sample backend service, which is secured with JWT Auth // authentication. jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler inboundJwtAuthHandler = new (inboundJwtAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundJwtAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Client with JWT Auth  A secured client, which is secured with JWT authentication should be used  to connect to a service, which is secured with JWT authentication.  The jwt:OutboundJWTAuthProvider is initialized with/without passing  the JWT issuer configurations as a record. If the JWT issuer configurations  are passed, a new JWT will be issued and it will be used for the outbound  authentication. If the JWT issuer configurations are not passed,  a JWT will be searched in runtime:AuthenticationContext and it will be  used for the outbound authentication.  The http:BearerAuthHandler is initialized by providing  the created jwt:OutboundBasicAuthProvider. An additional auth field is  added to the HTTP client endpoint initialization in order to secure the  simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the value  of it being the reference of the created http:BearerAuthHandler.    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new ({  username: \"ballerina\",  issuer: \"ballerina\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  customClaims: {\"scope\": \"hello\"},  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Defines the JWT auth client endpoint to call the backend services.  JWT authentication is enabled by creating a jwt:OutboundJWTAuthProvider  with/without passing the JWT issuer configurations as a record.  If the JWT issuer configurations are not passed, a JWT will be searched  in runtime:AuthenticationContext and it will be used for the outbound  authentication.   http:BearerAuthHandler outboundJwtAuthHandler = new (outboundJwtAuthProvider);    Create a Bearer Auth handler with the created JWT Auth provider.   http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }    Sends a GET request to the specified endpoint.   # To test the client, first start the sample service by executing the below # command by passing Ballerina home path as a system property. ballerina run secured_service_with_jwt_auth.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Then start the client by executing the below command by passing Ballerina home # path as a system property. ballerina run secured_client_with_jwt_auth.bal --b7a.home=<ballerina_home_path> INFO [ballerina/log] - Hello, World!!!    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler inboundJwtAuthHandler = new (inboundJwtAuthProvider); listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundJwtAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    Defines the sample backend service, which is secured with JWT Auth  authentication.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-client-with-basic-auth.html","name":"Secured Client with Basic Auth","summary":"A client, which is secured with Basic authentication should be used to\n connect to a service, which is secured with Basic authentication.\n The auth:OutboundBasicAuthProvider is initialized with the username and\n password and the http:BasicAuthHandler is initialized by providing\n the created auth:OutboundBasicAuthProvider. An additional auth field is\n added to the HTTP ...","content":"/  /  /  / Secured Client with Basic Auth  import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;  // Defines the Basic Auth client endpoint to call the backend services. // Basic Authentication is enabled by creating an // `auth:OutboundBasicAuthProvider` with the `username` and `password` // passed as a record. auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new ({  username: \"tom\",  password: \"1234\" });  // Creates a Basic Auth handler with the created Basic Auth provider. http:BasicAuthHandler outboundBasicAuthHandler =  new (outboundBasicAuthProvider);  http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  public function main() {  // Send a `GET` request to the specified endpoint.  var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } } import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;  // Defines the sample backend service, which is secured with Basic Auth // authentication. auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new (inboundBasicAuthProvider);  listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundBasicAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Client with Basic Auth  A client, which is secured with Basic authentication should be used to  connect to a service, which is secured with Basic authentication.  The auth:OutboundBasicAuthProvider is initialized with the username and  password and the http:BasicAuthHandler is initialized by providing  the created auth:OutboundBasicAuthProvider. An additional auth field is  added to the HTTP client endpoint initialization in order to secure the  simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the value of  it being the reference of the created http:BearerAuthHandler.    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new ({  username: \"tom\",  password: \"1234\" });    Defines the Basic Auth client endpoint to call the backend services.  Basic Authentication is enabled by creating an  auth:OutboundBasicAuthProvider with the username and password  passed as a record.   http:BasicAuthHandler outboundBasicAuthHandler =  new (outboundBasicAuthProvider);    Creates a Basic Auth handler with the created Basic Auth provider.   http:Client httpEndpoint = new (\"https://localhost:9090\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response = httpEndpoint->get(\"/hello/sayHello\");  if (response is http:Response) {  var result = response.getTextPayload();  log:printInfo((result is error) ? \"Failed to retrieve payload.\"  : result);  } else {  log:printError(\"Failed to call the endpoint.\", response);  } }    Send a GET request to the specified endpoint.   # To test the client, first start the sample service by executing the below # command by specifying the configuration file name and passing Ballerina home # path as a system property. ballerina run secured_service_with_basic_auth.bal --b7a.config.file=sample-users.toml --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Then start the client by executing the below command by passing Ballerina home # path as a system property. ballerina run secured_client_with_basic_auth.bal --b7a.home=<ballerina_home_path> INFO [ballerina/log] - Hello, World!!!    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new (inboundBasicAuthProvider);    Defines the sample backend service, which is secured with Basic Auth  authentication.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [inboundBasicAuthHandler],  scopes: [\"hello\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-service-with-basic-auth.html","name":"Secured Service with Basic Auth","summary":"A service can be secured using basic authentication and optionally, by\n enforcing authorization. The auth provider reads the username and password\n from a file which has a toml format. This stores usernames, passwords for\n authentication, and scopes for authorization.\n Ballerina uses the concept of scopes for authorization. A resource\n declared ...","content":"/  /  /  / Secured Service with Basic Auth  import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;  // Creates a Basic Auth header handler with the relevant configurations. auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new (basicAuthProvider);  // The endpoint used here is the `http:Listener`, which by default tries to // authenticate and authorize each request. The Basic Authentication handler is // set to this endpoint using the `authHandlers` attribute. It is optional to // override the authentication and authorization at the service level and/or // resource level. listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [basicAuthHandler]  },  // The secure hello world sample uses HTTPS.  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"scope1\"]  } } // The Auth configuration comprises of two parts - // authentication & authorization. // Authentication can be disabled by setting the `enabled: false` annotation // attribute. // Authorization is based on scopes. A scope maps to one or more groups. // For a user to access a resource, the user should be in the same groups as // the scope. // To specify one or more scopes of a resource, the `scopes` annotation // attribute can be used. service echo on ep {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"scope2\"]  }  }  // The authentication and authorization settings can be overridden at the  // resource level.  // The hello resource would inherit the `enabled: true` flag from the  // service level, which is set automatically. The service level scope  // (i.e., scope1) will be overridden by the scope defined in the resource  // level (i.e., scope2).  resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with Basic Auth  A service can be secured using basic authentication and optionally, by  enforcing authorization. The auth provider reads the username and password  from a file which has a toml format. This stores usernames, passwords for  authentication, and scopes for authorization.  Ballerina uses the concept of scopes for authorization. A resource  declared in a service can be bound to one/more scope(s). In the config  auth provider, scopes are mapped to users.  In the authorization phase, the scopes of the resource are compared against  the scopes mapped to the user for at least one match between the two sets.  The following code block shows the contents of the file sample-users.toml,  which has the required format of usernames, passwords and scopes, including  their mapping.   [b7a.users]   [b7a.users.alice]  password=\"password1\"  scopes=\"scope1\"   [b7a.users.bob]  password=\"password2\"  scopes=\"scope2,scope3\"   There are two users defined - Alice and Bob. Each user has a password and  assigned scopes.    import ballerina/auth; import ballerina/config; import ballerina/http; import ballerina/log;    auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new (basicAuthProvider);    Creates a Basic Auth header handler with the relevant configurations.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [basicAuthHandler]  },    The endpoint used here is the http:Listener, which by default tries to  authenticate and authorize each request. The Basic Authentication handler is  set to this endpoint using the authHandlers attribute. It is optional to  override the authentication and authorization at the service level and/or  resource level.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"scope1\"]  } }    service echo on ep {    The Auth configuration comprises of two parts -  authentication & authorization.  Authentication can be disabled by setting the enabled: false annotation  attribute.  Authorization is based on scopes. A scope maps to one or more groups.  For a user to access a resource, the user should be in the same groups as  the scope.  To specify one or more scopes of a resource, the scopes annotation  attribute can be used.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"scope2\"]  }  }    resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    The authentication and authorization settings can be overridden at the  resource level.  The hello resource would inherit the enabled: true flag from the  service level, which is set automatically. The service level scope  (i.e., scope1) will be overridden by the scope defined in the resource  level (i.e., scope2).   # At the command line, navigate to the directory that contains the `.bal` file. # Ensure that the `sample-users.toml` file is populated correctly with the user # information. If required, user passwords can be encrypted using the # `ballerina encrypt` configuration encryption command. echo '[\"b7a.users\"] [\"b7a.users.alice\"] password=\"password1\" scopes=\"scope1\" [\"b7a.users.bob\"] password=\"password2\" scopes=\"scope2,scope3\"' > sample-users.toml    # To run the service, execute the below command by specifying the configuration # file name and passing Ballerina home path as a system property. ballerina run secured_service_with_basic_auth.bal --b7a.config.file=sample-users.toml --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # Since the resource configuration has overridden the required scopes to denote # that `scope2` is required to invoke `sayHello` resource, the invocation will # fail during authorization. curl -k -u alice:password1 https://localhost:9090/hello/sayHello Authorization failure    # Since `bob` has `scope2`, the invocation will succeed. curl -k -u bob:password2 https://localhost:9090/hello/sayHello Hello, World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/response-with-multiparts.html","name":"Response With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.\n When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of\n entities). If the received parts contain nested parts, you can loop through the ...","content":"/  /  /  / Response With Multiparts  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  // Creates an endpoint for the client. http:Client clientEP = new (\"http://localhost:9092\");  // Creates a listener for the service. listener http:Listener multipartEP = new (9090);  @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseEncoder on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode_out_response\"  }  resource function multipartSender(http:Caller caller,  http:Request request) {  // Creates an enclosing entity to hold the child parts.  mime:Entity parentPart = new;   // Creates a child part with the JSON content.  mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});  // Creates another child part with a file.  mime:Entity childPart2 = new;  // This file path is relative to where the Ballerina is running.  //If your file is located outside, please give the  //absolute file path instead.  childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);  // Creates an array to hold the child parts.  mime:Entity[] childParts = [childPart1, childPart2];  // Sets the child parts to the parent part.  parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);  // Creates an array to hold the parent part and set it to the response.  mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  var result = caller->respond(outResponse);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }  // Binds the listener to the service. @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseDecoder on multipartEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/decode_in_response\"  }  // This resource accepts multipart responses.  resource function multipartReceiver(http:Caller caller,  http:Request request) {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {  // Extracts the body parts from the response.  var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {  //Loops through body parts.  foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  res.setPayload(\"Body Parts Received!\");  }  } else {  res.statusCode = 500;  res.setPayload(\"Connection error\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }  // Gets the child parts that are nested within the parent. function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  <string> childParts.detail().message);  }  } }  //The content logic that handles the body parts //vary based on your requirement. function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  // Extracts `xml` data from the body part.  var payload = bodyPart.getXml();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"XML data: \" + strValue);  } else {  log:printError(\"Error in parsing XML data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  // Extracts `json` data from the body part.  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", payload);  }  } else if (mime:TEXT_PLAIN == baseType) {  // Extracts text data from the body part.  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_PDF == baseType) {  //Extracts byte channel from the body part and save it as a file.  var payload = bodyPart.getByteChannel();  if (payload is io:ReadableByteChannel) {  io:WritableByteChannel destinationChannel =  <@untainted io:WritableByteChannel>io:openWritableFile(\"ReceivedFile.pdf\");  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  }  close(payload);  close(destinationChannel);  } else {  log:printError(\"Error in parsing byte channel :\", payload);  }  } }  //Gets the base type from a given content type. function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }  // Copies the content from the source channel to the destination channel. function copy(io:ReadableByteChannel src, io:WritableByteChannel dst)  returns error? {  while (true) {  //Operation attempts to read a maximum of 1000 bytes.  byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {  //Writes the given content into the channel.  int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }  //Closes the byte channel. function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Response With Multiparts  Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.  When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of  entities). If the received parts contain nested parts, you can loop through the parent parts and get the child parts.    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = new (\"http://localhost:9092\");    Creates an endpoint for the client.   listener http:Listener multipartEP = new (9090);    Creates a listener for the service.   @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseEncoder on new http:Listener(9092) {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/encode_out_response\"  }  resource function multipartSender(http:Caller caller,  http:Request request) {    mime:Entity parentPart = new;    Creates an enclosing entity to hold the child parts.   mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});    Creates a child part with the JSON content.   mime:Entity childPart2 = new;    Creates another child part with a file.   childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);    This file path is relative to where the Ballerina is running. If your file is located outside, please give the absolute file path instead.   mime:Entity[] childParts = [childPart1, childPart2];    Creates an array to hold the child parts.   parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);    Sets the child parts to the parent part.   mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  var result = caller->respond(outResponse);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Creates an array to hold the parent part and set it to the response.   @http:ServiceConfig {  basePath: \"/multiparts\" } service multipartResponseDecoder on multipartEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/decode_in_response\"  }    Binds the listener to the service.   resource function multipartReceiver(http:Caller caller,  http:Request request) {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {    This resource accepts multipart responses.   var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {    Extracts the body parts from the response.   foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  res.setPayload(\"Body Parts Received!\");  }  } else {  res.statusCode = 500;  res.setPayload(\"Connection error\");  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error in responding \", result);  }  } }    Loops through body parts.   function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  <string> childParts.detail().message);  }  } }    Gets the child parts that are nested within the parent.   function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    The content logic that handles the body parts vary based on your requirement.   var payload = bodyPart.getXml();  if (payload is xml) {  string strValue = io:sprintf(\"%s\", payload);  log:printInfo(\"XML data: \" + strValue);  } else {  log:printError(\"Error in parsing XML data\", payload);  }  } else if (mime:APPLICATION_JSON == baseType) {    Extracts xml data from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", payload);  }  } else if (mime:TEXT_PLAIN == baseType) {    Extracts json data from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", payload);  }  } else if (mime:APPLICATION_PDF == baseType) {    Extracts text data from the body part.   var payload = bodyPart.getByteChannel();  if (payload is io:ReadableByteChannel) {  io:WritableByteChannel destinationChannel =  <@untainted io:WritableByteChannel>io:openWritableFile(\"ReceivedFile.pdf\");  var result = copy(payload, destinationChannel);  if (result is error) {  log:printError(\"error occurred while performing copy \", result);  }  close(payload);  close(destinationChannel);  } else {  log:printError(\"Error in parsing byte channel :\", payload);  }  } }    Extracts byte channel from the body part and save it as a file.   function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Gets the base type from a given content type.   function copy(io:ReadableByteChannel src, io:WritableByteChannel dst)  returns error? {  while (true) {    Copies the content from the source channel to the destination channel.   byte[]|io:Error result = src.read(1000);  if (result is io:EofError) {  break;  } else if (result is error) {  return <@untained>result;  } else {    Operation attempts to read a maximum of 1000 bytes.   int i = 0;  while (i < result.length()) {  var result2 = dst.write(result, i);  if (result2 is error) {  return result2;  } else {  i = i + result2;  }  }  }  }  return; }    Writes the given content into the channel.   function close(io:ReadableByteChannel|io:WritableByteChannel ch) {  abstract object {  public function close() returns error?;  } channelResult = ch;  var cr = channelResult.close();  if (cr is error) {  log:printError(\"Error occurred while closing the channel: \", cr);  } }    Closes the byte channel.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run response_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 2018-11-30 08:43:53,163 INFO [ballerina/log] - Nested Parts Detected! 2018-11-30 08:43:53,177 INFO [ballerina/log] - JSON data: {\"name\":\"wso2\"} 2018-11-30 08:43:53,240 INFO [ballerina/log] - XML data: <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang>    #To encode the outbound response with multiparts. curl -X GET http://localhost:9092/multiparts/encode_out_response --5afd3d91ee639af3 content-type: multipart/mixed;boundary=de5520ef3bc703d7    --de5520ef3bc703d7 content-type: application/json    {\"name\":\"wso2\"} --de5520ef3bc703d7 content-type: text/xml    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --de5520ef3bc703d7--    --5afd3d91ee639af3--    #To decode the inbound response with multiparts. $ curl -X GET http://localhost:9090/multiparts/decode_in_response Body Parts Received!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-client-with-oauth2.html","name":"Secured Client with OAuth2","summary":"A client, which is secured with OAuth2 Authentication should be used\n to connect to a service, which is secured with OAuth2 Authentication.\n The oauth2:OutboundOAuth2Provider is initialized with the relevant\n configurations passed as a record. The http:BearerAuthHandler\n is initialized by providing the created oauth2:OutboundOAuth2Provider.\n An additional auth field is added to ...","content":"/  /  /  / Secured Client with OAuth2  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;  // Define the OAuth2 client endpoint to call the backend services. // The OAuth2 authentication with client credentials grant type is enabled by // creating an `oauth2:OutboundOAuth2Provider` with the relevant configurations // passed as a record. oauth2:OutboundOAuth2Provider oauth2Provider1 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  clientId: \"<Client ID for the client credentials grant authentication>\",  clientSecret: \"<Client secret for the client credentials grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  } }); http:BearerAuthHandler oauth2Handler1 = new (oauth2Provider1);  http:Client clientEP1 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler1  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  // Defines the OAuth2 client endpoint to call the backend services. // The OAuth2 authentication with the password grant type is enabled by // creating an `oauth2:OutboundOAuth2Provider` with the relevant // configurations passed as a record. If the access token expires or // becomes invalid, then it will be automatically refreshed with the provided // `refreshConfig`. oauth2:OutboundOAuth2Provider oauth2Provider2 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  username: \"<Username for password grant authentication>\",  password: \"<Password for password grant authentication>\",  clientId: \"<Client ID for password grant authentication>\",  clientSecret: \"<Client secret for password grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  },  refreshConfig: {  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler2 = new (oauth2Provider2);  http:Client clientEP2 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler2  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  // Defines the OAuth2 client endpoint to call the backend services. // The OAuth2 authentication with direct token mode is enabled by creating // an `oauth2:OutboundOAuth2Provider` with the relevant configurations passed // as a record. If the `accessToken` is invalid or not provided, it will // be automatically refreshed with the provided `refreshConfig`. oauth2:OutboundOAuth2Provider oauth2Provider3 = new ({  accessToken: \"<Access token for the authorization endpoint>\",  refreshConfig: {  clientId: \"<Client ID for authentication with the authorization endpoint>\",  clientSecret: \"<Client secret for authentication with the authorization endpoint>\",  refreshToken: \"<Refresh token for the refresh token server>\",  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler3 = new (oauth2Provider3);  http:Client clientEP3 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler3  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  public function main() {  // Sends a `GET` request to the specified endpoint.  var response1 = clientEP1->get(\"/\");  if (response1 is http:Response) {  var result = response1.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP1.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP1.\", response1);  }   // Send a `GET` request to the specified endpoint.  var response2 = clientEP2->get(\"/\");  if (response2 is http:Response) {  var result = response2.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP2.\", response2);  }   // Send a `GET` request to the specified endpoint.  var response3 = clientEP3->get(\"/\");  if (response3 is http:Response) {  var result = response3.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP3.\", response3);  } }    Secured Client with OAuth2  A client, which is secured with OAuth2 Authentication should be used  to connect to a service, which is secured with OAuth2 Authentication.  The oauth2:OutboundOAuth2Provider is initialized with the relevant  configurations passed as a record. The http:BearerAuthHandler  is initialized by providing the created oauth2:OutboundOAuth2Provider.  An additional auth field is added to the HTTP client endpoint  initialization in order to secure the simple HTTP client endpoint.  The authHandler field is defined inside the auth field with the  value of it being the reference of the created http:BearerAuthHandler.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;    oauth2:OutboundOAuth2Provider oauth2Provider1 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  clientId: \"<Client ID for the client credentials grant authentication>\",  clientSecret: \"<Client secret for the client credentials grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  } }); http:BearerAuthHandler oauth2Handler1 = new (oauth2Provider1);    Define the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with client credentials grant type is enabled by  creating an oauth2:OutboundOAuth2Provider with the relevant configurations  passed as a record.   http:Client clientEP1 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler1  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    oauth2:OutboundOAuth2Provider oauth2Provider2 = new ({  tokenUrl: \"<Token URL for the authorization endpoint>\",  username: \"<Username for password grant authentication>\",  password: \"<Password for password grant authentication>\",  clientId: \"<Client ID for password grant authentication>\",  clientSecret: \"<Client secret for password grant authentication>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  },  refreshConfig: {  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler2 = new (oauth2Provider2);    Defines the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with the password grant type is enabled by  creating an oauth2:OutboundOAuth2Provider with the relevant  configurations passed as a record. If the access token expires or  becomes invalid, then it will be automatically refreshed with the provided  refreshConfig.   http:Client clientEP2 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler2  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    oauth2:OutboundOAuth2Provider oauth2Provider3 = new ({  accessToken: \"<Access token for the authorization endpoint>\",  refreshConfig: {  clientId: \"<Client ID for authentication with the authorization endpoint>\",  clientSecret: \"<Client secret for authentication with the authorization endpoint>\",  refreshToken: \"<Refresh token for the refresh token server>\",  refreshUrl: \"<Refresh token URL for the refresh token server>\",  clientConfig: {  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  }  }  } }); http:BearerAuthHandler oauth2Handler3 = new (oauth2Provider3);    Defines the OAuth2 client endpoint to call the backend services.  The OAuth2 authentication with direct token mode is enabled by creating  an oauth2:OutboundOAuth2Provider with the relevant configurations passed  as a record. If the accessToken is invalid or not provided, it will  be automatically refreshed with the provided refreshConfig.   http:Client clientEP3 = new (\"<URL of the secured endpoint>\", {  auth: {  authHandler: oauth2Handler3  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    public function main() {    var response1 = clientEP1->get(\"/\");  if (response1 is http:Response) {  var result = response1.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP1.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP1.\", response1);  }    Sends a GET request to the specified endpoint.   var response2 = clientEP2->get(\"/\");  if (response2 is http:Response) {  var result = response2.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP2.\", response2);  }    Send a GET request to the specified endpoint.   var response3 = clientEP3->get(\"/\");  if (response3 is http:Response) {  var result = response3.getJsonPayload();  if (result is json) {  log:printInfo(result.toJsonString());  } else {  log:printError(\"Failed to retrieve payload for clientEP2.\");  }  } else {  log:printError(\"Failed to call the endpoint from clientEP3.\", response3);  } }    Send a GET request to the specified endpoint.   # To test the client, configure the clients with required parameters and # execute the below command by passing Ballerina home path as a system property. ballerina run secured_client_with_oauth2.bal --b7a.home=<ballerina_home_path>    # This should log the JSON output returned by the REST endpoints.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-service-with-jwt-auth.html","name":"Secured Service with JWT Auth","summary":"A service can be secured using JWT and optionally, by enforcing\n authorization. The JWT auth provider verifies the signature of the JWT\n token sent in the Authorization header. For this, Ballerina should trust the\n JWT issuer (the certificate of the JWT issuer must be present in the Ballerina\n certificate truststore).\n ...","content":"/  /  /  / Secured Service with JWT Auth  import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;  // Creates an inbound JWT authentication provider with the relevant // configurations. jwt:InboundJwtAuthProvider jwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  // Creates a Bearer Auth handler with the created JWT Auth provider. http:BearerAuthHandler jwtAuthHandler = new (jwtAuthProvider);  // The endpoint used here is the `http:Listener`. The JWT authentication // handler is set to this endpoint using the `authHandlers` attribute. // It is optional to override the authentication and authorization at the // service and resource levels. listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [jwtAuthHandler]  },  // The secure hello world sample uses HTTPS.  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\" } // The Auth configuration comprises of two parts - // authentication & authorization. // Authentication can be disabled by setting the `enabled: false` flag. // Authorization is based on scopes. A scope maps to one or more groups. // For a user to access a resource, the user should be in the same groups as // the scope. // To specify one or more scope of a resource, the annotation attribute // `scopes` can be used. service echo on ep {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"hello\"],  enabled: true  }  }  // The authentication and authorization settings can be overridden at  // the resource level.  // The hello resource would inherit the `enabled: true` flag from the  // service level, which is set automatically.  // The scope of the resource is defined as \"hello\".  resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with JWT Auth  A service can be secured using JWT and optionally, by enforcing  authorization. The JWT auth provider verifies the signature of the JWT  token sent in the Authorization header. For this, Ballerina should trust the  JWT issuer (the certificate of the JWT issuer must be present in the Ballerina  certificate truststore).  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scope can be included  in the JWT using the scope attribute.  In the authorization phase, the scopes of the resource are compared against  the scopes mapped to the user for at least one match between the two sets.    import ballerina/http; import ballerina/config; import ballerina/jwt; import ballerina/log;    jwt:InboundJwtAuthProvider jwtAuthProvider = new ({  issuer: \"ballerina\",  audience: \"ballerina.io\",  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });    Creates an inbound JWT authentication provider with the relevant  configurations.   http:BearerAuthHandler jwtAuthHandler = new (jwtAuthProvider);    Creates a Bearer Auth handler with the created JWT Auth provider.   listener http:Listener ep = new (9090, config = {  auth: {  authHandlers: [jwtAuthHandler]  },    The endpoint used here is the http:Listener. The JWT authentication  handler is set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   @http:ServiceConfig {  basePath: \"/hello\" }    service echo on ep {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/sayHello\",  auth: {  scopes: [\"hello\"],  enabled: true  }  }    The Auth configuration comprises of two parts -  authentication & authorization.  Authentication can be disabled by setting the enabled: false flag.  Authorization is based on scopes. A scope maps to one or more groups.  For a user to access a resource, the user should be in the same groups as  the scope.  To specify one or more scope of a resource, the annotation attribute  scopes can be used.   resource function hello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    The authentication and authorization settings can be overridden at  the resource level.  The hello resource would inherit the enabled: true flag from the  service level, which is set automatically.  The scope of the resource is defined as “hello”.   # To run the service, execute the command below by passing Ballerina home path # as a system property. ballerina run secured_service_with_jwt_auth.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    curl -k -H \"Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.\\ eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksIm\\ lhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQi\\ LCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY2\\ 9wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVk\\ x6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BYCbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTR\\ pCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2ey_Ho6fDhsKE3DZgssvgPgI9PBItnkip\\ Q3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG5XD0K4sgN9udVTi3EMKNMnVQaq\\ 399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2-mAEcstgiHVw\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Invoke the service using “cURL”.  Note that it is required to provide the correct bearer authentication header  with the cURL command.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-service-with-ldap.html","name":"Secured Service with LDAP","summary":"A service can be secured using LDAP and optionally by enforcing\n authorization. The LDAP auth provider verifies the token against the\n configured LDAP server. The result returned from the LDAP\n server is used for authentication and authorization.Defines the LDAP connection configurations.Creates an inbound LDAP authentication provider with the LDAP\n connection ...","content":"/  /  /  / Secured Service with LDAP  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/ldap;  // Defines the LDAP connection configurations. ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:9095\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 };  // Creates an inbound LDAP authentication provider with the LDAP // connection configurations. ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\");  // Creates a Basic Auth handler with the created LDAP Auth provider. http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider);  // The endpoint used here is the `http:Listener`. The LDAP Auth handler is // set to this endpoint using the `authHandlers` attribute. // It is optional to override the authentication and authorization at the // service and resource levels. listener http:Listener ep = new (9090, {  auth: {  authHandlers: [ldapAuthHandler]  },  // The secure hello world sample uses HTTPS.  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with LDAP  A service can be secured using LDAP and optionally by enforcing  authorization. The LDAP auth provider verifies the token against the  configured LDAP server. The result returned from the LDAP  server is used for authentication and authorization.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/ldap;    ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:9095\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 };    Defines the LDAP connection configurations.   ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\");    Creates an inbound LDAP authentication provider with the LDAP  connection configurations.   http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider);    Creates a Basic Auth handler with the created LDAP Auth provider.   listener http:Listener ep = new (9090, {  auth: {  authHandlers: [ldapAuthHandler]  },    The endpoint used here is the http:Listener. The LDAP Auth handler is  set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    # To run the service, execute the below command by passing the Ballerina home path # as a system property. ballerina run secured_service_with_ldap.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    curl -k -H \"Authorization: Basic YWxpY2U6YWJjMTIz\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Start the LDAP server and invoke the service using cURL.  It is required to provide the correct basic authentication header or  <username>:<password> with the -u parameter and the cURL command.  It will get validated against the LDAP server.   curl -k -u alice:abc123 https://localhost:9090/hello/sayHello Hello, World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/shift-expressions.html","name":"Shift Expressions","summary":"A shift expression performs a bitwise shift. Both the value to be shifted (left hand operand) and the shift amount\n (right hand operand) should have static types that are subtypes of the int type.\n All except the bottom 6 bits of the shift amount are masked out.\n All shift operations ...","content":"/  /  /  / Shift Expressions  import ballerina/io; import ballerina/lang.'int;  public function main() {  int a = 1;  // `<<` performs a left shift. The bits shifted in on the right, in place  // of the bits shifted to the left, are `0`.  // The type of the result of a left shift is always `int`.  int res1 = a << 2;  io:println(\"`int` 1 << 2: \", res1);   'int:Unsigned8 b = 128;  int res2 = b << 3;  io:println(\"`int:Unsigned8` 128 << 3: \", res2);   // `>>` performs a signed right shift. The bits shifted in on the left, in place  // of the bits shifted to the right, are the same as the most significant bit.  // If the value to be shifted is of a signed subtype of `int`, the type of  // the result of the signed right shift is `int`.  'int:Signed16 c = -32700;  int res3 = c >> 2;  io:println(\"`int:Signed16` -32700 >> 2: \", res3);   // If the value to be shifted is of an unsigned subtype of `int`, the type of  // the result of the signed right shift is the same unsigned subtype of `int`.  'int:Unsigned8 d = 255;  int e = 4;  'int:Unsigned8 res4 = d >> e;  io:println(\"`int:Unsigned8` 255 >> 4: \", res4);   // `>>>` performs an unsigned right shift. The bits shifted in on the left, in place  // of the bits shifted to the right, are `0`.  // If the value to be shifted is of a signed subtype of `int`, the type of  // the result of the signed right shift is `int`.  'int:Signed32 f = 123167;  int res5 = f >>> 3;  io:println(\"`int:Signed32` 123167 >>> 3: \", res5);   // If the value to be shifted is of an unsigned subtype of `int`, the type of  // the result of the signed right shift is the same unsigned subtype of `int`.  'int:Unsigned16 g = 32001;  'int:Unsigned16 res6 = g >> 2;  io:println(\"`int:Unsigned16` 32001 >>> 2: \", res6); }    Shift Expressions  A shift expression performs a bitwise shift. Both the value to be shifted (left hand operand) and the shift amount  (right hand operand) should have static types that are subtypes of the int type.  All except the bottom 6 bits of the shift amount are masked out.  All shift operations are based on the 64-bit representations of the values.    import ballerina/io; import ballerina/lang.'int;    public function main() {  int a = 1;    int res1 = a << 2;  io:println(\"`int` 1 << 2: \", res1);    << performs a left shift. The bits shifted in on the right, in place  of the bits shifted to the left, are 0.  The type of the result of a left shift is always int.   'int:Unsigned8 b = 128;  int res2 = b << 3;  io:println(\"`int:Unsigned8` 128 << 3: \", res2);    'int:Signed16 c = -32700;  int res3 = c >> 2;  io:println(\"`int:Signed16` -32700 >> 2: \", res3);    >> performs a signed right shift. The bits shifted in on the left, in place  of the bits shifted to the right, are the same as the most significant bit.  If the value to be shifted is of a signed subtype of int, the type of  the result of the signed right shift is int.   'int:Unsigned8 d = 255;  int e = 4;  'int:Unsigned8 res4 = d >> e;  io:println(\"`int:Unsigned8` 255 >> 4: \", res4);    If the value to be shifted is of an unsigned subtype of int, the type of  the result of the signed right shift is the same unsigned subtype of int.   'int:Signed32 f = 123167;  int res5 = f >>> 3;  io:println(\"`int:Signed32` 123167 >>> 3: \", res5);    >>> performs an unsigned right shift. The bits shifted in on the left, in place  of the bits shifted to the right, are 0.  If the value to be shifted is of a signed subtype of int, the type of  the result of the signed right shift is int.   'int:Unsigned16 g = 32001;  'int:Unsigned16 res6 = g >> 2;  io:println(\"`int:Unsigned16` 32001 >>> 2: \", res6); }    If the value to be shifted is of an unsigned subtype of int, the type of  the result of the signed right shift is the same unsigned subtype of int.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run shift_expressions.bal `int` 1 << 2: 4 `int:Unsigned8` 128 << 3: 1024 `int:Signed16` -32700 >> 2: -8175 `int:Unsigned8` 255 >> 4: 15 `int:Signed32` 123167 >>> 3: 15395 `int:Unsigned16` 32001 >>> 2: 8000    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/secured-service-with-oauth2.html","name":"Secured Service with OAuth2","summary":"A service can be secured using OAuth2 and optionally by enforcing\n authorization. The OAuth2 auth provider verifies the token against the\n configured introspection server. The result returned from the introspection\n server is used for token expiration, authorization etc.\n Ballerina uses the concept of scopes for authorization. A resource declared\n in ...","content":"/  /  /  / Secured Service with OAuth2  import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;  // Creates an inbound OAuth2 authentication provider with the relevant // configurations of the introspection server. oauth2:InboundOAuth2Provider oauth2Provider = new ({  url: \"https://localhost:9095/oauth2/token/introspect\" });  // Creates a Bearer Auth handler with the created OAuth2 provider. http:BearerAuthHandler oauth2Handler = new (oauth2Provider);  // The endpoint used here is the `http:Listener`. The OAuth2 handler is // set to this endpoint using the `authHandlers` attribute. // It is optional to override the authentication and authorization at the // service and resource levels. listener http:Listener ep = new (9090, {  auth: {  authHandlers: [oauth2Handler]  },  // The secure hello world sample uses HTTPS.  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    Secured Service with OAuth2  A service can be secured using OAuth2 and optionally by enforcing  authorization. The OAuth2 auth provider verifies the token against the  configured introspection server. The result returned from the introspection  server is used for token expiration, authorization etc.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scopes are included in  the introspection response and the scopes of the resource are compared  against those for at least one match between the two sets.    import ballerina/http; import ballerina/config; import ballerina/log; import ballerina/oauth2;    oauth2:InboundOAuth2Provider oauth2Provider = new ({  url: \"https://localhost:9095/oauth2/token/introspect\" });    Creates an inbound OAuth2 authentication provider with the relevant  configurations of the introspection server.   http:BearerAuthHandler oauth2Handler = new (oauth2Provider);    Creates a Bearer Auth handler with the created OAuth2 provider.   listener http:Listener ep = new (9090, {  auth: {  authHandlers: [oauth2Handler]  },    The endpoint used here is the http:Listener. The OAuth2 handler is  set to this endpoint using the authHandlers attribute.  It is optional to override the authentication and authorization at the  service and resource levels.   secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") +  \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });    The secure hello world sample uses HTTPS.   service hello on ep {  resource function sayHello(http:Caller caller, http:Request req) {  error? result = caller->respond(\"Hello, World!!!\");  if (result is error) {  log:printError(\"Error in responding to caller\", result);  }  } }    # To run the service, execute the below command by passing Ballerina home path # as a system property. ballerina run secured_service_with_oauth2.bal --b7a.home=<ballerina_home_path> [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    curl -k -H \"Authorization: Bearer YWRtaW46MTIz\" \\ https://localhost:9090/hello/sayHello Hello, World!!!    Start the introspection server on 9095 with the /oauth2/token/introspect  resource path and invoke the service using cURL. Note that it is required  to provide the correct bearer authentication header with the cURL command.  It will get validated against the introspection server.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/send-and-receive-emails.html","name":"Send and Receive Emails","summary":"The Email Connector is used to send (with SMTP) and receive (with POP3 or\n IMAP4) emails using the SSL or STARTTLS protocols. This sample includes\n sending and receiving emails with default configurations over SSL using\n default ports.Creates an SMTP client with the connection parameters, host, username,\n and password. Default port ...","content":"/  /  /  / Send and Receive Emails  import ballerina/email; import ballerina/io;  public function main() {  // Creates an SMTP client with the connection parameters, host, username,  // and password. Default port number `465` is used over SSL with these  // configurations.  email:SmtpClient smtpClient = new (\"smtp.email.com\", \"sender@email.com\"  , \"pass123\");   // Define the email that is required to be sent.  email:Email email = {  // \"TO\", \"CC\" and \"BCC\" address lists are added as follows.  // Only \"TO\" address list is mandatory out of these three.  to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],  // Subject of the email is added as follows. This field is mandatory.  subject: \"Sample Email\",  // Body content of the email is added as follows.  // This field is mandatory.  body: \"This is a sample email.\",  // Email author's address is added as follows. This field is mandatory.  'from: \"author@email.com\",  // Email sender service address is added as follows.  // This field is optional. `Sender` is same as the `'from` when the  // email author himself sends the email.  sender: \"sender@email.com\",  // List of recipients when replying to the email is added as follows.  // This field is optional. These addresses are required when the emails  // are to be replied to some other address(es) other than the sender or  // the author.  replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };   // Send the email with the client.  email:Error? response = smtpClient->send(email);  if (response is email:Error) {  io:println(\"Error while sending the email: \"  + <string> response.detail()[\"message\"]);  }  } import ballerina/email; import ballerina/io;  public function main() {  // Create the client with the connection parameters, host, username, and  // password. An error is received in failure. Default port number `995` is  // used over SSL with these configurations.  email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\", \"pass456\");  if (popClient is email:PopClient) {  // Read the first unseen email received by the POP3 server. Nil is  // returned when there are no new unseen emails. In error cases an  // error is returned.  email:Email|email:Error? emailResponse = popClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);  // When no emails are available in the server, nil is returned.  } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> popClient.detail()[\"message\"]);  } } import ballerina/email; import ballerina/io;  public function main() {  // Create the client with the connection parameters, host, username, and  // password. An error is received in failure. Default port number `993` is  // used over SSL with these configurations.  email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");  if (imapClient is email:ImapClient) {  // Read the first unseen email received by the IMAP4 server. Nil is  // returned when there are no new unseen emails. In error cases an  // error is returned.  email:Email|email:Error? emailResponse = imapClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);  // When no emails are available in the server, nil is returned.  } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> imapClient.detail()[\"message\"]);  } }    Send and Receive Emails  The Email Connector is used to send (with SMTP) and receive (with POP3 or  IMAP4) emails using the SSL or STARTTLS protocols. This sample includes  sending and receiving emails with default configurations over SSL using  default ports.    import ballerina/email; import ballerina/io;    public function main() {    email:SmtpClient smtpClient = new (\"smtp.email.com\", \"sender@email.com\"  , \"pass123\");    Creates an SMTP client with the connection parameters, host, username,  and password. Default port number 465 is used over SSL with these  configurations.   email:Email email = {    Define the email that is required to be sent.   to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],    “TO”, “CC” and “BCC” address lists are added as follows.  Only “TO” address list is mandatory out of these three.   subject: \"Sample Email\",    Subject of the email is added as follows. This field is mandatory.   body: \"This is a sample email.\",    Body content of the email is added as follows.  This field is mandatory.   'from: \"author@email.com\",    Email author’s address is added as follows. This field is mandatory.   sender: \"sender@email.com\",    Email sender service address is added as follows.  This field is optional. Sender is same as the 'from when the  email author himself sends the email.   replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };    List of recipients when replying to the email is added as follows.  This field is optional. These addresses are required when the emails  are to be replied to some other address(es) other than the sender or  the author.   email:Error? response = smtpClient->send(email);  if (response is email:Error) {  io:println(\"Error while sending the email: \"  + <string> response.detail()[\"message\"]);  }    Send the email with the client.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run send_email.bal    # Check the inbox to view the email.    import ballerina/email; import ballerina/io;    public function main() {    email:PopClient|email:Error popClient = new (\"pop.email.com\",  \"reader@email.com\", \"pass456\");  if (popClient is email:PopClient) {    Create the client with the connection parameters, host, username, and  password. An error is received in failure. Default port number 995 is  used over SSL with these configurations.   email:Email|email:Error? emailResponse = popClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);    Read the first unseen email received by the POP3 server. Nil is  returned when there are no new unseen emails. In error cases an  error is returned.   } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> popClient.detail()[\"message\"]);  } }    When no emails are available in the server, nil is returned.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run receive_email.bal    # Subject and the content body of the email would be printed.    import ballerina/email; import ballerina/io;    public function main() {    email:ImapClient|email:Error imapClient = new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");  if (imapClient is email:ImapClient) {    Create the client with the connection parameters, host, username, and  password. An error is received in failure. Default port number 993 is  used over SSL with these configurations.   email:Email|email:Error? emailResponse = imapClient->read();  if (emailResponse is email:Email) {  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse.body);    Read the first unseen email received by the IMAP4 server. Nil is  returned when there are no new unseen emails. In error cases an  error is returned.   } else if (emailResponse is ()) {  io:println(\"There are no emails in the INBOX.\");  } else {  io:println(\"Error while getting getting response: \"  + <string> emailResponse.detail()[\"message\"]);  }  } else {  io:println(\"Error while creating client: \"  + <string> imapClient.detail()[\"message\"]);  } }    When no emails are available in the server, nil is returned.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run receive_email.bal    # Subject and the content body of the email will be printed.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/string-template.html","name":"String Template Literal","summary":"String templates are string literals, which allow embedded expressions of simple basic types (except nil).\n The placeholders for expressions are indicated by the dollar symbol followed by open and close curly braces ${}.\n You can enclose a string literal with the keyword string followed by two back-tick characters.Create a string ...","content":"/  /  /  / String Template Literal  import ballerina/io;  public function main() {  string name = \"Ballerina\";  // Create a `string` template embedding the `name` variable.  string template = string `Hello ${name}!!!`;  // Print the defined string value.  io:println(template); }    String Template Literal  String templates are string literals, which allow embedded expressions of simple basic types (except nil).  The placeholders for expressions are indicated by the dollar symbol followed by open and close curly braces ${}.  You can enclose a string literal with the keyword string followed by two back-tick characters.    import ballerina/io;    public function main() {  string name = \"Ballerina\";    string template = string `Hello ${name}!!!`;    Create a string template embedding the name variable.   io:println(template); }    Print the defined string value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run string_template.bal Hello Ballerina!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/streams.html","name":"Streams","summary":"The stream type represents a sequence that may be constructed lazily\n and is used to iterate over the sequence of values of type T with error type E.\n stream<T> is short for stream<T, never>.\n A stream can be iterated over at most once.\n A stream has a next() method; a ...","content":"/  /  /  / Streams  import ballerina/io;  //Defines an object called `OddNumberGenerator`. Each object has its own next() method, //which gets invoked when the stream's `next()` function gets called. type OddNumberGenerator object {  int i = 1;  public function next() returns record {|int value;|}|error? {  self.i += 2;  return {value: self.i};  } };  type ResultValue record {|  int value; |};  type Student record {  string firstName;  string lastName;  float score; };  type StudentValue record {|  Student value; |};  type FullName record {|  string firstName;  string lastName; |};  type Subscription record {|  string firstName;  string lastName;  float score;  string degree; |};  public function main() {  OddNumberGenerator oddGen = new;   //Creating a stream passing an OddNumberGenerator object to the stream constructor  var oddNumberStream = new stream<int, error>(oddGen);   record {|int value;|}|error? oddNumber = oddNumberStream.next();   if (oddNumber is ResultValue) {  io:println(\"Retrieved odd number: \", oddNumber.value);  }   io:println(\"Filter records and map them to a different type :\");   Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};   Student[] studentList = [s1, s2, s3];   //Iterable types can be converted to a stream.  stream<Student> studentStream = studentList.toStream();   //The `filter` and `map` functions return streams and work lazily.  stream<Subscription> subscriptionStream = studentStream.filter(function (Student student) returns boolean {  return student.score > 1;  }).'map(function (Student student) returns Subscription {  Subscription subscription = {  firstName: student.firstName,  lastName: student.lastName,  score: student.score,  degree: \"Bachelor of Medicine\"  };  return subscription;  });   io:println(\"Calculate the average score of the subscribed students: \");  //The `reduce` function reduces the stream to a single value.  float? avg = subscriptionStream.reduce(function (float accum, Student student) returns float {  return accum + <float>student.score / studentList.length();  }, 0.0);   if (avg is float) {  io:println(\"Average: \", avg);  }   //A stream can be iterated at most for once. Hence, another stream gets created from the record list.  stream<Student> studentStream2 = studentList.toStream();   io:println(\"Calls next method manually and get the next iteration value: \");  //Calls the `next()` operation to retrieve the data from the stream.  record {|Student value;|}|error? student = studentStream2.next();  if (student is StudentValue) {  io:println(student.value);  }   io:println(\"Use foreach method to loop through the rest of the stream: \");   //If there is any error during the iteration of the  // studentList2 stream, the result stream will terminate and return the error.  error? e = studentStream2.forEach(function (Student student) {  io:println(\"Student \", student.firstName, \" has a score of \", student.score);  });   //Check and handle the error during the iteration of the stream.  if (e is error) {  io:println(\"ForEach operation on the stream failed: \", e);  }   stream<Student> studentStream3 = studentList.toStream();  var iterator = studentStream3.iterator();   //Calls the `next()` operation on the iterator to retrieve the next data from the stream.  record {|Student value;|}|error? nextStudent = iterator.next();  if (nextStudent is StudentValue) {  io:println(nextStudent.value);  } }    Streams  The stream type represents a sequence that may be constructed lazily  and is used to iterate over the sequence of values of type T with error type E.  stream<T> is short for stream<T, never>.  A stream can be iterated over at most once.  A stream has a next() method; a stream’s iterator works by calling this method.  The stream type provides methods similar to lists such as map, foreach, filter, reduce, and iterator.  The stream type does not provide a length method. This is a preview feature.    import ballerina/io;    type OddNumberGenerator object {  int i = 1;  public function next() returns record {|int value;|}|error? {  self.i += 2;  return {value: self.i};  } };    Defines an object called OddNumberGenerator. Each object has its own next() method, which gets invoked when the stream’s next() function gets called.   type ResultValue record {|  int value; |};    type Student record {  string firstName;  string lastName;  float score; };    type StudentValue record {|  Student value; |};    type FullName record {|  string firstName;  string lastName; |};    type Subscription record {|  string firstName;  string lastName;  float score;  string degree; |};    public function main() {  OddNumberGenerator oddGen = new;    var oddNumberStream = new stream<int, error>(oddGen);    Creating a stream passing an OddNumberGenerator object to the stream constructor   record {|int value;|}|error? oddNumber = oddNumberStream.next();    if (oddNumber is ResultValue) {  io:println(\"Retrieved odd number: \", oddNumber.value);  }    io:println(\"Filter records and map them to a different type :\");    Student s1 = {firstName: \"Alex\", lastName: \"George\", score: 1.5};  Student s2 = {firstName: \"Ranjan\", lastName: \"Fonseka\", score: 0.9};  Student s3 = {firstName: \"John\", lastName: \"David\", score: 1.2};    Student[] studentList = [s1, s2, s3];    stream<Student> studentStream = studentList.toStream();    Iterable types can be converted to a stream.   stream<Subscription> subscriptionStream = studentStream.filter(function (Student student) returns boolean {  return student.score > 1;  }).'map(function (Student student) returns Subscription {  Subscription subscription = {  firstName: student.firstName,  lastName: student.lastName,  score: student.score,  degree: \"Bachelor of Medicine\"  };  return subscription;  });    The filter and map functions return streams and work lazily.   io:println(\"Calculate the average score of the subscribed students: \");    float? avg = subscriptionStream.reduce(function (float accum, Student student) returns float {  return accum + <float>student.score / studentList.length();  }, 0.0);    The reduce function reduces the stream to a single value.   if (avg is float) {  io:println(\"Average: \", avg);  }    stream<Student> studentStream2 = studentList.toStream();    A stream can be iterated at most for once. Hence, another stream gets created from the record list.   io:println(\"Calls next method manually and get the next iteration value: \");    record {|Student value;|}|error? student = studentStream2.next();  if (student is StudentValue) {  io:println(student.value);  }    Calls the next() operation to retrieve the data from the stream.   io:println(\"Use foreach method to loop through the rest of the stream: \");    error? e = studentStream2.forEach(function (Student student) {  io:println(\"Student \", student.firstName, \" has a score of \", student.score);  });    If there is any error during the iteration of the  studentList2 stream, the result stream will terminate and return the error.   if (e is error) {  io:println(\"ForEach operation on the stream failed: \", e);  }    Check and handle the error during the iteration of the stream.   stream<Student> studentStream3 = studentList.toStream();  var iterator = studentStream3.iterator();    record {|Student value;|}|error? nextStudent = iterator.next();  if (nextStudent is StudentValue) {  io:println(nextStudent.value);  } }    Calls the next() operation on the iterator to retrieve the next data from the stream.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run streams.bal    Retrieved odd number: 3 Filter records and map them to a different type : Calculate the average score of the subscribed students: Average: 0.8999999999999999 Calls next method manually and get the next iteration value: firstName=Alex lastName=George score=1.5 Use foreach method to loop through the rest of the stream: Student Ranjan has a score of 0.9 Student John has a score of 1.2 firstName=Alex lastName=George score=1.5    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/strings.html","name":"String","summary":"Ballerina contains a comprehensive set of functions to manipulate Strings.Create a new string, which is a substring of the specified string.\n You must provide the original string\n and the starting and ending indexes of the substring.Retrieve the starting index of the first occurrence of the substring “on” within the statement ...","content":"/  /  /  / String  import ballerina/io; import ballerina/lang.'string;  public function main() {   string statement = \"Lion in Town. Catch the Lion\";   string s1 = statement.toUpperAscii();  io:println(\"ToUpper: \", s1);   string s2 = statement.toLowerAscii();  io:println(\"ToLower: \", s2);   // Create a new `string`, which is a substring of the specified string.  // You must provide the original `string`  // and the starting and ending indexes of the substring.  string s3 = statement.substring(0, 4);  io:println(\"SubString: \", s3);   // Retrieve the starting index of the first occurrence of the substring \"on\" within the `statement` string.  int? index = statement.indexOf(\"on\");  if (index is int) {  io:println(\"IndexOf: \", index);  }   // Retrieve the length of the `string`.  int length = statement.length();  io:println(\"Length: \", length);   string hello = \"Hello\";  string ballerina = \"Ballerina!\";   // Concat multiple strings.  string s4 = hello.concat(\" \", ballerina);  io:println(\"Concat: \", s4);   // Join strings with a separator.  string s5 = \",\".'join(hello, ballerina);  io:println(\"Join: \", s5);   // Convert `hello` to a `byte` array.  byte[] bArray = hello.toBytes();   // Convert a `byte` array to a `string`.  string|error s6 = 'string:fromBytes(bArray);  if (s6 is string) {  io:println(\"From bytes: \", s6);  }   // Remove leading and trailing white spaces.  string toTrim = \" Ballerina Programming Language \";  string s7 = toTrim.trim();  io:println(\"Trim: \", s7);   // Check whether the given `string` ends with the suffix \"Lion\".  boolean hasSuffix = statement.endsWith(\"Lion\");  io:println(\"HasSuffix: \", hasSuffix);   // Check whether the given `string` starts with the prefix \"Lion\".  boolean hasPrefix = statement.startsWith(\"Lion\");  io:println(\"HasPrefix: \", hasPrefix);   // Format a `string` according to the given format arguments.  string name = \"Sam\";  int marks = 90;  string[] subjects = [\"English\", \"Science\"];  float average = 71.5;  string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\",  name, marks, subjects[0], average);  io:println(\"Sprintf: \", s8);   // Member access is allowed with strings to access individual characters  // of a string. Member access panics if the integer index is out of range.  string country = \"Sri Lanka\";  string c = country[4];  io:println(\"Member Access: \", c); }    String  Ballerina contains a comprehensive set of functions to manipulate Strings.    import ballerina/io; import ballerina/lang.'string;    public function main() {    string statement = \"Lion in Town. Catch the Lion\";    string s1 = statement.toUpperAscii();  io:println(\"ToUpper: \", s1);    string s2 = statement.toLowerAscii();  io:println(\"ToLower: \", s2);    string s3 = statement.substring(0, 4);  io:println(\"SubString: \", s3);    Create a new string, which is a substring of the specified string.  You must provide the original string  and the starting and ending indexes of the substring.   int? index = statement.indexOf(\"on\");  if (index is int) {  io:println(\"IndexOf: \", index);  }    Retrieve the starting index of the first occurrence of the substring “on” within the statement string.   int length = statement.length();  io:println(\"Length: \", length);    Retrieve the length of the string.   string hello = \"Hello\";  string ballerina = \"Ballerina!\";    string s4 = hello.concat(\" \", ballerina);  io:println(\"Concat: \", s4);    Concat multiple strings.   string s5 = \",\".'join(hello, ballerina);  io:println(\"Join: \", s5);    Join strings with a separator.   byte[] bArray = hello.toBytes();    Convert hello to a byte array.   string|error s6 = 'string:fromBytes(bArray);  if (s6 is string) {  io:println(\"From bytes: \", s6);  }    Convert a byte array to a string.   string toTrim = \" Ballerina Programming Language \";  string s7 = toTrim.trim();  io:println(\"Trim: \", s7);    Remove leading and trailing white spaces.   boolean hasSuffix = statement.endsWith(\"Lion\");  io:println(\"HasSuffix: \", hasSuffix);    Check whether the given string ends with the suffix “Lion”.   boolean hasPrefix = statement.startsWith(\"Lion\");  io:println(\"HasPrefix: \", hasPrefix);    Check whether the given string starts with the prefix “Lion”.   string name = \"Sam\";  int marks = 90;  string[] subjects = [\"English\", \"Science\"];  float average = 71.5;  string s8 = io:sprintf(\"%s scored %d for %s and has an average of %.2f.\",  name, marks, subjects[0], average);  io:println(\"Sprintf: \", s8);    Format a string according to the given format arguments.   string country = \"Sri Lanka\";  string c = country[4];  io:println(\"Member Access: \", c); }    Member access is allowed with strings to access individual characters  of a string. Member access panics if the integer index is out of range.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run strings.bal ToUpper: LION IN TOWN. CATCH THE LION ToLower: lion in town. catch the lion SubString: Lion IndexOf: 2 Length: 28 Concat: Hello Ballerina! Join: Hello,Ballerina! From bytes: Hello Trim: Ballerina Programming Language HasSuffix: true HasPrefix: true Sprintf: Sam scored 90 for English and has an average of 71.50. Member Access: L    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/task-scheduler-appointment.html","name":"Task Scheduler Appointment","summary":"A Task Scheduler can be used to schedule an Appointment. An appointment should\n have an appointmentData field. It can be either a string representing a\n CRON expression or an AppointmentData record. There is an optional\n noOfRecurrences field that can be used to provide the maximum number of times\n the appointment ...","content":"/  /  /  / Task Scheduler Appointment  import ballerina/io; import ballerina/runtime; import ballerina/task;  int reminderCount = 0;  public function main() {  // The Appointment data record provides the appointment configurations.  task:AppointmentData appointmentData = {  seconds: \"0/2\",  minutes: \"*\",  hours: \"*\",  daysOfMonth: \"?\",  months: \"*\",  daysOfWeek: \"*\",  year: \"*\"  };   // Create an Appointment using the configurations.  task:Scheduler appointment = new ({appointmentDetails: appointmentData});   // Attach the service to the scheduler and exit if there is an error.  var attachResult = appointment.attach(appointmentService);  if (attachResult is error) {  io:println(\"Error attaching the service.\");  return;  }   // Start the scheduler and exit if there is an error.  var startResult = appointment.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }   runtime:sleep(10000);   // Cancel the appointment.  var result = appointment.stop();  if (result is error) {  io:println(\"Error occurred while cancelling the task\");  return;  }  io:println(\"Appointment cancelled.\"); }  // Creating a service on the task Listener. service appointmentService = service {  // This resource triggers when the appointment is due.  resource function onTrigger() {  if (reminderCount < 5) {  reminderCount = reminderCount + 1;  io:println(\"Schedule is due - Reminder: \" + reminderCount.toString());  }  } };    Task Scheduler Appointment  A Task Scheduler can be used to schedule an Appointment. An appointment should  have an appointmentData field. It can be either a string representing a  CRON expression or an AppointmentData record. There is an optional  noOfRecurrences field that can be used to provide the maximum number of times  the appointment should run before shutting down.  A service can be attached to the Scheduler using the attach() function.  Then the Scheduler can be started using start() method. When the scheduler  needs to be cancelled, stop() method can be called.    import ballerina/io; import ballerina/runtime; import ballerina/task;    int reminderCount = 0;    public function main() {    task:AppointmentData appointmentData = {  seconds: \"0/2\",  minutes: \"*\",  hours: \"*\",  daysOfMonth: \"?\",  months: \"*\",  daysOfWeek: \"*\",  year: \"*\"  };    The Appointment data record provides the appointment configurations.   task:Scheduler appointment = new ({appointmentDetails: appointmentData});    Create an Appointment using the configurations.   var attachResult = appointment.attach(appointmentService);  if (attachResult is error) {  io:println(\"Error attaching the service.\");  return;  }    Attach the service to the scheduler and exit if there is an error.   var startResult = appointment.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }    Start the scheduler and exit if there is an error.   runtime:sleep(10000);    var result = appointment.stop();  if (result is error) {  io:println(\"Error occurred while cancelling the task\");  return;  }  io:println(\"Appointment cancelled.\"); }    Cancel the appointment.   service appointmentService = service {    Creating a service on the task Listener.   resource function onTrigger() {  if (reminderCount < 5) {  reminderCount = reminderCount + 1;  io:println(\"Schedule is due - Reminder: \" + reminderCount.toString());  }  } };    This resource triggers when the appointment is due.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run task_scheduler_appointment.bal Schedule is due - Reminder: 1 Schedule is due - Reminder: 2 Schedule is due - Reminder: 3 Schedule is due - Reminder: 4 Schedule is due - Reminder: 5 Appointment cancelled.    This example demonstrates an Appointment, which is used to send a reminder  every 2 seconds up to 5 reminders. When the reminder count reaches 5,  the task scheduler will stop running.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/table.html","name":"Table","summary":"The type table is a data structure that organizes information in rows and columns. This example demonstrates how to\n create an in-memory table using a type constraint, insert data to it, and then access/delete the data.This is the type created to represent a data row.This creates an in-memory table constrained ...","content":"/  /  /  / Table  import ballerina/io; import ballerina/jsonutils; import ballerina/xmlutils;  // This is the `type` created to represent a data row. type Employee record {  int id;  string name;  float salary; };  public function main() {  // This creates an in-memory `table` constrained by the `Employee` type with the `id` marked as the  // primary key in the column descriptor. Three data records are inserted into the `table`. The order of  // the data values should match the order of the column descriptor.  table<Employee> tbEmployee = table {  {key id, name, salary},  [  {1, \"Mary\", 300.5},  {2, \"John\", 200.5},  {3, \"Jim\", 330.5}  ]  };  // Print the `table` data.  io:print(\"Table Information: \");  io:println(tbEmployee);   // Create `Employee` records.  Employee e1 = {id: 1, name: \"Jane\", salary: 300.50};  Employee e2 = {id: 2, name: \"Anne\", salary: 100.50};  Employee e3 = {id: 3, name: \"John\", salary: 400.50};  Employee e4 = {id: 4, name: \"Peter\", salary: 150.0};   // Create an in-memory `table` constrained by the `Employee` type with  // the `id` as the primary key. Two records are inserted into the `table`.  table<Employee> tb = table {  {key id, name, salary},  [  e1,  e2  ]  };   Employee[] employees = [e3, e4];  // Add the created records to the `table`.  foreach var emp in employees {  var ret = tb.add(emp);  if (ret is ()) {  io:println(\"Adding record to table successful\");  } else {  io:println(\"Adding to table failed: \", ret.reason());  }  }   // Print the `table` data.  io:println(\"Table Information: \", tb);   // Access the rows using the `foreach` loop.  io:println(\"Using foreach:\");  foreach var x in tb {  io:println(\"Name: \", x.name);  }   // Access rows using the `while` loop.  io:println(\"Using while loop:\");  while (tb.hasNext()) {  var ret = tb.getNext();  io:println(\"Name: \", ret.name);  }   // Convert the `table` to JSON format.  json retValJson = jsonutils:fromTable(tb);  io:println(\"JSON: \", retValJson.toJsonString());   // Convert the `table` to XML format.  xml retValXml = xmlutils:fromTable(tb);  io:println(\"XML: \", retValXml);   // Remove employees with salaries higher than 300.0  // from the table.  int|error count = tb.remove(isHigherSalary);  io:println(\"Deleted Count: \", count);   // Now the table contains the employees with salaries less than 300.0.  io:println(tb); }  // Check whether a given employee's salary is higher than 300.0. function isHigherSalary(Employee emp) returns boolean {  return emp.salary > 300.0; }    Table  The type table is a data structure that organizes information in rows and columns. This example demonstrates how to  create an in-memory table using a type constraint, insert data to it, and then access/delete the data.    import ballerina/io; import ballerina/jsonutils; import ballerina/xmlutils;    type Employee record {  int id;  string name;  float salary; };    This is the type created to represent a data row.   public function main() {    table<Employee> tbEmployee = table {  {key id, name, salary},  [  {1, \"Mary\", 300.5},  {2, \"John\", 200.5},  {3, \"Jim\", 330.5}  ]  };    This creates an in-memory table constrained by the Employee type with the id marked as the  primary key in the column descriptor. Three data records are inserted into the table. The order of  the data values should match the order of the column descriptor.   io:print(\"Table Information: \");  io:println(tbEmployee);    Print the table data.   Employee e1 = {id: 1, name: \"Jane\", salary: 300.50};  Employee e2 = {id: 2, name: \"Anne\", salary: 100.50};  Employee e3 = {id: 3, name: \"John\", salary: 400.50};  Employee e4 = {id: 4, name: \"Peter\", salary: 150.0};    Create Employee records.   table<Employee> tb = table {  {key id, name, salary},  [  e1,  e2  ]  };    Create an in-memory table constrained by the Employee type with  the id as the primary key. Two records are inserted into the table.   Employee[] employees = [e3, e4];    foreach var emp in employees {  var ret = tb.add(emp);  if (ret is ()) {  io:println(\"Adding record to table successful\");  } else {  io:println(\"Adding to table failed: \", ret.reason());  }  }    Add the created records to the table.   io:println(\"Table Information: \", tb);    Print the table data.   io:println(\"Using foreach:\");  foreach var x in tb {  io:println(\"Name: \", x.name);  }    Access the rows using the foreach loop.   io:println(\"Using while loop:\");  while (tb.hasNext()) {  var ret = tb.getNext();  io:println(\"Name: \", ret.name);  }    Access rows using the while loop.   json retValJson = jsonutils:fromTable(tb);  io:println(\"JSON: \", retValJson.toJsonString());    Convert the table to JSON format.   xml retValXml = xmlutils:fromTable(tb);  io:println(\"XML: \", retValXml);    Convert the table to XML format.   int|error count = tb.remove(isHigherSalary);  io:println(\"Deleted Count: \", count);    Remove employees with salaries higher than 300.0  from the table.   io:println(tb); }    Now the table contains the employees with salaries less than 300.0.   function isHigherSalary(Employee emp) returns boolean {  return emp.salary > 300.0; }    Check whether a given employee’s salary is higher than 300.0.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run table.bal Table Information: id=1 name=Mary salary=300.5 id=2 name=John salary=200.5 id=3 name=Jim salary=330.5 Adding record to table successful Adding record to table successful Table Information: id=1 name=Jane salary=300.5 id=2 name=Anne salary=100.5 id=3 name=John salary=400.5 id=4 name=Peter salary=150.0 Using foreach: Name: Jane Name: Anne Name: John Name: Peter Using while loop: Name: Jane Name: Anne Name: John Name: Peter JSON: [{\"id\":1, \"name\":\"Jane\", \"salary\":300.5}, {\"id\":2, \"name\":\"Anne\", \"salary\":100.5}, {\"id\":3, \"name\":\"John\", \"salary\":400.5}, {\"id\":4, \"name\":\"Peter\", \"salary\":150.0}] XML: <results><result><id>1</id><name>Jane</name><salary>300.5</salary></result><result><id>2</id><name>Anne</name><salary>100.5</salary></result><result><id>3</id><name>John</name><salary>400.5</salary></result><result><id>4</id><name>Peter</name><salary>150.0</salary></result></results> Deleted Count: 2 id=2 name=Anne salary=100.5 id=4 name=Peter salary=150.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/taint-checking.html","name":"Taint Checking","summary":"Ballerina is designed to ensure that programs written in Ballerina are inherently secure. Ballerina programs\n are resilient to major security vulnerabilities including SQL injection, path manipulation, file manipulation,\n unauthorized file access, and unvalidated redirect (open redirect).A taint analysis mechanism is used to achieve this. As a result of the taint ...","content":"/  /  /  / Taint Checking  import ballerina/lang.'int; import ballerinax/java.jdbc;  // The `@untainted` annotation can be used with the parameters of user-defined functions. This allow users to restrict // passing untrusted (tainted) data into a security sensitive parameter. function userDefinedSecureOperation(@untainted string secureParameter) {  }  type Student record {  string firstname; };  public function main(string... args) {  jdbc:Client customerDBEP = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: {maximumPoolSize: 5},  dbOptions: {useSSL: false}  });   // Sensitive parameters of functions that are built-in to Ballerina are decorated with the `@untainted` annotation.  // This ensures that tainted data cannot pass into the security sensitive parameter.  //  // For example, the taint checking mechanism of Ballerina completely prevents SQL injection vulnerabilities by  // disallowing tainted data in the SQL query.  //  // This line results in a compile error because the query is appended with a user-provided argument.  var result = customerDBEP->  select(\"SELECT firstname FROM student WHERE\" +  \" registration_id = \" + args[0], ());   if (result is error) {  panic result;  }   table<Student> dataTable = <table<Student>>result;   // This line results in a compiler error because a user-provided argument is passed to a sensitive parameter.  userDefinedSecureOperation(args[0]);   if (isInteger(args[0])) {  // After performing necessary validations and/or escaping, we can use type cast expression with @untainted annotation  // to mark the proceeding value as `trusted` and pass it to a sensitive parameter.  userDefinedSecureOperation(<@untainted>args[0]);  } else {  error err = error(\"Validation error: ID should be an integer\");  panic err;  }   while (dataTable.hasNext()) {  Student jsonData = dataTable.getNext();  // The return values of certain functions built-in to Ballerina are decorated with the `@tainted` annotation to  // denote that the return value should be untrusted (tainted). One such example is the data read from a  // database.  //  // This line results in a compile error because a value derived from a database read (tainted) is passed to a  // sensitive parameter.  userDefinedSecureOperation(jsonData.firstname);   string sanitizedData1 = sanitizeAndReturnTainted(jsonData.firstname);  // This line results in a compile error because the `sanitize` function returns a value derived from the tainted  // data. Therefore, the return of the `sanitize` function is also tainted.  userDefinedSecureOperation(sanitizedData1);   string sanitizedData2 = sanitizeAndReturnUntainted(jsonData.firstname);  // This line successfully compiles. Although the `sanitize` function returns a value derived from tainted data,  // the return value is annotated with the `@untainted` annotation. This means that the return value is safe and can be  // trusted.  userDefinedSecureOperation(sanitizedData2);  }  checkpanic customerDBEP.stop();  return; }  function sanitizeAndReturnTainted(string input) returns string {  // transform and sanitize the string here.  return input; }  // The `@untainted` annotation denotes that the return value of the function should be trusted (untainted) even though // the return value is derived from tainted data. function sanitizeAndReturnUntainted(string input) returns @untainted string {  // transform and sanitize the string here.  return input; }  function isInteger(string input) returns boolean {  var intVal = 'int:fromString(input);  if (intVal is error) {  return false;  } else {  return true;  } }    Taint Checking  Ballerina is designed to ensure that programs written in Ballerina are inherently secure. Ballerina programs  are resilient to major security vulnerabilities including SQL injection, path manipulation, file manipulation,  unauthorized file access, and unvalidated redirect (open redirect).  A taint analysis mechanism is used to achieve this. As a result of the taint analysis mechanism, the Ballerina compiler  identifies untrusted (tainted) data by observing how tainted data propagates through the program. If untrusted data  is passed to a security sensitive parameter, a compile error is generated.    import ballerina/lang.'int; import ballerinax/java.jdbc;    function userDefinedSecureOperation(@untainted string secureParameter) {    The @untainted annotation can be used with the parameters of user-defined functions. This allow users to restrict  passing untrusted (tainted) data into a security sensitive parameter.   }    type Student record {  string firstname; };    public function main(string... args) {  jdbc:Client customerDBEP = new ({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"root\",  password: \"root\",  poolOptions: {maximumPoolSize: 5},  dbOptions: {useSSL: false}  });    var result = customerDBEP->  select(\"SELECT firstname FROM student WHERE\" +  \" registration_id = \" + args[0], ());    Sensitive parameters of functions that are built-in to Ballerina are decorated with the @untainted annotation.  This ensures that tainted data cannot pass into the security sensitive parameter.  For example, the taint checking mechanism of Ballerina completely prevents SQL injection vulnerabilities by  disallowing tainted data in the SQL query.  This line results in a compile error because the query is appended with a user-provided argument.   if (result is error) {  panic result;  }    table<Student> dataTable = <table<Student>>result;    userDefinedSecureOperation(args[0]);    This line results in a compiler error because a user-provided argument is passed to a sensitive parameter.   if (isInteger(args[0])) {    userDefinedSecureOperation(<@untainted>args[0]);  } else {  error err = error(\"Validation error: ID should be an integer\");  panic err;  }    After performing necessary validations and/or escaping, we can use type cast expression with @untainted annotation  to mark the proceeding value as trusted and pass it to a sensitive parameter.   while (dataTable.hasNext()) {  Student jsonData = dataTable.getNext();    userDefinedSecureOperation(jsonData.firstname);    The return values of certain functions built-in to Ballerina are decorated with the @tainted annotation to  denote that the return value should be untrusted (tainted). One such example is the data read from a  database.  This line results in a compile error because a value derived from a database read (tainted) is passed to a  sensitive parameter.   string sanitizedData1 = sanitizeAndReturnTainted(jsonData.firstname);    userDefinedSecureOperation(sanitizedData1);    This line results in a compile error because the sanitize function returns a value derived from the tainted  data. Therefore, the return of the sanitize function is also tainted.   string sanitizedData2 = sanitizeAndReturnUntainted(jsonData.firstname);    userDefinedSecureOperation(sanitizedData2);  }  checkpanic customerDBEP.stop();  return; }    This line successfully compiles. Although the sanitize function returns a value derived from tainted data,  the return value is annotated with the @untainted annotation. This means that the return value is safe and can be  trusted.   function sanitizeAndReturnTainted(string input) returns string {    return input; }    transform and sanitize the string here.   function sanitizeAndReturnUntainted(string input) returns @untainted string {    The @untainted annotation denotes that the return value of the function should be trusted (untainted) even though  the return value is derived from tainted data.   return input; }    transform and sanitize the string here.   function isInteger(string input) returns boolean {  var intVal = 'int:fromString(input);  if (intVal is error) {  return false;  } else {  return true;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run taint_checking.bal error: .::taint_checking.bal:60:36: tainted value passed to untainted parameter 'secureParameter' error: .::taint_checking.bal:31:39: tainted value passed to untainted parameter 'sqlQuery' error: .::taint_checking.bal:41:32: tainted value passed to untainted parameter 'secureParameter' error: .::taint_checking.bal:65:36: tainted value passed to untainted parameter 'secureParameter'    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/task-service-appointment.html","name":"Task Service Appointment","summary":"Task Appointment Services are used to schedule and execute tasks.\n An appointment should have an appointmentData field. It can be either a\n string representing a CRON expression or an AppointmentData record.\n An optional noOfRecurrences field can be used to provide the maximum\n number of times the appointment should run before ...","content":"/  /  /  / Task Service Appointment  import ballerina/log; import ballerina/task;  // Task Appointment configuration record of the Task Listener. // Task Appointment can either have a CRON expression (`string`) or an // `AppointmentData` record for the `appointmentData` field. Optionally, a // `noOfRecurrences` can be provided to limit the number of executions. task:AppointmentConfiguration appointmentConfiguration = {  // This cron expression will schedule the appointment every second.  appointmentDetails: \"* * * * * ?\",  // Number of recurrences will limit the number of times the timer runs.  noOfRecurrences: 10 };  // Initialize the listener using pre defined configurations. listener task:Listener appointment = new (appointmentConfiguration);  int count = 0;  // Creating a service on the task Listener. service appointmentService on appointment {  // This resource triggers when the appointment is due.  resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    Task Service Appointment  Task Appointment Services are used to schedule and execute tasks.  An appointment should have an appointmentData field. It can be either a  string representing a CRON expression or an AppointmentData record.  An optional noOfRecurrences field can be used to provide the maximum  number of times the appointment should run before shutting down.    import ballerina/log; import ballerina/task;    task:AppointmentConfiguration appointmentConfiguration = {    Task Appointment configuration record of the Task Listener.  Task Appointment can either have a CRON expression (string) or an  AppointmentData record for the appointmentData field. Optionally, a  noOfRecurrences can be provided to limit the number of executions.   appointmentDetails: \"* * * * * ?\",    This cron expression will schedule the appointment every second.   noOfRecurrences: 10 };    Number of recurrences will limit the number of times the timer runs.   listener task:Listener appointment = new (appointmentConfiguration);    Initialize the listener using pre defined configurations.   int count = 0;    service appointmentService on appointment {    Creating a service on the task Listener.   resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    This resource triggers when the appointment is due.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run task_service_appointment.bal 2019-09-06 13:35:28,259 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:28,260 INFO [ballerina/log] - 0 2019-09-06 13:35:29,004 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:29,004 INFO [ballerina/log] - 1 2019-09-06 13:35:30,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:30,003 INFO [ballerina/log] - 2 2019-09-06 13:35:31,005 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:31,006 INFO [ballerina/log] - 3 2019-09-06 13:35:32,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:32,003 INFO [ballerina/log] - 4 2019-09-06 13:35:33,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:33,003 INFO [ballerina/log] - 5 2019-09-06 13:35:34,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:34,003 INFO [ballerina/log] - 6 2019-09-06 13:35:35,003 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:35,003 INFO [ballerina/log] - 7 2019-09-06 13:35:36,006 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:36,006 INFO [ballerina/log] - 8 2019-09-06 13:35:37,006 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:35:37,007 INFO [ballerina/log] - 9    The onTrigger() function is triggered every two seconds starting from the  0th second of a minute. The sample will print logs once every two seconds.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/task-scheduler-timer.html","name":"Task Scheduler Timer","summary":"A Task scheduler can be used to create timers to trigger periodically. A\n service can be attached to the task Scheduler object using the attach()\n function and the Listener can be started using the start() function.\n The service that is being attached must contain the onTrigger() resource function.\n Additionally, a ...","content":"/  /  /  / Task Scheduler Timer  import ballerina/io; import ballerina/runtime; import ballerina/task;  // Defines a custom record type to use in the timer. public type Person record {|  string name;  int age;  int maxAge; |};  public function main() {  // The interval in which the timer should trigger.  int intervalInMillis = 1000;   // Initializes the timer scheduler using the interval value.  // The delay will be equal to the interval as an initial delay is not provided.  task:Scheduler timer = new ({  intervalInMillis: intervalInMillis,  initialDelayInMillis: 0  });   // Define a person object  Person person = {name: \"Sam\", age: 0, maxAge: 10};   // Attaching the service to the timer. This will not start the timer.  // However, it will attach the service to the timer and also passes the  // person object into the `onTrigger()` resource  var attachResult = timer.attach(service1, person);  if (attachResult is error) {  io:println(\"Error attaching the service1.\");  return;  }   attachResult = timer.attach(service2, person);  if (attachResult is error) {  io:println(\"Error attaching the service2.\");  return;  }   // Starts the timer.  var startResult = timer.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }   // While loop will stop the function from exiting until the service ends.  while (person.age < person.maxAge) {  // Waits until the age of the person reaches the max age.  runtime:sleep(2000);  }   runtime:sleep(1000);   // Cancels the timer. This will stop the timer and all the services  // attached to it.  var stopResult = timer.stop();  if (stopResult is error) {  io:println(\"Stopping the task is failed.\");  return;  }   io:println(\"End.\"); }  // The service, which will be attached to the timer. service service1 = service {  // The onTrigger resource, which will trigger when the timer runs off.  // The usage of the Person object being passed inside the function, which we  // attached with the timer.  resource function onTrigger(Person person) {  if (person.age < person.maxAge) {  person.age = person.age + 1;  io:println(\"Hi \" + person.name + \" you are \" + person.age.toString() + \" years old now.\");  }  } };  service service2 = service {  resource function onTrigger(Person person) {  if (person.age == 5) {  io:println(person.name + \" started schooling\");  }  } };    Task Scheduler Timer  A Task scheduler can be used to create timers to trigger periodically. A  service can be attached to the task Scheduler object using the attach()  function and the Listener can be started using the start() function.  The service that is being attached must contain the onTrigger() resource function.  Additionally, a user can pass a set of any values to the resource using  the attach() function, which then can be used inside the onTrigger()  function. The Listener can be stopped by calling the stop() function.    import ballerina/io; import ballerina/runtime; import ballerina/task;    public type Person record {|  string name;  int age;  int maxAge; |};    Defines a custom record type to use in the timer.   public function main() {    int intervalInMillis = 1000;    The interval in which the timer should trigger.   task:Scheduler timer = new ({  intervalInMillis: intervalInMillis,  initialDelayInMillis: 0  });    Initializes the timer scheduler using the interval value.  The delay will be equal to the interval as an initial delay is not provided.   Person person = {name: \"Sam\", age: 0, maxAge: 10};    Define a person object   var attachResult = timer.attach(service1, person);  if (attachResult is error) {  io:println(\"Error attaching the service1.\");  return;  }    Attaching the service to the timer. This will not start the timer.  However, it will attach the service to the timer and also passes the  person object into the onTrigger() resource   attachResult = timer.attach(service2, person);  if (attachResult is error) {  io:println(\"Error attaching the service2.\");  return;  }    var startResult = timer.start();  if (startResult is error) {  io:println(\"Starting the task is failed.\");  return;  }    Starts the timer.   while (person.age < person.maxAge) {    While loop will stop the function from exiting until the service ends.   runtime:sleep(2000);  }    Waits until the age of the person reaches the max age.   runtime:sleep(1000);    var stopResult = timer.stop();  if (stopResult is error) {  io:println(\"Stopping the task is failed.\");  return;  }    Cancels the timer. This will stop the timer and all the services  attached to it.   io:println(\"End.\"); }    service service1 = service {    The service, which will be attached to the timer.   resource function onTrigger(Person person) {  if (person.age < person.maxAge) {  person.age = person.age + 1;  io:println(\"Hi \" + person.name + \" you are \" + person.age.toString() + \" years old now.\");  }  } };    The onTrigger resource, which will trigger when the timer runs off.  The usage of the Person object being passed inside the function, which we  attached with the timer.   service service2 = service {  resource function onTrigger(Person person) {  if (person.age == 5) {  io:println(person.name + \" started schooling\");  }  } };    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run task_scheduler_timer.bal Hi Sam you are 1 years old now. Hi Sam you are 2 years old now. Hi Sam you are 3 years old now. Hi Sam you are 4 years old now. Hi Sam you are 5 years old now. Hi Sam you are 6 years old now. Sam started schooling Hi Sam you are 7 years old now. Hi Sam you are 8 years old now. Hi Sam you are 9 years old now. Hi Sam you are 10 years old now. End.    A scheduler can have any number of services attached to it. All the attached services  will run when the scheduler triggers them.  A Person record is attached to the Scheduler when attaching the service.  It is then passed into the resource functions of the service.  When the age of the person reaches the maxAge, the while loop is returned.  Hence the task is stopped.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/task-service-timer.html","name":"Task Service Timer","summary":"Task Timer Services are used to execute tasks periodically. A timer should\n have an intervalInMillis specified and an initialDelayInMillis if\n needed. The delay specifies the initial delay before the task is executed\n for the first time. Thereafter, the timer triggers at the provided interval.\n The onTrigger() resource is called when ...","content":"/  /  /  / Task Service Timer  import ballerina/log; import ballerina/task;  // The Task Timer configuration record to configure the Task Listener. task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 3000,  // Number of recurrences will limit the number of times the timer runs.  noOfRecurrences: 10 };  // Initialize the listener using the above defined configurations. listener task:Listener timer = new (timerConfiguration);  int count = 0;  // Creating a service on the task Listener. service timerService on timer {  // This resource triggers when the timer goes off.  resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    Task Service Timer  Task Timer Services are used to execute tasks periodically. A timer should  have an intervalInMillis specified and an initialDelayInMillis if  needed. The delay specifies the initial delay before the task is executed  for the first time. Thereafter, the timer triggers at the provided interval.  The onTrigger() resource is called when the timer triggers. An optional  noOfRecurrences field can be used to provide the maximum number of times  the Timer should run before shutting down.    import ballerina/log; import ballerina/task;    task:TimerConfiguration timerConfiguration = {  intervalInMillis: 1000,  initialDelayInMillis: 3000,    The Task Timer configuration record to configure the Task Listener.   noOfRecurrences: 10 };    Number of recurrences will limit the number of times the timer runs.   listener task:Listener timer = new (timerConfiguration);    Initialize the listener using the above defined configurations.   int count = 0;    service timerService on timer {    Creating a service on the task Listener.   resource function onTrigger() {  log:printInfo(\"Cleaning up...\");  log:printInfo(count.toString());  count = count + 1;  } }    This resource triggers when the timer goes off.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run task_service_timer.bal 2019-09-06 13:37:17,298 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:17,299 INFO [ballerina/log] - 0 2019-09-06 13:37:18,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:18,289 INFO [ballerina/log] - 1 2019-09-06 13:37:19,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:19,289 INFO [ballerina/log] - 2 2019-09-06 13:37:20,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:20,289 INFO [ballerina/log] - 3 2019-09-06 13:37:21,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:21,288 INFO [ballerina/log] - 4 2019-09-06 13:37:22,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:22,287 INFO [ballerina/log] - 5 2019-09-06 13:37:23,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:23,288 INFO [ballerina/log] - 6 2019-09-06 13:37:24,287 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:24,287 INFO [ballerina/log] - 7 2019-09-06 13:37:25,288 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:25,289 INFO [ballerina/log] - 8 2019-09-06 13:37:26,285 INFO [ballerina/log] - Cleaning up... 2019-09-06 13:37:26,286 INFO [ballerina/log] - 9    The onTrigger() function is triggered every second but with an initial delay of 3 seconds.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-before-and-after-each.html","name":"Before and After Each","summary":"The function specified with the BeforeEach annotation is executed before every test and\n the function specified with the AfterEach annotation is executed after every test within the test suite.\n This can be used for repeatedly initializing and tearing down test level aspects before every test function.\n For more information, see ...","content":"/  /  /  / Before and After Each  import ballerina/io; import ballerina/test;  // The before-each function, which is executed before each test function. @test:BeforeEach function beforeEachFunc() {  io:println(\"I'm the before each function!\"); }  // The after-each function, which is executed after each test function. @test:AfterEach function afterEachFunc() {  io:println(\"I'm the after each function!\"); }  // A test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // A test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // A test function. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    Before and After Each  The function specified with the BeforeEach annotation is executed before every test and  the function specified with the AfterEach annotation is executed after every test within the test suite.  This can be used for repeatedly initializing and tearing down test level aspects before every test function.  For more information, see and the .    import ballerina/io; import ballerina/test;    @test:BeforeEach function beforeEachFunc() {  io:println(\"I'm the before each function!\"); }    The before-each function, which is executed before each test function.   @test:AfterEach function afterEachFunc() {  io:println(\"I'm the after each function!\"); }    The after-each function, which is executed after each test function.   @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    A test function.   ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before each function! I'm in test function 1! I'm the after each function! I'm the before each function! I'm in test function 2! I'm the after each function! I'm the before each function! I'm in test function 3! I'm the after each function!    [pass] testFunction3  [pass] testFunction2  [pass] testFunction1    3 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-before-and-after-test.html","name":"Before and After Test","summary":"The before attribute allows you to execute a function before a test function.\n This capability can be used for setting up prerequisites that need to be executed before executing a test.\n Similarly, the after attribute can be used to execute a function after a test function.\n For more information, see ...","content":"/  /  /  / Before and After Test  import ballerina/io; import ballerina/test;  // This before-function is executed before the test function. function beforeFunc() {  io:println(\"I'm the before function!\"); }  // The Test function. // Use the `before` and `after` attributes to define the function names // of the functions that need to be executed before and after the test function. @test:Config {  before: \"beforeFunc\",  after: \"afterFunc\" } function testFunction() {  io:println(\"I'm in test function!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This after-function is executed after the test function. function afterFunc() {  io:println(\"I'm the after function!\"); }    Before and After Test  The before attribute allows you to execute a function before a test function.  This capability can be used for setting up prerequisites that need to be executed before executing a test.  Similarly, the after attribute can be used to execute a function after a test function.  For more information, see and the .    import ballerina/io; import ballerina/test;    function beforeFunc() {  io:println(\"I'm the before function!\"); }    This before-function is executed before the test function.   @test:Config {  before: \"beforeFunc\",  after: \"afterFunc\" } function testFunction() {  io:println(\"I'm in test function!\");  test:assertTrue(true, msg = \"Failed!\"); }    The Test function.  Use the before and after attributes to define the function names  of the functions that need to be executed before and after the test function.   function afterFunc() {  io:println(\"I'm the after function!\"); }    This after-function is executed after the test function.   # For the moment `ballerina test` works only in projects. ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before function! I'm in test function! I'm the after function!    [pass] testFunction    1 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tcp-socket-listener-client.html","name":"Basic TCP Socket","summary":"The TCP Listener is used to expose TCP service over the TCP protocol.\n The TCP Client is used to connect to a remote TCP server.\n This sample demonstrates how the TCP socket listener service interacts with the TCP client.This is the client implementation for the TCP socket with the attached ...","content":"/  /  /  / Basic TCP Socket  // This is the client implementation for the TCP socket with the attached callback service. Callback service is optional. import ballerina/io; import ballerina/socket;  public function main() {  // Create a new socket client by providing the host, port, and callback service.  socket:Client socketClient = new ({  host: \"localhost\",  port: 61598  });  string content = \"Hello Ballerina\";  byte[] payloadByte = content.toBytes();  // Send desired content to the server using the write function.  int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = socketClient->write(payloadByte);  if (writeResult is error) {  io:println(\"Unable to written the content \", writeResult);  } else {  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  }  }  // Reading response from the server.  var result = socketClient->read();  if (result is [byte[], int]) {  var [reply, length] = result;  if (length > 0) {  var byteChannel =  io:createReadableChannel(reply);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(25);  if (str is string) {  io:println(<@untainted>str);  } else {  io:println(\"Error while reading characters \", str);  }  } else {  io:println(\"Client close: \", socketClient.remotePort);  }  }  } else {  io:println(result);  }   // Close the connection between the server and the client.  var closeResult = socketClient->close();  if (closeResult is error) {  io:println(closeResult);  } else {  io:println(\"Client connection closed successfully.\");  } }  // This is the server implementation for the TCP socket. import ballerina/io; import ballerina/log; import ballerina/socket;  // Bind the service to the port. // The socket listener should have these four predefined resources. service echoServer on new socket:Listener(61598) {  // This resource is invoked when the new client joins.  resource function onConnect(socket:Caller caller) {  log:printInfo(\"Client connected: \" + caller.id.toString());  }   // This resource is invoked once the content is received from the client.  resource function onReadReady(socket:Caller caller) {  var result = caller->read();  if (result is [byte[], int]) {  var [content, length] = result;  if (length > 0) {  // Create a new `ReadableByteChannel` using the newly received content.  var byteChannel =  io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(20);  if (str is string) {  string reply = <@untainted>str + \" back\";  byte[] payloadByte = reply.toBytes();  // Send the reply to the `caller`.  int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = caller->write(payloadByte);  if (writeResult is int) {  log:printInfo(\"Number of bytes written: \"  + writeResult.toString());  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  } else {  log:printError(\"Unable to write the content\",  writeResult);  }  }  } else {  log:printError(\"Error while writing content to the caller\",  str);  }  }  } else {  log:printInfo(\"Client left: \" + caller.id.toString());  }  } else {  io:println(result);  }  }   // This resource is invoked for the error situation  // if it happens during the `onConnect` and `onReadReady`.  resource function onError(socket:Caller caller, error er) {  log:printError(\"An error occurred\", er);  } }    Basic TCP Socket  The TCP Listener is used to expose TCP service over the TCP protocol.  The TCP Client is used to connect to a remote TCP server.  This sample demonstrates how the TCP socket listener service interacts with the TCP client.    import ballerina/io; import ballerina/socket;    This is the client implementation for the TCP socket with the attached callback service. Callback service is optional.   public function main() {    socket:Client socketClient = new ({  host: \"localhost\",  port: 61598  });  string content = \"Hello Ballerina\";  byte[] payloadByte = content.toBytes();    Create a new socket client by providing the host, port, and callback service.   int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = socketClient->write(payloadByte);  if (writeResult is error) {  io:println(\"Unable to written the content \", writeResult);  } else {  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  }  }    Send desired content to the server using the write function.   var result = socketClient->read();  if (result is [byte[], int]) {  var [reply, length] = result;  if (length > 0) {  var byteChannel =  io:createReadableChannel(reply);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(25);  if (str is string) {  io:println(<@untainted>str);  } else {  io:println(\"Error while reading characters \", str);  }  } else {  io:println(\"Client close: \", socketClient.remotePort);  }  }  } else {  io:println(result);  }    Reading response from the server.   var closeResult = socketClient->close();  if (closeResult is error) {  io:println(closeResult);  } else {  io:println(\"Client connection closed successfully.\");  } }    Close the connection between the server and the client.   # To run the client, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run tcp_socket_client.bal    # Print the response that is obtained from the server. Hello Ballerina back Client connection closed successfully.    import ballerina/io; import ballerina/log; import ballerina/socket;    This is the server implementation for the TCP socket.   service echoServer on new socket:Listener(61598) {    Bind the service to the port.  The socket listener should have these four predefined resources.   resource function onConnect(socket:Caller caller) {  log:printInfo(\"Client connected: \" + caller.id.toString());  }    This resource is invoked when the new client joins.   resource function onReadReady(socket:Caller caller) {  var result = caller->read();  if (result is [byte[], int]) {  var [content, length] = result;  if (length > 0) {    This resource is invoked once the content is received from the client.   var byteChannel =  io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(20);  if (str is string) {  string reply = <@untainted>str + \" back\";  byte[] payloadByte = reply.toBytes();    Create a new ReadableByteChannel using the newly received content.   int i = 0;  int arrayLength = payloadByte.length();  while (i < arrayLength) {  var writeResult = caller->write(payloadByte);  if (writeResult is int) {  log:printInfo(\"Number of bytes written: \"  + writeResult.toString());  i = i + writeResult;  payloadByte = payloadByte.slice(writeResult, arrayLength);  } else {  log:printError(\"Unable to write the content\",  writeResult);  }  }  } else {  log:printError(\"Error while writing content to the caller\",  str);  }  }  } else {  log:printInfo(\"Client left: \" + caller.id.toString());  }  } else {  io:println(result);  }  }    Send the reply to the caller.   resource function onError(socket:Caller caller, error er) {  log:printError(\"An error occurred\", er);  } }    This resource is invoked for the error situation  if it happens during the onConnect and onReadReady.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command below. ballerina run tcp_socket_listener.bal    # The socket listener starts listening to the port 61598 for incoming client requests. [ballerina/socket] started socket listener 61598    2019-02-18 11:24:32,429 INFO [] - Client connected: 504372137 2019-02-18 11:24:32,467 INFO [] - Number of bytes written: 20 2019-02-18 11:24:32,487 INFO [] - Client left: 504372137    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-before-and-after-suite.html","name":"Before and After Suite","summary":"The BeforeSuite feature allows you to execute a function before executing a test suite.\n A module is considered as a suite in testerina. This capability can be used for\n setting up prerequisites before executing a test suite.\n Similarly, the AfterSuite annotation can be used to execute a function after a ...","content":"/  /  /  / Before and After Suite  import ballerina/io; import ballerina/test;  // The function annotated with `BeforeSuite` is executed before all the test functions in the module. @test:BeforeSuite function beforeSuit() {  io:println(\"I'm the before suite function!\"); }  // A Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // A Test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }  // The function annotated with `AfterSuite` will be executed after all the test functions in the module have executed. @test:AfterSuite function afterSuite() {  io:println(\"I'm the after suite function!\"); }    Before and After Suite  The BeforeSuite feature allows you to execute a function before executing a test suite.  A module is considered as a suite in testerina. This capability can be used for  setting up prerequisites before executing a test suite.  Similarly, the AfterSuite annotation can be used to execute a function after a test suite.  For more information, see and the .    import ballerina/io; import ballerina/test;    @test:BeforeSuite function beforeSuit() {  io:println(\"I'm the before suite function!\"); }    The function annotated with BeforeSuite is executed before all the test functions in the module.   @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }    A Test function.   @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }    A Test function.   @test:AfterSuite function afterSuite() {  io:println(\"I'm the after suite function!\"); }    The function annotated with AfterSuite will be executed after all the test functions in the module have executed.   # For the moment `ballerina test` works only in projects. ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm the before suite function! I'm in test function 2! I'm in test function 1! I'm the after suite function!    [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-assertions.html","name":"Assertions","summary":"Testerina has in-built assertions that enable users to\n assert an outcome against an expected outcome.\n This example illustrates how to use different assertions.\n For more information, see \n and the .The assertEquals() function allows you to compare primitive types (e.g., int) against composite objects.\n Compares values of the type int.Compares ...","content":"/  /  /  / Assertions  import ballerina/test;  // The `assertEquals()` function allows you to compare primitive types (e.g., int) against composite objects. // Compares values of the type `int`. @test:Config {} function testAssertIntEquals() {  int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"int values not equal\"); }  // Compares values of the type `float`. @test:Config {} function testAssertFloatEquals() {  float a = 10.000;  float b = 20.050;  float answer = floatAdd(a, b);  test:assertEquals(answer, 30.050, msg = \"float values not equal\"); }  // Compares values of the type `string`. @test:Config {} function testAssertStringEquals() {  string a = \"John\";  string b = \"Doe\";  string concatenated = stringConcat(a, b);  test:assertEquals(concatenated, \"JohnDoe\", msg = \"string values not equal\"); }  // Compares values of the type `json`. @test:Config {} function testAssertJsonEquals() {  json a = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  json b = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  test:assertEquals(a, b, msg = \"JSON values not equal\"); }  // Compares values of the type `xml`. @test:Config {} function testAssertXmlEquals() {  xml x1 = xml `<book>The Lost World</book>`;  xml x2 = xml `Hello, world!`;  xml x3 = xml `<!--I am a comment-->`;  xml x4 = x1 + x2 + x3;  xml x5 = xml `<book>The Lost World</book>` + xml `Hello, world!` + xml `<!--I am a comment-->`;  test:assertEquals(x4, x5, msg = \"XML values not equal\"); }  // Compares values of the type `boolean`. @test:Config {} function testAssertBooleanEquals() {  boolean x = true;  boolean y = true;  test:assertEquals(x, y, msg = \"boolean values not equal\"); }  // Compares values of the type `string[]`. @test:Config {} function testAssertStringArrayEquals() {  string[] x = [\"A\", \"B\", \"C\"];  string[] y = [\"A\", \"B\", \"C\"];  test:assertEquals(x, y, msg = \"string array values not equal\"); }  // Compares values of the type `int[]`. @test:Config {} function testAssertIntArrayEquals() {  int[] x = [1, 2, 3];  int[] y = [1, 2, 3];  test:assertEquals(x, y, msg = \"int array values not equal\"); }  // Compares values of the type `float[]`. @test:Config {} function testAssertFloatArrayEquals() {  float[] x = [1.1, 2.2, 3.3];  float[] y = [1.1, 2.2, 3.3];  test:assertEquals(x, y, msg = \"float array values not equal\"); }  // Compares distinct values of the type `string`. @test:Config {} function testAssertNotEqualsString() {  string s1 = \"abc\";  string s2 = \"def\";  test:assertNotEquals(s1, s2, msg = \"string values are equal\"); }  // Compares distinct values of the type `json`. @test:Config {} function testAssertNotEqualsJson() {  json a = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  json b = {name:\"John Doe New\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  test:assertNotEquals(a, b, msg = \"JSON values are equal\"); }  // Compares distinct values of the type `xml`. @test:Config {} function testAssertNotEqualsXml() {  xml x1 = xml `<book>The Lost World</book>`;  xml x2 = xml `Hello, world!`;  xml x3 = x1 + x2;  xml x4 = xml `<book>The Lost World</book>` + xml `Hello, world!` + xml `<!--I am a comment-->`;  test:assertNotEquals(x3, x4, msg = \"XML values are equal\"); }  // Asserts `true`. @test:Config {} function testAssertTrue() {  boolean value = true;  test:assertTrue(value, msg = \"AssertTrue failed\"); }  // Asserts `false`. @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }  // A test-example, which is failing intentionally. @test:Config {} function testAssertFail() {  if (true) {  return;  }  test:assertFail(msg = \"AssertFailed\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }  function floatAdd(float a, float b) returns (float) {  return (a + b); }  function stringConcat(string a, string b) returns (string) {  return (a + b); }    Assertions  Testerina has in-built assertions that enable users to  assert an outcome against an expected outcome.  This example illustrates how to use different assertions.  For more information, see and the .    import ballerina/test;    @test:Config {} function testAssertIntEquals() {  int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"int values not equal\"); }    The assertEquals() function allows you to compare primitive types (e.g., int) against composite objects.  Compares values of the type int.   @test:Config {} function testAssertFloatEquals() {  float a = 10.000;  float b = 20.050;  float answer = floatAdd(a, b);  test:assertEquals(answer, 30.050, msg = \"float values not equal\"); }    Compares values of the type float.   @test:Config {} function testAssertStringEquals() {  string a = \"John\";  string b = \"Doe\";  string concatenated = stringConcat(a, b);  test:assertEquals(concatenated, \"JohnDoe\", msg = \"string values not equal\"); }    Compares values of the type string.   @test:Config {} function testAssertJsonEquals() {  json a = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  json b = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  test:assertEquals(a, b, msg = \"JSON values not equal\"); }    Compares values of the type json.   @test:Config {} function testAssertXmlEquals() {  xml x1 = xml `<book>The Lost World</book>`;  xml x2 = xml `Hello, world!`;  xml x3 = xml `<!--I am a comment-->`;  xml x4 = x1 + x2 + x3;  xml x5 = xml `<book>The Lost World</book>` + xml `Hello, world!` + xml `<!--I am a comment-->`;  test:assertEquals(x4, x5, msg = \"XML values not equal\"); }    Compares values of the type xml.   @test:Config {} function testAssertBooleanEquals() {  boolean x = true;  boolean y = true;  test:assertEquals(x, y, msg = \"boolean values not equal\"); }    Compares values of the type boolean.   @test:Config {} function testAssertStringArrayEquals() {  string[] x = [\"A\", \"B\", \"C\"];  string[] y = [\"A\", \"B\", \"C\"];  test:assertEquals(x, y, msg = \"string array values not equal\"); }    Compares values of the type string[].   @test:Config {} function testAssertIntArrayEquals() {  int[] x = [1, 2, 3];  int[] y = [1, 2, 3];  test:assertEquals(x, y, msg = \"int array values not equal\"); }    Compares values of the type int[].   @test:Config {} function testAssertFloatArrayEquals() {  float[] x = [1.1, 2.2, 3.3];  float[] y = [1.1, 2.2, 3.3];  test:assertEquals(x, y, msg = \"float array values not equal\"); }    Compares values of the type float[].   @test:Config {} function testAssertNotEqualsString() {  string s1 = \"abc\";  string s2 = \"def\";  test:assertNotEquals(s1, s2, msg = \"string values are equal\"); }    Compares distinct values of the type string.   @test:Config {} function testAssertNotEqualsJson() {  json a = {name:\"John Doe\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  json b = {name:\"John Doe New\", age:25, address:{city:\"Colombo\", country:\"Sri Lanka\"}};  test:assertNotEquals(a, b, msg = \"JSON values are equal\"); }    Compares distinct values of the type json.   @test:Config {} function testAssertNotEqualsXml() {  xml x1 = xml `<book>The Lost World</book>`;  xml x2 = xml `Hello, world!`;  xml x3 = x1 + x2;  xml x4 = xml `<book>The Lost World</book>` + xml `Hello, world!` + xml `<!--I am a comment-->`;  test:assertNotEquals(x3, x4, msg = \"XML values are equal\"); }    Compares distinct values of the type xml.   @test:Config {} function testAssertTrue() {  boolean value = true;  test:assertTrue(value, msg = \"AssertTrue failed\"); }    Asserts true.   @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }    Asserts false.   @test:Config {} function testAssertFail() {  if (true) {  return;  }  test:assertFail(msg = \"AssertFailed\"); }    A test-example, which is failing intentionally.   function intAdd(int a, int b) returns (int) {  return (a + b); }    function floatAdd(float a, float b) returns (float) {  return (a + b); }    function stringConcat(string a, string b) returns (string) {  return (a + b); }    # For the moment `ballerina test` works only in projects. ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0    [pass] testAssertFail \t[pass] testAssertFalse \t[pass] testAssertTrue \t[pass] testAssertNotEqualsXml \t[pass] testAssertNotEqualsJson \t[pass] testAssertNotEqualsString \t[pass] testAssertFloatArrayEquals \t[pass] testAssertIntArrayEquals \t[pass] testAssertStringArrayEquals \t[pass] testAssertBooleanEquals \t[pass] testAssertXmlEquals \t[pass] testAssertJsonEquals \t[pass] testAssertStringEquals \t[pass] testAssertFloatEquals \t[pass] testAssertIntEquals    15 passing \t0 failing \t0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-group-tests.html","name":"Group Tests","summary":"You can tag your test cases with a single group name or multiple group names (one or more).\n This allows you to control the execution of selected tests.\n In order to execute tests belonging to a selected test group, you can name the\n test groups that are to be executed ...","content":"/  /  /  / Group Tests  import ballerina/io; import ballerina/test;  // The test function, which belongs to the group `g1`. @test:Config {  groups: [\"g1\"] } function testFunction1() {  io:println(\"I'm in test belonging to group g1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // The test function, which belongs to the groups `g1` and `g2` @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction2() {  io:println(\"I'm in test belonging to groups g1 and g2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This test doesn't belong to any group. @test:Config {} function testFunction3() {  io:println(\"I'm the ungrouped test\");  test:assertTrue(true, msg = \"Failed!\"); }    Group Tests  You can tag your test cases with a single group name or multiple group names (one or more).  This allows you to control the execution of selected tests.  In order to execute tests belonging to a selected test group, you can name the  test groups that are to be executed when you run tests.  Likewise, you can exclude executing selected tests as well.  For more information, see and the .    import ballerina/io; import ballerina/test;    @test:Config {  groups: [\"g1\"] } function testFunction1() {  io:println(\"I'm in test belonging to group g1!\");  test:assertTrue(true, msg = \"Failed!\"); }    The test function, which belongs to the group g1.   @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction2() {  io:println(\"I'm in test belonging to groups g1 and g2!\");  test:assertTrue(true, msg = \"Failed!\"); }    The test function, which belongs to the groups g1 and g2   @test:Config {} function testFunction3() {  io:println(\"I'm the ungrouped test\");  test:assertTrue(true, msg = \"Failed!\"); }    This test doesn’t belong to any group.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina test` command below. # You need to have the ballerina-tools distribution # installed to execute this command. ballerina test testerina_group_tests.bal --groups g1 --groups g2 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm in test belonging to groups g1 and g2! I'm in test belonging to group g1!  [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped    $ ballerina test testerina_group_tests.bal --groups g1 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm in test belonging to groups g1 and g2! I'm in test belonging to group g1!  [pass] testFunction2  [pass] testFunction1    2 passing  0 failing  0 skipped    $ ballerina test testerina_group_tests.bal --disable-groups g2 Compiling tests  testerina_group_tests.bal    Running tests  testerina_group_tests.bal I'm the ungrouped test I'm in test belonging to group g1!  [pass] testFunction3  [pass] testFunction1    2 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-guarantee-test-execution-order.html","name":"Guarantee Test Execution Order","summary":"The dependsOnattribute can be used to define a list of function names that the test\n function depends on. These functions will be executed before the test execution.\n This allows you to ensure that the tests are being executed in the expected order.\n For more information, see \n and the .This ...","content":"/  /  /  / Guarantee Test Execution Order  import ballerina/io; import ballerina/test;  // This test function depends on the `testFunction3`. @test:Config {  // You can provide a list of the dependent functions here.  dependsOn: [\"testFunction3\"] } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This test function depends on the `testFunction1`. @test:Config {  dependsOn: [\"testFunction1\"] } function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This is a random test function. This will randomly execute without depending on other functions. // However,the other function does depend on this. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    Guarantee Test Execution Order  The dependsOnattribute can be used to define a list of function names that the test  function depends on. These functions will be executed before the test execution.  This allows you to ensure that the tests are being executed in the expected order.  For more information, see and the .    import ballerina/io; import ballerina/test;    @test:Config {    This test function depends on the testFunction3.   dependsOn: [\"testFunction3\"] } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }    You can provide a list of the dependent functions here.   @test:Config {  dependsOn: [\"testFunction1\"] } function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }    This test function depends on the testFunction1.   @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }    This is a random test function. This will randomly execute without depending on other functions.  However,the other function does depend on this.   # For the moment `ballerina test` works only in projects. ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 I'm in test function 3! I'm in test function 1! I'm in test function 2!  3 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-data-driven-tests.html","name":"Data Driven Tests","summary":"Testerina provides in-built support for data-driven tests.\n You can provide a function pointer as a data-provider. The function returns a\n value-set of data and you can iterate the same test over the returned dataset.\n For more information, see \n and the .The dataProvider attribute allows you to add a data ...","content":"/  /  /  / Data Driven Tests  import ballerina/io; import ballerina/test;  // The `dataProvider` attribute allows you to add a data provider function to the test-case. @test:Config {  // The `stringDataProvider` function provides the data set to this function.  dataProvider: \"stringDataProvider\" } // Data is passed to the function as function parameters. function testAddingValues(string fValue, string sValue, string result) {   int|error val1 = int.constructFrom(fValue);  int value1 = val1 is int ? val1 : 0;  int|error val2 = int.constructFrom(sValue);  int value2 = val2 is int ? val2 : 0;  int|error res1 = int.constructFrom(result);  int result1 = res1 is int ? res1 : 0;   io:println(\"Input : [\" + fValue + \",\" + sValue + \",\" + result + \"]\");  test:assertEquals(value1 + value2, result1, msg = \"Incorrect Sum\"); }  // The data provider function, which returns a `string` value-set. function stringDataProvider() returns (string[][]) {  return [[\"1\", \"2\", \"3\"], [\"10\", \"20\", \"30\"], [\"5\", \"6\", \"11\"]]; }  @test:Config {  // The `jsonDataProvider` function provides the data set to this function.  dataProvider: \"jsonDataProvider\" } function testJsonObjects(json fValue, json sValue, json result) {  json a = {\"a\": \"a\"};  json b = {\"b\": \"b\"};  json c = {\"c\": \"c\"};  test:assertEquals(fValue, a, msg = \"json data provider failed\");  test:assertEquals(sValue, b, msg = \"json data provider failed\");  test:assertEquals(result, c, msg = \"json data provider failed\"); }  // The data provider function, which returns a JSON value-set. function jsonDataProvider() returns (json[][]) {  return [[{\"a\": \"a\"}, {\"b\": \"b\"}, {\"c\": \"c\"}]]; }    Data Driven Tests  Testerina provides in-built support for data-driven tests.  You can provide a function pointer as a data-provider. The function returns a  value-set of data and you can iterate the same test over the returned dataset.  For more information, see and the .    import ballerina/io; import ballerina/test;    @test:Config {    The dataProvider attribute allows you to add a data provider function to the test-case.   dataProvider: \"stringDataProvider\" }    The stringDataProvider function provides the data set to this function.   function testAddingValues(string fValue, string sValue, string result) {    Data is passed to the function as function parameters.   int|error val1 = int.constructFrom(fValue);  int value1 = val1 is int ? val1 : 0;  int|error val2 = int.constructFrom(sValue);  int value2 = val2 is int ? val2 : 0;  int|error res1 = int.constructFrom(result);  int result1 = res1 is int ? res1 : 0;    io:println(\"Input : [\" + fValue + \",\" + sValue + \",\" + result + \"]\");  test:assertEquals(value1 + value2, result1, msg = \"Incorrect Sum\"); }    function stringDataProvider() returns (string[][]) {  return [[\"1\", \"2\", \"3\"], [\"10\", \"20\", \"30\"], [\"5\", \"6\", \"11\"]]; }    The data provider function, which returns a string value-set.   @test:Config {    dataProvider: \"jsonDataProvider\" } function testJsonObjects(json fValue, json sValue, json result) {  json a = {\"a\": \"a\"};  json b = {\"b\": \"b\"};  json c = {\"c\": \"c\"};  test:assertEquals(fValue, a, msg = \"json data provider failed\");  test:assertEquals(sValue, b, msg = \"json data provider failed\");  test:assertEquals(result, c, msg = \"json data provider failed\"); }    The jsonDataProvider function provides the data set to this function.   function jsonDataProvider() returns (json[][]) {  return [[{\"a\": \"a\"}, {\"b\": \"b\"}, {\"c\": \"c\"}]]; }    The data provider function, which returns a JSON value-set.   # For the moment `ballerina test` works only in projects. ballerina test test_module Compiling source  ballerinatest/test_module:0.1.0    Creating balos  target/balo/test_module-2020r1-any-0.1.0.balo    Running tests  ballerinatest/test_module:0.1.0 Input : [1,2,3] Input : [10,20,30] Input : [5,6,11]    [pass] testJsonObjects  [pass] testAddingValues  [pass] testAddingValues  [pass] testAddingValues    4 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-mocking-functions.html","name":"Function Mocks","summary":"Mock functions allow you to hide the real functions and engage your own functions when running the tests.\n This allows you to isolate your test functions from the rest. Both mocking an imported function and a\n function declared in the module under a test can be mocked with dedicated annotations.\n ...","content":"/  /  /  / Function Mocks  import ballerina/io; import ballerina/math;  // This function calls the `intAdd` function and returns the result. public function addValues(int a, int b) returns int {  return intAdd(a, b); }  // This function adds two integers and returns the result. public function intAdd(int a, int b) returns int {  return (a + b); }  // This function prints the value of PI using the `io:println` function. public function printMathConsts() {  io:println(\"Value of PI : \", math:PI); } // This demonstrates different ways to mock functions. import ballerina/test;  (any|error)[] outputs = [];  @test:Mock {  // This specifies a mock function that should replace the  // imported `io:println` function.  moduleName: \"ballerina/io\",  functionName: \"println\" } function mockIoPrintLn((any|error)... text) {  outputs.push(text); }  @test:Config {} function testMathConsts() {  // This function call to the `io:println` will be replaced with the `mockIoPrintLn` function.  printMathConsts();  test:assertEquals(outputs[0].toString(), \"Value of PI : 3.141592653589793\"); }  // This creates an object for stubbing calls to the intAdd` function // which is written in the same module. @test:MockFn { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();  @test:Config {} function testAssertIntEquals() {  // This stubs the calls to the `intAdd` function to return the specified value.  test:when(intAddMockFn).thenReturn(20);   // This stubs the calls to the `intAdd` function to return the specified value  // when the specified arguments are provided.  test:when(intAddMockFn).withArguments(0, 0).thenReturn(-1);   test:assertEquals(intAdd(10, 6), 20, msg = \"function mocking failed\");  test:assertEquals(intAdd(0, 0), -1,  msg = \"function mocking with arguments failed\");   // This stubs the calls to the `intAdd` function to invoke the specified function.  test:when(intAddMockFn).call(\"mockIntAdd\");   test:assertEquals(addValues(11, 6), 5, msg = \"function mocking failed\"); }  // This is a mock function that can be called // in place of the `intAdd` function. public function mockIntAdd(int a, int b) returns int {  return (a - b); }    Function Mocks  Mock functions allow you to hide the real functions and engage your own functions when running the tests.  This allows you to isolate your test functions from the rest. Both mocking an imported function and a  function declared in the module under a test can be mocked with dedicated annotations.  Mocking an imported function will apply the mocked function to every instance of the original function call.  It is not limited to the test file in which it is being mocked. Mocking a function from the module under the test  can be scoped to have different behaviors for different test cases.  For more information, see and the .    import ballerina/io; import ballerina/math;    public function addValues(int a, int b) returns int {  return intAdd(a, b); }    This function calls the intAdd function and returns the result.   public function intAdd(int a, int b) returns int {  return (a + b); }    This function adds two integers and returns the result.   public function printMathConsts() {  io:println(\"Value of PI : \", math:PI); }    This function prints the value of PI using the io:println function.   import ballerina/test;    This demonstrates different ways to mock functions.   (any|error)[] outputs = [];    @test:Mock {    moduleName: \"ballerina/io\",  functionName: \"println\" } function mockIoPrintLn((any|error)... text) {  outputs.push(text); }    This specifies a mock function that should replace the  imported io:println function.   @test:Config {} function testMathConsts() {    printMathConsts();  test:assertEquals(outputs[0].toString(), \"Value of PI : 3.141592653589793\"); }    This function call to the io:println will be replaced with the mockIoPrintLn function.   @test:MockFn { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();    This creates an object for stubbing calls to the intAdd` function  which is written in the same module.   @test:Config {} function testAssertIntEquals() {    test:when(intAddMockFn).thenReturn(20);    This stubs the calls to the intAdd function to return the specified value.   test:when(intAddMockFn).withArguments(0, 0).thenReturn(-1);    This stubs the calls to the intAdd function to return the specified value  when the specified arguments are provided.   test:assertEquals(intAdd(10, 6), 20, msg = \"function mocking failed\");  test:assertEquals(intAdd(0, 0), -1,  msg = \"function mocking with arguments failed\");    test:when(intAddMockFn).call(\"mockIntAdd\");    This stubs the calls to the intAdd function to invoke the specified function.   test:assertEquals(addValues(11, 6), 5, msg = \"function mocking failed\"); }    public function mockIntAdd(int a, int b) returns int {  return (a - b); }    This is a mock function that can be called  in place of the intAdd function.   # To run this sample, create a Ballerina project and a module inside it. # Replace the content of the `main.bal` and ``main_test.bal` files with the above code, # and execute the `ballerina test` command below from the project root directory. # Function mocking is not supported for testing single BAL files. ballerina test bbe_mocking Compiling source  ballerinatest/bbe_mocking:0.1.0    Creating balos  target/balo/bbe_mocking-2020r1-any-0.1.0.balo    Running Tests  ballerinatest/bbe_mocking:0.1.0    [pass] testAssertIntEquals  [pass] testMathConsts    2 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/the-main-function.html","name":"The Main Function","summary":"A public function named main is considered as an entry point to a Ballerina program.\n The main function is data-binding and can have zero or more parameters whose types are subtypes of anydata,\n including any number of required/defaultable parameters and/or a single rest parameter.\n The main function could also return ...","content":"/  /  /  / The Main Function  import ballerina/io;  // The `main` function that accepts student information and prints out a formatted string. // The first parameter `name` is a required parameter, while the second parameter `age` is a defaultable // parameter with the default value `18`. The third parameter `year` is also a defaultable parameter. // The rest parameter `modules` represents the additional arguments. // The `main` function may return an `error` or `()`. public function main(string name,  int age = 18,  string year = \"Freshman\",  string... modules)  returns error? {   // Return an error if the name is invalid.  if (name.length() < 5) {  error e = error(\"InvalidName\", message = \"invalid length\");  return e;  }   string info = string `Name: ${name}, Age: ${age}, Year: ${year}`;   if (modules.length() > 0) {  info += \", Module(s): \" + modules.toString();  }  io:println(info); }    The Main Function  A public function named main is considered as an entry point to a Ballerina program.  The main function is data-binding and can have zero or more parameters whose types are subtypes of anydata,  including any number of required/defaultable parameters and/or a single rest parameter.  The main function could also return a value whose type is a subtype of error?.    import ballerina/io;    public function main(string name,  int age = 18,  string year = \"Freshman\",  string... modules)  returns error? {    The main function that accepts student information and prints out a formatted string.  The first parameter name is a required parameter, while the second parameter age is a defaultable  parameter with the default value 18. The third parameter year is also a defaultable parameter.  The rest parameter modules represents the additional arguments.  The main function may return an error or ().   if (name.length() < 5) {  error e = error(\"InvalidName\", message = \"invalid length\");  return e;  }    Return an error if the name is invalid.   string info = string `Name: ${name}, Age: ${age}, Year: ${year}`;    if (modules.length() > 0) {  info += \", Module(s): \" + modules.toString();  }  io:println(info); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command.    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name`. `18` would be set as the value for # `age` and `Freshman` would be set as the value for `year`. ballerina run the_main_function.bal Alice Name: Alice, Age: 18, Year: Freshman    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name` and `20` as the integer value for # `age`. Both arguments are specified as positional arguments. ballerina run the_main_function.bal Alice 20 Name: Alice, Age: 20, Year: Freshman    # Use the ballerina `run` command to invoke the `main` function specifying `Alice` # as the string argument for `name` and `Sophomore` as the string argument for # `year`. The value for `year` is specified as a named argument. ballerina run the_main_function.bal Alice -year=Sophomore Name: Alice, Age: 18, Year: Sophomore    # Use the ballerina `run` command to invoke the `main` function specifying values for # all parameters, including the rest parameter. All arguments are specified as # positional arguments. ballerina run the_main_function.bal Alice 20 Sophomore math physics Name: Alice, Age: 20, Year: Sophomore, Module(s): math physics    # Use the ballerina `run` command to invoke the `main` function specifying an invalid # string as the argument for `name`. The `error` returned would be printed. ballerina run the_main_function.bal Ali error: InvalidName message=invalid length    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/threads-and-strands.html","name":"Threads and Strands","summary":"A strand is a lightweight thread construct. There are two situations in which the Ballerina runtime creates a new strand:\n (1) To execute statements in a named worker declaration\n (2) To execute the function or method in the start action.  By default,\n these new strands will be part of ...","content":"/  /  /  / Threads and Strands  import ballerina/io;  // This function creates a new strand, which belongs to the same // thread as the current strand. public function case1() {  // Execution of the `start` action causes the creation of a new strand and  // it will be part of the thread executing the current strand.  // However, the Ballerina runtime will not execute the new strand until the current strand yields.  io:println(\"--- case 1 ---\");  future<int> f1 = start multiply(1, 2);   // Here, the `wait` action causes the current strand to yield.  // Once it yields, the Ballerina runtime executes the new strand.  io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }  // This function creates a new strand and it should be in a separate thread from the current strand. // The usage of the `@strand` annotation with the `thread` field value \"any\" enforces this behavior. public function case2() {  // This new strand does not belong to the thread executing the current strand.  // The Ballerina runtime assigns this new strand to a separate thread in the runtime thread pool.  io:println(\"--- case 2 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);   io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }  // Create two new strands and assign them to separate threads from the thread executing the current strand. public function case3() {  io:println(\"--- case 3 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = @strand {thread: \"any\"} start multiply(4, 5);   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }  // Create two new strands. Ballerina runtime assigns the first one to a separate thread and assigns // the second one to the same thread executing the current strand. public function case4() {  io:println(\"--- case 4 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = start multiply(4, 5);   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }  // Create two new strands. The Ballerina runtime assigns both strands to the same thread executing the current strand. public function case5() {  io:println(\"--- case 5 ---\");  future<int> f1 = start multiply(1, 2);  future<int> f2 = start multiply(4, 5);   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }  public function main() {  case1();  case2();  case3();  case4();  case5(); }  function multiply(int x, int y) returns int {  io:println(string `Multiplying ${x} * ${y}`);  return x * y; }    Threads and Strands  A strand is a lightweight thread construct. There are two situations in which the Ballerina runtime creates a new strand:  (1) To execute statements in a named worker declaration  (2) To execute the function or method in the start action. By default,  these new strands will be part of the same thread as the current strand.  Strands that belong to the same thread share the following characteristics. Only one strand can run simultaneously.  The currently-running strand should yield to switch its thread to execute another strand.  Therefore, strands belonging to a particular thread are cooperatively multitasked.  All the strands created in a particular execution of a Ballerina program will be executed  sequentially by a single thread. In some situations, it would be desirable to assign strands to different threads.  The @strand annotation helps you to achieve this.  You can annotate the named worker declarations and start actions with the @strand annotation to instruct  the Ballerina runtime to put new strands in a separate thread from the current strand.    import ballerina/io;    public function case1() {    This function creates a new strand, which belongs to the same  thread as the current strand.   io:println(\"--- case 1 ---\");  future<int> f1 = start multiply(1, 2);    Execution of the start action causes the creation of a new strand and  it will be part of the thread executing the current strand.  However, the Ballerina runtime will not execute the new strand until the current strand yields.   io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }    Here, the wait action causes the current strand to yield.  Once it yields, the Ballerina runtime executes the new strand.   public function case2() {    This function creates a new strand and it should be in a separate thread from the current strand.  The usage of the @strand annotation with the thread field value “any” enforces this behavior.   io:println(\"--- case 2 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);    This new strand does not belong to the thread executing the current strand.  The Ballerina runtime assigns this new strand to a separate thread in the runtime thread pool.   io:println(\"Before the wait action\");  int result = wait f1;  io:println(\"After the wait action\\n\"); }    public function case3() {  io:println(\"--- case 3 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = @strand {thread: \"any\"} start multiply(4, 5);    Create two new strands and assign them to separate threads from the thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function case4() {  io:println(\"--- case 4 ---\");  future<int> f1 = @strand {thread: \"any\"} start multiply(1, 2);  future<int> f2 = start multiply(4, 5);    Create two new strands. Ballerina runtime assigns the first one to a separate thread and assigns  the second one to the same thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function case5() {  io:println(\"--- case 5 ---\");  future<int> f1 = start multiply(1, 2);  future<int> f2 = start multiply(4, 5);    Create two new strands. The Ballerina runtime assigns both strands to the same thread executing the current strand.   io:println(\"Before the wait action\");  map<int> results = wait {f1, f2};  io:println(\"After the wait action\\n\"); }    public function main() {  case1();  case2();  case3();  case4();  case5(); }    function multiply(int x, int y) returns int {  io:println(string `Multiplying ${x} * ${y}`);  return x * y; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run threads-and-strands.bal --- case 1 --- Before the wait action Multiplying 1 * 2 After the wait action    --- case 2 --- Multiplying 1 * 2 Before the wait action After the wait action    --- case 3 --- Multiplying 1 * 2 Multiplying 4 * 5 Before the wait action After the wait action    --- case 4 --- Multiplying 1 * 2 Before the wait action Multiplying 4 * 5 After the wait action    --- case 5 --- Before the wait action Multiplying 4 * 5 Multiplying 1 * 2 After the wait action    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/testerina-mocking-objects.html","name":"Object Mocks","summary":"Object mocking enables controlling the values of member variables and the behavior of\n the member functions of an object. Mocking of objects can be done in two ways. \n 1. Creating a test double - providing an equivalent mock object in place of the real\n 2. Stubbing the member function ...","content":"/  /  /  / Object Mocks  // This demonstrates different ways to mock a client object. import ballerina/http; import ballerina/io; import ballerina/email;  // Clients objects are defined globally to be able to replace in test files. http:Client clientEndpoint = new(\"http://postman-echo.com\"); email:SmtpClient smtpClient = new (\"localhost\", \"admin\",\"admin\");  // This function performs two `GET` requests to the specified // endpoint and returns the response. function performGet() returns http:Response {  io:println(\"Executing the 1st GET request\");  http:Response|error result = clientEndpoint->get(\"/headers\");  http:Response response = <http:Response>result;  io:println(\"Status code: \" + response.statusCode.toString());   if(response.statusCode == 200) {  io:println(\"Executing the 2nd GET request\");  http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");  result = clientEndpoint->get(\"/get?test=123\", req);  response = <http:Response>result;  io:println(\"Status code: \" + response.statusCode.toString());  }  return response; }  // This function sends out emails to the specified email addresses // and returns an error if they are not found. function sendNotification(string[] emailIds) returns error? {  email:Email msg = {  'from: \"builder@abc.com\",  subject: \"Error Alert ...\",  to: emailIds,  body: \"\"  };  email:Error? response = smtpClient->send(msg);  if (response is error) {  io:println(\"error while sending the email: \" + response.message());  return response;  } } // This demonstrates different ways to mock a client object. import ballerina/test; import ballerina/http; import ballerina/email;  // This is the test double of the `http:Client` object with the // implementation of the required functions. public type MockHttpClient client object {  public remote function get(@untainted string path,  public http:RequestMessage message = ()) returns  http:Response|http:ClientError {   http:Response res = new;  res.statusCode = 500;  return res;  } };  @test:Config {} function testTestDouble() {  // This creates and assigns the defined test-double.  clientEndpoint = test:mock(http:Client, new MockHttpClient());  http:Response res = performGet();  test:assertEquals(res.statusCode, 500); }  @test:Config {} function testReturn() {  // This creates and assigns a default mock object, which needs to be stubbed subsequently.  clientEndpoint = test:mock(http:Client);  // This stubs the `get` function to return the specified HTTP response.  test:prepare(clientEndpoint).when(\"get\").thenReturn(new http:Response());  http:Response res = performGet();  test:assertEquals(res.statusCode, 200); }  @test:Config {} function testReturnWithArgs() {  http:Response mockResponse = new;  mockResponse.statusCode = 404;   clientEndpoint = test:mock(http:Client);  // This stubs the `get` function to return the specified HTTP response  // when the specified argument is passed.  test:prepare(clientEndpoint).when(\"get\").withArguments(\"/headers\")  .thenReturn(mockResponse);  // The object and record types should be denoted by the `test:ANY` constant  test:prepare(clientEndpoint).when(\"get\")  .withArguments(\"/get?test=123\", test:ANY).thenReturn(mockResponse);  http:Response res = performGet();  test:assertEquals(res.statusCode, 404); }  @test:Config {} function testReturnSequence() {  http:Response mockResponse = new;  mockResponse.statusCode = 404;   clientEndpoint = test:mock(http:Client);  // This stubs the `get` function to return the specified HTTP response  // for each call (i.e., the first call will return the status code `200`  // and the second call will return the status code `404`).  test:prepare(clientEndpoint).when(\"get\")  .thenReturnSequence(new http:Response(), mockResponse);  http:Response res = performGet();  test:assertEquals(res.statusCode, 404); }  @test:Config {} function testSendNotification() {  smtpClient = test:mock(email:SmtpClient);  // This stubs the `send` method of the `mockSmtpClient` to do nothing.  // This is used for functions with an optional or no return type  test:prepare(smtpClient).when(\"send\").doNothing();  string[] emailIds = [\"user1@test.com\", \"user2@test.com\"];  error? err = sendNotification(emailIds);  test:assertEquals(err, ());  }  @test:Config {} function testMemberVariable() {  string mockClientUrl = \"http://foo\";  clientEndpoint = test:mock(http:Client);  // This stubs the value of the `url` to return the specified string.  test:prepare(clientEndpoint).getMember(\"url\").thenReturn(mockClientUrl);  test:assertEquals(clientEndpoint.url, mockClientUrl);  }    Object Mocks  Object mocking enables controlling the values of member variables and the behavior of  the member functions of an object. Mocking of objects can be done in two ways. 1. Creating a test double - providing an equivalent mock object in place of the real  2. Stubbing the member function or member variable - stubbing the behavior of functions  and values of the variables  Creating a test double is suitable when a single mock function/object can be used  throughout all tests whereas stubbing is ideal when defining different behaviors for  different test cases is required.  For more information, see and the .    import ballerina/http; import ballerina/io; import ballerina/email;    This demonstrates different ways to mock a client object.   http:Client clientEndpoint = new(\"http://postman-echo.com\"); email:SmtpClient smtpClient = new (\"localhost\", \"admin\",\"admin\");    Clients objects are defined globally to be able to replace in test files.   function performGet() returns http:Response {  io:println(\"Executing the 1st GET request\");  http:Response|error result = clientEndpoint->get(\"/headers\");  http:Response response = <http:Response>result;  io:println(\"Status code: \" + response.statusCode.toString());    This function performs two GET requests to the specified  endpoint and returns the response.   if(response.statusCode == 200) {  io:println(\"Executing the 2nd GET request\");  http:Request req = new;  req.addHeader(\"Sample-Name\", \"http-client-connector\");  result = clientEndpoint->get(\"/get?test=123\", req);  response = <http:Response>result;  io:println(\"Status code: \" + response.statusCode.toString());  }  return response; }    function sendNotification(string[] emailIds) returns error? {  email:Email msg = {  'from: \"builder@abc.com\",  subject: \"Error Alert ...\",  to: emailIds,  body: \"\"  };  email:Error? response = smtpClient->send(msg);  if (response is error) {  io:println(\"error while sending the email: \" + response.message());  return response;  } }    This function sends out emails to the specified email addresses  and returns an error if they are not found.   import ballerina/test; import ballerina/http; import ballerina/email;    This demonstrates different ways to mock a client object.   public type MockHttpClient client object {  public remote function get(@untainted string path,  public http:RequestMessage message = ()) returns  http:Response|http:ClientError {    This is the test double of the http:Client object with the  implementation of the required functions.   http:Response res = new;  res.statusCode = 500;  return res;  } };    @test:Config {} function testTestDouble() {    clientEndpoint = test:mock(http:Client, new MockHttpClient());  http:Response res = performGet();  test:assertEquals(res.statusCode, 500); }    This creates and assigns the defined test-double.   @test:Config {} function testReturn() {    clientEndpoint = test:mock(http:Client);    This creates and assigns a default mock object, which needs to be stubbed subsequently.   test:prepare(clientEndpoint).when(\"get\").thenReturn(new http:Response());  http:Response res = performGet();  test:assertEquals(res.statusCode, 200); }    This stubs the get function to return the specified HTTP response.   @test:Config {} function testReturnWithArgs() {  http:Response mockResponse = new;  mockResponse.statusCode = 404;    clientEndpoint = test:mock(http:Client);    test:prepare(clientEndpoint).when(\"get\").withArguments(\"/headers\")  .thenReturn(mockResponse);    This stubs the get function to return the specified HTTP response  when the specified argument is passed.   test:prepare(clientEndpoint).when(\"get\")  .withArguments(\"/get?test=123\", test:ANY).thenReturn(mockResponse);  http:Response res = performGet();  test:assertEquals(res.statusCode, 404); }    The object and record types should be denoted by the test:ANY constant   @test:Config {} function testReturnSequence() {  http:Response mockResponse = new;  mockResponse.statusCode = 404;    clientEndpoint = test:mock(http:Client);    test:prepare(clientEndpoint).when(\"get\")  .thenReturnSequence(new http:Response(), mockResponse);  http:Response res = performGet();  test:assertEquals(res.statusCode, 404); }    This stubs the get function to return the specified HTTP response  for each call (i.e., the first call will return the status code 200  and the second call will return the status code 404).   @test:Config {} function testSendNotification() {  smtpClient = test:mock(email:SmtpClient);    test:prepare(smtpClient).when(\"send\").doNothing();  string[] emailIds = [\"user1@test.com\", \"user2@test.com\"];  error? err = sendNotification(emailIds);  test:assertEquals(err, ());    This stubs the send method of the mockSmtpClient to do nothing.  This is used for functions with an optional or no return type   }    @test:Config {} function testMemberVariable() {  string mockClientUrl = \"http://foo\";  clientEndpoint = test:mock(http:Client);    test:prepare(clientEndpoint).getMember(\"url\").thenReturn(mockClientUrl);  test:assertEquals(clientEndpoint.url, mockClientUrl);    This stubs the value of the url to return the specified string.   }    # To run this sample, create a Ballerina project and a module inside it. # Replace the content of the `main_test.bal` file residing inside the tests/ directory under the created module, and execute the `ballerina test` command below from the project root directory. ballerina test bbe_mocking Compiling source  ballerinatest/bbe_mocking:0.1.0    Creating balos  target/balo/bbe_mocking-2020r1-any-0.1.0.balo    Running Tests  ballerinatest/bbe_mocking:0.1.0 Executing the 1st GET request Status code: 500 Executing the 1st GET request Status code: 200 Executing the 2nd GET request Status code: 200 Executing the 1st GET request Status code: 200 Executing the 2nd GET request Status code: 401 Executing the 1st GET request Status code: 403 Executing the 1st GET request Status code: 404    [pass] testGetClientUrl  [pass] testSendNotification  [pass] testPerformGet    3 passing  0 failing  0 skipped    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/trap.html","name":"Trap","summary":"The trap unary opearator captures a panic making it possible to treat the panic as a normal error.Calling the divide() function with 0 as the divisor results in a panic. A panic will cause the\n runtime to exit. If needed, trap can be used to capture panics and treat them ...","content":"/  /  /  / Trap  import ballerina/io;  public function main() {  // Calling the `divide()` function with `0` as the divisor results in a panic. A panic will cause the  // runtime to exit. If needed, `trap` can be used to capture panics and treat them as errors thereafter.  int|error result = trap divide(1, 0);  if (result is int) {  io:println(\"int result: \", result);  } else {  io:println(\"Error occurred: \", result.reason());  } }  function divide(int a, int b) returns int {  return a / b; }    Trap  The trap unary opearator captures a panic making it possible to treat the panic as a normal error.    import ballerina/io;    public function main() {    int|error result = trap divide(1, 0);  if (result is int) {  io:println(\"int result: \", result);  } else {  io:println(\"Error occurred: \", result.reason());  } }    Calling the divide() function with 0 as the divisor results in a panic. A panic will cause the  runtime to exit. If needed, trap can be used to capture panics and treat them as errors thereafter.   function divide(int a, int b) returns int {  return a / b; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run trap.bal Error occurred: {ballerina}DivisionByZero    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/time.html","name":"Time","summary":"The Ballerina time API manipulates information with relation to\n date and time.To create the time:Time object, use either the currentTime(),\n createTime(), or the parse() function.\n This fetches the current time.Specifies a time with the required year, month, date,\n time, and timezone information.This retrieves the time for a given string representation\n ...","content":"/  /  /  / Time  import ballerina/io; import ballerina/time;  public function main() {  // To create the `time:Time` object, use either the `currentTime()`,  // `createTime()`, or the `parse()` function.  // This fetches the current time.  time:Time time = time:currentTime();  int currentTimeMills = time.time;  io:println(\"Current system time in milliseconds: \", currentTimeMills);  // Specifies a time with the required year, month, date,  // time, and timezone information.  time:Time|error timeCreated = time:createTime(2017, 3, 28, 23, 42, 45,  554, \"America/Panama\");  if (timeCreated is time:Time) {  io:println(\"Created Time: \", time:toString(timeCreated));  }  // This retrieves the time for a given string representation  // based on the specified String format.  time:Time|error t1 = time:parse(\"2017-06-26T09:46:22.444-0500\",  \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");  if (t1 is time:Time) {  io:println(\"Parsed Time: \", time:toString(t1));  }  // You can retrieve the string representation of the time via the `toString()`  // function or the `format()` function.  // This fetches the ISO 8601 formatted String of a given time.  string standardTimeString = time:toString(time);  io:println(\"Current system time in ISO format: \", standardTimeString);  // This fetches the formatted String of a given time.  string|error customTimeString = time:format(time, \"yyyy-MM-dd-E\");  if (customTimeString is string) {  io:println(\"Current system time in custom format: \", customTimeString);  }  // These functions retrieve information related to a time object.  // This fetches the year of a given time.  int year = time:getYear(time);  io:println(\"Year: \", year);  // This fetches the month value of a given time.  int month = time:getMonth(time);  io:println(\"Month: \", month);  // This fetches the day value of a given time.  int day = time:getDay(time);  io:println(\"Day: \", day);  // This fetches the hour value of a given time.  int hour = time:getHour(time);  io:println(\"Hour: \", hour);  // This fetches the minute value of a given time.  int minute = time:getMinute(time);  io:println(\"Minute: \", minute);  // This fetches the seconds value of a given time.  int second = time:getSecond(time);  io:println(\"Second: \", second);  // This fetches the millisecond value of a given time.  int milliSecond = time:getMilliSecond(time);  io:println(\"Millisecond: \", milliSecond);  // This fetches the day of the week of a given time.  string weekday = time:getWeekday(time);  io:println(\"Weekday: \", weekday);  // This fetches the date component of the time using a single function.  [year, month, day] = time:getDate(time);  io:println(\"Date: \", year, \":\", month, \":\", day);  // This fetches the time component using a single function.  [hour, minute, second, milliSecond] = time:getTime(time);  io:println(\"Time: \", hour, \":\", minute, \":\", second, \":\", milliSecond);  // This adds a given duration to a time. This example adds  // one year, one month, and one second to the current time.  time:Time tmAdd = time:addDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After adding a duration: \", time:toString(tmAdd));  // This subtracts a given duration from a time. This example  // subtract sone year, one month, and one second from the current time.  time:Time tmSub = time:subtractDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After subtracting a duration: \", time:toString(tmSub));  // This converts the time to a different timezone.  time:Time|error t2 = time:createTime(2017, 3, 28, 23, 42, 45, 554,  \"America/Panama\");  if (t2 is time:Time) {  io:println(\"Before converting the time zone: \", time:toString(t2));  time:Time|error t3 = time:toTimeZone(t2, \"Asia/Colombo\");  if (t3 is time:Time) {  io:println(\"After converting the time zone: \", time:toString(t3));  }  } }    Time  The Ballerina time API manipulates information with relation to  date and time.    import ballerina/io; import ballerina/time;    public function main() {    time:Time time = time:currentTime();  int currentTimeMills = time.time;  io:println(\"Current system time in milliseconds: \", currentTimeMills);    To create the time:Time object, use either the currentTime(),  createTime(), or the parse() function.  This fetches the current time.   time:Time|error timeCreated = time:createTime(2017, 3, 28, 23, 42, 45,  554, \"America/Panama\");  if (timeCreated is time:Time) {  io:println(\"Created Time: \", time:toString(timeCreated));  }    Specifies a time with the required year, month, date,  time, and timezone information.   time:Time|error t1 = time:parse(\"2017-06-26T09:46:22.444-0500\",  \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\");  if (t1 is time:Time) {  io:println(\"Parsed Time: \", time:toString(t1));  }    This retrieves the time for a given string representation  based on the specified String format.   string standardTimeString = time:toString(time);  io:println(\"Current system time in ISO format: \", standardTimeString);    You can retrieve the string representation of the time via the toString()  function or the format() function.  This fetches the ISO 8601 formatted String of a given time.   string|error customTimeString = time:format(time, \"yyyy-MM-dd-E\");  if (customTimeString is string) {  io:println(\"Current system time in custom format: \", customTimeString);  }    This fetches the formatted String of a given time.   int year = time:getYear(time);  io:println(\"Year: \", year);    These functions retrieve information related to a time object.  This fetches the year of a given time.   int month = time:getMonth(time);  io:println(\"Month: \", month);    This fetches the month value of a given time.   int day = time:getDay(time);  io:println(\"Day: \", day);    This fetches the day value of a given time.   int hour = time:getHour(time);  io:println(\"Hour: \", hour);    This fetches the hour value of a given time.   int minute = time:getMinute(time);  io:println(\"Minute: \", minute);    This fetches the minute value of a given time.   int second = time:getSecond(time);  io:println(\"Second: \", second);    This fetches the seconds value of a given time.   int milliSecond = time:getMilliSecond(time);  io:println(\"Millisecond: \", milliSecond);    This fetches the millisecond value of a given time.   string weekday = time:getWeekday(time);  io:println(\"Weekday: \", weekday);    This fetches the day of the week of a given time.   [year, month, day] = time:getDate(time);  io:println(\"Date: \", year, \":\", month, \":\", day);    This fetches the date component of the time using a single function.   [hour, minute, second, milliSecond] = time:getTime(time);  io:println(\"Time: \", hour, \":\", minute, \":\", second, \":\", milliSecond);    This fetches the time component using a single function.   time:Time tmAdd = time:addDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After adding a duration: \", time:toString(tmAdd));    This adds a given duration to a time. This example adds  one year, one month, and one second to the current time.   time:Time tmSub = time:subtractDuration(time, 1, 1, 0, 0, 0, 1, 0);  io:println(\"After subtracting a duration: \", time:toString(tmSub));    This subtracts a given duration from a time. This example  subtract sone year, one month, and one second from the current time.   time:Time|error t2 = time:createTime(2017, 3, 28, 23, 42, 45, 554,  \"America/Panama\");  if (t2 is time:Time) {  io:println(\"Before converting the time zone: \", time:toString(t2));  time:Time|error t3 = time:toTimeZone(t2, \"Asia/Colombo\");  if (t3 is time:Time) {  io:println(\"After converting the time zone: \", time:toString(t3));  }  } }    This converts the time to a different timezone.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run time.bal Current system time in milliseconds: 1543938113165 Created Time: 2017-03-28T23:42:45.554-05:00 Parsed Time: 2017-06-26T09:46:22.444-05:00 Current system time in ISO format: 2018-12-04T21:11:53.165+05:30 Current system time in custom format: 2018-12-04-Tue Year: 2018 Month: 12 Day: 4 Hour: 21 Minute: 11 Second: 53 Millisecond: 165 Weekday: TUESDAY Date: 2018:12:4 Time: 21:11:53:165 After adding a duration: 2020-01-04T21:11:54.165+05:30 After subtracting a duration: 2017-11-04T21:11:52.165+05:30 Before converting the time zone: 2017-03-28T23:42:45.554-05:00 After converting the time zone: 2017-03-29T10:12:45.554+05:30    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tracing.html","name":"Distributed Tracing","summary":"Ballerina supports Observability out of the box, and Tracing is one of the three important aspect of the\n Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.\n The developers can trace their code blocks and measure the time incurred during the actual runtime execution.\n ...","content":"/  /  /  / Distributed Tracing  import ballerina/http; import ballerina/log; import ballerina/observe; import ballerina/runtime;  // Make sure you start the service with the '--b7a.observability.enabled=true` property or with tracing enabled. service hello on new http:Listener(9234) {   // Invoke all resources with arguments of server connector and request.  resource function sayHello(http:Caller caller, http:Request req)  returns error? {  http:Response res = new;   //Start a child span attaching to the system span generated.  int spanId = check observe:startSpan(\"MyFirstLogicSpan\");   //Start a new root span without attaching to the system span.  int rootParentSpanId = observe:startRootSpan(\"MyRootParentSpan\");  // Some actual logic will go here, and for example we have introduced some delay with sleep.  runtime:sleep(1000);  //Start a new child span for the span `MyRootParentSpan`.  int childSpanId = check observe:startSpan(\"MyRootChildSpan\", (),  rootParentSpanId);  // Some actual logic will go here, and for example we have introduced some delay with sleep.  runtime:sleep(1000);  //Finish `MyRootChildSpan` span.  error? result = observe:finishSpan(childSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }  // Some actual logic will go here, and for example we have introduced some delay with sleep.  runtime:sleep(1000);  //Finish `MyRootParentSpan` span.  result = observe:finishSpan(rootParentSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }   //Some actual logic will go here, and for example we have introduced some delay with sleep.  runtime:sleep(1000);   //Finish the created child span `MyFirstLogicSpan`, which was attached to the system trace.  result = observe:finishSpan(spanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }  //Use a util method to set a string payload.  res.setPayload(\"Hello, World!\");   //Send the response back to the caller.  result = caller->respond(res);   if (result is error) {  log:printError(\"Error sending response\", result);  }   return ();  } }    Distributed Tracing  Ballerina supports Observability out of the box, and Tracing is one of the three important aspect of the  Observability. To observe Ballerina code, the ‘–b7a.observability.enabled=true’ property should be given when starting the service.  The developers can trace their code blocks and measure the time incurred during the actual runtime execution.  They can choose the hook their measurement with the default trace created or can create a completely new trace.    import ballerina/http; import ballerina/log; import ballerina/observe; import ballerina/runtime;    service hello on new http:Listener(9234) {    Make sure you start the service with the ‘–b7a.observability.enabled=true` property or with tracing enabled.   resource function sayHello(http:Caller caller, http:Request req)  returns error? {  http:Response res = new;    Invoke all resources with arguments of server connector and request.   int spanId = check observe:startSpan(\"MyFirstLogicSpan\");    Start a child span attaching to the system span generated.   int rootParentSpanId = observe:startRootSpan(\"MyRootParentSpan\");    Start a new root span without attaching to the system span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   int childSpanId = check observe:startSpan(\"MyRootChildSpan\", (),  rootParentSpanId);    Start a new child span for the span MyRootParentSpan.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   error? result = observe:finishSpan(childSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish MyRootChildSpan span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   result = observe:finishSpan(rootParentSpanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish MyRootParentSpan span.   runtime:sleep(1000);    Some actual logic will go here, and for example we have introduced some delay with sleep.   result = observe:finishSpan(spanId);  if (result is error) {  log:printError(\"Error in finishing span\", result);  }    Finish the created child span MyFirstLogicSpan, which was attached to the system trace.   res.setPayload(\"Hello, World!\");    Use a util method to set a string payload.   result = caller->respond(res);    Send the response back to the caller.   if (result is error) {  log:printError(\"Error sending response\", result);  }    return ();  } }    # Jaeger is the default tracing tool used in Ballerina. To start the Jaeger execute the below command. docker run -d -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778 -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command with '--b7a.observability.enabled=true' property. ballerina run tracing.bal --b7a.observability.enabled=true [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9234    curl http://localhost:9234/hello/sayHello Hello, World!    Invoke the service using cURL.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tuple-destructure-binding-pattern.html","name":"Tuple Destructure Binding Pattern","summary":"Tuple binding patterns are used to destructure and assign values to each individual variable of the tuple.\n The tuple destructuring binding patterns will be used to refer to existing variables as a tuple, destructure the\n given value on the right hand side, and assign the values to each individual variable ...","content":"/  /  /  / Tuple Destructure Binding Pattern  import ballerina/io;  public function main() {   // Tuple variables can be destructured with new values when used as a tuple variable  // reference based binding pattern.  [string, [int, boolean]] [a1, [a2, a3]] = [\"Hello\", [123, true]];  [a1, [a2, a3]] = [\"Ballerina\", [453, false]];  io:println(\"Tuple variable : \", a1, \" \", a2, \" \", a3);   // The variable can also be updated individually because once they are defined they are treated as individual  // variables at runtime.  [string, [int, boolean]] [b1, [b2, b3]] = [\"Hello\", [123, true]];  b1 = \"Ballerina\";  b2 = 453;  b3 = false;  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);   // The binding patterns are recursive in nature. These examples show how to write complex recursive  // variable references for destructuring.  [string, [int, [boolean, float]]] [c1, [c2, [c3, c4]]] =  [\"Test\", [123, [true, 5.6]]];  [[c1, c2], c3] = [[\"Ballerina\", 453], false];  [c2, c3, c4] = [657, true, 76.8];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);   // Tuple variables can also be referenced using tuple-type expressions.  [[string, [int, [boolean, int]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, int]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  [[d1, [d2, [d3, d4]]], [d5, d6]] = bar();  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);   // Tuple type can also take \"var\" as the type label in which the type will be inferred from the right hand side.  var [e1, [e2, e3]] = foo();  io:println(\"Tuple variable : \", e1, \" \", e2, \" \", e3);   var [[f1, [f2, [f3, f4]]], [f5, f6]] = bar();  io:println(\"Tuple variable : \",  f1, \" \", f2, \" \", f3, \" \", f4, \" \", f5, \" \", f6); }  function foo() returns [string, [int, boolean]] {  return [\"Ballerina\", [453, false]]; }  function bar() returns [[string, [int, [boolean, int]]], [float, int]] {  return [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]]; }    Tuple Destructure Binding Pattern  Tuple binding patterns are used to destructure and assign values to each individual variable of the tuple.  The tuple destructuring binding patterns will be used to refer to existing variables as a tuple, destructure the  given value on the right hand side, and assign the values to each individual variable of the tuple at runtime.    import ballerina/io;    public function main() {    [string, [int, boolean]] [a1, [a2, a3]] = [\"Hello\", [123, true]];  [a1, [a2, a3]] = [\"Ballerina\", [453, false]];  io:println(\"Tuple variable : \", a1, \" \", a2, \" \", a3);    Tuple variables can be destructured with new values when used as a tuple variable  reference based binding pattern.   [string, [int, boolean]] [b1, [b2, b3]] = [\"Hello\", [123, true]];  b1 = \"Ballerina\";  b2 = 453;  b3 = false;  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);    The variable can also be updated individually because once they are defined they are treated as individual  variables at runtime.   [string, [int, [boolean, float]]] [c1, [c2, [c3, c4]]] =  [\"Test\", [123, [true, 5.6]]];  [[c1, c2], c3] = [[\"Ballerina\", 453], false];  [c2, c3, c4] = [657, true, 76.8];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);    The binding patterns are recursive in nature. These examples show how to write complex recursive  variable references for destructuring.   [[string, [int, [boolean, int]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, int]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  [[d1, [d2, [d3, d4]]], [d5, d6]] = bar();  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);    Tuple variables can also be referenced using tuple-type expressions.   var [e1, [e2, e3]] = foo();  io:println(\"Tuple variable : \", e1, \" \", e2, \" \", e3);    Tuple type can also take “var” as the type label in which the type will be inferred from the right hand side.   var [[f1, [f2, [f3, f4]]], [f5, f6]] = bar();  io:println(\"Tuple variable : \",  f1, \" \", f2, \" \", f3, \" \", f4, \" \", f5, \" \", f6); }    function foo() returns [string, [int, boolean]] {  return [\"Ballerina\", [453, false]]; }    function bar() returns [[string, [int, [boolean, int]]], [float, int]] {  return [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]]; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run tuple_destructure_binding_pattern.bal Tuple variable : Ballerina 453 false Tuple variable : Ballerina 453 false Tuple variable : Ballerina 657 true 76.8 Tuple variable : Ballerina 3 true 34 5.6 45 Tuple variable : Ballerina 453 false Tuple variable : Ballerina 3 true 34 5.6 45    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tuple-type.html","name":"Tuples","summary":"A tuple is an immutable list of two or more values of a fixed length.\n A tuple type is described by specifying the type of each member in the list.Defines the type of a as a pair that consists of an int and a string.Defines a tuple of variable names ...","content":"/  /  /  / Tuples  import ballerina/io;  public function main() {   // Defines the type of `a` as a pair that consists of an `int` and a `string`.  [int, string] a = [10, \"John\"];  io:println(a);   int aint;  string astr;  // Defines a tuple of variable names on the left with a variable reference of which the type is a tuple.  // The assignment statement assigns values of the tuple on the right to the variables on the left.  // In Ballerina, this is referred to as tuple destructuring.  [aint, astr] = a;  io:println(aint);  io:println(astr);   // You can declare and assign values with `var` like this.  var [aint1, astr1] = a;   // Invokes a function that returns a tuple.  var [q, r] = divideBy10(6);  io:println(\"06/10: \", \"quotient=\", q, \" remainder=\", r);   // To ignore a value in a tuple, use `_`.  // This ignores the second return value.  var [q1, _] = divideBy10(57);  io:println(\"57/10: \", \"quotient=\", q1);   [int, int] returnValue = divideBy10(9);  // This ignores the first value of a tuple.  var [_, r1] = returnValue;  io:println(\"09/10: \", \"remainder=\", r1); }  // This function returns a tuple of two integers. function divideBy10(int d) returns ([int, int]) {  int q = d / 10;  int r = d % 10;  return [q, r]; }    Tuples  A tuple is an immutable list of two or more values of a fixed length.  A tuple type is described by specifying the type of each member in the list.    import ballerina/io;    public function main() {    [int, string] a = [10, \"John\"];  io:println(a);    Defines the type of a as a pair that consists of an int and a string.   int aint;  string astr;    [aint, astr] = a;  io:println(aint);  io:println(astr);    Defines a tuple of variable names on the left with a variable reference of which the type is a tuple.  The assignment statement assigns values of the tuple on the right to the variables on the left.  In Ballerina, this is referred to as tuple destructuring.   var [aint1, astr1] = a;    You can declare and assign values with var like this.   var [q, r] = divideBy10(6);  io:println(\"06/10: \", \"quotient=\", q, \" remainder=\", r);    Invokes a function that returns a tuple.   var [q1, _] = divideBy10(57);  io:println(\"57/10: \", \"quotient=\", q1);    To ignore a value in a tuple, use _.  This ignores the second return value.   [int, int] returnValue = divideBy10(9);    var [_, r1] = returnValue;  io:println(\"09/10: \", \"remainder=\", r1); }    This ignores the first value of a tuple.   function divideBy10(int d) returns ([int, int]) {  int q = d / 10;  int r = d % 10;  return [q, r]; }    This function returns a tuple of two integers.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run tuple_type.bal 10 John 10 John 06/10: quotient=0 remainder=6 57/10: quotient=5 09/10: remainder=9    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tuple-typed-binding-pattern.html","name":"Tuple-Typed Binding Pattern","summary":"Tuple-binding patterns are used to de-structure and assign values to each individual variable of the tuple.\n The tuple-typed binding patterns will be used in declaring and defining new tuple variables.\n The tuple-type variable definition must have an assignment expression on the right hand side.This is a simple binding pattern, which ...","content":"/  /  /  / Tuple-Typed Binding Pattern  import ballerina/io;  public function main() {   // This is a simple binding pattern, which involves only a single variable.  [boolean, float] t = [true, 0.4];  io:println(\"Simple variable : \", t);   // The same variable definition can be written using a tuple-binding pattern  // with separate variables.  [boolean, float] [a1, a2] = [true, 0.4];  io:println(\"Tuple variable : \", a1, \" \", a2);   // The binding patterns are recursive in nature. These examples show  // how to write complex recursive variable definitions.  [[string, int], float] [[b1, b2], b3] = [[\"Ballerina\", 4], 6.7];  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);   [[string, int], [boolean, float]] [[c1, c2], [c3, c4]] =  [[\"Ballerina\", 34], [true, 6.7]];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);   // Tuple variables can also be defined using tuple-type expressions.  [[string, [int, [boolean, byte]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, byte]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);   // Tuple variable definitions can also take union types.  [string|int|float, [string|float, int]] [g1, [g2, g3]] =  [\"Ballerina\", [3.4, 456]];  io:println(\"Tuple variable : \", g1, \" \", g2, \" \", g3); }    Tuple-Typed Binding Pattern  Tuple-binding patterns are used to de-structure and assign values to each individual variable of the tuple.  The tuple-typed binding patterns will be used in declaring and defining new tuple variables.  The tuple-type variable definition must have an assignment expression on the right hand side.    import ballerina/io;    public function main() {    [boolean, float] t = [true, 0.4];  io:println(\"Simple variable : \", t);    This is a simple binding pattern, which involves only a single variable.   [boolean, float] [a1, a2] = [true, 0.4];  io:println(\"Tuple variable : \", a1, \" \", a2);    The same variable definition can be written using a tuple-binding pattern  with separate variables.   [[string, int], float] [[b1, b2], b3] = [[\"Ballerina\", 4], 6.7];  io:println(\"Tuple variable : \", b1, \" \", b2, \" \", b3);    The binding patterns are recursive in nature. These examples show  how to write complex recursive variable definitions.   [[string, int], [boolean, float]] [[c1, c2], [c3, c4]] =  [[\"Ballerina\", 34], [true, 6.7]];  io:println(\"Tuple variable : \", c1, \" \", c2, \" \", c3, \" \", c4);    [[string, [int, [boolean, byte]]], [float, int]] v1 =  [[\"Ballerina\", [3, [true, 34]]], [5.6, 45]];  [[string, [int, [boolean, byte]]],  [float, int]] [[d1, [d2, [d3, d4]]], [d5, d6]] = v1;  io:println(\"Tuple variable : \",  d1, \" \", d2, \" \", d3, \" \", d4, \" \", d5, \" \", d6);    Tuple variables can also be defined using tuple-type expressions.   [string|int|float, [string|float, int]] [g1, [g2, g3]] =  [\"Ballerina\", [3.4, 456]];  io:println(\"Tuple variable : \", g1, \" \", g2, \" \", g3); }    Tuple variable definitions can also take union types.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run tuple_type_binding_pattern.bal Simple variable : true 0.4 Tuple variable : true 0.4 Tuple variable : Ballerina 4 6.7 Tuple variable : Ballerina 34 true 6.7 Tuple variable : Ballerina 3 true 34 5.6 45 Tuple variable : Ballerina 3.4 456    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/transactions-distributed.html","name":"Distributed Transactions","summary":"To improve the reliability of microservice-based applications,\n a series of microservice invocations can be bound into a single unit of work.\n The underlying mechanisms are that of infection and agreement protocols.\n This example demonstrates the Ballerina distributed transactions protocol\n in action.\n Ballerina transactions are at experimental stage,\n please use the ...","content":"/  /  /  / Distributed Transactions  import ballerina/http; import ballerina/log; import ballerina/math; import ballerina/transactions;  // This is the initiator of the distributed transaction. @http:ServiceConfig {  basePath: \"/\" } service InitiatorService on new http:Listener(8080) {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function init(http:Caller conn, http:Request req) {  http:Response res = new;  log:printInfo(\"Initiating transaction...\");  // When the `transaction` statement starts, a distributed transaction context is created.  transaction {  // Print the current transaction ID  log:printInfo(\"Started transaction: \" +  transactions:getCurrentTransactionId());  // When a participant is called, the transaction context is propagated, and that participant  // gets infected and joins the distributed transaction.  boolean successful = callBusinessService();  if (successful) {  res.statusCode = http:STATUS_OK;  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  abort;  }  // As soon as the `transaction` block ends, the `2-phase commit  // coordination` protocol will run. All participants are prepared  // and depending on the joint outcome, either a `notify commit` or  // `notify abort` will be sent to the participants.  } committed {  log:printInfo(\"Initiated transaction committed\");  } aborted {  log:printInfo(\"Initiated transaction aborted\");  }  // Send the response back to the client.  var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to client\",  err = result);  } else {  log:printInfo(\"Sent response back to client\");  }  } }  // This is the participant business function call. function callBusinessService() returns boolean {  http:Client participantEP = new (\"http://localhost:8889/stockquote/update\");  // Generate the payload  float price = <int>math:randomInRange(200, 250) + math:random();  json bizReq = {symbol: \"GOOG\", price: price};  // Send the request to the backend service.  http:Request req = new;  req.setJsonPayload(bizReq);  var result = participantEP->post(\"\", req);  log:printInfo(\"Got response from bizservice\");  if (result is error) {  log:printError(\"Error when calling the backend: \", result);  return false;  } else {  return result.statusCode == http:STATUS_OK;  } } import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/transactions;  // This service is a participant in the distributed transaction. It will get // infected when it receives a transaction context from the participant. The // transaction context, in the HTTP case, will be passed in as custom HTTP headers. @http:ServiceConfig {  basePath: \"/stockquote\" } service ParticipantService on new http:Listener(8889) {   @http:ResourceConfig {  path: \"/update\"  }  @transactions:Participant {  oncommit: printParticipantCommit,  onabort: printParticipantAbort  }  resource function updateStockQuote(http:Caller conn, http:Request req) {  // Since a transaction context has been received, this resource will  // register with the initiator as a participant.  log:printInfo(\"Received update stockquote request\");  // Print the current transaction ID.  log:printInfo(\"Joined transaction: \" +  transactions:getCurrentTransactionId());  // Get the json payload.  var updateReq = <@untainted>req.getJsonPayload();  // Generate the response.  http:Response res = new;  if (updateReq is json) {  string msg = io:sprintf(\"Update stock quote request received. \" +  \"symbol:%s, price:%s\", updateReq.symbol, updateReq.price);  log:printInfo(msg);  json jsonRes = {\"message\": \"updating stock\"};  res.statusCode = http:STATUS_OK;  res.setJsonPayload(jsonRes);  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload(updateReq.reason());  log:printError(\"Payload error occurred!\", updateReq);  }  // Send the response back to the initiator.  var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to initiator\",  err = result);  } else {  log:printInfo(\"Sent response back to initiator\");  }  } }  // The participant function that will get called when the distributed // transaction is aborted. function printParticipantAbort(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" aborted\"); }  // The participant function that will get called when the distributed // transaction is committed. function printParticipantCommit(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" committed\"); }    Distributed Transactions  To improve the reliability of microservice-based applications,  a series of microservice invocations can be bound into a single unit of work.  The underlying mechanisms are that of infection and agreement protocols.  This example demonstrates the Ballerina distributed transactions protocol  in action.  Ballerina transactions are at experimental stage,  please use the –experimental flag to enable them.    import ballerina/http; import ballerina/log; import ballerina/math; import ballerina/transactions;    @http:ServiceConfig {  basePath: \"/\" } service InitiatorService on new http:Listener(8080) {    This is the initiator of the distributed transaction.   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function init(http:Caller conn, http:Request req) {  http:Response res = new;  log:printInfo(\"Initiating transaction...\");    transaction {    When the transaction statement starts, a distributed transaction context is created.   log:printInfo(\"Started transaction: \" +  transactions:getCurrentTransactionId());    Print the current transaction ID   boolean successful = callBusinessService();  if (successful) {  res.statusCode = http:STATUS_OK;  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  abort;  }    When a participant is called, the transaction context is propagated, and that participant  gets infected and joins the distributed transaction.   } committed {  log:printInfo(\"Initiated transaction committed\");  } aborted {  log:printInfo(\"Initiated transaction aborted\");  }    As soon as the transaction block ends, the 2-phase commit  coordination protocol will run. All participants are prepared  and depending on the joint outcome, either a notify commit or  notify abort will be sent to the participants.   var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to client\",  err = result);  } else {  log:printInfo(\"Sent response back to client\");  }  } }    Send the response back to the client.   function callBusinessService() returns boolean {  http:Client participantEP = new (\"http://localhost:8889/stockquote/update\");    This is the participant business function call.   float price = <int>math:randomInRange(200, 250) + math:random();  json bizReq = {symbol: \"GOOG\", price: price};    Generate the payload   http:Request req = new;  req.setJsonPayload(bizReq);  var result = participantEP->post(\"\", req);  log:printInfo(\"Got response from bizservice\");  if (result is error) {  log:printError(\"Error when calling the backend: \", result);  return false;  } else {  return result.statusCode == http:STATUS_OK;  } }    Send the request to the backend service.   # To start the `initiator` service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. ballerina run --experimental initiator.bal [ballerina/http] started HTTP/WS listener 10.100.7.118:64337 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/transactions;    @http:ServiceConfig {  basePath: \"/stockquote\" } service ParticipantService on new http:Listener(8889) {    This service is a participant in the distributed transaction. It will get  infected when it receives a transaction context from the participant. The  transaction context, in the HTTP case, will be passed in as custom HTTP headers.   @http:ResourceConfig {  path: \"/update\"  }  @transactions:Participant {  oncommit: printParticipantCommit,  onabort: printParticipantAbort  }  resource function updateStockQuote(http:Caller conn, http:Request req) {    log:printInfo(\"Received update stockquote request\");    Since a transaction context has been received, this resource will  register with the initiator as a participant.   log:printInfo(\"Joined transaction: \" +  transactions:getCurrentTransactionId());    Print the current transaction ID.   var updateReq = <@untainted>req.getJsonPayload();    Get the json payload.   http:Response res = new;  if (updateReq is json) {  string msg = io:sprintf(\"Update stock quote request received. \" +  \"symbol:%s, price:%s\", updateReq.symbol, updateReq.price);  log:printInfo(msg);  json jsonRes = {\"message\": \"updating stock\"};  res.statusCode = http:STATUS_OK;  res.setJsonPayload(jsonRes);  } else {  res.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  res.setPayload(updateReq.reason());  log:printError(\"Payload error occurred!\", updateReq);  }    Generate the response.   var result = conn->respond(res);  if (result is error) {  log:printError(\"Could not send response back to initiator\",  err = result);  } else {  log:printInfo(\"Sent response back to initiator\");  }  } }    Send the response back to the initiator.   function printParticipantAbort(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" aborted\"); }    The participant function that will get called when the distributed  transaction is aborted.   function printParticipantCommit(string transactionId) {  log:printInfo(\"Participated transaction: \" + transactionId + \" committed\"); }    The participant function that will get called when the distributed  transaction is committed.   # To start the `participant` service, navigate to the directory that contains the # `.bal` file and use the `ballerina run` command. #Run this command to start the `participant` service. ballerina run --experimental participant.bal [ballerina/http] started HTTP/WS listener 10.100.1.182:54774 [ballerina/http] started HTTP/WS listener localhost:8889    #Run this curl command to invoke the services. curl -v localhost:8080    Outputs similar to the following should be available from the initiator and participant.    Output from initiator:    [ballerina/http] started HTTP/WS listener 10.100.7.118:64337 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 2019-09-04 12:04:58,404 INFO [] - Initiating transaction... 2019-09-04 12:04:58,419 INFO [ballerina/transactions] - Created transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,423 INFO [] - Started transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,833 INFO [ballerina/transactions] - Registered remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,876 INFO [] - Got response from bizservice 2019-09-04 12:04:58,877 INFO [ballerina/transactions] - Running 2-phase commit for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,899 INFO [ballerina/transactions] - Preparing remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 2019-09-04 12:04:58,927 INFO [ballerina/transactions] - Remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 prepared 2019-09-04 12:04:58,928 INFO [ballerina/transactions] - Notify(commit) remote participant: http://10.100.7.118:64553/balcoordinator/participant/2pc/$anon$.$0 2019-09-04 12:04:58,941 INFO [ballerina/transactions] - Remote participant: f677d80b-710f-4e9c-9d46-c30782086581:$anon$.$0 committed 2019-09-04 12:04:58,942 INFO [] - Initiated transaction committed 2019-09-04 12:04:58,945 INFO [] - Sent response back to client    Output from participant:    [ballerina/http] started HTTP/WS listener 10.100.7.118:64553 [ballerina/http] started HTTP/WS listener 0.0.0.0:8889 2019-09-04 12:04:58,683 INFO [ballerina/transactions] - Registering for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 with coordinator: http://10.100.7.118:64337/balcoordinator/initiator/$anon$.$0/register 2019-09-04 12:04:58,847 INFO [ballerina/transactions] - Registered with coordinator for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,848 INFO [ballerina/transactions] - participant registered: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,851 INFO [] - Received update stockquote request 2019-09-04 12:04:58,852 INFO [] - Joined transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,858 INFO [] - Update stock quote request received.  symbol:GOOG, price:249.7214191144464 2019-09-04 12:04:58,872 INFO [] - Sent response back to initiator 2019-09-04 12:04:58,917 INFO [ballerina/transactions] - Prepare received for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,918 INFO [ballerina/transactions] - Prepared transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a 2019-09-04 12:04:58,935 INFO [ballerina/transactions] - Notify(commit) received for transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 2019-09-04 12:04:58,936 INFO [] - Participated transaction: 2c9584d2-e5d0-4dad-bfc1-946cc4c00f6a:$anon$.$0 committed    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/tuple-match-statement.html","name":"Tuple Match","summary":"The match statement in Ballerina will support value-based match patterns only. There are static and structured\n based match patterns that can be used with the match clauses. Structured match patterns will take structured\n binding patterns for matching. Tuple binding pattern is one of the structured binding patterns that can be ...","content":"/  /  /  / Tuple Match  import ballerina/io;  public function main() {  // In this example, four variables are created and they will be matched against  // the patterns specified in the `match` statement of the `basicMatch()` function.  [string, int]|[float, string, boolean]|float a1 = 66.6;  [string, int]|[float, string, boolean]|float a2 = [\"Hello\", 12];  [float, boolean]|[float, string, boolean]|float a3 = [4.5, true];  [string, int]|[float, string, boolean]|float a4 = [6.7, \"Test\", false];   basicMatch(a1);  basicMatch(a2);  basicMatch(a3);  basicMatch(a4);   // In this example, five variables are created and they will be matched  // against the match-guarded patterns specified in the `match` statement of the 'matchWithMatchGuard()' function.  [string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];  [string, int]|[float, boolean]|[int, boolean]|int|float b2 = [4.5, true];  [float, boolean]|[boolean, int]|[int, boolean]|int|float b3 = [false, 4];  [string, int]|[int, boolean]|int|float b4 = [455, true];  [float, boolean]|[boolean, int]|[int, boolean]|float b5 = 5.6;   matchWithMatchGuard(b1);  matchWithMatchGuard(b2);  matchWithMatchGuard(b3);  matchWithMatchGuard(b4);  matchWithMatchGuard(b5); }  // This method uses tuple match patterns of different sizes. The `match` expression `a` // will be matched against the given pattern list at run time based on the // \"is-like\" relationship between the expression and a pattern. function basicMatch(any a) {  match a {  // This pattern check is for a tuple of three members of any type.  var [s, i, b] => {  io:println(\"Matched with three vars : \", io:sprintf(\"%s\", a));  }  // This pattern check is for a tuple of two members of any type.  var [s, i] => {  io:println(\"Matched with two vars : \", io:sprintf(\"%s\", a));  }  // This pattern check is for a single variable, which can be of type `any`. This has to be the last pattern.  var s => {  io:println(\"Matched with single var : \", io:sprintf(\"%s\", a));  }  } }  // This method uses structured tuple match patterns with different sizes along with match guards. The given // `match` expression will be checked for \"is-like\" relationship and also it will check the match guard for the pattern // to match at runtime. function matchWithMatchGuard(any b) {  match b {  // This pattern check is for a tuple of two members of the types `string` and `int` respectively.  var [s, i] if (s is string && i is int) => {  io:println(\"'s' is string and 'i' is int : \", io:sprintf(\"%s\", b));  }  // This pattern check is for a tuple of two members where the first member is of the type `float`.  var [s, i] if s is float => {  io:println(\"Only 's' is float : \", io:sprintf(\"%s\", b));  }  // This pattern check is for a tuple of two members where the second member is of the type `int`.  var [s, i] if i is int => {  io:println(\"Only 'i' is int : \", io:sprintf(\"%s\", b));  }  // This pattern check is for a tuple of two members without any match guard.  var [s, i] => {  io:println(\"No type guard : \", io:sprintf(\"%s\", b));  }  // This pattern check is for a single variable of the type `float`.  var s if s is float => {  io:println(\"'s' is float only : \", io:sprintf(\"%s\", b));  }   } }    Tuple Match  The match statement in Ballerina will support value-based match patterns only. There are static and structured  based match patterns that can be used with the match clauses. Structured match patterns will take structured  binding patterns for matching. Tuple binding pattern is one of the structured binding patterns that can be used  with the match. The value will be checked for the “isLike” relationship with the pattern to match at runtime.  The match pattern clauses can also have additional type guard conditions as strong match conditions.    import ballerina/io;    public function main() {    [string, int]|[float, string, boolean]|float a1 = 66.6;  [string, int]|[float, string, boolean]|float a2 = [\"Hello\", 12];  [float, boolean]|[float, string, boolean]|float a3 = [4.5, true];  [string, int]|[float, string, boolean]|float a4 = [6.7, \"Test\", false];    In this example, four variables are created and they will be matched against  the patterns specified in the match statement of the basicMatch() function.   basicMatch(a1);  basicMatch(a2);  basicMatch(a3);  basicMatch(a4);    [string, int]|[boolean, int]|[int, boolean]|int|float b1 = [\"Hello\", 45];  [string, int]|[float, boolean]|[int, boolean]|int|float b2 = [4.5, true];  [float, boolean]|[boolean, int]|[int, boolean]|int|float b3 = [false, 4];  [string, int]|[int, boolean]|int|float b4 = [455, true];  [float, boolean]|[boolean, int]|[int, boolean]|float b5 = 5.6;    In this example, five variables are created and they will be matched  against the match-guarded patterns specified in the match statement of the ‘matchWithMatchGuard()’ function.   matchWithMatchGuard(b1);  matchWithMatchGuard(b2);  matchWithMatchGuard(b3);  matchWithMatchGuard(b4);  matchWithMatchGuard(b5); }    function basicMatch(any a) {  match a {    This method uses tuple match patterns of different sizes. The match expression a  will be matched against the given pattern list at run time based on the  “is-like” relationship between the expression and a pattern.   var [s, i, b] => {  io:println(\"Matched with three vars : \", io:sprintf(\"%s\", a));  }    This pattern check is for a tuple of three members of any type.   var [s, i] => {  io:println(\"Matched with two vars : \", io:sprintf(\"%s\", a));  }    This pattern check is for a tuple of two members of any type.   var s => {  io:println(\"Matched with single var : \", io:sprintf(\"%s\", a));  }  } }    This pattern check is for a single variable, which can be of type any. This has to be the last pattern.   function matchWithMatchGuard(any b) {  match b {    This method uses structured tuple match patterns with different sizes along with match guards. The given  match expression will be checked for “is-like” relationship and also it will check the match guard for the pattern  to match at runtime.   var [s, i] if (s is string && i is int) => {  io:println(\"'s' is string and 'i' is int : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members of the types string and int respectively.   var [s, i] if s is float => {  io:println(\"Only 's' is float : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members where the first member is of the type float.   var [s, i] if i is int => {  io:println(\"Only 'i' is int : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members where the second member is of the type int.   var [s, i] => {  io:println(\"No type guard : \", io:sprintf(\"%s\", b));  }    This pattern check is for a tuple of two members without any match guard.   var s if s is float => {  io:println(\"'s' is float only : \", io:sprintf(\"%s\", b));  }    This pattern check is for a single variable of the type float.   } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run tuple_match_statement.bal Matched with single var : 66.6 Matched with two vars : Hello 12 Matched with two vars : 4.5 true Matched with three vars : 6.7 Test false 's' is string and 'i' is int : Hello 45 Only 's' is float : 4.5 true Only 'i' is int : false 4 No type guard : 455 true 's' is float only : 5.6    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/type-cast.html","name":"Type Cast","summary":"Type cast casts a value to a target type performing a numeric conversion if required.\n If the value belongs to the target type, the result of the type cast expression is the value itself.\n Else, if the target type contains exactly one basic numeric type, and the value belongs to ...","content":"/  /  /  / Type Cast  import ballerina/io;  type Person record {  string name;  int age; };  type Employee record {  string name;  int age;  int empNo; };  type Department record {  string code; };  public function main() {  // Define an `Employee` value and cast it to a `Person`.  Employee employee = {name: \"Jane Doe\", age: 25, empNo: 1};  Person person = <Person>employee;  io:println(\"Person Name: \", person.name);  io:println(\"Person Age: \", person.age);   // Cast the value held by the `person` variable to an `Employee`.  // This should succeed since `person` holds an `Employee` value.  Employee employeeTwo = <Employee>person;  io:println(\"Employee Name: \", employeeTwo.name);  io:println(\"Employee Age: \", employeeTwo.age);   // Cast an `int` value held by an `anydata` typed variable as an  // `int` value.  anydata value = 100;  int i = <int>value;  io:println(\"Integer Value: \", i);   // Use the type cast expression with `value`, which currently holds  // an `int` value, to cast it to `float`.  // A numeric conversion would happen from `int` to `float`.  float f = <float>value;  io:println(\"Converted Float Value: \", f);   // Casting to a union type would also work similarly.  // If `value` belongs to the union type, the resultant value would  // be `value` itself. Else, if applicable, a numeric conversion will  // be attempted.  // A numeric conversion would happen from `int` to `float` here.  float|boolean u = <float|boolean>value;  io:println(\"Converted Float Value: \", u);   // Assign `employee` to `value`.  value = employee;  // Casting a value to an incorrect type (the value does not belong  // to the type and numeric conversion is not possible) would result  // in an abrupt completion with a panic.  Department department = <Department>value; }    Type Cast  Type cast casts a value to a target type performing a numeric conversion if required.  If the value belongs to the target type, the result of the type cast expression is the value itself.  Else, if the target type contains exactly one basic numeric type, and the value belongs to a numeric type,  the resultant value would be the numeric conversion of the value to the target numeric type.  If neither is satisfied or if the numeric conversion returns an error, the type cast expression completes abruptly  with a panic.    import ballerina/io;    type Person record {  string name;  int age; };    type Employee record {  string name;  int age;  int empNo; };    type Department record {  string code; };    public function main() {    Employee employee = {name: \"Jane Doe\", age: 25, empNo: 1};  Person person = <Person>employee;  io:println(\"Person Name: \", person.name);  io:println(\"Person Age: \", person.age);    Define an Employee value and cast it to a Person.   Employee employeeTwo = <Employee>person;  io:println(\"Employee Name: \", employeeTwo.name);  io:println(\"Employee Age: \", employeeTwo.age);    Cast the value held by the person variable to an Employee.  This should succeed since person holds an Employee value.   anydata value = 100;  int i = <int>value;  io:println(\"Integer Value: \", i);    Cast an int value held by an anydata typed variable as an  int value.   float f = <float>value;  io:println(\"Converted Float Value: \", f);    Use the type cast expression with value, which currently holds  an int value, to cast it to float.  A numeric conversion would happen from int to float.   float|boolean u = <float|boolean>value;  io:println(\"Converted Float Value: \", u);    Casting to a union type would also work similarly.  If value belongs to the union type, the resultant value would  be value itself. Else, if applicable, a numeric conversion will  be attempted.  A numeric conversion would happen from int to float here.   value = employee;    Assign employee to value.   Department department = <Department>value; }    Casting a value to an incorrect type (the value does not belong  to the type and numeric conversion is not possible) would result  in an abrupt completion with a panic.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run type_cast.bal Person Name: Jane Doe Person Age: 25 Employee Name: Jane Doe Employee Age: 25 Integer Value: 100 Converted Float Value: 100.0 Converted Float Value: 100.0 error: {ballerina}TypeCastError message=incompatible types: 'Employee' cannot be cast to 'Department'  at type_cast:main(type_cast.bal:56)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/type-guard.html","name":"Type Guard","summary":"A type guard (based on the type test) is a construct that allows selective code execution based on\n the type of the expression that is being tested.\n The type of the expression within the type guard (except for global variables) would be a narrowed type based on the\n relevant type ...","content":"/  /  /  / Type Guard  import ballerina/io;  public function main() {  // The `value` variable can hold a value of the type `string`, `int` or `boolean`.  string|int|boolean value = 10;   // The type guard can be used with `value` to test to which of the types it belongs to and perform conditional  // logic based on the type which it belongs to.  if (value is string) {  // The type of `value` within this block is narrowed to `string`, and thus, `value` can be assigned to a  // variable of the type `string`.  string str = value;  io:println(\"value is a string: \", str);  } else if (value is int) {  // The type of `value` within this block is narrowed to `int`, and thus, `value` can be used in a  // context where an `int` is expected.  io:println(\"value is an int: \", value);  io:println(\"value + 1: \", addOneToInt(value));   // If the value is updated within a type guard, the type is reset to the original type.  value = \"Hello World\";   // The type test needs to be used again since the type of `value` is reset to `string|int|boolean`.  if (value is int) {  // `value` is an `int` here.  int i = value;  io:println(\"- value is an int: \", i);  } else {  // `value` is `string` or `boolean` here.  string|boolean sb = value;  io:println(\"- value is string|boolean: \", sb);  }  } else {  // Within this block, the type of `value` is `boolean` since the previous `if` and `else if` blocks handle the  // other possible scenarios.  if (value) {  io:println(\"s is 'true'\");  }  } }  // A function that expects an `int` as an argument. function addOneToInt(int i) returns int {  return i + 1; }    Type Guard  A type guard (based on the type test) is a construct that allows selective code execution based on  the type of the expression that is being tested.  The type of the expression within the type guard (except for global variables) would be a narrowed type based on the  relevant type test.    import ballerina/io;    public function main() {    string|int|boolean value = 10;    The value variable can hold a value of the type string, int or boolean.   if (value is string) {    The type guard can be used with value to test to which of the types it belongs to and perform conditional  logic based on the type which it belongs to.   string str = value;  io:println(\"value is a string: \", str);  } else if (value is int) {    The type of value within this block is narrowed to string, and thus, value can be assigned to a  variable of the type string.   io:println(\"value is an int: \", value);  io:println(\"value + 1: \", addOneToInt(value));    The type of value within this block is narrowed to int, and thus, value can be used in a  context where an int is expected.   value = \"Hello World\";    If the value is updated within a type guard, the type is reset to the original type.   if (value is int) {    The type test needs to be used again since the type of value is reset to string|int|boolean.   int i = value;  io:println(\"- value is an int: \", i);  } else {    value is an int here.   string|boolean sb = value;  io:println(\"- value is string|boolean: \", sb);  }  } else {    value is string or boolean here.   if (value) {  io:println(\"s is 'true'\");  }  } }    Within this block, the type of value is boolean since the previous if and else if blocks handle the  other possible scenarios.   function addOneToInt(int i) returns int {  return i + 1; }    A function that expects an int as an argument.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run type_guard.bal value is an int: 10 value + 1: 11 - value is string|boolean: Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/type-conversion.html","name":"Type Conversion","summary":"The .constructFrom() method creates a new value with a target storage type from a given anydata-typed\n value, and assigns it to a target variable.\n .constructFrom() is defined on all structured types, and returns an error if the operation is unsuccessful.This function attempts to convert an anydata record Employee to an ...","content":"/  /  /  / Type Conversion  import ballerina/io; import ballerina/lang.'decimal; import ballerina/lang.'float; import ballerina/lang.'int;  type Person record {  string name;  int age; };  type Employee record {  string name;  int age;  int empNo; };  // This function attempts to convert an `anydata` record `Employee` to an `anydata` record `Person`. function convertEmployeeToPerson(Employee emp) {  // Attempts to create a new value of the type `Person` from the `Employee`-typed `emp` value without changing  // the inherent type of `emp`.  Person|error res = Person.constructFrom(emp);  if (res is Person) {  // If the conversion is successful, this prints the `name` field.  io:println(\"Employee to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion\");  } }  // This function attempts to convert an `anydata` constrained map to an `anydata` record `Person`. // The conversion would return an error if an incompatible value is found. function convertAnydataMapToPerson(map<anydata> m) {  // Attempts to create a new value of the type `Person` from the `map<anydata>` typed `m` value without changing  // the inherent type of `m`.  Person|error res = Person.constructFrom(m);  if (res is Person) {  // If the conversion is successful, this prints the `name` field.  io:println(\"map<anydata> to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion: \", res.detail());  } }  // This function creates numeric values from string values. function createNumericValues() {  string s1 = \"45\";  string s2 = \"abc\";  string s3 = \"12.3\";  string s4 = \"8\";   // The `fromString()` method in the `ballerina/lang.int` module returns the integer value represented by a  // given string if there is a valid representation, else returns an `error`.  int|error res1 = 'int:fromString(s1);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }   res1 = 'int:fromString(s2);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }   // The `fromString()` method in the `ballerina/lang.float` module returns the float value represented by a given  // string if there is a valid representation, else returns an `error`.  float|error res2 = 'float:fromString(s3);  if (res2 is float) {  io:println(\"float value: \", res2);  } else {  io:println(\"error: \", res2.detail());  }   // The `fromString()` method in the `ballerina/lang.decimal` module returns the decimal value represented by a given  // string if there is a valid representation, else returns an `error`.  decimal|error res3 = 'decimal:fromString(s4);  if (res3 is decimal) {  io:println(\"decimal value: \", res3);  } else {  io:println(\"error: \", res3.detail());  } }  public function main() {  // Attempts to convert an `anydata`-typed record to another `anydata`-typed record.  Employee emp = {name: \"Jack Sparrow\", age: 54, empNo: 100};  convertEmployeeToPerson(emp);   // Attempts to convert an `anydata` constrained map to an `anydata`-typed record.  // This conversion would be successful since all the expected elements are present.  map<anydata> m = {name: \"Hector Barbossa\", age: 54, empNo: 100};  convertAnydataMapToPerson(m);   // This conversion would not be successful since all the required elements are not  // present in the map.  map<anydata> n = {name: \"Elizabeth Swann\"};  convertAnydataMapToPerson(n);   // Attempts to convert strings to numeric types.  createNumericValues(); }    Type Conversion  The .constructFrom() method creates a new value with a target storage type from a given anydata-typed  value, and assigns it to a target variable.  .constructFrom() is defined on all structured types, and returns an error if the operation is unsuccessful.    import ballerina/io; import ballerina/lang.'decimal; import ballerina/lang.'float; import ballerina/lang.'int;    type Person record {  string name;  int age; };    type Employee record {  string name;  int age;  int empNo; };    function convertEmployeeToPerson(Employee emp) {    This function attempts to convert an anydata record Employee to an anydata record Person.   Person|error res = Person.constructFrom(emp);  if (res is Person) {    Attempts to create a new value of the type Person from the Employee-typed emp value without changing  the inherent type of emp.   io:println(\"Employee to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion\");  } }    If the conversion is successful, this prints the name field.   function convertAnydataMapToPerson(map<anydata> m) {    This function attempts to convert an anydata constrained map to an anydata record Person.  The conversion would return an error if an incompatible value is found.   Person|error res = Person.constructFrom(m);  if (res is Person) {    Attempts to create a new value of the type Person from the map<anydata> typed m value without changing  the inherent type of m.   io:println(\"map<anydata> to Person, name: \", res[\"name\"]);  } else {  io:println(\"Error occurred on conversion: \", res.detail());  } }    If the conversion is successful, this prints the name field.   function createNumericValues() {  string s1 = \"45\";  string s2 = \"abc\";  string s3 = \"12.3\";  string s4 = \"8\";    This function creates numeric values from string values.   int|error res1 = 'int:fromString(s1);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }    The fromString() method in the ballerina/lang.int module returns the integer value represented by a  given string if there is a valid representation, else returns an error.   res1 = 'int:fromString(s2);  if (res1 is int) {  io:println(\"int value: \", res1);  } else {  io:println(\"error: \", res1.detail());  }    float|error res2 = 'float:fromString(s3);  if (res2 is float) {  io:println(\"float value: \", res2);  } else {  io:println(\"error: \", res2.detail());  }    The fromString() method in the ballerina/lang.float module returns the float value represented by a given  string if there is a valid representation, else returns an error.   decimal|error res3 = 'decimal:fromString(s4);  if (res3 is decimal) {  io:println(\"decimal value: \", res3);  } else {  io:println(\"error: \", res3.detail());  } }    The fromString() method in the ballerina/lang.decimal module returns the decimal value represented by a given  string if there is a valid representation, else returns an error.   public function main() {    Employee emp = {name: \"Jack Sparrow\", age: 54, empNo: 100};  convertEmployeeToPerson(emp);    Attempts to convert an anydata-typed record to another anydata-typed record.   map<anydata> m = {name: \"Hector Barbossa\", age: 54, empNo: 100};  convertAnydataMapToPerson(m);    Attempts to convert an anydata constrained map to an anydata-typed record.  This conversion would be successful since all the expected elements are present.   map<anydata> n = {name: \"Elizabeth Swann\"};  convertAnydataMapToPerson(n);    This conversion would not be successful since all the required elements are not  present in the map.   createNumericValues(); }    Attempts to convert strings to numeric types.   # To run the program, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run type_conversion.bal Employee to Person, name: Jack Sparrow map<anydata> to Person, name: Hector Barbossa Error occurred on conversion: message='map<anydata>' value cannot be converted to 'Person' int value: 45 error: message='string' value 'abc' cannot be converted to 'int' float value: 12.3 decimal value: 8    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/type-test-expression.html","name":"Type Test Expression","summary":"The type test expression can be used to assert the runtime type of a value in Ballerina.\n It is an expression that always evaluates to true or false.Checks whether the actual value of the any type variable is a string.The type test can be used as a condition of an ...","content":"/  /  /  / Type Test Expression  import ballerina/io;  public function main() {  any a = \"Hello, world!\";   // Checks whether the actual value of the `any` type variable is a `string`.  boolean b = a is string;  io:println(\"Is 'a' a string? \", b);   // The type test can be used as a condition of an `if` statement.  if (a is int) {  io:println(\"'a' is an int with value: \", a);  } else if (a is string) {  io:println(\"'a' is a string with value: \", a);  } else {  io:println(\"'a' is not an int or string, with value: \", a);  }   // The type test can be used to find the runtime type of union type variables.  Student alex = {name : \"Alex\"};  Student|Person|Vehicle x = alex;   // Type of `x` is `Student`. Therefore, the `if` check will pass.  if (x is Student) {  io:println(\"Alex is a student\");  } else {  io:println(\"Alex is not a student\");  }   // Type of `x` is `Student`. However, it is structurally equivalent to `Person`.  // Therefore, the `if` check will pass.  if (x is Person) {  io:println(\"Alex is a person\");  } else {  io:println(\"Alex is not a person\");  }   // Type of `x` is Student. However, it is not structurally equivalent to `Vehicle`.  if (x is Vehicle) {  io:println(\"Alex is a vehicle\");  } else {  io:println(\"Alex is not a vehicle\");  }   // The type test expression can be used with any expression.  boolean isStudent = foo(\"student\") is Student;  io:println(\"Does foo return a student? \", isStudent);  isStudent = foo(\"vehicle\") is Student;  io:println(\"Does foo return a student? \", isStudent); }  type Person record {  string name; };  type Student record {  string name;  int age = 0; };  type Vehicle record {  string brand; };  function foo(string t) returns any {  if (t == \"student\") {  return <Student>{name: \"Alex\"};  } else if (t == \"vehicle\") {  return <Vehicle>{brand: \"Honda\"};  }  return \"invalid type\"; }    Type Test Expression  The type test expression can be used to assert the runtime type of a value in Ballerina.  It is an expression that always evaluates to true or false.    import ballerina/io;    public function main() {  any a = \"Hello, world!\";    boolean b = a is string;  io:println(\"Is 'a' a string? \", b);    Checks whether the actual value of the any type variable is a string.   if (a is int) {  io:println(\"'a' is an int with value: \", a);  } else if (a is string) {  io:println(\"'a' is a string with value: \", a);  } else {  io:println(\"'a' is not an int or string, with value: \", a);  }    The type test can be used as a condition of an if statement.   Student alex = {name : \"Alex\"};  Student|Person|Vehicle x = alex;    The type test can be used to find the runtime type of union type variables.   if (x is Student) {  io:println(\"Alex is a student\");  } else {  io:println(\"Alex is not a student\");  }    Type of x is Student. Therefore, the if check will pass.   if (x is Person) {  io:println(\"Alex is a person\");  } else {  io:println(\"Alex is not a person\");  }    Type of x is Student. However, it is structurally equivalent to Person.  Therefore, the if check will pass.   if (x is Vehicle) {  io:println(\"Alex is a vehicle\");  } else {  io:println(\"Alex is not a vehicle\");  }    Type of x is Student. However, it is not structurally equivalent to Vehicle.   boolean isStudent = foo(\"student\") is Student;  io:println(\"Does foo return a student? \", isStudent);  isStudent = foo(\"vehicle\") is Student;  io:println(\"Does foo return a student? \", isStudent); }    The type test expression can be used with any expression.   type Person record {  string name; };    type Student record {  string name;  int age = 0; };    type Vehicle record {  string brand; };    function foo(string t) returns any {  if (t == \"student\") {  return <Student>{name: \"Alex\"};  } else if (t == \"vehicle\") {  return <Vehicle>{brand: \"Honda\"};  }  return \"invalid type\"; }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run type_test_expression.bal Is 'a' a string? true 'a' is a string with value: Hello, world! Alex is a student Alex is a person Alex is not a vehicle Does foo return a student? true Does foo return a student? false    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/udp-socket-client.html","name":"Basic UDP Client Socket","summary":"The UDP Client is used to connect to a remote UDP host.\n This sample demonstrates how to send data to a remote server and print the echoed response.This is the client implementation for the UDP socket.Create a new socket client.\n Optionally, you can provide port that this socket need to ...","content":"/  /  /  / Basic UDP Client Socket  // This is the client implementation for the UDP socket. import ballerina/io; import ballerina/socket;  public function main() {  // Create a new socket client.  // Optionally, you can provide port that this socket need to bind or  // both interface and port as follows.  // socket:UdpClient client = new(localAddress = { port: 48828 });  // socket:UdpClient client = new(localAddress = { host: \"localhost\", port: 48828 });  socket:UdpClient socketClient = new;  string msg = \"Hello from UDP client\";  byte[] c1 = msg.toBytes();  // Send data to remote host.  // Second parameter is the address of the remote host.  var sendResult =  socketClient->sendTo(c1, {host: \"localhost\", port: 48826});  if (sendResult is int) {  io:println(\"Number of bytes written: \", sendResult);  } else {  error e = sendResult;  panic e;  }  // Wait until data receive from remote host.  // This will block until receive at least a single byte.  // Optionally, you can specify the length as below.  // socketClient->receiveFrom(length = 30)  // This will block until specified length of bytes receive from host.  var result = socketClient->receiveFrom();  if (result is [byte[], int, socket:Address]) {  var [content, length, address] = result;  var byteChannel = io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(60);  if (str is string) {  io:println(\"Received: \", <@untainted>str);  } else {  io:println(\"Error: \", str.detail()?.message);  }  }  } else {  io:println(\"An error occurred while receiving the data \",  result);  }  // Close the client and release the bound port.  var closeResult = socketClient->close();  if (closeResult is error) {  io:println(\"An error occurred while closing the connection \",  closeResult);  } }    Basic UDP Client Socket  The UDP Client is used to connect to a remote UDP host.  This sample demonstrates how to send data to a remote server and print the echoed response.    import ballerina/io; import ballerina/socket;    This is the client implementation for the UDP socket.   public function main() {    socket:UdpClient socketClient = new;  string msg = \"Hello from UDP client\";  byte[] c1 = msg.toBytes();    Create a new socket client.  Optionally, you can provide port that this socket need to bind or  both interface and port as follows.  socket:UdpClient client = new(localAddress = { port: 48828 });  socket:UdpClient client = new(localAddress = { host: “localhost”, port: 48828 });   var sendResult =  socketClient->sendTo(c1, {host: \"localhost\", port: 48826});  if (sendResult is int) {  io:println(\"Number of bytes written: \", sendResult);  } else {  error e = sendResult;  panic e;  }    Send data to remote host.  Second parameter is the address of the remote host.   var result = socketClient->receiveFrom();  if (result is [byte[], int, socket:Address]) {  var [content, length, address] = result;  var byteChannel = io:createReadableChannel(content);  if (byteChannel is io:ReadableByteChannel) {  io:ReadableCharacterChannel characterChannel =  new io:ReadableCharacterChannel(byteChannel, \"UTF-8\");  var str = characterChannel.read(60);  if (str is string) {  io:println(\"Received: \", <@untainted>str);  } else {  io:println(\"Error: \", str.detail()?.message);  }  }  } else {  io:println(\"An error occurred while receiving the data \",  result);  }    Wait until data receive from remote host.  This will block until receive at least a single byte.  Optionally, you can specify the length as below.  socketClient->receiveFrom(length = 30)  This will block until specified length of bytes receive from host.   var closeResult = socketClient->close();  if (closeResult is error) {  io:println(\"An error occurred while closing the connection \",  closeResult);  } }    Close the client and release the bound port.   # To run the client, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run udp_socket_client.bal    # This will print the below output upon a successful write. Number of bytes written: 21 # Print the response that is returned from the server as an echo. Received: Hello from UDP client    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/union-type.html","name":"Union Types","summary":"Union types are types of which, the set of values is the union of the value spaces of its component types.\n For example, you can use a variable of a union type to store a string or an int,\n but there is only one type of value at any given ...","content":"/  /  /  / Union Types  import ballerina/io;  // This function expects the `value` parameter to be either a `string` or an `int`. function println(string|int value) {  io:println(value); }  // This function returns either a `string` or an `error`. function getValue(string key) returns string|error {  if (key == \"\") {  error err = error(\"key '\" + key + \"' not found\");  return err;  } else {  return \"this is a value\";  } }  public function main() {  // This passes a `string` value.  println(\"This is a string\");   // This passes an `int` value.  println(101);   // This function call returns a `string` value.  string|error valueOrError1 = getValue(\"name\");  io:println(valueOrError1);   // This call returns an error.  string|error valueOrError2 = getValue(\"\");  io:println(valueOrError2); }    Union Types  Union types are types of which, the set of values is the union of the value spaces of its component types.  For example, you can use a variable of a union type to store a string or an int,  but there is only one type of value at any given time.  Syntactically, you can define a union type with component types separated by a “|” (i.e., a vertical bar).    import ballerina/io;    function println(string|int value) {  io:println(value); }    This function expects the value parameter to be either a string or an int.   function getValue(string key) returns string|error {  if (key == \"\") {  error err = error(\"key '\" + key + \"' not found\");  return err;  } else {  return \"this is a value\";  } }    This function returns either a string or an error.   public function main() {    println(\"This is a string\");    This passes a string value.   println(101);    This passes an int value.   string|error valueOrError1 = getValue(\"name\");  io:println(valueOrError1);    This function call returns a string value.   string|error valueOrError2 = getValue(\"\");  io:println(valueOrError2); }    This call returns an error.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run union_type.bal This is a string 101 this is a value error key '' not found    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/url-encode-decode.html","name":"URL Encode/Decode Operations","summary":"Ballerina encoding API supports encoding/decoding content using different URL encoding mechanisms and algorithms.Encoding a URL into a Base64-encoded string.Decoding a Base64 URL encoded string into a byte array.Encoding a URI component into a string.Decoding an encoded URI component into a string.This website uses cookies so that we can provide you ...","content":"/  /  /  / URL Encode/Decode Operations  import ballerina/encoding; import ballerina/io; import ballerina/lang.'string as str;  public function main() returns error? {  string encodingValue = \"abc123!?$*&()'-=@~\";  // Encoding a URL into a Base64-encoded string.  string urlEncodedValue = encoding:encodeBase64Url(encodingValue.toBytes());  io:println(\"Base64 URL encoded value: \" + urlEncodedValue);   string decodingValue = \"YWJjMTIzIT8kKiYoKSctPUB-\";  // Decoding a Base64 URL encoded string into a byte array.  byte[] urlDecodedValue = check encoding:decodeBase64Url(decodingValue);  io:println(\"Base64 URL decoded value: \" + check str:fromBytes(urlDecodedValue));   string encodingUriComp = \"data=value\";  // Encoding a URI component into a string.  string encodedUriComponent = check encoding:encodeUriComponent(encodingUriComp, \"UTF-8\");  io:println(\"URI encoded value: \" + encodedUriComponent);   string data = \"data%3Dvalue\";  // Decoding an encoded URI component into a string.  string decodedUriComponent = check encoding:decodeUriComponent(data, \"UTF-8\");  io:println(\"URI decoded value: \" + decodedUriComponent); }    URL Encode/Decode Operations  Ballerina encoding API supports encoding/decoding content using different URL encoding mechanisms and algorithms.    import ballerina/encoding; import ballerina/io; import ballerina/lang.'string as str;    public function main() returns error? {  string encodingValue = \"abc123!?$*&()'-=@~\";    string urlEncodedValue = encoding:encodeBase64Url(encodingValue.toBytes());  io:println(\"Base64 URL encoded value: \" + urlEncodedValue);    Encoding a URL into a Base64-encoded string.   string decodingValue = \"YWJjMTIzIT8kKiYoKSctPUB-\";    byte[] urlDecodedValue = check encoding:decodeBase64Url(decodingValue);  io:println(\"Base64 URL decoded value: \" + check str:fromBytes(urlDecodedValue));    Decoding a Base64 URL encoded string into a byte array.   string encodingUriComp = \"data=value\";    string encodedUriComponent = check encoding:encodeUriComponent(encodingUriComp, \"UTF-8\");  io:println(\"URI encoded value: \" + encodedUriComponent);    Encoding a URI component into a string.   string data = \"data%3Dvalue\";    string decodedUriComponent = check encoding:decodeUriComponent(data, \"UTF-8\");  io:println(\"URI decoded value: \" + decodedUriComponent); }    Decoding an encoded URI component into a string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run url_encode_decode.bal Base64 URL encoded value: YWJjMTIzIT8kKiYoKSctPUB- Base64 URL decoded value: abc123!?$*&()'-=@~ URI encoded value: data%3Dvalue URI decoded value: data=value    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/var.html","name":"Var","summary":"Ballerina allows you to declare variables using the var keyword instead of specifying a type.\n The type of the declared variable is inferred from the expression on the right-hand side.The variable type is inferred from the expression on the right-hand side.\n This is the same as int k = 5;The ...","content":"/  /  /  / Var  import ballerina/io;  public function main() {  // The variable type is inferred from the expression on the right-hand side.  // This is the same as `int k = 5`;  var k = 5;  io:println(10 + k);   // The type of `strVar` is `string`.  var strVar = \"Hello!\";  io:println(strVar); }    Var  Ballerina allows you to declare variables using the var keyword instead of specifying a type.  The type of the declared variable is inferred from the expression on the right-hand side.    import ballerina/io;    public function main() {    var k = 5;  io:println(10 + k);    The variable type is inferred from the expression on the right-hand side.  This is the same as int k = 5;   var strVar = \"Hello!\";  io:println(strVar); }    The type of strVar is string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run var.bal 15 Hello!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/values.html","name":"Values","summary":"Ballerina programs operate on a universe of values and each value belongs to only one basic type\n such as int, boolean, map, record, function etc. There are three kinds of values\n corresponding to three kinds of basic types. They are simple values (e.g., int, string, boolean),\n structured values (e.g., record, ...","content":"/  /  /  / Values  import ballerina/io; import ballerina/lang.'float; import ballerina/lang.'int;  // The types `int`, `float`, `decimal`, `string`, `boolean`, `byte`, and `nil` are called simple basic types // because they are basic types with only simple values. Simple values are always immutable. public function main() {  // The `int` type represents the set of 64-bit signed integers.  int i = 10;  io:println(i);   // The `ballerina/lang.int` module contains common functions that can be used  // with `int` values.  int|error i2 = 'int:fromString(\"100\");  if (i2 is int) {  io:println(i2);  }   // The `float` type represents the set of double precision IEEE 754 floating point numbers.  float f = 20.0;  io:println(f);   // The `ballerina/lang.float` module contains common functions that can be used with `float` values.  float f1 = 'float:fromBitsInt(i);  float f2 = 22.0;  float max = 'float:max(f1, f2);  io:println(\"Max float: \", max);   // The `.isNaN()`, `.isInfinite()`, and `.isFinite()` langlib functions are supported by the `float` type.  // The `.isNaN()` function will return true if the `float` value is neither finite nor infinite.  float nanVal = 0.0 / 0.0;  io:println(nanVal.isNaN());   // The `.isInfinite()` function will return true if the `float` value is neither NaN nor finite.  float infiniteVal = 12.0 / 0.0;  io:println(infiniteVal.isInfinite());   // The `.isFinite()` function will return true if the `float` value is neither NaN nor infinite.  float finiteVal = 6.0 / 3.0;  io:println(finiteVal.isFinite());   // The `decimal` type represents the set of 128-bits IEEE 754R decimal floating point numbers.  decimal d = 27.5;  io:println(d);   // The `byte` type represents the set of 8-bit unsigned integers.  byte c = 23;  io:println(c);   // The `string` type represents the set of sequences of Unicode code points.  string s = \"Ballerina\";  io:println(s);   // The `boolean` type has only two values: `true` and `false`.  boolean b = true;  io:println(b);   // The `nil` type has a single value and is used to represent the absence of any other value.  // Both the `nil` type and the `nil` value are written as `()`.  () n = ();  io:println(n);  // Another representation for the `nil` value is the `null` literal.  // However, the use of the `null` literal in only allowed in JSON contexts.  json j = null;  io:println(j); }    Values  Ballerina programs operate on a universe of values and each value belongs to only one basic type  such as int, boolean, map, record, function etc. There are three kinds of values  corresponding to three kinds of basic types. They are simple values (e.g., int, string, boolean),  structured values (e.g., record, map, array), and behavioral values (e.g., function, object).  Simple values belong to one of the simple basic types, namely nil, boolean, int, float, decimal, and  string.    import ballerina/io; import ballerina/lang.'float; import ballerina/lang.'int;    public function main() {    The types int, float, decimal, string, boolean, byte, and nil are called simple basic types  because they are basic types with only simple values. Simple values are always immutable.   int i = 10;  io:println(i);    The int type represents the set of 64-bit signed integers.   int|error i2 = 'int:fromString(\"100\");  if (i2 is int) {  io:println(i2);  }    The ballerina/lang.int module contains common functions that can be used  with int values.   float f = 20.0;  io:println(f);    The float type represents the set of double precision IEEE 754 floating point numbers.   float f1 = 'float:fromBitsInt(i);  float f2 = 22.0;  float max = 'float:max(f1, f2);  io:println(\"Max float: \", max);    The ballerina/lang.float module contains common functions that can be used with float values.   float nanVal = 0.0 / 0.0;  io:println(nanVal.isNaN());    The .isNaN(), .isInfinite(), and .isFinite() langlib functions are supported by the float type.  The .isNaN() function will return true if the float value is neither finite nor infinite.   float infiniteVal = 12.0 / 0.0;  io:println(infiniteVal.isInfinite());    The .isInfinite() function will return true if the float value is neither NaN nor finite.   float finiteVal = 6.0 / 3.0;  io:println(finiteVal.isFinite());    The .isFinite() function will return true if the float value is neither NaN nor infinite.   decimal d = 27.5;  io:println(d);    The decimal type represents the set of 128-bits IEEE 754R decimal floating point numbers.   byte c = 23;  io:println(c);    The byte type represents the set of 8-bit unsigned integers.   string s = \"Ballerina\";  io:println(s);    The string type represents the set of sequences of Unicode code points.   boolean b = true;  io:println(b);    The boolean type has only two values: true and false.   () n = ();  io:println(n);    The nil type has a single value and is used to represent the absence of any other value.  Both the nil type and the nil value are written as ().   json j = null;  io:println(j); }    Another representation for the nil value is the null literal.  However, the use of the null literal in only allowed in JSON contexts.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run values.bal 10 100 20.0 Max float: 22.0 true true true 27.5 23 Ballerina true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/variables.html","name":"Variables","summary":"Ballerina provides you with two ways to declare variables.\n You can either use the var keyword followed by the variable name and an initializer expression or use a\n type name followed by the variable name in which you can optionally specify the initializer expression.Declare a module-level variable.Declare a constant.Declare a ...","content":"/  /  /  / Variables  import ballerina/io;  // Declare a module-level variable. int total = 99;  // Declare a constant. const string OK = \"ok\";  // Declare a `public` constant. public const int COUNT = 1;  // Declare a final variable. // The value of the `final` variable is read-only. Once a value is assigned to a final // variable, it becomes immutable. All parameters of a function call are // implicitly final. final int status = 1;  public function main() {   // Access a global variable.  io:println(total);   // Access a public constant.  io:println(COUNT);   // This is a local variable.  boolean available = false;  io:println(available); }    Variables  Ballerina provides you with two ways to declare variables.  You can either use the var keyword followed by the variable name and an initializer expression or use a  type name followed by the variable name in which you can optionally specify the initializer expression.    import ballerina/io;    int total = 99;    Declare a module-level variable.   const string OK = \"ok\";    Declare a constant.   public const int COUNT = 1;    Declare a public constant.   final int status = 1;    Declare a final variable.  The value of the final variable is read-only. Once a value is assigned to a final  variable, it becomes immutable. All parameters of a function call are  implicitly final.   public function main() {    io:println(total);    Access a global variable.   io:println(COUNT);    Access a public constant.   boolean available = false;  io:println(available); }    This is a local variable.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run variables.bal 99 1 false    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/user-defined-error.html","name":"User-defined Error Types","summary":"Ballerina allows defining custom error types to match\n the errors being modeled. User defined error types in Ballerina should have\n a reason type which is a subtype of string, and a detail type which\n is a subtype of\n record {| string message?; error cause?; (anydata|error)...; |}.The nature of the default ...","content":"/  /  /  / User-defined Error Types  import ballerina/io;  const INVALID_ACC_TYPE = \"InvalidAccountType\";  // Define a record to represent the error details. // This record can have fields of `anydata|error` types and should be a subtype of the built-in error's detail type. type InvalidAccountTypeErrorData record {  string message?;  error cause?;  string accountType; };  // User-defined `error` with a `constant` reason. type InvalidAccountTypeError error<INVALID_ACC_TYPE, InvalidAccountTypeErrorData>;  function getTypeId(string accountType) returns int|InvalidAccountTypeError {  match accountType {  \"checking\" => { return 1; }  \"savings\" => { return 2; }  }   // When a constant reason is used in the error definition the error type name can be used as the error constructor,  // and the error details can be provided as named arguments, without specifying the reason.  InvalidAccountTypeError e = InvalidAccountTypeError(accountType = accountType);  return e; }  type AccountNotFoundErrorData record {  string message?;  error cause?;  int accountID; };  const INVALID_ACCOUNT_ID = \"InvalidAccountID\"; const ACCOUNT_NOT_FOUND = \"AccountNotFound\";  // Define an `error` type where error reason must be either `ACCOUNT_NOT_FOUND` or `INVALID_ACCOUNT_ID`. type AccountNotFoundError error<ACCOUNT_NOT_FOUND|INVALID_ACCOUNT_ID, AccountNotFoundErrorData>;  function getAccountBalance(int accountID) returns int|AccountNotFoundError {  if (accountID < 0) {  // Return an error with \"InvalidAccountID\" as the reason if the `accountID` is less than zero.  // The default error constructor can be used to construct the error value.  AccountNotFoundError accountNotFoundError =  error(INVALID_ACCOUNT_ID, accountID = accountID);  return accountNotFoundError;  } else if (accountID > 100) {  // Return an error with \"AccountNotFound\" as the reason if the `accountID` is greater than hundred.  AccountNotFoundError accountNotFoundError =  error(ACCOUNT_NOT_FOUND, accountID = accountID);  return accountNotFoundError;  }  // Return a value if the `accountID` is in between zero and hundred inclusive.  return 600; }  // Error detail type where `message` and `cause` are mandatory. type InquiryFailedErrorData record {|  string message;  error cause;  int accountID; |};  type AccountInquiryFailed error<string, InquiryFailedErrorData>;  function transferToAccount(int fromAccountId, int toAccountId, int amount) returns int|AccountInquiryFailed {  var balance = getAccountBalance(fromAccountId);  if (balance is error) {  // Create a new error, with the error returned from `getAccountBalance()` as the cause.  AccountInquiryFailed e = error(\"AccountInquiryFailed\", message = balance.reason(), cause = balance, accountID = fromAccountId);  return e;  } else {  // Perform transfer  }   return 0; }  public function main() {  int|InvalidAccountTypeError result = getTypeId(\"Joined\");  if (result is int) {  io:println(\"Account type ID: \", result);  } else {  io:println(\"Error: \", result.reason(),  \", Account type: \", result.detail().accountType);  }   var result2 = getAccountBalance(-1);  // If the `result` is an `int`, then print the value.  if (result2 is int) {  io:println(\"Account Balance: \", result2);  // If an error is returned, print the reason and the account ID from the detail record.  } else {  io:println(\"Error: \", result2.reason(),  \", Account ID: \", result2.detail().accountID);  }   var result3 = transferToAccount(-1, 90, 1000);  if (result3 is int) {  io:println(\"Transfer success: \", result3);  } else {  // Print the mandatory error detail fields message and cause.  io:println(\"Error: \", result3.reason(),  \", Message: \", result3.detail().message,  \", Cause: \", result3.detail().cause);  } }    User-defined Error Types  Ballerina allows defining custom error types to match  the errors being modeled. User defined error types in Ballerina should have  a reason type which is a subtype of string, and a detail type which  is a subtype of  record {| string message?; error cause?; (anydata|error)...; |}.  The nature of the default error detail record is that each field is optional  and can contain additional anydata|error fields as required.    import ballerina/io;    const INVALID_ACC_TYPE = \"InvalidAccountType\";    type InvalidAccountTypeErrorData record {  string message?;  error cause?;  string accountType; };    Define a record to represent the error details.  This record can have fields of anydata|error types and should be a subtype of the built-in error’s detail type.   type InvalidAccountTypeError error<INVALID_ACC_TYPE, InvalidAccountTypeErrorData>;    User-defined error with a constant reason.   function getTypeId(string accountType) returns int|InvalidAccountTypeError {  match accountType {  \"checking\" => { return 1; }  \"savings\" => { return 2; }  }    InvalidAccountTypeError e = InvalidAccountTypeError(accountType = accountType);  return e; }    When a constant reason is used in the error definition the error type name can be used as the error constructor,  and the error details can be provided as named arguments, without specifying the reason.   type AccountNotFoundErrorData record {  string message?;  error cause?;  int accountID; };    const INVALID_ACCOUNT_ID = \"InvalidAccountID\"; const ACCOUNT_NOT_FOUND = \"AccountNotFound\";    type AccountNotFoundError error<ACCOUNT_NOT_FOUND|INVALID_ACCOUNT_ID, AccountNotFoundErrorData>;    Define an error type where error reason must be either ACCOUNT_NOT_FOUND or INVALID_ACCOUNT_ID.   function getAccountBalance(int accountID) returns int|AccountNotFoundError {  if (accountID < 0) {    AccountNotFoundError accountNotFoundError =  error(INVALID_ACCOUNT_ID, accountID = accountID);  return accountNotFoundError;  } else if (accountID > 100) {    Return an error with “InvalidAccountID” as the reason if the accountID is less than zero.  The default error constructor can be used to construct the error value.   AccountNotFoundError accountNotFoundError =  error(ACCOUNT_NOT_FOUND, accountID = accountID);  return accountNotFoundError;  }    Return an error with “AccountNotFound” as the reason if the accountID is greater than hundred.   return 600; }    Return a value if the accountID is in between zero and hundred inclusive.   type InquiryFailedErrorData record {|  string message;  error cause;  int accountID; |};    Error detail type where message and cause are mandatory.   type AccountInquiryFailed error<string, InquiryFailedErrorData>;    function transferToAccount(int fromAccountId, int toAccountId, int amount) returns int|AccountInquiryFailed {  var balance = getAccountBalance(fromAccountId);  if (balance is error) {    AccountInquiryFailed e = error(\"AccountInquiryFailed\", message = balance.reason(), cause = balance, accountID = fromAccountId);  return e;  } else {    Create a new error, with the error returned from getAccountBalance() as the cause.   }    Perform transfer   return 0; }    public function main() {  int|InvalidAccountTypeError result = getTypeId(\"Joined\");  if (result is int) {  io:println(\"Account type ID: \", result);  } else {  io:println(\"Error: \", result.reason(),  \", Account type: \", result.detail().accountType);  }    var result2 = getAccountBalance(-1);    if (result2 is int) {  io:println(\"Account Balance: \", result2);    If the result is an int, then print the value.   } else {  io:println(\"Error: \", result2.reason(),  \", Account ID: \", result2.detail().accountID);  }    If an error is returned, print the reason and the account ID from the detail record.   var result3 = transferToAccount(-1, 90, 1000);  if (result3 is int) {  io:println(\"Transfer success: \", result3);  } else {    io:println(\"Error: \", result3.reason(),  \", Message: \", result3.detail().message,  \", Cause: \", result3.detail().cause);  } }    Print the mandatory error detail fields message and cause.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run user_defined_error.bal Error: InvalidAccountType, Account type: Joined Error: InvalidAccountID, Account ID: -1 Error: AccountInquiryFailed, Message: InvalidAccountID, Cause: error InvalidAccountID accountID=-1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-client.html","name":"Client Endpoint","summary":"The WebSocket client can be used to connect to and interact with a WebSocket server.Creates a new WebSocket client with the backend URL and assigns a callback service.Pushes a text message to the server.Prints the error.The client callback service, which handles backend responses.This resource is triggered when a new text ...","content":"/  /  /  / Client Endpoint  import ballerina/http; import ballerina/io;  public function main() {  // Creates a new WebSocket client with the backend URL and assigns a callback service.  http:WebSocketClient wsClientEp = new (\"ws://echo.websocket.org\",  config = {callbackService: ClientService});  // Pushes a text message to the server.  var err = wsClientEp->pushText(\"Hello World!\");  if (err is error) {  // Prints the error.  io:println(err);  } } // The client callback service, which handles backend responses. service ClientService = @http:WebSocketServiceConfig {} service {   // This resource is triggered when a new text frame is received from the remote backend.  resource function onText(http:WebSocketClient conn, string text, boolean finalFrame) {  io:println(text);  }  // This is triggered if an error occurs.  resource function onError(http:WebSocketClient conn, error err) {  io:println(err);  } };    Client Endpoint  The WebSocket client can be used to connect to and interact with a WebSocket server.    import ballerina/http; import ballerina/io;    public function main() {    http:WebSocketClient wsClientEp = new (\"ws://echo.websocket.org\",  config = {callbackService: ClientService});    Creates a new WebSocket client with the backend URL and assigns a callback service.   var err = wsClientEp->pushText(\"Hello World!\");  if (err is error) {    Pushes a text message to the server.   io:println(err);  } }    Prints the error.   service ClientService = @http:WebSocketServiceConfig {} service {    The client callback service, which handles backend responses.   resource function onText(http:WebSocketClient conn, string text, boolean finalFrame) {  io:println(text);  }    This resource is triggered when a new text frame is received from the remote backend.   resource function onError(http:WebSocketClient conn, error err) {  io:println(err);  } };    This is triggered if an error occurs.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. ballerina run websocket_client.bal    Hello World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-chat-application.html","name":"Chat Application","summary":"This example explains how to write a simple chat application using Ballerina.Upgrade from HTTP to WebSocket and define the service the WebSocket client needs to connect to.Retrieve query parameters from the http:Request.Cancel the handshake by sending a 400 status code if the age parameter is missing in the request.The attributes ...","content":"/  /  /  / Chat Application  import ballerina/http; import ballerina/log;  final string NAME = \"NAME\"; final string AGE = \"AGE\";  @http:ServiceConfig {  basePath: \"/chat\" } service chatAppUpgrader on new http:Listener(9090) {   // Upgrade from HTTP to WebSocket and define the service the WebSocket client needs to connect to.  @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/{name}\",  upgradeService: chatApp  }  }  resource function upgrader(http:Caller caller, http:Request req,  string name) {  // Retrieve query parameters from the `http:Request`.  map<string[]> queryParams = req.getQueryParams();  // Cancel the handshake by sending a 400 status code if the age parameter is missing in the request.  if (!queryParams.hasKey(\"age\")) {  var err = caller->cancelWebSocketUpgrade(400, \"Age is required\");  if (err is http:WebSocketError) {  log:printError(\"Error cancelling handshake\", err);  }  return;  }  map<string> headers = {};  http:WebSocketCaller|http:WebSocketError wsEp = caller->acceptWebSocketUpgrade(headers);  if (wsEp is http:WebSocketCaller) {  // The attributes of the caller is useful for storing connection-specific data.  // In this case, the `NAME`and `AGE` are unique to each connection.  wsEp.setAttribute(NAME, name);  string? ageValue = req.getQueryParamValue(\"age\");  string age = ageValue is string ? ageValue : \"\";  wsEp.setAttribute(AGE, age);  string msg =  \"Hi \" + name + \"! You have successfully connected to the chat\";  var err = wsEp->pushText(msg);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } else {  log:printError(\"Error during WebSocket upgrade\", wsEp);  }  } }  // Stores the connection IDs of users who join the chat. map<http:WebSocketCaller> connectionsMap = {};  service chatApp = @http:WebSocketServiceConfig {} service {   // Once a user connects to the chat, store the attributes of the user, such as username and age, and  // broadcast that the user has joined the chat.  resource function onOpen(http:WebSocketCaller caller) {  string msg;  msg = getAttributeStr(caller, NAME) + \" with age \"  + getAttributeStr(caller, AGE) + \" connected to chat\";  broadcast(msg);  connectionsMap[caller.getConnectionId()] = <@untainted>caller;  }   // Broadcast the messages sent by a user.  resource function onText(http:WebSocketCaller caller, string text) {  string msg = getAttributeStr(caller, NAME) + \": \" + text;  log:printInfo(msg);  broadcast(msg);  }   // Broadcast that a user has left the chat once a user leaves the chat.  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  _ = connectionsMap.remove(caller.getConnectionId());  string msg = getAttributeStr(caller, NAME) + \" left the chat\";  broadcast(msg);  } };  // Function to perform the broadcasting of text messages. function broadcast(string text) {  foreach var con in connectionsMap {  var err = con->pushText(text);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } }  function getAttributeStr(http:WebSocketCaller ep, string key) returns (string) {  var name = ep.getAttribute(key);  return name.toString(); }    Chat Application  This example explains how to write a simple chat application using Ballerina.    import ballerina/http; import ballerina/log;    final string NAME = \"NAME\"; final string AGE = \"AGE\";    @http:ServiceConfig {  basePath: \"/chat\" } service chatAppUpgrader on new http:Listener(9090) {    @http:ResourceConfig {  webSocketUpgrade: {  upgradePath: \"/{name}\",  upgradeService: chatApp  }  }  resource function upgrader(http:Caller caller, http:Request req,  string name) {    Upgrade from HTTP to WebSocket and define the service the WebSocket client needs to connect to.   map<string[]> queryParams = req.getQueryParams();    Retrieve query parameters from the http:Request.   if (!queryParams.hasKey(\"age\")) {  var err = caller->cancelWebSocketUpgrade(400, \"Age is required\");  if (err is http:WebSocketError) {  log:printError(\"Error cancelling handshake\", err);  }  return;  }  map<string> headers = {};  http:WebSocketCaller|http:WebSocketError wsEp = caller->acceptWebSocketUpgrade(headers);  if (wsEp is http:WebSocketCaller) {    Cancel the handshake by sending a 400 status code if the age parameter is missing in the request.   wsEp.setAttribute(NAME, name);  string? ageValue = req.getQueryParamValue(\"age\");  string age = ageValue is string ? ageValue : \"\";  wsEp.setAttribute(AGE, age);  string msg =  \"Hi \" + name + \"! You have successfully connected to the chat\";  var err = wsEp->pushText(msg);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } else {  log:printError(\"Error during WebSocket upgrade\", wsEp);  }  } }    The attributes of the caller is useful for storing connection-specific data.  In this case, the NAMEand AGE are unique to each connection.   map<http:WebSocketCaller> connectionsMap = {};    Stores the connection IDs of users who join the chat.   service chatApp = @http:WebSocketServiceConfig {} service {    resource function onOpen(http:WebSocketCaller caller) {  string msg;  msg = getAttributeStr(caller, NAME) + \" with age \"  + getAttributeStr(caller, AGE) + \" connected to chat\";  broadcast(msg);  connectionsMap[caller.getConnectionId()] = <@untainted>caller;  }    Once a user connects to the chat, store the attributes of the user, such as username and age, and  broadcast that the user has joined the chat.   resource function onText(http:WebSocketCaller caller, string text) {  string msg = getAttributeStr(caller, NAME) + \": \" + text;  log:printInfo(msg);  broadcast(msg);  }    Broadcast the messages sent by a user.   resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  _ = connectionsMap.remove(caller.getConnectionId());  string msg = getAttributeStr(caller, NAME) + \" left the chat\";  broadcast(msg);  } };    Broadcast that a user has left the chat once a user leaves the chat.   function broadcast(string text) {  foreach var con in connectionsMap {  var err = con->pushText(text);  if (err is http:WebSocketError) {  log:printError(\"Error sending message\", err);  }  } }    Function to perform the broadcasting of text messages.   function getAttributeStr(http:WebSocketCaller ep, string key) returns (string) {  var name = ep.getAttribute(key);  return name.toString(); }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. ballerina run websocket_chat_application.bal    # To check the sample, use the Chrome or Firefox JavaScript console and run the following commands. <br> # Run the first 3 lines of the following code in two or more different consoles and see how the messages are received. # Change the names and/or age in the `/chat/fistName?age` URI so that they are different for each client. var ws = new WebSocket(\"ws://localhost:9090/chat/bruce?age=30\"); ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send messages. ws.send(\"hello world\");    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-basic-sample.html","name":"Basic Server Functionalities","summary":"This example explains the basic functions of a WebSocket server endpoint.This resource is triggered after a successful client connection.This resource is triggered when a new text frame is received from a client.This resource is triggered when a new binary frame is received from a client.This resource is triggered when a ...","content":"/  /  /  / Basic Server Functionalities  import ballerina/http; import ballerina/io; import ballerina/log;  string ping = \"ping\"; byte[] pingData = ping.toBytes();  @http:WebSocketServiceConfig {  path: \"/basic/ws\",  subProtocols: [\"xml\", \"json\"],  idleTimeoutInSeconds: 120 } service basic on new http:Listener(9090) {   // This `resource` is triggered after a successful client connection.  resource function onOpen(http:WebSocketCaller caller) {  io:println(\"\\nNew client connected\");  io:println(\"Connection ID: \" + caller.getConnectionId());  io:println(\"Negotiated Sub protocol: \" + caller.getNegotiatedSubProtocol().toString());  io:println(\"Is connection open: \" + caller.isOpen().toString());  io:println(\"Is connection secured: \" + caller.isSecure().toString());  }   // This `resource` is triggered when a new text frame is received from a client.  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  io:println(\"\\ntext message: \" + text + \" & final fragment: \"  + finalFrame.toString());  if (text == \"ping\") {  io:println(\"Pinging...\");  var err = caller->ping(pingData);  if (err is http:WebSocketError) {  log:printError(\"Error sending ping\", err);  }  } else if (text == \"closeMe\") {  error? result = caller->close(statusCode = 1001,  reason = \"You asked me to close the connection\",  timeoutInSeconds = 0);  if (result is http:WebSocketError) {  log:printError(\"Error occurred when closing connection\", result);  }  } else {  var err = caller->pushText(\"You said: \" + text);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text\", err);  }  }  }   // This `resource` is triggered when a new binary frame is received from a client.  resource function onBinary(http:WebSocketCaller caller, byte[] b) {  io:println(\"\\nNew binary message received\");  io:print(\"UTF-8 decoded binary message: \");  io:println(b);  var err = caller->pushBinary(b);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary\", err);  }  }   // This `resource` is triggered when a ping message is received from the client. If this resource is not implemented,  // a pong message is automatically sent to the connected `http:WebSocketCaller` when a ping is received.  resource function onPing(http:WebSocketCaller caller, byte[] data) {  var err = caller->pong(data);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }   // This resource is triggered when a pong message is received.  resource function onPong(http:WebSocketCaller caller, byte[] data) {  io:println(\"Pong received\");  }   // This resource is triggered when a particular client reaches the idle timeout that is defined in the  // `http:WebSocketServiceConfig` annotation.  resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"\\nReached idle timeout\");  io:println(\"Closing connection \" + caller.getConnectionId());  var err = caller->close(statusCode = 1001, reason =  \"Connection timeout\");  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }   // This resource is triggered when an error occurred in the connection or the transport.  // This resource is always followed by a connection closure with an appropriate WebSocket close frame  // and this is used only to indicate the error to the user and take post decisions if needed.  resource function onError(http:WebSocketCaller caller, error err) {  log:printError(\"Error occurred \", err);  }   // This resource is triggered when a client connection is closed from the client side.  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  io:println(string `Client left with ${statusCode} because ${reason}`);  } }    Basic Server Functionalities  This example explains the basic functions of a WebSocket server endpoint.    import ballerina/http; import ballerina/io; import ballerina/log;    string ping = \"ping\"; byte[] pingData = ping.toBytes();    @http:WebSocketServiceConfig {  path: \"/basic/ws\",  subProtocols: [\"xml\", \"json\"],  idleTimeoutInSeconds: 120 } service basic on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {  io:println(\"\\nNew client connected\");  io:println(\"Connection ID: \" + caller.getConnectionId());  io:println(\"Negotiated Sub protocol: \" + caller.getNegotiatedSubProtocol().toString());  io:println(\"Is connection open: \" + caller.isOpen().toString());  io:println(\"Is connection secured: \" + caller.isSecure().toString());  }    This resource is triggered after a successful client connection.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  io:println(\"\\ntext message: \" + text + \" & final fragment: \"  + finalFrame.toString());  if (text == \"ping\") {  io:println(\"Pinging...\");  var err = caller->ping(pingData);  if (err is http:WebSocketError) {  log:printError(\"Error sending ping\", err);  }  } else if (text == \"closeMe\") {  error? result = caller->close(statusCode = 1001,  reason = \"You asked me to close the connection\",  timeoutInSeconds = 0);  if (result is http:WebSocketError) {  log:printError(\"Error occurred when closing connection\", result);  }  } else {  var err = caller->pushText(\"You said: \" + text);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text\", err);  }  }  }    This resource is triggered when a new text frame is received from a client.   resource function onBinary(http:WebSocketCaller caller, byte[] b) {  io:println(\"\\nNew binary message received\");  io:print(\"UTF-8 decoded binary message: \");  io:println(b);  var err = caller->pushBinary(b);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary\", err);  }  }    This resource is triggered when a new binary frame is received from a client.   resource function onPing(http:WebSocketCaller caller, byte[] data) {  var err = caller->pong(data);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }    This resource is triggered when a ping message is received from the client. If this resource is not implemented,  a pong message is automatically sent to the connected http:WebSocketCaller when a ping is received.   resource function onPong(http:WebSocketCaller caller, byte[] data) {  io:println(\"Pong received\");  }    This resource is triggered when a pong message is received.   resource function onIdleTimeout(http:WebSocketCaller caller) {  io:println(\"\\nReached idle timeout\");  io:println(\"Closing connection \" + caller.getConnectionId());  var err = caller->close(statusCode = 1001, reason =  \"Connection timeout\");  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  }    This resource is triggered when a particular client reaches the idle timeout that is defined in the  http:WebSocketServiceConfig annotation.   resource function onError(http:WebSocketCaller caller, error err) {  log:printError(\"Error occurred \", err);  }    This resource is triggered when an error occurred in the connection or the transport.  This resource is always followed by a connection closure with an appropriate WebSocket close frame  and this is used only to indicate the error to the user and take post decisions if needed.   resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {  io:println(string `Client left with ${statusCode} because ${reason}`);  } }    This resource is triggered when a client connection is closed from the client side.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command. ballerina run websocket_basic_sample.bal    # To check the sample, use a Chrome or Firefox JavaScript console and run the following commands. <br> # Change `xml` to another sub protocol to observe the behavior of the WebSocket server. var ws = new WebSocket(\"ws://localhost:9090/basic/ws\", \"xml\", \"my-protocol\");    ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send a message. ws.send(\"hello world\");    # Use an advanced client to check the ping and pong since the browser client does not have the capability to send pings. # Use the following command to observe the behavior when the server sends a ping message to the browser client. ws.send(\"ping\");    # Close the connection. ws.close(1000, \"I want to go\");    # Close the connection from the server side. ws.send(\"closeMe\");    # Wait for 120 seconds to check the connection closure due to the connection timeout # or change the timeout in the configuration annotation.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-proxy-server.html","name":"Proxy Server","summary":"Ballerina can act as a proxy to another remote service. Ballerina forwards the\nrequests sent by the clients that connect to it via a WebSocket to the respective remote service.The Url of the remote backend.This resource gets invoked when a new client connects.\n Since messages to the server are not read ...","content":"/  /  /  / Proxy Server  import ballerina/http; import ballerina/log;  final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\"; // The Url of the remote backend. final string REMOTE_BACKEND = \"ws://echo.websocket.org\";  @http:WebSocketServiceConfig {  path: \"/proxy/ws\" } service SimpleProxyService on new http:Listener(9090) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service until the execution of the `onOpen` resource finishes,  // operations which should happen before reading messages should be done in the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {   http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: ClientService,  // When creating client endpoint, if `readyOnConnect` flag is set to  // `false` client endpoint does not start reading frames automatically.  readyOnConnect: false  }  );  //Associate connections before starting to read messages.  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);   // Once the client is ready to receive frames the remote function `ready`  // of the client need to be called separately.  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }   //This resource gets invoked upon receiving a new text frame from a client.  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   //This resource gets invoked upon receiving a new binary frame from a client.  resource function onBinary(http:WebSocketCaller caller, byte[] data,  boolean finalFrame) {   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }   //This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketCaller caller, error err) {   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hence closing the connection\", err);  }   //This resource gets invoked when a client connection is closed from the client side.  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } }  //Client service to receive frames from the remote server. service ClientService = @http:WebSocketServiceConfig {} service {   //This resource gets invoked upon receiving a new text frame from the remote backend.  resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   //This resource gets invoked upon receiving a new binary frame from the remote backend.  resource function onBinary(http:WebSocketClient caller, byte[] data,  boolean finalFrame) {   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }   //This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketClient caller, error err) {   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hense closing the connection\", err);  }   //This resource gets invoked when a client connection is closed by the remote backend.  resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } };  // Function to retrieve associated client for a particular caller. function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient =  <http:WebSocketClient>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }  // Function to retrieve the associated caller for a client. function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =  <http:WebSocketCaller>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Proxy Server  Ballerina can act as a proxy to another remote service. Ballerina forwards the requests sent by the clients that connect to it via a WebSocket to the respective remote service.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    final string REMOTE_BACKEND = \"ws://echo.websocket.org\";    The Url of the remote backend.   @http:WebSocketServiceConfig {  path: \"/proxy/ws\" } service SimpleProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen resource finishes,  operations which should happen before reading messages should be done in the onOpen resource.   http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: ClientService,    readyOnConnect: false  }  );    When creating client endpoint, if readyOnConnect flag is set to  false client endpoint does not start reading frames automatically.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames the remote function ready  of the client need to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onBinary(http:WebSocketCaller caller, byte[] data,  boolean finalFrame) {    This resource gets invoked upon receiving a new binary frame from a client.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hence closing the connection\", err);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketClient clientEp =  getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } }    service ClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onBinary(http:WebSocketClient caller, byte[] data,  boolean finalFrame) {    This resource gets invoked upon receiving a new binary frame from the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->pushBinary(data, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending binary message\", err);  }  }    resource function onError(http:WebSocketClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by the remote backend.   http:WebSocketCaller serverEp =  getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  _ = caller.removeAttribute(ASSOCIATED_CONNECTION);  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient =  <http:WebSocketClient>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve associated client for a particular caller.   function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =  <http:WebSocketCaller>ep.getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller for a client.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command below. ballerina run websocket_proxy_server.bal    # Now, this service can be invoked by any WebSocket client using the url \"ws://localhost:9090/proxy/ws\"    # To check the sample, you can use Chrome or Firefox JavaScript console and run the following commands. <br> var ws = new WebSocket(\"ws://localhost:9090/proxy/ws\"); ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send messages. ws.send(\"hello world\");    #Close the connection. ws.close(1000, \"I want to go\");    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/while.html","name":"While","summary":"A while loop statement repeatedly executes the code block that is defined within the while block as long as a given\n condition is met.This is a basic while loop.The break statement can be used to break the loop.The continue statement can be used to move to the\n next loop iteration ...","content":"/  /  /  / While  import ballerina/io;  public function main() {  int i = 0;  // This is a basic `while` loop.  while (i < 3) {  io:println(i);  i = i + 1;  }   int j = 0;  while (j < 5) {  io:println(j);  j = j + 1;   // The `break` statement can be used to break the loop.  if (j == 3) {  break;  }  }   int k = 0;  while (k < 5) {  // The `continue` statement can be used to move to the  // next loop iteration immediately.  if (k < 3) {  k = k + 1;  continue;  }   io:println(k);  k = k + 1;  } }    While  A while loop statement repeatedly executes the code block that is defined within the while block as long as a given  condition is met.    import ballerina/io;    public function main() {  int i = 0;    while (i < 3) {  io:println(i);  i = i + 1;  }    This is a basic while loop.   int j = 0;  while (j < 5) {  io:println(j);  j = j + 1;    if (j == 3) {  break;  }  }    The break statement can be used to break the loop.   int k = 0;  while (k < 5) {    if (k < 3) {  k = k + 1;  continue;  }    The continue statement can be used to move to the  next loop iteration immediately.   io:println(k);  k = k + 1;  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run while.bal 0 1 2 0 1 2 3 4    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-retry.html","name":"Retry","summary":"If the WebSocket client lost a connection by the server being shut down or by getting any IOExceptions, Ballerina automatically reconnects to the same backend until the connection becomes successful or until the maximum reconnect attempts count is reached.The URL of the remote backend.This resource gets invoked when a new ...","content":"/  /  /  / Retry  import ballerina/http; import ballerina/log;  final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";  // The URL of the remote backend. const string REMOTE_BACKEND = \"ws://localhost:9095/retry/ws\";  @http:WebSocketServiceConfig {  path: \"/retry/ws\" } service retryProxyService on new http:Listener(9090) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service until  // the execution of the `onOpen` resource finishes,  // operations, which should happen before reading messages should be done  // in the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {   // Defines the webSocket client.  http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: retryClientService,  // When creating client endpoint, if `readyOnConnect` flag is set to  // `false`, client endpoint does not start reading frames automatically.  readyOnConnect: false,  // Retry configuration options.  retryConfig: {  // The number of milliseconds to delay before attempting to reconnect.  intervalInMillis: 3000,  // The maximum number of retry attempts.  // If the count is zero, the client will retry indefinitely.  maxCount: 20,  // The rate of increase of the reconnect delay.  backOffFactor: 2.0,  // Upper limit of the retry interval in milliseconds. If  // `intervalInMillis` into `backOffFactor` value exceeded  // `maxWaitIntervalInMillis` interval value, then  // `maxWaitIntervalInMillis` will be considered as the retry interval.  maxWaitIntervalInMillis: 20000  }  });   // Associate connections before starting to read messages.  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);   // Once the client is ready to receive frames, the remote function `ready`  // of the client needs to be called separately.  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }   // This resource gets invoked upon receiving a new text frame from a client.  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   // This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketCaller caller, error err) {   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", e);  }   // This resource gets invoked when a client connection is closed from the client side.  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }  // Client service to receive frames from the remote server. service retryClientService = @http:WebSocketServiceConfig {} service {   // This resource gets invoked upon receiving a new text frame from  // the remote backend.  resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   // This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketClient caller, error err) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }   // This resource gets invoked when a client connection is closed by  // the remote backend.  resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };  // Function to retrieve the associated client of a particular caller. function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient = <http:WebSocketClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }  // Function to retrieve the associated caller of a client. function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint = <http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; } import ballerina/http; import ballerina/log;  // The annotation which is used to configure a WebSocket service. @http:WebSocketServiceConfig {  path: \"/retry/ws\" }  // Define the backend service with port 9095, which is called by the client. service server on new http:Listener(9095) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service  // until the execution of the `onOpen` resource finishes,  // operations which should happen before reading messages should be  // done in the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connected wih the server. \" +  \"The Connection ID: \" + caller.getConnectionId());  }   // This resource gets invoked when a server is receiving  // a text message from the client.  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    Retry  If the WebSocket client lost a connection by the server being shut down or by getting any IOExceptions, Ballerina automatically reconnects to the same backend until the connection becomes successful or until the maximum reconnect attempts count is reached.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    const string REMOTE_BACKEND = \"ws://localhost:9095/retry/ws\";    The URL of the remote backend.   @http:WebSocketServiceConfig {  path: \"/retry/ws\" } service retryProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until  the execution of the onOpen resource finishes,  operations, which should happen before reading messages should be done  in the onOpen resource.   http:WebSocketClient wsClientEp = new (  REMOTE_BACKEND,  {  callbackService: retryClientService,    Defines the webSocket client.   readyOnConnect: false,    When creating client endpoint, if readyOnConnect flag is set to  false, client endpoint does not start reading frames automatically.   retryConfig: {    Retry configuration options.   intervalInMillis: 3000,    The number of milliseconds to delay before attempting to reconnect.   maxCount: 20,    The maximum number of retry attempts.  If the count is zero, the client will retry indefinitely.   backOffFactor: 2.0,    The rate of increase of the reconnect delay.   maxWaitIntervalInMillis: 20000  }  });    Upper limit of the retry interval in milliseconds. If  intervalInMillis into backOffFactor value exceeded  maxWaitIntervalInMillis interval value, then  maxWaitIntervalInMillis will be considered as the retry interval.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames, the remote function ready  of the client needs to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", e);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }    service retryClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketClient) {  http:WebSocketClient wsClient = <http:WebSocketClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve the associated client of a particular caller.   function getAssociatedServerEndpoint(http:WebSocketClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint = <http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller of a client.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `ballerina run` command.    ballerina run websocket_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 ballerina run websocket_retry.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Now, this service can be invoked by any WebSocket client using the URL: \"ws://localhost:9090/retry/ws\".    # To check the sample, you can use Chrome or Firefox JavaScript console and run the following commands. <br> var ws = new WebSocket(\"ws://localhost:9090/retry/ws\"); ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send messages. ws.send(\"hello world\");    # To stop the running service, press Ctrl + C. # Restart the service.    # Send messages. ws.send(\"hello world\");    # Close the connection. ws.close(1000, \"I want to go\");    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/retry/ws\" }    The annotation which is used to configure a WebSocket service.   service server on new http:Listener(9095) {    Define the backend service with port 9095, which is called by the client.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connected wih the server. \" +  \"The Connection ID: \" + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service  until the execution of the onOpen resource finishes,  operations which should happen before reading messages should be  done in the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving  a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run webSocket_service.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 13:31:38,842 INFO [] - WebSocket client connected wih the server. The Connection ID: 08d40cfffe258b13-00000bfd-00000001-a1eade696304c59e-7f64181e    # Stop the running service. [ballerina/http] stopped HTTP/WS listener 0.0.0.0:9095    # Restart the service. ballerina run websocket_service.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 13:34:55,543 INFO [] - WebSocket client connected wih the server. The Connection ID: 08d40cfffe258b13-0000118b-00000001-9bc9b9fb2d07c5b5-8fb73e4f    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websub-internal-hub-sample.html","name":"Internal Hub Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process will be initiated at the startup. Signature validation\n is ...","content":"/  /  /  / Internal Hub Sample  // The Ballerina WebSub Publisher brings up the internal Ballerina hub, registers a topic at the hub, and publishes updates to the topic. import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;  public function main() {   // Specifies the port that the internal Ballerina hub needs to start on and start the hub.  io:println(\"Starting up the Ballerina Hub Service\");   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }   // Registers a topic at the hub.  var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }   // Makes the publisher wait until the subscriber subscribes at the hub.  runtime:sleep(5000);   // Publishes directly to the internal Ballerina hub.  io:println(\"Publishing update to internal Hub\");  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});   if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }   // Keeps the service is running until the subscriber receives the update notification.  runtime:sleep(2000); } // Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub. import ballerina/http; import ballerina/log; import ballerina/websub;  // The endpoint to which the subscriber service is bound. listener websub:Listener websubEP = new websub:Listener(8181);  // Annotations specifying the subscription parameters. @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {   // Define sthe resource, which accepts the intent verification requests.  // If the resource is not specified, intent verification happens automatically. It verifies if the topic specified in the intent  // verification request matches the topic specified as the annotation.  resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {  // Builds the response to the intent verification request that was received for subscription.  http:Response response =  request.buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");  if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);   if (result is error) {  log:printError(\"Error responding to intent verification request\",  err = result);  }  }   // Defines the resource that accepts the content delivery requests.  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Internal Hub Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process will be initiated at the startup. Signature validation  is performed by default for subscribers that receive authenticated content. Ballerina WebSub Subscriber  Services could thus be registered as webhooks to receive event notifications.  Ballerina also comes with an in-built WebSub Hub service, which can be brought up by publishers that need to bring  up a hub.  In this example, a WebSub Publisher brings up an internal hub and publishes updates to it, and a WebSub Subscriber  subscribes at the publisher’s hub to receive notifications of the updates sent to the topic.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher brings up the internal Ballerina hub, registers a topic at the hub, and publishes updates to the topic.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");    Specifies the port that the internal Ballerina hub needs to start on and start the hub.   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   io:println(\"Publishing update to internal Hub\");  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});    Publishes directly to the internal Ballerina hub.   if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    runtime:sleep(2000); }    Keeps the service is running until the subscriber receives the update notification.   # This sample requires starting up the Subscriber Service after the Publisher starts up the hub and registers the topic. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run publisher.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub Topic registration successful! [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 2019-11-01 14:12:22,809 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:12:22,906 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:12:23,139 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Publishing update to internal Hub Update notification successful!    import ballerina/http; import ballerina/log; import ballerina/websub;    Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub.   listener websub:Listener websubEP = new websub:Listener(8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.   resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {    Define sthe resource, which accepts the intent verification requests.  If the resource is not specified, intent verification happens automatically. It verifies if the topic specified in the intent  verification request matches the topic specified as the annotation.   http:Response response =  request.buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");  if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);    Builds the response to the intent verification request that was received for subscription.   if (result is error) {  log:printError(\"Error responding to intent verification request\",  err = result);  }  }    resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource that accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:12:22,870 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] 2019-11-01 14:12:23,074 INFO [] - Intent verified for subscription request 2019-11-01 14:12:25,035 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websub-hub-client-sample.html","name":"Hub Client Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process would be initiated at the startup.\n The subscription/unsubscription process ...","content":"/  /  /  / Hub Client Sample  // The Ballerina WebSub Publisher brings up the internal Ballerina Hub, // registers a topic at the hub, and publishes updates to the topic. import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;  public function main() {   // Starts the internal Ballerina Hub.  io:println(\"Starting up the Ballerina Hub Service\");  websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }  // Registers a topic at the hub.  var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }   // Makes the publisher wait until the subscriber subscribes at the hub.  runtime:sleep(5000);   // Publishes directly to the internal Ballerina Hub.  var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }   // Makes the publisher wait until the subscriber unsubscribes at the hub.  runtime:sleep(5000);   // Publishes directly to the internal Ballerina Hub.  publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }   // Makes the publisher wait until subscribers are notified.  runtime:sleep(2000); } // The Ballerina WebSub Subscriber service, which represents the callback registered at the Hub. import ballerina/log; import ballerina/websub;  // The endpoint to which the subscriber service is bound. listener websub:Listener websubEP = new (8181);  // Annotations specifying the subscription parameters. // The omission of `subscribeOnStartUp` as an annotation due to which a subscription request would not be sent // automatically on the start up. // Also, the exclusion of the onIntentVerification resource will result in auto intent-verification. @websub:SubscriberServiceConfig {  path: \"/websub\",  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {   // This resource accepts content delivery requests.  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } } // The Ballerina main program, which demonstrates the usage of the Hub client endpoint to subscribe/unsubscribe to notifications. import ballerina/io; import ballerina/runtime; import ballerina/websub;  websub:SubscriptionClient websubHubClientEP =  new (\"http://localhost:9191/websub/hub\");  public function main() {   // Sends the subscription request for the subscriber service.  websub:SubscriptionChangeRequest subscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\",  secret: \"Kslk30SNF2AChs2\"  };   var response = websubHubClientEP->subscribe(subscriptionRequest);   if (response is websub:SubscriptionChangeResponse) {  io:println(\"Subscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Subscription Request: \" + errCause);  }   // Waits for the initial notification before unsubscribing.  runtime:sleep(5000);   // Sends the unsubscription request to the subscriber service.  websub:SubscriptionChangeRequest unsubscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\"  };   response = websubHubClientEP->unsubscribe(unsubscriptionRequest);   if (response is websub:SubscriptionChangeResponse) {  io:println(\"Unsubscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Unsubscription Request: \" + errCause);  } }    Hub Client Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process would be initiated at the startup.  The subscription/unsubscription process could also be initiated via the Ballerina WebSub Hub Client Endpoint.  This example demonstrates the usage of the WebSub Hub Client Endpoint to subscribe and unsubscribe to updates for  a particular topic at the hub. Also, it demonstrates auto intent verification in which intent verification for subscription or  unsubscription requests would happen automatically (against the annotated topic) if the onIntentVerification request  is not included.  The Hub Client Endpoint can be used by subscribers to subscribe/unsubscribe at a Hub, and by publishers to  register topics and publish updates for topics at the Hub.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher brings up the internal Ballerina Hub,  registers a topic at the hub, and publishes updates to the topic.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");  websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");  if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    Starts the internal Ballerina Hub.   var registrationResponse = webSubHub.registerTopic(  \"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   var publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes directly to the internal Ballerina Hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber unsubscribes at the hub.   publishResponse = webSubHub.publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"internal-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes directly to the internal Ballerina Hub.   runtime:sleep(2000); }    Makes the publisher wait until subscribers are notified.   # This sample requires running the subscriber client main program after the # Publisher starts up the hub and registers the topic, and the subscriber # service (representing the callback) is started. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run publisher.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 Topic registration successful! 2019-11-01 14:06:38,035 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:38,255 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:38,781 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Update notification successful! 2019-11-01 14:06:40,572 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:40,576 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:40,627 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] Update notification successful! 2019-11-01 14:06:45,628 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:06:45,637 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:06:45,695 INFO [ballerina/websub] - Intent verification successful for mode: [unsubscribe], for callback URL: [http://localhost:8181/websub]    import ballerina/log; import ballerina/websub;    The Ballerina WebSub Subscriber service, which represents the callback registered at the Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.  The omission of subscribeOnStartUp as an annotation due to which a subscription request would not be sent  automatically on the start up.  Also, the exclusion of the onIntentVerification resource will result in auto intent-verification.   resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    This resource accepts content delivery requests.   # The update published after unsubscription is not received by the subscriber service. # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run subscriber_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:06:38,171 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://websubpubtopic.com], Lease Seconds [86400] 2019-11-01 14:06:40,196 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"} ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://websubpubtopic.com], Lease Seconds [86400] 2019-11-01 14:06:45,052 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"internal-hub\"} ballerina: Intent Verification agreed - Mode [unsubscribe], Topic [http://websubpubtopic.com]    import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina main program, which demonstrates the usage of the Hub client endpoint to subscribe/unsubscribe to notifications.   websub:SubscriptionClient websubHubClientEP =  new (\"http://localhost:9191/websub/hub\");    public function main() {    websub:SubscriptionChangeRequest subscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\",  secret: \"Kslk30SNF2AChs2\"  };    Sends the subscription request for the subscriber service.   var response = websubHubClientEP->subscribe(subscriptionRequest);    if (response is websub:SubscriptionChangeResponse) {  io:println(\"Subscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Subscription Request: \" + errCause);  }    runtime:sleep(5000);    Waits for the initial notification before unsubscribing.   websub:SubscriptionChangeRequest unsubscriptionRequest = {  topic: \"http://websubpubtopic.com\",  callback: \"http://localhost:8181/websub\"  };    Sends the unsubscription request to the subscriber service.   response = websubHubClientEP->unsubscribe(unsubscriptionRequest);    if (response is websub:SubscriptionChangeResponse) {  io:println(\"Unsubscription Request successful at Hub [\" + response.hub +  \"] for Topic [\" + response.topic + \"]\");  } else {  error err = response;  string errCause = <string>err.detail()?.message;  io:println(\"Error occurred with Unsubscription Request: \" + errCause);  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run subscription_change_client.bal Subscription Request successful at Hub [http://localhost:9191/websub/hub] for Topic [http://websubpubtopic.com] Unsubscription Request successful at Hub [http://localhost:9191/websub/hub] for Topic [http://websubpubtopic.com]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websocket-failover.html","name":"Failover","summary":"Ballerina users can configure multiple backends in a given failover config. If the client looses the connection by the server being shut down or by getting any IOExceptions, Ballerina automatically tries to connect with the remaining backends that are specified in the configuration. The trying happens only once for each ...","content":"/  /  /  / Failover  import ballerina/http; import ballerina/log;  final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";  @http:WebSocketServiceConfig {  path: \"/failover/ws\" } service failoverProxyService on new http:Listener(9090) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service until  // the execution of the `onOpen` resource finishes,  // operations, which should happen before reading messages should be done  // in the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {   // Defines the webSocket failover client.  http:WebSocketFailoverClient wsClientEp = new (  {  callbackService: failoverClientService,  // Defines a set of targets.  targetUrls: [ \"ws://localhost:9095/failover/ws\",  \"ws://localhost:9096/failover/ws\", \"ws://localhost:9094/failover/ws\"],  // Failover interval in milliseconds.  failoverIntervalInMillis: 2000,  // When creating the client endpoint, if the `readyOnConnect` flag is set to  // `false` the client endpoint does not start reading frames automatically.  readyOnConnect: false  });   // Associate connections before starting to read messages.  wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);   // Once the client is ready to receive frames the remote `ready` function  // of the client needs to be called separately.  var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }   // This resource gets invoked upon receiving a new text frame from a client.  resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   // This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketCaller caller, error err) {   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", err);  }   // This resource gets invoked when a client connection is closed from the client side.  resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }  // Client service to receive frames from the remote server. service failoverClientService = @http:WebSocketServiceConfig {} service {   // This resource gets invoked upon receiving a new text frame from the remote backend.  resource function onText(http:WebSocketFailoverClient caller, string text,  boolean finalFrame) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }   // This resource gets invoked when an error occurs in the connection.  resource function onError(http:WebSocketFailoverClient caller, error err) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }   // This resource gets invoked when a client connection is closed by  // the remote backend.  resource function onClose(http:WebSocketFailoverClient caller, int statusCode,  string reason) {   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };  // Function to retrieve the associated client for a particular caller. function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketFailoverClient) {  http:WebSocketFailoverClient wsClient = <http:WebSocketFailoverClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }  // Function to retrieve the associated caller for a client. function getAssociatedServerEndpoint(http:WebSocketFailoverClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =<http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; } import ballerina/http; import ballerina/log;  @http:WebSocketServiceConfig {  path: \"/failover/ws\" }  // Define the backend service with port 9094, which is called by the failover client. service server on new http:Listener(9094) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service until the execution of the `onOpen`  // resource finishes, operations, which should happen before reading the messages should be done in  // the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9094. The Connection ID: \"  + caller.getConnectionId());  }   // This resource gets invoked when a server is receiving a text message from the client.  resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } } import ballerina/http; import ballerina/log;  @http:WebSocketServiceConfig {  path: \"/failover/ws\" }  // Define the backend service with port 9095, which is called by the failover. service server on new http:Listener(9095) {   // This resource gets invoked when a new client connects.  // Since messages to the server are not read by the service until the execution of the `onOpen`  // resource finishes, operations, which should happen before reading messages should be done in  // the `onOpen` resource.  resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9095. The Connection ID: \"  + caller.getConnectionId());  }   // This resource gets invoked when a server is receiving a text message from the client.  resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    Failover  Ballerina users can configure multiple backends in a given failover config. If the client looses the connection by the server being shut down or by getting any IOExceptions, Ballerina automatically tries to connect with the remaining backends that are specified in the configuration. The trying happens only once for each of the backends.    import ballerina/http; import ballerina/log;    final string ASSOCIATED_CONNECTION = \"ASSOCIATED_CONNECTION\";    @http:WebSocketServiceConfig {  path: \"/failover/ws\" } service failoverProxyService on new http:Listener(9090) {    resource function onOpen(http:WebSocketCaller caller) {    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until  the execution of the onOpen resource finishes,  operations, which should happen before reading messages should be done  in the onOpen resource.   http:WebSocketFailoverClient wsClientEp = new (  {  callbackService: failoverClientService,    Defines the webSocket failover client.   targetUrls: [ \"ws://localhost:9095/failover/ws\",  \"ws://localhost:9096/failover/ws\", \"ws://localhost:9094/failover/ws\"],    Defines a set of targets.   failoverIntervalInMillis: 2000,    Failover interval in milliseconds.   readyOnConnect: false  });    When creating the client endpoint, if the readyOnConnect flag is set to  false the client endpoint does not start reading frames automatically.   wsClientEp.setAttribute(ASSOCIATED_CONNECTION, caller);  caller.setAttribute(ASSOCIATED_CONNECTION, wsClientEp);    Associate connections before starting to read messages.   var err = wsClientEp->ready();  if (err is http:WebSocketError) {  log:printError(\"Error calling ready on client\", err);  }  }    Once the client is ready to receive frames the remote ready function  of the client needs to be called separately.   resource function onText(http:WebSocketCaller caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from a client.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketCaller caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var e = clientEp->close(statusCode = 1011, reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", e);  }  log:printError(\"Unexpected error hence closing the connection\", err);  }    resource function onClose(http:WebSocketCaller caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed from the client side.   http:WebSocketFailoverClient clientEp = getAssociatedClientEndpoint(caller);  var err = clientEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } }    service failoverClientService = @http:WebSocketServiceConfig {} service {    Client service to receive frames from the remote server.   resource function onText(http:WebSocketFailoverClient caller, string text,  boolean finalFrame) {    This resource gets invoked upon receiving a new text frame from the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  }    resource function onError(http:WebSocketFailoverClient caller, error err) {    This resource gets invoked when an error occurs in the connection.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var e = serverEp->close(statusCode = 1011,  reason = \"Unexpected condition\");  if (e is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\",  err = e);  }  log:printError(\"Unexpected error hense closing the connection\", err);  }    resource function onClose(http:WebSocketFailoverClient caller, int statusCode,  string reason) {    This resource gets invoked when a client connection is closed by  the remote backend.   http:WebSocketCaller serverEp = getAssociatedServerEndpoint(caller);  var err = serverEp->close(statusCode = statusCode, reason = reason);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when closing the connection\", err);  }  } };    function getAssociatedClientEndpoint(http:WebSocketCaller ep)  returns (http:WebSocketFailoverClient) {  http:WebSocketFailoverClient wsClient = <http:WebSocketFailoverClient>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsClient; }    Function to retrieve the associated client for a particular caller.   function getAssociatedServerEndpoint(http:WebSocketFailoverClient ep)  returns (http:WebSocketCaller) {  http:WebSocketCaller wsEndpoint =<http:WebSocketCaller>ep.  getAttribute(ASSOCIATED_CONNECTION);  return wsEndpoint; }    Function to retrieve the associated caller for a client.   # To start the services, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command below.    ballerina run websocket_service_9095.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    ballerina run websocket_service_9094.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9094    ballerina run websocket_failover.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Now, this service can be invoked by any WebSocket client using the following URL: \"ws://localhost:9090/failover/ws\"    # To check the sample, you can use Chrome or the Firefox JavaScript console and run the following commands. <br> var ws = new WebSocket(\"ws://localhost:9090/failover/ws\"); ws.onmessage = function(frame) {console.log(frame.data)};    # Send messages. ws.send(\"hello world\");    # To stop the running service, press Ctrl + C.    # Send messages. ws.send(\"hello world\");    # Close the connection. ws.close(1000, \"I want to go\");    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/failover/ws\" }    service server on new http:Listener(9094) {    Define the backend service with port 9094, which is called by the failover client.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9094. The Connection ID: \"  + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen  resource finishes, operations, which should happen before reading the messages should be done in  the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and run the `ballerina run` command below. ballerina run websocket_service_9094.bal    [ballerina/http] started HTTP/WS listener 0.0.0.0:9094 2019-11-20 14:05:09,596 INFO [] - WebSocket client connects wih the server 9094. The Connection ID: 08d40cfffe258b13-00003526-00000001-c69a4c7eb8c373f5-76217d0a    import ballerina/http; import ballerina/log;    @http:WebSocketServiceConfig {  path: \"/failover/ws\" }    service server on new http:Listener(9095) {    Define the backend service with port 9095, which is called by the failover.   resource function onOpen(http:WebSocketCaller caller) {  log:printInfo(\"WebSocket client connects wih the server 9095. The Connection ID: \"  + caller.getConnectionId());  }    This resource gets invoked when a new client connects.  Since messages to the server are not read by the service until the execution of the onOpen  resource finishes, operations, which should happen before reading messages should be done in  the onOpen resource.   resource function onText(http:WebSocketCaller caller, string text, boolean finalFrame) {  var err = caller->pushText(text, finalFrame);  if (err is http:WebSocketError) {  log:printError(\"Error occurred when sending text message\", err);  }  } }    This resource gets invoked when a server is receiving a text message from the client.   # To start the service, navigate to the directory that contains the # `.bal` file, and run the `ballerina run` command below. ballerina run websocket_service_9095.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095 2019-11-20 14:04:20,515 INFO [] - WebSocket client connects wih the server 9095. The Connection ID: 08d40cfffe258b13-00003366-00000001-0cf944d788c2b464-774dc3ff [ballerina/http] stopped HTTP/WS listener 0.0.0.0:9095    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/worker-interaction.html","name":"Worker Interactions","summary":"Workers interact with each other by sending and receiving messages.\n Messages are sent and received over a communication channel that is transparent to the user.\n Asynchronous sending of the worker does not wait until the message is delivered whereas synchronous sending waits until the message is delivered.\n Flush can be ...","content":"/  /  /  / Worker Interactions  import ballerina/io; import ballerina/runtime;  // Workers interact with each other by sending and receiving messages. // Ballerina validates every worker interaction (send and receive) // to avoid deadlocks. public function main() {  worker w1 {  int i = 100;  float k = 2.34;   // Sends messages asynchronously to the worker `w2`. This message contains a  // tuple value with the member types `int` and `float`.  [int, float] t1 = [i, k];  t1 -> w2;  io:println(\"[w1 -> w2] i: \", i, \" k: \", k);   // Receives a message from the worker `w2`. This message contains `  // a `json`-typed value.  json j = {};  j = <- w2;  string jStr = j.toString();  io:println(\"[w1 <- w2] j: \", jStr);  io:println(\"[w1 ->> w2] i: \", i);   // Sends messages synchronously to the worker `w2`. The worker `w1` will wait  // until the worker `w2` receives the message.  () send = i ->> w2;   // The synchronous sending returns `nil` if the message was successfully sent or  // returns an error or panics based on the receiving worker's state.  io:println(\"[w1 ->> w2] successful!!\");   // Sends messages asynchronously to the worker `w3`.  io:println(\"[w1 -> w3] k: \", k);  k -> w3;  k -> w3;  k -> w3;   io:println(\"Waiting for worker w3 to fetch messages..\");   // Flushes all messages sent asynchronously to the worker `w3`. The worker  // will halt at this point until all messages are sent or until the worker `w3`  // fails.  error? flushResult = flush w3;  io:println(\"[w1 -> w3] Flushed!!\");  }   worker w2 {  // Receives a message from the worker `w1`.  int iw;  float kw;  [int, float] vW1 = [0, 1.0];  vW1 = <- w1;  [iw, kw] = vW1;  io:println(\"[w2 <- w1] iw: \", iw, \" kw: \", kw);   // Sends a message asynchronously to the worker `w1`.  json jw = {\"name\": \"Ballerina\"};  io:println(\"[w2 -> w1] jw: \", jw);  jw -> w1;   // Receives the message sent synchronously from the worker `w1`  int lw;  runtime:sleep(5);  lw = <- w1;  io:println(\"[w2 <- w1] lw: \", lw);  }   worker w3 {  float mw;   // Receives messages from the worker `w1` after a certain time.  runtime:sleep(50);  mw = <- w1;  mw = <- w1;  mw = <- w1;  io:println(\"[w3 <- w1] mw: \", mw);  }   // Waits for the worker `w1`to finish.  wait w1; }    Worker Interactions  Workers interact with each other by sending and receiving messages.  Messages are sent and received over a communication channel that is transparent to the user.  Asynchronous sending of the worker does not wait until the message is delivered whereas synchronous sending waits until the message is delivered.  Flush can be used to check if all asynchronous messages were sent successfully to a given worker.  Both synchronous send and flush may fail if a receiving worker returned an error before receiving the messages.  Similarly ,they may panic if a receiver panicked.    import ballerina/io; import ballerina/runtime;    public function main() {  worker w1 {  int i = 100;  float k = 2.34;    Workers interact with each other by sending and receiving messages.  Ballerina validates every worker interaction (send and receive)  to avoid deadlocks.   [int, float] t1 = [i, k];  t1 -> w2;  io:println(\"[w1 -> w2] i: \", i, \" k: \", k);    Sends messages asynchronously to the worker w2. This message contains a  tuple value with the member types int and float.   json j = {};  j = <- w2;  string jStr = j.toString();  io:println(\"[w1 <- w2] j: \", jStr);  io:println(\"[w1 ->> w2] i: \", i);    Receives a message from the worker w2. This message contains ajson`-typed value.   () send = i ->> w2;    Sends messages synchronously to the worker w2. The worker w1 will wait  until the worker w2 receives the message.   io:println(\"[w1 ->> w2] successful!!\");    The synchronous sending returns nil if the message was successfully sent or  returns an error or panics based on the receiving worker’s state.   io:println(\"[w1 -> w3] k: \", k);  k -> w3;  k -> w3;  k -> w3;    Sends messages asynchronously to the worker w3.   io:println(\"Waiting for worker w3 to fetch messages..\");    error? flushResult = flush w3;  io:println(\"[w1 -> w3] Flushed!!\");  }    Flushes all messages sent asynchronously to the worker w3. The worker  will halt at this point until all messages are sent or until the worker w3  fails.   worker w2 {    int iw;  float kw;  [int, float] vW1 = [0, 1.0];  vW1 = <- w1;  [iw, kw] = vW1;  io:println(\"[w2 <- w1] iw: \", iw, \" kw: \", kw);    Receives a message from the worker w1.   json jw = {\"name\": \"Ballerina\"};  io:println(\"[w2 -> w1] jw: \", jw);  jw -> w1;    Sends a message asynchronously to the worker w1.   int lw;  runtime:sleep(5);  lw = <- w1;  io:println(\"[w2 <- w1] lw: \", lw);  }    Receives the message sent synchronously from the worker w1   worker w3 {  float mw;    runtime:sleep(50);  mw = <- w1;  mw = <- w1;  mw = <- w1;  io:println(\"[w3 <- w1] mw: \", mw);  }    Receives messages from the worker w1 after a certain time.   wait w1; }    Waits for the worker w1to finish.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run worker_interaction.bal [w1 -> w2] i: 100 k: 2.34 [w2 <- w1] iw: 100 kw: 2.34 [w2 -> w1] jw: name=Ballerina [w1 <- w2] j: name=Ballerina [w1 ->> w2] i: 100 [w2 <- w1] lw: 100 [w1 ->> w2] successful!! [w1 -> w3] k: 2.34 Waiting for worker w3 to fetch messages.. [w1 -> w3] Flushed!! [w3 <- w1] mw: 2.34    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websub-remote-hub-sample.html","name":"Remote Hub Sample","summary":"Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,\n to receive notifications. If specified, the subscription process can be initiated at the startup. Signature\n validation is ...","content":"/  /  /  / Remote Hub Sample  // The Main program, which brings up the Ballerina WebSub Hub. import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;  public function main() {   // Starts the internal Ballerina Hub on port 9191 allowing remote publishers to register topics and publish  // updates of the topics.  io:println(\"Starting up the Ballerina Hub Service\");   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\",  hubConfiguration = {  remotePublish: {  enabled: true  }  }  );   if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }   // Waits for the subscriber to subscribe at this hub and for the publisher to publish the notifications.  runtime:sleep(10000);  } // The Ballerina WebSub Publisher, which registers a topic at the hub and publishes updates to the hub for the topic. import ballerina/io; import ballerina/runtime; import ballerina/websub;  // This is the remote WebSub Hub Endpoint to which registration and publish requests are sent. websub:PublisherClient websubHubClientEP =  new (\"http://localhost:9191/websub/publish\");  public function main() {   // Registers a topic at the hub.  var registrationResponse =  websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }   // Makes the publisher wait until the subscriber subscribes at the hub.  runtime:sleep(5000);   // Publishes updates to the remote hub.  io:println(\"Publishing update to remote Hub\");  var publishResponse =  websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"remote-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }  } // Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub. import ballerina/http; import ballerina/log; import ballerina/websub;  // The endpoint to which the subscriber service is bound. listener websub:Listener websubEP = new (8181);  // Annotations specifying the subscription parameters. @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {   // Defines the resource that accepts the intent verification requests.  // If the resource is not specified, intent verification happens automatically. It verifies if the topic  // specified in the intent verification request matches the topic specified as the annotation.  resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {  // Builds the response for the subscription intent verification request that was received.  http:Response response = request.  buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");   if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);   if (result is error) {  log:printError(\"Error responding to intent verification request\",  result);  }  }   // Defines the resource that accepts the content delivery requests.  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Remote Hub Sample  Ballerina provides the capability to easily introduce publishers and subscribers that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic they wish to subscribe to and the hub they wish to subscribe at,  to receive notifications. If specified, the subscription process can be initiated at the startup. Signature  validation is performed by default for subscribers that receive authenticated content. Ballerina WebSub Subscriber  Services could thus be registered as webhooks to receive event notifications.  Ballerina also comes with an in-built WebSub Hub service, which can be brought up by publishers that need to bring up  a hub.  This example demonstrates a simple WebSub publisher and subscriber scenario, in which a Ballerina WebSub Hub  that is brought up remotely is used by a Ballerina WebSub publisher to publish updates to a topic. A Ballerina  WebSub Subscriber subscribes at this remote hub to get the topic updates.    import ballerina/http; import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Main program, which brings up the Ballerina WebSub Hub.   public function main() {    io:println(\"Starting up the Ballerina Hub Service\");    Starts the internal Ballerina Hub on port 9191 allowing remote publishers to register topics and publish  updates of the topics.   websub:Hub webSubHub;  var result = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\",  hubConfiguration = {  remotePublish: {  enabled: true  }  }  );    if (result is websub:Hub) {  webSubHub = result;  } else if (result is websub:HubStartedUpError) {  webSubHub = result.startedUpHub;  } else {  io:println(\"Hub start error:\" + <string>result.detail()?.message);  return;  }    runtime:sleep(10000);    Waits for the subscriber to subscribe at this hub and for the publisher to publish the notifications.   }    # This sample requires the Hub Service to start via the hub.bal file, prior to running the Publisher main program. The # Subscriber Service needs to start after the publisher registers the topic at the hub. # If the port is not specified, the hub service starts on the default port. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run hub.bal Starting up the Ballerina Hub Service [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 2019-11-01 14:36:36,782 INFO [ballerina/websub] - Topic registration successful at Hub, for topic[http://websubpubtopic.com] 2019-11-01 14:36:42,764 INFO [ballerina/websub] - Subscription request received for topic[http://websubpubtopic.com] with callback[http://localhost:8181/websub] 2019-11-01 14:36:42,807 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/websub] for topic[http://websubpubtopic.com] 2019-11-01 14:36:43,116 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/websub] 2019-11-01 14:36:46,952 INFO [ballerina/websub] - Update notification done for Topic [http://websubpubtopic.com]    import ballerina/io; import ballerina/runtime; import ballerina/websub;    The Ballerina WebSub Publisher, which registers a topic at the hub and publishes updates to the hub for the topic.   websub:PublisherClient websubHubClientEP =  new (\"http://localhost:9191/websub/publish\");    This is the remote WebSub Hub Endpoint to which registration and publish requests are sent.   public function main() {    var registrationResponse =  websubHubClientEP->registerTopic(\"http://websubpubtopic.com\");  if (registrationResponse is error) {  io:println(\"Error occurred registering topic: \" +  <string>registrationResponse.detail()?.message);  } else {  io:println(\"Topic registration successful!\");  }    Registers a topic at the hub.   runtime:sleep(5000);    Makes the publisher wait until the subscriber subscribes at the hub.   io:println(\"Publishing update to remote Hub\");  var publishResponse =  websubHubClientEP->publishUpdate(\"http://websubpubtopic.com\",  {\"action\": \"publish\", \"mode\": \"remote-hub\"});  if (publishResponse is error) {  io:println(\"Error notifying hub: \" +  <string>publishResponse.detail()?.message);  } else {  io:println(\"Update notification successful!\");  }    Publishes updates to the remote hub.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run publisher.bal Topic registration successful! Publishing update to remote Hub Update notification successful!    import ballerina/http; import ballerina/log; import ballerina/websub;    Ballerina WebSub Subscriber service, which subscribes to notifications at a Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/websub\",  subscribeOnStartUp: true,  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters.   resource function onIntentVerification(websub:Caller caller,  websub:IntentVerificationRequest request) {    Defines the resource that accepts the intent verification requests.  If the resource is not specified, intent verification happens automatically. It verifies if the topic  specified in the intent verification request matches the topic specified as the annotation.   http:Response response = request.  buildSubscriptionVerificationResponse(\"http://websubpubtopic.com\");    Builds the response for the subscription intent verification request that was received.   if (response.statusCode == 202) {  log:printInfo(\"Intent verified for subscription request\");  } else {  log:printWarn(\"Intent verification denied for subscription request\");  }  var result = caller->respond(<@untainted>response);    if (result is error) {  log:printError(\"Error responding to intent verification request\",  result);  }  }    resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource that accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:36:42,797 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://websubpubtopic.com], with Callback [http://localhost:8181/websub] 2019-11-01 14:36:43,050 INFO [] - Intent verified for subscription request 2019-11-01 14:36:47,098 INFO [] - WebSub Notification Received: {\"action\":\"publish\", \"mode\":\"remote-hub\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/websub-service-integration-sample.html","name":"Service Integration Sample","summary":"Ballerina provides the capability to easily introduce webhooks via its implementation of the WebSub recommendation.Ballerina Services, which act as WebSub Publishers could start up a Ballerina WebSub Hub to which they would publish\n updates against topics on the occurrence of particular events.Ballerina WebSub subscribers can subscribe at these hubs, by ...","content":"/  /  /  / Service Integration Sample  // The order management HTTP service acting as a Ballerina WebSub Publisher brings up an internal Ballerina WebSub Hub // at which it will publish updates. import ballerina/http; import ballerina/log; import ballerina/websub;  listener http:Listener httpListener = new (9090);  // The topic against which the publisher will publish updates and the subscribers // need to subscribe to, to receive notifications when an order is placed. final string ORDER_TOPIC = \"http://localhost:9090/ordermgt/ordertopic\";  // An in-memory `map` to which orders will be added. map<json> orderMap = {};  // Invokes the function that starts up a Ballerina WebSub Hub, registers the topic // against which updates will be published, and maintains a reference to the // returned hub object to publish updates. websub:Hub webSubHub = startHubAndRegisterTopic();  @http:ServiceConfig {  basePath: \"/ordermgt\" } service orderMgt on httpListener {   // This resource accepts the discovery requests.  // Requests received at this resource would respond with a Link Header  // indicating the topic to subscribe to and the hub(s) to subscribe at.  @http:ResourceConfig {  methods: [\"GET\", \"HEAD\"],  path: \"/order\"  }  resource function discoverPlaceOrder(http:Caller caller, http:Request req) {  http:Response response = new;  // Adds a link header indicating the hub and topic.  websub:addWebSubLinkHeader(response, [webSubHub.subscriptionUrl], ORDER_TOPIC);  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }  }   // This resource accepts order placement requests.  @http:ResourceConfig {  methods: [\"POST\"],  path: \"/order\"  }  resource function placeOrder(http:Caller caller, http:Request req) {  var orderReq = req.getJsonPayload();  if (orderReq is json) {  string orderId = orderReq.Order.ID.toString();  orderMap[orderId] = <@untainted>orderReq;   // Creates the response message indicating successful order creation.  http:Response response = new;  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }   // Publishes the update to the Hub to notify the subscribers.  string orderCreatedNotification = \"New Order Added: \" + orderId;  log:printInfo(orderCreatedNotification);  var updateResult = webSubHub.publishUpdate(ORDER_TOPIC,  orderCreatedNotification);  if (updateResult is error) {  log:printError(\"Error publishing update\", updateResult);  }  } else {  error e = orderReq;  log:printError(\"Error retrieving payload\", e);  panic e;  }  }  }  // Starts up a Ballerina WebSub Hub on port 9191 and registers the topic against // which updates will be published. function startHubAndRegisterTopic() returns websub:Hub {  var hubStartUpResult = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");   websub:Hub? hubVar = ();  if hubStartUpResult is websub:HubStartupError {  panic hubStartUpResult;  } else {  hubVar = hubStartUpResult is websub:HubStartedUpError  ? hubStartUpResult.startedUpHub : hubStartUpResult;  }   websub:Hub internalHub = <websub:Hub>hubVar;  var result = internalHub.registerTopic(ORDER_TOPIC);  if (result is error) {  log:printError(\"Error registering topic\", result);  }  return internalHub; } // The Ballerina WebSub Subscriber service, which subscribes to notifications at the Hub. import ballerina/log; import ballerina/websub;  // The endpoint to which the subscriber service is bound. listener websub:Listener websubEP = new (8181);  // Annotations specifying the subscription parameters for the order management service. // A subscription request would be sent to the hub with the topic discovered at the // resource URL specified. @websub:SubscriberServiceConfig {  path: \"/ordereventsubscriber\",  subscribeOnStartUp: true,  target: \"http://localhost:9090/ordermgt/order\",  leaseSeconds: 3600,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {  // Defines the resource, which accepts the content delivery requests.  resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Service Integration Sample  Ballerina provides the capability to easily introduce webhooks via its implementation of the WebSub recommendation.  Ballerina Services, which act as WebSub Publishers could start up a Ballerina WebSub Hub to which they would publish  updates against topics on the occurrence of particular events.  Ballerina WebSub subscribers can subscribe at these hubs, by specifying the topics, to receive notifications on  the occurrence of particular events.  Any of the Ballerina’s WebSub components (Publisher, Hub, or Subscriber) could be used with non-Ballerina components, which  are WebSub-compliant.    import ballerina/http; import ballerina/log; import ballerina/websub;    The order management HTTP service acting as a Ballerina WebSub Publisher brings up an internal Ballerina WebSub Hub  at which it will publish updates.   listener http:Listener httpListener = new (9090);    final string ORDER_TOPIC = \"http://localhost:9090/ordermgt/ordertopic\";    The topic against which the publisher will publish updates and the subscribers  need to subscribe to, to receive notifications when an order is placed.   map<json> orderMap = {};    An in-memory map to which orders will be added.   websub:Hub webSubHub = startHubAndRegisterTopic();    Invokes the function that starts up a Ballerina WebSub Hub, registers the topic  against which updates will be published, and maintains a reference to the  returned hub object to publish updates.   @http:ServiceConfig {  basePath: \"/ordermgt\" } service orderMgt on httpListener {    @http:ResourceConfig {  methods: [\"GET\", \"HEAD\"],  path: \"/order\"  }  resource function discoverPlaceOrder(http:Caller caller, http:Request req) {  http:Response response = new;    This resource accepts the discovery requests.  Requests received at this resource would respond with a Link Header  indicating the topic to subscribe to and the hub(s) to subscribe at.   websub:addWebSubLinkHeader(response, [webSubHub.subscriptionUrl], ORDER_TOPIC);  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }  }    Adds a link header indicating the hub and topic.   @http:ResourceConfig {  methods: [\"POST\"],  path: \"/order\"  }  resource function placeOrder(http:Caller caller, http:Request req) {  var orderReq = req.getJsonPayload();  if (orderReq is json) {  string orderId = orderReq.Order.ID.toString();  orderMap[orderId] = <@untainted>orderReq;    This resource accepts order placement requests.   http:Response response = new;  response.statusCode = 202;  var result = caller->respond(response);  if (result is error) {  log:printError(\"Error responding on ordering\", result);  }    Creates the response message indicating successful order creation.   string orderCreatedNotification = \"New Order Added: \" + orderId;  log:printInfo(orderCreatedNotification);  var updateResult = webSubHub.publishUpdate(ORDER_TOPIC,  orderCreatedNotification);  if (updateResult is error) {  log:printError(\"Error publishing update\", updateResult);  }  } else {  error e = orderReq;  log:printError(\"Error retrieving payload\", e);  panic e;  }  }    Publishes the update to the Hub to notify the subscribers.   }    function startHubAndRegisterTopic() returns websub:Hub {  var hubStartUpResult = websub:startHub(new http:Listener(9191), \"/websub\", \"/hub\");    Starts up a Ballerina WebSub Hub on port 9191 and registers the topic against  which updates will be published.   websub:Hub? hubVar = ();  if hubStartUpResult is websub:HubStartupError {  panic hubStartUpResult;  } else {  hubVar = hubStartUpResult is websub:HubStartedUpError  ? hubStartUpResult.startedUpHub : hubStartUpResult;  }    websub:Hub internalHub = <websub:Hub>hubVar;  var result = internalHub.registerTopic(ORDER_TOPIC);  if (result is error) {  log:printError(\"Error registering topic\", result);  }  return internalHub; }    # This sample requires starting up the Subscriber Service after the Publisher Service. # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run order_mgmt_service.bal [ballerina/websub] Ballerina WebSub Hub started up. [ballerina/websub] Publish URL: http://localhost:9191/websub/publish [ballerina/websub] Subscription URL: http://localhost:9191/websub/hub [ballerina/http] started HTTP/WS listener 0.0.0.0:9191 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 2019-11-01 14:15:05,814 INFO [ballerina/websub] - Subscription request received for topic[http://localhost:9090/ordermgt/ordertopic] with callback[http://localhost:8181/ordereventsubscriber] 2019-11-01 14:15:05,858 INFO [ballerina/websub] - Sending intent verification request to callback[http://localhost:8181/ordereventsubscriber] for topic[http://localhost:9090/ordermgt/ordertopic] 2019-11-01 14:15:06,037 INFO [ballerina/websub] - Intent verification successful for mode: [subscribe], for callback URL: [http://localhost:8181/ordereventsubscriber] 2019-11-01 14:15:58,756 INFO [] - New Order Added: 1001    curl -X POST -d '{ \"Order\": { \"ID\": \"1001\", \"Name\": \"XYZ\" } }' \"http://localhost:9090/ordermgt/order\" -H \"Content-Type:application/json\"    Invoke the service via the below “curl” command to place an order after starting up the subscriber service.   import ballerina/log; import ballerina/websub;    The Ballerina WebSub Subscriber service, which subscribes to notifications at the Hub.   listener websub:Listener websubEP = new (8181);    The endpoint to which the subscriber service is bound.   @websub:SubscriberServiceConfig {  path: \"/ordereventsubscriber\",  subscribeOnStartUp: true,  target: \"http://localhost:9090/ordermgt/order\",  leaseSeconds: 3600,  secret: \"Kslk30SNF2AChs2\" } service websubSubscriber on websubEP {    Annotations specifying the subscription parameters for the order management service.  A subscription request would be sent to the hub with the topic discovered at the  resource URL specified.   resource function onNotification(websub:Notification notification) {  var payload = notification.getTextPayload();  if (payload is string) {  log:printInfo(\"WebSub Notification Received: \" + payload);  } else {  log:printError(\"Error retrieving payload as string\", payload);  }  } }    Defines the resource, which accepts the content delivery requests.   # To start the service, navigate to the directory that contains the # `.bal` file, and use the `ballerina run` command. ballerina run subscriber.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8181 2019-11-01 14:15:05,823 INFO [ballerina/websub] - Subscription Request successfully sent to Hub[http://localhost:9191/websub/hub], for Topic[http://localhost:9090/ordermgt/ordertopic], with Callback [http://localhost:8181/ordereventsubscriber] ballerina: Intent Verification agreed - Mode [subscribe], Topic [http://localhost:9090/ordermgt/ordertopic], Lease Seconds [3600] 2019-11-01 14:15:58,892 INFO [] - WebSub Notification Received: New Order Added: 1001    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/workers.html","name":"Workers","summary":"Workers in Ballerina allow developers to delegate their tasks to independently running executions.\n Worker execution starts immediately after invoking the relevant function, remote function, or resource that encloses the worker(s).\n Workers can be declared within functions, remote functions, or resources.\n Worker execution starts immediately after executing the statements declared before ...","content":"/  /  /  / Workers  import ballerina/io;  // In Ballerina, each function consists of one or more workers, which are // independent execution paths called strands. If explicit workers are // not mentioned within worker blocks, the function code will belong to a // single implicit default worker. The default worker in each function wil be // executed in the same strand as the caller function. public function main() {  io:println(\"Worker execution started\");   // This block belongs to the worker `w1`.  worker w1 {  // Calculates the sum(n).  int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i;  }  io:println(\"sum of first \", n, \" positive numbers = \", sum);  }   // By default workers run on the same physical thread of the parent strand.  // By adding `@strand` annotation, this worker's strand is allowed to run  // on any available physical thread.  @strand {  thread:\"any\"  }  // This block belongs to the worker `w2`.  worker w2 {  // Calculates the sum(n^2).  int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i * i;  }  io:println(\"sum of squares of first \", n,  \" positive numbers = \", sum);  }   // Waits for both workers to finish.  _ = wait {w1, w2};   io:println(\"Worker execution finished\"); }    Workers  Workers in Ballerina allow developers to delegate their tasks to independently running executions.  Worker execution starts immediately after invoking the relevant function, remote function, or resource that encloses the worker(s).  Workers can be declared within functions, remote functions, or resources.  Worker execution starts immediately after executing the statements declared before the first worker declaration in the relevant function,  remote function, or resource that encloses the worker(s).    import ballerina/io;    public function main() {  io:println(\"Worker execution started\");    In Ballerina, each function consists of one or more workers, which are  independent execution paths called strands. If explicit workers are  not mentioned within worker blocks, the function code will belong to a  single implicit default worker. The default worker in each function wil be  executed in the same strand as the caller function.   worker w1 {    This block belongs to the worker w1.   int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i;  }  io:println(\"sum of first \", n, \" positive numbers = \", sum);  }    Calculates the sum(n).   @strand {  thread:\"any\"  }    By default workers run on the same physical thread of the parent strand.  By adding @strand annotation, this worker’s strand is allowed to run  on any available physical thread.   worker w2 {    This block belongs to the worker w2.   int n = 10000000;  int sum = 0;  foreach var i in 1 ... n {  sum += i * i;  }  io:println(\"sum of squares of first \", n,  \" positive numbers = \", sum);  }    Calculates the sum(n^2).   _ = wait {w1, w2};    Waits for both workers to finish.   io:println(\"Worker execution finished\"); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run workers.bal Worker execution started sum of first 10000000 positive numbers = 50000005000000 sum of squares of first 10000000 positive numbers = 1291990006563070912 Worker execution finished    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xa-transactions.html","name":"XA Transactions","summary":"Ballerina XA transactions are used when the transaction is happening over\n two or more databases. This example uses two H2 DBs (these\n are created when executing the example). Before running the example,\n change the DB connection properties as required.\n Ballerina transactions are at the experimental stage.\n Therefore, use  the ...","content":"/  /  /  / XA Transactions  import ballerina/io; import ballerinax/java.jdbc;  // JDBC Client for the first H2 database. Since this `Client` // participates in a distributed transaction, the `isXA` property should be true. jdbc:Client testDB1 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb1\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });  // JDBC Client for the second H2 database. Since this endpoint // participates in a distributed transaction, the `isXA` property should be true. jdbc:Client testDB2 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb2\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });  public function main() {  // Create the table named CUSTOMER in the first database.  var ret = testDB1->update(\"CREATE TABLE CUSTOMER (ID INTEGER \" +  \"AUTO_INCREMENT, NAME VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");  // Create the table named SALARY in the second database.  ret = testDB2->update(\"CREATE TABLE SALARY (ID INT, VALUE FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");   // Start the transaction.  transaction {  // This is the first remote function to participate in the transaction. It inserts  // the customer name to the first DB and gets the generated key.  ret = testDB1->update(\"INSERT INTO CUSTOMER(NAME) \" +  \"VALUES ('Anne')\");  int key = -1;  if (ret is jdbc:UpdateResult) {  int count = ret.updatedRowCount;  key = <int>ret.generatedKeys[\"ID\"];  io:println(\"Inserted row count: \", count);  io:println(\"Generated key: \", key);  } else {  io:println(\"Insert to student table failed: \",  <string>ret.detail()?.message);  }   // This is the second remote function to participate in the transaction. It inserts the  // salary info to the second DB along with the key generated in the first DB.  ret = testDB2->update(\"INSERT INTO SALARY (ID, VALUE) VALUES (?, ?)\",  key, 2500);  handleUpdate(ret, \"Insert to SALARY table\");  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  }   // Drop the tables created for this sample.  ret = testDB1->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop Table CUSTOMER\");   ret = testDB2->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop Table SALARY\"); }  // Function to handle the return value of the `update` remote function. function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    XA Transactions  Ballerina XA transactions are used when the transaction is happening over  two or more databases. This example uses two H2 DBs (these  are created when executing the example). Before running the example,  change the DB connection properties as required.  Ballerina transactions are at the experimental stage.  Therefore, use the –experimental flag to enable them.    import ballerina/io; import ballerinax/java.jdbc;    jdbc:Client testDB1 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb1\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });    JDBC Client for the first H2 database. Since this Client  participates in a distributed transaction, the isXA property should be true.   jdbc:Client testDB2 = new ({  url: \"jdbc:h2:file:./xa-transactions/Testdb2\",  username: \"test\",  password: \"test\",  poolOptions: {isXA: true} });    JDBC Client for the second H2 database. Since this endpoint  participates in a distributed transaction, the isXA property should be true.   public function main() {    var ret = testDB1->update(\"CREATE TABLE CUSTOMER (ID INTEGER \" +  \"AUTO_INCREMENT, NAME VARCHAR(30))\");  handleUpdate(ret, \"Create CUSTOMER table\");    Create the table named CUSTOMER in the first database.   ret = testDB2->update(\"CREATE TABLE SALARY (ID INT, VALUE FLOAT)\");  handleUpdate(ret, \"Create SALARY table\");    Create the table named SALARY in the second database.   transaction {    Start the transaction.   ret = testDB1->update(\"INSERT INTO CUSTOMER(NAME) \" +  \"VALUES ('Anne')\");  int key = -1;  if (ret is jdbc:UpdateResult) {  int count = ret.updatedRowCount;  key = <int>ret.generatedKeys[\"ID\"];  io:println(\"Inserted row count: \", count);  io:println(\"Generated key: \", key);  } else {  io:println(\"Insert to student table failed: \",  <string>ret.detail()?.message);  }    This is the first remote function to participate in the transaction. It inserts  the customer name to the first DB and gets the generated key.   ret = testDB2->update(\"INSERT INTO SALARY (ID, VALUE) VALUES (?, ?)\",  key, 2500);  handleUpdate(ret, \"Insert to SALARY table\");  } onretry {  io:println(\"Retrying transaction\");  } committed {  io:println(\"Transaction committed\");  } aborted {  io:println(\"Transaction aborted\");  }    This is the second remote function to participate in the transaction. It inserts the  salary info to the second DB along with the key generated in the first DB.   ret = testDB1->update(\"DROP TABLE CUSTOMER\");  handleUpdate(ret, \"Drop Table CUSTOMER\");    Drop the tables created for this sample.   ret = testDB2->update(\"DROP TABLE SALARY\");  handleUpdate(ret, \"Drop Table SALARY\"); }    function handleUpdate(jdbc:UpdateResult|error returned, string message) {  if (returned is jdbc:UpdateResult) {  io:println(message, \" status: \", returned.updatedRowCount);  } else {  io:println(message, \" failed: \", <string>returned.detail()?.message);  } }    Function to handle the return value of the update remote function.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run --experimental xa_transactions.bal Create CUSTOMER table status: 0 Create SALARY table status: 0 2019-12-16 10:25:35,658 INFO [ballerina/transactions] - Created transaction: ab7cc71e-30f0-45ac-982e-01e0a0e39875 Inserted row count: 1 Generated key: 1 Insert to SALARY table status: 1 2019-12-16 10:25:35,672 INFO [ballerina/transactions] - Running 2-phase commit for transaction: ab7cc71e-30f0-45ac-982e-01e0a0e39875:$anon$.$0 Transaction committed Drop Table CUSTOMER status: 0 Drop Table SALARY status: 0 [ballerina/http] started HTTP/WS listener 10.100.7.118:52159 [ballerina/http] stopped HTTP/WS listener 10.100.7.118:52159    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-access.html","name":"XML Access","summary":"XML elements can contain child XML items. Ballerina allows you to access these\n child elements conveniently using XML step expressions and XML filter expressions.The XML element with nested children.You can access child XML items using XML step expressions.Accessing a non-existing child will return an empty xml sequence.You can also retrieve ...","content":"/  /  /  / XML Access  import ballerina/io;  public function main() {   // The XML element with nested children.  xml bookXML = xml `<book>  <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->  </book>`;  // You can access child XML items using XML step expressions.  io:println(bookXML/<author>/<fname>);   // Accessing a non-existing child will return an empty `xml` sequence.  io:println(bookXML/<ISBN>/<code>);   // You can also retrieve attributes of the resulting child XML.  io:println(bookXML/<author>/<fname>.title);   // You can match descendant elements using the following stepping access syntax.  io:println(bookXML/**/<fname>);   // Select all the children elements using the below syntax.  io:println(bookXML/*);   // Select all children elements using the bellow syntax.  io:println(bookXML/<*>);   // Select all the children belonging to a specific namespace.  xmlns \"http://ballerina.com/a\" as bar;  io:println(bookXML/<bar:*>/*);   xml seq = bookXML/*;  // XML sequences can be filtered using XML filter expressions.  io:println(seq.<name>);  io:println(seq.<bar:year>); }    XML Access  XML elements can contain child XML items. Ballerina allows you to access these  child elements conveniently using XML step expressions and XML filter expressions.    import ballerina/io;    public function main() {    xml bookXML = xml `<book>  <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->  </book>`;  The XML element with nested children.   io:println(bookXML/<author>/<fname>);    You can access child XML items using XML step expressions.   io:println(bookXML/<ISBN>/<code>);    Accessing a non-existing child will return an empty xml sequence.   io:println(bookXML/<author>/<fname>.title);    You can also retrieve attributes of the resulting child XML.   io:println(bookXML/**/<fname>);    You can match descendant elements using the following stepping access syntax.   io:println(bookXML/*);    Select all the children elements using the below syntax.   io:println(bookXML/<*>);    Select all children elements using the bellow syntax.   xmlns \"http://ballerina.com/a\" as bar;  io:println(bookXML/<bar:*>/*);    Select all the children belonging to a specific namespace.   xml seq = bookXML/*;    io:println(seq.<name>);  io:println(seq.<bar:year>); }    XML sequences can be filtered using XML filter expressions.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml-access.bal <fname title=\"Sir\">Arthur</fname>    Sir <fname title=\"Sir\">Arthur</fname>    <name>Sherlock Holmes</name>  <author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author>  <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>  <!--Price: $10-->    <name>Sherlock Holmes</name><author>  <fname title=\"Sir\">Arthur</fname>  <mname>Conan</mname>  <lname>Doyle</lname>  </author><bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year> 2019 <name>Sherlock Holmes</name> <bar:year xmlns:bar=\"http://ballerina.com/a\">2019</bar:year>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-attributes.html","name":"XML Attributes","summary":"XML elements may have any number of attributes and any number\n of namespace declarations that apply for that element.\n In Ballerina, both of these types are treated the same.\n XML attribute access in Ballerina is lax-typed similar\n to json, we can use field access expression (.) and\n optional field access ...","content":"/  /  /  / XML Attributes  import ballerina/io; import ballerina/lang.'xml as xmllib;  xmlns \"http://ballerina.com/aa\" as ns0;  public function main() {  // Creates an XML element, which has attributes that are bound to a namespace as well as ones that are not.  xmllib:Element x1 = <xmllib:Element> xml `<ns0:book ns0:status=\"available\" count=\"5\"/>`;  io:println(x1);   // A single attribute that is bound to a namespace can be accessed using its qualified name.  io:println(x1.ns0:status);   // Attribute access expressions are lax typed.  string|error count = x1.count;  io:println(count);   // Accessing a non-existent attribute will return an error.  string|error count2 = x1.count2;  io:println(count2 is error);   // It is possible to get all the attributes of an `xml` element.  map<string> attributeMap = x1.getAttributes();  io:println(attributeMap);   // An attribute can also be accessed using the string representation of the qualified name from the attribute map.  string? s = attributeMap[\"{http://ballerina.com/aa}status\"];  io:println(s);   // Update an attribute by updating the attribute map of an `xml` element.  attributeMap[ns0:status] = \"Not Available\";  io:println(x1.ns0:status); }    XML Attributes  XML elements may have any number of attributes and any number  of namespace declarations that apply for that element.  In Ballerina, both of these types are treated the same.  XML attribute access in Ballerina is lax-typed similar  to json, we can use field access expression (.) and  optional field access expressions (`?.) to access the  attribute of an XML value.    import ballerina/io; import ballerina/lang.'xml as xmllib;    xmlns \"http://ballerina.com/aa\" as ns0;    public function main() {    xmllib:Element x1 = <xmllib:Element> xml `<ns0:book ns0:status=\"available\" count=\"5\"/>`;  io:println(x1);    Creates an XML element, which has attributes that are bound to a namespace as well as ones that are not.   io:println(x1.ns0:status);    A single attribute that is bound to a namespace can be accessed using its qualified name.   string|error count = x1.count;  io:println(count);    Attribute access expressions are lax typed.   string|error count2 = x1.count2;  io:println(count2 is error);    Accessing a non-existent attribute will return an error.   map<string> attributeMap = x1.getAttributes();  io:println(attributeMap);    It is possible to get all the attributes of an xml element.   string? s = attributeMap[\"{http://ballerina.com/aa}status\"];  io:println(s);    An attribute can also be accessed using the string representation of the qualified name from the attribute map.   attributeMap[ns0:status] = \"Not Available\";  io:println(x1.ns0:status); }    Update an attribute by updating the attribute map of an xml element.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml_attributes.bal <ns0:book xmlns:ns0=\"http://ballerina.com/aa\" ns0:status=\"available\" count=\"5\"/> available 5 true {http://www.w3.org/2000/xmlns/}ns0=http://ballerina.com/aa {http://ballerina.com/aa}status=available count=5 available Not Available    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-functions.html","name":"XML Functions","summary":"Ballerina supports various built-in functions to manipulate XML content.Get the name of an XML element.Concatenate XML and string values.Get the number of XML items in a sequence.Get a subsequence of an XML sequence.Get all the element-type items in an XML sequence.Set the children elements of an XML element.Strip the insignificant ...","content":"/  /  /  / XML Functions  import ballerina/io; import ballerina/lang.'xml as xmllib;  public function main() {  xml bookName = xml `<name>Book1</name>`;  xml bookComment = xml `<!--some comment-->`;  xml someText = xml `Hello, World!`;  xml content = someText + bookName + bookComment;   xmllib:Element book = <xmllib:Element> xml `<book/>`;   // Get the name of an XML element.  xmllib:Element bookNameElem = <xmllib:Element> bookName;  io:println(bookNameElem.getName());   // Concatenate XML and string values.  xml concat = xmllib:concat(someText, bookName, bookComment);  io:println(concat);  io:println(content == concat);   // Get the number of XML items in a sequence.  io:println(concat.length());   // Get a subsequence of an XML sequence.  xml x = content.slice(2, 3);  io:println(x);   // Get all the element-type items in an XML sequence.  x = content.elements();  io:println(x);   // Set the children elements of an XML element.  book.setChildren(content);  io:println(book);   // Strip the insignificant parts of an XML value.  // Comment items, processing instruction items are considered insignificant.  x = content.strip();  io:println(x); }    XML Functions  Ballerina supports various built-in functions to manipulate XML content.    import ballerina/io; import ballerina/lang.'xml as xmllib;    public function main() {  xml bookName = xml `<name>Book1</name>`;  xml bookComment = xml `<!--some comment-->`;  xml someText = xml `Hello, World!`;  xml content = someText + bookName + bookComment;    xmllib:Element book = <xmllib:Element> xml `<book/>`;    xmllib:Element bookNameElem = <xmllib:Element> bookName;  io:println(bookNameElem.getName());    Get the name of an XML element.   xml concat = xmllib:concat(someText, bookName, bookComment);  io:println(concat);  io:println(content == concat);    Concatenate XML and string values.   io:println(concat.length());    Get the number of XML items in a sequence.   xml x = content.slice(2, 3);  io:println(x);    Get a subsequence of an XML sequence.   x = content.elements();  io:println(x);    Get all the element-type items in an XML sequence.   book.setChildren(content);  io:println(book);    Set the children elements of an XML element.   x = content.strip();  io:println(x); }    Strip the insignificant parts of an XML value.  Comment items, processing instruction items are considered insignificant.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command. ballerina run xml_functions.bal    name Hello, World!<name>Book1</name><!--some comment--> true 3 <!--some comment--> <name>Book1</name> <book>Hello, World!<name>Book1</name><!--some comment--></book> Hello, World!<name>Book1</name>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-literal.html","name":"XML Literal","summary":"Ballerina allows you to define XML as part of the language\n and syntactically validates it. You can insert expressions into\n  the XML literal to pass values dynamically at runtime.A complex XML defined using the literal syntax, which contains nested elements of different types.Defines namespaces. These are visible to all ...","content":"/  /  /  / XML Literal  import ballerina/io;  public function main() {   // A complex XML defined using the literal syntax, which contains nested elements of different types.  xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x1);   // Defines namespaces. These are visible to all the XML literals defined from this point onwards. xmlns \"http://ballerina.com/\";  xmlns \"http://ballerina.com/aa\" as ns0;   // Creates an XML element. Previously-defined namespaces will be added to the element. // The defined prefixes can be applied to elements and attributes inside the element. xml x2 = xml `<book ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x2);   // XML can be interpolated with expressions using the `${}` notation.  // The expression can be a previously-defined variable, arithmetic expressions, or even a function call. // These expressions are evaluated at runtime.  string title = \"(Sir)\";   xml x3 = xml `<ns0:newBook>  <name>Sherlock Holmes</name>  <author>${title} Arthur Conan Doyle</author>  <!--Price: $${ 40 / 5 + 4 }-->  </ns0:newBook>`;  io:println(x3); }    XML Literal  Ballerina allows you to define XML as part of the language  and syntactically validates it. You can insert expressions into  the XML literal to pass values dynamically at runtime.    import ballerina/io;    public function main() {    xml x1 = xml `<book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x1);    A complex XML defined using the literal syntax, which contains nested elements of different types.   xmlns \"http://ballerina.com/\";  xmlns \"http://ballerina.com/aa\" as ns0;    Defines namespaces. These are visible to all the XML literals defined from this point onwards.   xml x2 = xml `<book ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book>`;  io:println(x2);    Creates an XML element. Previously-defined namespaces will be added to the element.  The defined prefixes can be applied to elements and attributes inside the element.   string title = \"(Sir)\";    XML can be interpolated with expressions using the ${} notation.  The expression can be a previously-defined variable, arithmetic expressions, or even a function call.  These expressions are evaluated at runtime.   xml x3 = xml `<ns0:newBook>  <name>Sherlock Holmes</name>  <author>${title} Arthur Conan Doyle</author>  <!--Price: $${ 40 / 5 + 4 }-->  </ns0:newBook>`;  io:println(x3); }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml_literal.bal <book>  <name>Sherlock Holmes</name>  <author>Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book> <book xmlns=\"http://ballerina.com/\" xmlns:ns0=\"http://ballerina.com/aa\" ns0:status=\"available\">  <ns0:name>Sherlock Holmes</ns0:name>  <author xmlns=\"http://ballerina.com/\">Sir Arthur Conan Doyle</author>  <!--Price: $10-->  </book> <ns0:newBook xmlns:ns0=\"http://ballerina.com/aa\">  <name xmlns=\"http://ballerina.com/\">Sherlock Holmes</name>  <author xmlns=\"http://ballerina.com/\">(Sir) Arthur Conan Doyle</author>  <!--Price: $12-->    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-io.html","name":"XML I/O","summary":"This example demonstrates how XML content can be read from a file and written\n to a file using a character channel and the readXml() and writeXml() functions of the I/O API.Creates XML content from the string.Writes the content.Reads the content.Writes xml content to a given path.Creates a byte channel from ...","content":"/  /  /  / XML I/O  import ballerina/io; import ballerina/log;  public function main() {  string filePath = \"./files/sample.xml\";  // Creates XML content from the `string`.  xml x1 = xml `<book>The Lost World</book>`;  io:println(\"Preparing to write xml file\");  // Writes the content.  var wResult = write(x1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing xml: \", wResult);  } else {  io:println(\"Preparing to read the content written\");  // Reads the content.  var rResult = read(filePath);  if (rResult is xml) {  io:println(rResult);  } else {  log:printError(\"Error occurred while reading xml: \", rResult);  }  } }  // Writes `xml` content to a given path. function write(xml content, string path) returns @tainted error? {  // Creates a byte channel from the given path.  io:WritableByteChannel wbc = check io:openWritableFile(path);  // Derives the character channel from the byte channel.  io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeXml(content);  // Closes the character channel once you are done with it.  closeWc(wch);  return result; }  // Reads `xml` from a given path. function read(string path) returns @tainted xml|error {  // Creates a byte channel from the given path.  io:ReadableByteChannel rbc = check io:openReadableFile(path);  // Derives the character channel from the byte Channel.  io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");  // Reads the XML content from the character channel.  var result = rch.readXml();  // Closes the character channel once you are done with it.  closeRc(rch);  return result; }  // Closes a readable channel. function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }  // Closes a writable channel. function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    XML I/O  This example demonstrates how XML content can be read from a file and written  to a file using a character channel and the readXml() and writeXml() functions of the I/O API.    import ballerina/io; import ballerina/log;    public function main() {  string filePath = \"./files/sample.xml\";    xml x1 = xml `<book>The Lost World</book>`;  io:println(\"Preparing to write xml file\");    Creates XML content from the string.   var wResult = write(x1, filePath);  if (wResult is error) {  log:printError(\"Error occurred while writing xml: \", wResult);  } else {  io:println(\"Preparing to read the content written\");    Writes the content.   var rResult = read(filePath);  if (rResult is xml) {  io:println(rResult);  } else {  log:printError(\"Error occurred while reading xml: \", rResult);  }  } }    Reads the content.   function write(xml content, string path) returns @tainted error? {    Writes xml content to a given path.   io:WritableByteChannel wbc = check io:openWritableFile(path);    Creates a byte channel from the given path.   io:WritableCharacterChannel wch = new (wbc, \"UTF8\");  var result = wch.writeXml(content);    Derives the character channel from the byte channel.   closeWc(wch);  return result; }    Closes the character channel once you are done with it.   function read(string path) returns @tainted xml|error {    Reads xml from a given path.   io:ReadableByteChannel rbc = check io:openReadableFile(path);    Creates a byte channel from the given path.   io:ReadableCharacterChannel rch = new (rbc, \"UTF8\");    Derives the character channel from the byte Channel.   var result = rch.readXml();    Reads the XML content from the character channel.   closeRc(rch);  return result; }    Closes the character channel once you are done with it.   function closeRc(io:ReadableCharacterChannel rc) {  var result = rc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a readable channel.   function closeWc(io:WritableCharacterChannel wc) {  var result = wc.close();  if (result is error) {  log:printError(\"Error occurred while closing character stream\",  err = result);  } }    Closes a writable channel.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml_io.bal Preparing to write xml file Preparing to read the content written <book>The Lost World</book>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml-namespaces.html","name":"XML Namespaces","summary":"Ballerina has built-in support for defining and using XML namespaces.Namespaces can be declared at the module level as well as at the function level. The identifier followed by the\n as keyword is the prefix bound to this namespace name.Namespaces can be declared without the prefix. This will define a default ...","content":"/  /  /  / XML Namespaces  import ballerina/io;  xmlns \"http://ballerina.com/aa\" as ns0;  public function main() {  // Namespaces can be declared at the module level as well as at the function level. The identifier followed by the  // `as` keyword is the prefix bound to this namespace name.  xmlns \"http://ballerina.com/bb\" as ns1;   // Namespaces can be declared without the prefix. This will define a default namespace.  xmlns \"http://ballerina.com/default\";   // Namespaces can be used for XML-qualified names.  io:println(ns0:foo);   // Module level namespaces can be overridden at the function level.  xmlns \"http://ballerina.com/updated\" as ns0;  io:println(ns0:foo); }    XML Namespaces  Ballerina has built-in support for defining and using XML namespaces.    import ballerina/io;    xmlns \"http://ballerina.com/aa\" as ns0;    public function main() {    xmlns \"http://ballerina.com/bb\" as ns1;    Namespaces can be declared at the module level as well as at the function level. The identifier followed by the  as keyword is the prefix bound to this namespace name.   xmlns \"http://ballerina.com/default\";    Namespaces can be declared without the prefix. This will define a default namespace.   io:println(ns0:foo);    Namespaces can be used for XML-qualified names.   xmlns \"http://ballerina.com/updated\" as ns0;  io:println(ns0:foo); }    Module level namespaces can be overridden at the function level.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml_namespaces.bal {http://ballerina.com/aa}foo {http://ballerina.com/updated}foo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xml.html","name":"XML","summary":"The XML type in Ballerina represents a sequence of zero or more XML items.\n Each item can be an element, a text, a comment, or a processing instruction.The XML element. There can be only one root element.The XML text.The XML comment.The XML processing instructions.Multiple XML items can be combined to ...","content":"/  /  /  / XML  import ballerina/io;  public function main() {  // The XML element. There can be only one root element.  xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);   // The XML text.  xml x2 = xml `Hello, world!`;  io:println(x2);   // The XML comment.  xml x3 = xml `<!--I am a comment-->`;  io:println(x3);   // The XML processing instructions.  xml x4 = xml `<?target data?>`;  io:println(x4);   // Multiple XML items can be combined to form a sequence of XML. The resulting sequence is another XML on its own.  xml x5 = x1 + x2 + x3 + x4;  io:println(\"\\nResulting XML sequence:\");  io:println(x5); }    XML  The XML type in Ballerina represents a sequence of zero or more XML items.  Each item can be an element, a text, a comment, or a processing instruction.    import ballerina/io;    public function main() {    xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);    The XML element. There can be only one root element.   xml x2 = xml `Hello, world!`;  io:println(x2);    The XML text.   xml x3 = xml `<!--I am a comment-->`;  io:println(x3);    The XML comment.   xml x4 = xml `<?target data?>`;  io:println(x4);    The XML processing instructions.   xml x5 = x1 + x2 + x3 + x4;  io:println(\"\\nResulting XML sequence:\");  io:println(x5); }    Multiple XML items can be combined to form a sequence of XML. The resulting sequence is another XML on its own.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `ballerina run` command below. ballerina run xml.bal <book>The Lost World</book> Hello, world! <!--I am a comment--> <?target data?>    Resulting XML sequence: <book>The Lost World</book>Hello, world!<!--I am a comment--><?target data?>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/by-example/xslt-transformation.html","name":"XSLT Transformation","summary":"This example demonstrates how the XML content can be transformed to HTML using a given XSL transformation.Gets an XML object, which needs to be transformed.Gets an XSL style sheet represented in an XML object.Transforms the XML to another formats.Returns an XML object, which needs to be transformed.Returns an XSL style ...","content":"/  /  /  / XSLT Transformation  import ballerina/io; import ballerina/xslt;  public function main() {  // Gets an `XML` object, which needs to be transformed.  xml sourceXml = getXml();  // Gets an `XSL` style sheet represented in an XML object.  xml xsl = getXsl();   // Transforms the `XML` to another formats.  xml|error target = xslt:transform(sourceXml, xsl);  if (target is xml) {  io:println(\"Transformed xml : \", target);  } else {  io:print(\"Error : \", target);  } }  // Returns an `XML` object, which needs to be transformed. function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; }  // Returns an `XSL` style sheet represented in an XML object. function getXsl() returns xml {  return xml `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    XSLT Transformation  This example demonstrates how the XML content can be transformed to HTML using a given XSL transformation.    import ballerina/io; import ballerina/xslt;    public function main() {    xml sourceXml = getXml();    Gets an XML object, which needs to be transformed.   xml xsl = getXsl();    Gets an XSL style sheet represented in an XML object.   xml|error target = xslt:transform(sourceXml, xsl);  if (target is xml) {  io:println(\"Transformed xml : \", target);  } else {  io:print(\"Error : \", target);  } }    Transforms the XML to another formats.   function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; }    Returns an XML object, which needs to be transformed.   function getXsl() returns xml {  return xml `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    Returns an XSL style sheet represented in an XML object.   # To run this sample, navigate to the directory that contains the # `.bal` file and run the `ballerina run` command below. $ ballerina run xslt_transformation.bal Transformed xml : <html> <body> <h2>All time favourites</h2> <table border=\"1\"> <tr bgcolor=\"#9acd33\"> <th>Title</th><th>Artist</th> </tr> <tr> <td>Summer of 69</td><td>Bryan Adams</td> </tr> <tr> <td>Zombie</td><td>Bad Wolves</td> </tr> </table> </body> </html>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/calling-java-code-from-ballerina/","name":"Calling Java Code from Ballerina","summary":"Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java.  Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering ...","content":"/  /  / Calling Java Code from Ballerina  Calling Java Code from Ballerina  Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java. Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering to the Ballerina language semantics.  Table of contents Ballerina Bindings to Java code Your task is to write Ballerina code (Ballerina bindings) that lets you call the corresponding Java API as illustrated in the below diagram.    This guide teaches you how to write those bindings manually as well as how to generate those bindings automatically but first, let’s look at why you want to call Java from Ballerina.  The Need to Call Java from Ballerina   Ballerina is a relatively new language. Therefore, you may experience a shortage of libraries in . In such situations, as a workaround, you can use an existing Java library.  You are already familiar with a stable Java API that you would like to use in your Ballerina project.  You want to take advantage of the strengths of Ballerina but you don’t want to reinvest in the libraries that you or your company have written already.   There may be other reasons but these are great motivations to use Ballerina bindings.  Writing Ballerina Bindings Writing Ballerina bindings manually is a tedious task. You’ll soon see why. Therefore, we’ve developed a tool called bindgen that can generate Ballerina bindings for given Java APIs. The of this guide shows you how to use it. The is a reference guide to the tool.  The explains how to package Java libraries (JAR files) with Ballerina programs. This section is useful because whenever you generate bindings for a Java library, you need to package this Java library and its transitive dependencies to produce a self-contained executable program.  The and sections explain how to write these bindings manually. It is also a useful section for those who want to understand the inner workings of calling Java from Ballerina and for those who want to customize the bindings generated by the bindgen tool.  Using the SnakeYAML Java Library in Ballerina SnakeYAML is a YAML parser for Java. In this section, we’ll learn how to use this library to parse a YAML document using Ballerina.  We’ll develop a Ballerina program that parses the given YAML file and writes the content to the standard out.  Let’s get started.  Step 1 - Writing the Java Code We recommend you to always start by writing the Java code. It gives you an idea of the set of Java classes required to implement your logic. Then, we can use the bindgen tool to generate Ballerina bindings for those classes.  The following Java code uses the SnakeYAML API to parse the given YAML file. Note that this is not the most idiomatic way of writing the Java code for this scenario.  import org.yaml.snakeyaml.Yaml;  import java.io.FileInputStream; import java.io.InputStream; import java.util.Map;  public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Here, we’ve used four Java classes.   org.yaml.snakeyaml.Yaml  java.io.FileInputStream  java.io.InputStream  java.util.Map   You can see them in the imported class list. We encourage you to generate Ballerina bindings for these four classes as a start.  Now, we’ll create an environment for our Ballerina program.  Step 2 - Setting Up the Ballerina Project This section assumes that you have already read .  Creating a Ballerina Project > ballerina new yaml-project Created new Ballerina project at yaml-project  Next:  Move into the project directory and use `ballerina add <module-name>` to  add a new Ballerina module.  Adding a Ballerina Module to Your Project > ballerina add yamlparser Added new ballerina module at 'src/yamlparser’  Adding a Sample YAML File Copy the below content to a file named invoice.yml in the project root directory. invoice: 34843 date : 2001-01-23 bill-to: &id001  given : Chris  family : Dumars  address:  lines: |  458 Walkman Dr.  Suite #292  city : Royal Oak  state : MI  postal : 48046 ship-to: *id001 product:  - sku : BL394D  quantity : 4  description : Basketball  price : 450.00  - sku : BL4438H  quantity :  description : Super Hoop  price : 2392.00 tax : 251.42 total: 4443.52 comments: >  Late afternoon is best.  Backup contact is Nancy  Billsmer @ 338-4338.\\   Verifying the Project > ballerina build yamlparser Compiling source \tsameera/yamlparser:0.1.0  Creating balos \ttarget/balo/yamlparser-2020r1-any-0.1.0.balo ... ...  Generating executables \ttarget/bin/yamlparser.jar  > ballerina run target/bin/yamlparser.jar Hello World!  Great! You are all set for the next step.  Step 3 - Generating the Ballerina Bindings In this step, we’ll use the bindgen tool to generate Ballerina bindings for those four classes that we talked about in Step 1. If you want more information about the tool, you can refer .  > ballerina bindgen -mvn org.yaml:snakeyaml:1.25 -o src/yamlparser org.yaml.snakeyaml.Yaml java.io.FileInputStream java.io.InputStream java.util.Map  Ballerina project detected at: /Users/sameera/yaml-project  Resolving maven dependencies... snakeyaml-1.25.pom 100% [=================================================] 37/37 KB (0:00:00 / 0:00:00) snakeyaml-1.25.jar 100% [===============================================] 297/297 KB (0:00:01 / 0:00:00)  Updated the `Ballerina.toml` file with the new platform libraries.  The following JARs were added to the classpath: \tsnakeyaml-1.25.jar  Generating bindings for: \tjava.util.Map \tjava.io.FileInputStream \torg.yaml.snakeyaml.Yaml \tjava.io.InputStream  Generating dependency bindings for: \torg.yaml.snakeyaml.introspector.BeanAccess \tjava.util.function.BiFunction \torg.yaml.snakeyaml.DumperOptions$FlowStyle \t... \t...     The -mvn option specifies the Maven dependency of the Java library required to generate bindings.  The -o option specifies the output directory in which the generated bindings are stored. In this case, the tool is instructed to store bindings inside the yamlparser module.  The argument list specifies the Java class names.   The bindgen tool generates bindings for:   the specified Java classes  the Java classes exposed in the public APIs of all the specified classes   Before we move onto the next step, let’s verify the generated code. > ballerina build yamlparser ... ...  Generating executables \ttarget/bin/yamlparser.jar  > ballerina run target/bin/yamlparser.jar Hello World!   Step 4 - Writing the Ballerina Code    Note: The bindgen tool is still experimental. We are in the process of improving the generated code.   Now, we’ll use the generated bindings and write the Ballerina code, which uses the SnakeYAML library. Here is the Java code. Let’s develop the corresponding Ballerina code step by step. public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Creating the ‘FileInputStream’ Our goal here is to create a new java.io.FileInputStream instance from the filename. In step 3, we generated bindings for the required Java classes. The following is the code snippet that does the job.  FileInputStream | FileNotFoundException fileInputStream = newFileInputStream3(filename);   Here, FileInputStream is the Ballerina object generated for the java.io.FileInputStream class.   You can find functions that start with newFileInputStream in the generated code. Each such function creates a new java.io.FileInputStream instance. Ballerina does not support function overloading. Therefore, the bindgen tool generates a separate Ballerina function for each overloaded method or constructor. We will improve the function names of the generated bindings in a future release.  All the public methods in the java.io.FileInputStream class are mapped to methods in the generated Ballerina object.   Next, we’ll handle the error using a type guard. if fileInputStream is FileNotFoundException { \t// The type of fileInputStream is FileNotFoundException within this block  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \", fileInputStream.reason()); } else { \t// The type of fileInputStream is FileInputStream within this block }  Creating the SnakeYAML Entry Point The org.yaml.snakeyaml.Yaml class is the entry point to the SnakeYAML API. The generated corresponding Ballerina object is Yaml. The newYaml1() function is mapped to the default constructor of the Java class. Yaml yaml = newYaml1();  Loading the YAML Document We’ll be using the org.yaml.snakeyaml.Yaml.load(InputStream is) method to get a Java Map instance from the given InputStream. Object mapObj = yaml.load(inputStream);   The org.yaml.snakeyaml.Yaml.load(InputStream is) is a generic method. The bindgen tool does not support Java generics at the moment. That is why the corresponding Ballerina method returns an Object.  Printing the Returned Map Instance You can print the content of the Map instance in the standard out as follows. io:println(mapObj);  Completing the Code Here, is the complete code. You can replace the contents in src/yamlparser/main.bal with the following code. import ballerina/io;  public function main(string... args) returns error? {  string filename = args[0];  FileInputStream | FileNotFoundException fileInputStream = newFileInputStream3(filename);  if fileInputStream is FileNotFoundException {  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \", fileInputStream.reason());  } else {  Yaml yaml = newYaml1();  Object mapObj = yaml.load(fileInputStream);  io:println(mapObj);  } }   Let’s build and run this code. > ballerina build yamlparser Compiling source \tsameera/yamlparser:0.1.0  Creating balos \ttarget/balo/yamlparser-2020r1-any-0.1.0.balo ... ...  Generating executables \ttarget/bin/yamlparser.jar   Now, we need to pass the YAML file name as the first argument. > ballerina run target/bin/yamlparser.jar invoice.yml {invoice=34843, date=Mon Jan 22 16:00:00 PST 2001, bill-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, ship-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, product=[{sku=BL394D, quantity=4, description=Basketball, price=450.0}, {sku=BL4438H, quantity=null, description=Super Hoop, price=2392.0}], tax=251.42, total=4443.52, comments=Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338.\\}  In this section, we explained how to use the bindgen tool to generate Ballerina bindings for Java classes and how to use those generated ones.  The next sections provide more details on various aspects related to Java interoperability in Ballerina.  The ‘bindgen’ Tool  The following subsections explain how the bindgen tool works.    Note: The bindgen tool is still experimental and the generated code is being improved currently.   The bindgen is a CLI tool, which generates Ballerina bindings for Java classes.  The ‘bindgen’ Command  ballerina bindgen [(-cp|--classpath) <classpath>...]  [(-mvn|--maven) <groupId>:<artifactId>:<version>]  [(-o|--output) <output>]  [--public]  (<class-name>...)   (-cp|--classpath) <classpath>... This optional parameter could be used to specify one or more comma-delimited classpaths for retrieving the required Java libraries needed by the bindgen tool execution. The classpath could be provided as comma-separated paths of JAR files or as comma-separated paths of directories containing all the relevant Java libraries. If the Ballerina bindings are to be generated from a standard Java library, from a library available inside the Ballerina SDK, or from a platform library specified in the Ballerina.toml, then you need not specify the classpath explicitly.  (-mvn|--maven) <groupId>:<artifactId>:<version> This optional parameter could be used to specify a Maven dependency required for the generation of the Ballerina bindings. Here, the specified library and its transitive dependencies will be resolved into the target/platform-libs directory of the project. If the tool is not executed inside a project or if the output path does not point to a project, the target/platform-libs directory structure will be created in the output path to store the Maven dependencies. The tool will also update the Ballerina.toml file with the platform libraries if the command is executed inside a Ballerina project.  (-o|--output) <output> This optional parameter could be used to specify the directory path to which the Ballerina bindings should be inserted. If this path is not specified, the output will be written to the same directory from which the command is run. You can point to the path of a Ballerina module to generate the code inside a Ballerina module.  --public Set the visibility modifier of the generated binding objects to public. By default, the generated bindings will be module private.  <class-name>... One or more space-separated fully-qualified Java class names for which the Ballerina bridge code is to be generated. Please note that these class names should be provided at the end of the command.  Generated Bridge Code  When the tool is run, a .bal file will be created to represent each Java class. This would contain the respective Ballerina binding object along with the required Java interoperability mappings. These .bal files would reside inside sub directories representing the package structure.  Apart from creating bindings for the specified Java classes, the command will also generate empty Ballerina binding objects for the dependent Java classes. A Java class would be considered dependent if it is used inside one of the generated Ballerina binding objects.  A set of additional utility files will also be generated in order to support the auto-generated Ballerina bindings. This includes a Constants.bal file to store constants used for proper functioning of the Ballerina binding objects and .bal files to store the error types used within the Ballerina binding objects.  The folder structure of the generated bindings will be as follows.  <ballerina_bindings>  ├── <bindings>  ├── <package-name>  ├── <class-name>.bal  └── ...  └── ...  ├── <dependencies>  ├── <package-name>  ├── <class-name>.bal  └── ...  └── ...  └── <utils>  ├── Constants.bal  └── <error_types>  ├── <class-name>.bal  └── ...   Java to Ballerina Mapping  Java Classes A Java class will be mapped onto a Ballerina object. This Ballerina object will have the same name as that of the Java class.  E.g., Generated Ballerina object of the java.util.ArrayDeque class will be as follows. @java:Binding {  'class: \"java.util.ArrayDeque\" } type ArrayDeque object {   *java:JObject;   function init(handle obj) {  self.jObj = obj;  }   ... };  If there are multiple classes with the same simple name, they need to be generated using a single execution. The tool will then apply a numerical identifier at the end of duplicated object names. This could be manually changed into something meaningful if required.  The format for specifying inner classes using the command is <package-name>.ClassName$InnerClassName. The dollar sign might have to be escaped using the blackslash key.  E.g., The command to generate bindings for java.lang.Character.Subset class will be as follows. > ballerina bindgen java.lang.Character\\$Subset   When referring a Java code to figure out the imported classes, you should be cautious about the Java classes from the java.lang package since these will not be visible as imports in the Java code. However, you need not generate bindings for the java.lang.String class since it is mapped into the Ballerina string type from within the Ballerina bindings generated.  Constructors Constructors of Java classes will be mapped onto public functions outside the Ballerina object. These function names are comprised of the constructor name prefixed with the new keyword. If there are multiple constructors, they will be suffixed with an auto increment number.  E.g., Generated constructors of the java.util.ArrayDeque class will be as follows. function newArrayDeque1() returns ArrayDeque {  ... }  function newArrayDeque2(int arg0) returns ArrayDeque {  ... }  function newArrayDeque3(Collection arg0) returns ArrayDeque {  ... }   Methods All public methods will be exposed through Ballerina bindings. Instance methods will reside inside the Ballerina object and these would take the name of the Java method. However, if there are overloaded methods, a numeric suffix will be appended at the end of the name.  E.g., Some of the generated instance methods of the java.util.ArrayDeque class will be as follows. type ArrayDeque object {  ...  function add(Object arg0) returns boolean {  ...  }   function isEmpty() returns boolean {  ...  } };  Static methods would reside outside the Ballerina object as public functions, which take the name of the Java method with the Java class name appended at the beginning as a prefix.  E.g., A generated static method randomUUID() of the java.util.UUID class will be as follows. Here, the Ballerina equivalent of calling UUID.randomUUID() in Java will be UUID_randomUUID(). function UUID_randomUUID() returns UUID {  ... }   Fields All public fields of a Java class will be exposed through Ballerina bindings in the form of getters and setters. Instance fields will have the respective getter and setter functions inside the Ballerina object, whereas the static fields will have getter and setter functions outside the Ballerina object.  The getter and setter functions of an instance field will take the name of the field prefixed with a get or set at the beginning.  E.g., get<FIELD_NAME>() and set<FIELD_NAME>(<type> arg)  For a static field, the getter and setter (if the field is not final) functions will take the name of the field with a get or set prefix along with the Java simple class name appended at the beginning.  E.g., <Class_Name>_get<FIELD_NAME>() and <Class_Name>_set<FIELD_NAME>(<type> arg)  External Interop Functions These external interop functions are module private and they take the fully-qualified Java method name as the function it is calling. However, if overloaded methods exist, a numeric suffix will be appended at the end.  E.g., Generated external interop function for close() method of java.io.FileInputStream will be as follows. function java_io_FileInputStream_close(handle receiver) returns error? = @java:Method {  name: \"close\",  'class: \"java.io.FileInputStream\",  paramTypes: [] } external;   Dependency Objects When there are dependent Java classes present inside generated Ballerina bindings (as parameters or return types), the bindgen tool generates an empty Ballerina binding object to represent each one of these classes. This will represent a Java class mapping without the constructors, methods, or field bindings. If one of these classes is required later, the bindgen tool could be re-run to generate the Ballerina bindings.  E.g., The generated dependency object representing java.util.List will be as follows. public type List object {  *JObject;  public function __init(handle obj) {  self.jObj = obj;  }   public function toString() returns string {  return java:jObjToString(self.jObj);  } };   Ballerina JObject A Ballerina binding object representing a Java class will always be implemented using the abstract class JObject. This is present inside the ballerina/java module of the Ballerina standard library and could be accessed as java:JObject if the java module is imported into a project.  To explain the implementation further, this Ballerina object will always store the handle reference of the Java object in it’s jObj field.  public type JObject abstract object {  public handle jObj; };   Java to Ballerina Type Mappings Generated Ballerina bindings will support the following type mappings between Java and Ballerina.   Ballerina primitive - Java primitive  Ballerina string type - Java String object  Ballerina binding objects - Java objects   The Ballerina binding objects will store a handle reference of the Java object using its jObj field. More details on the type mappings could be found in the section of this guide.  Support for Java Subtyping Ballerina bindings provide support for Java subtyping with the aid of structural typing in the language.  E.g., A Ballerina binding object mapping the java.io.FileInputStream Java class could be assigned to a Ballerina binding object mapping the java.io.InputStream as follows. InputStream inputStream = check newFileInputStream3(\"sample.txt\");     Note: For Java Subtyping to work, the Ballerina binding objects need to be fully implemented, it will not work with empty dependency objects.   Support for Java Casting The ballerina/java module of the Ballerina standard library provides the cast function to support Java casting. This could be used to cast Ballerina binding objects into their subtypes based on assignability.  E.g., A Ballerina binding object instance mapping the java.io.InputStream Java class inputStream could be casted onto a Ballerina binding object mapping the java.io.FileInputStream Java class as follows. FileInputStream fileInputStream = <FileInputStream>check java:cast(inputStream, typedesc<FileInputStream>);   Java Exceptions to Ballerina Errors When generating Ballerina bindings, Java exceptions will be mapped onto Ballerina errors. They will have identical names as that of the corresponding Java exceptions and these will be generated inside the ballerina_bindings/utils/error_types directory. Instead of returning a generic error from the Java side, the bindings will return a more meaningful error representing the exact Java exception.  E.g., The following IOException will be returned from the read() function in the java.io.FileInputStream Ballerina binding object.  function read() returns int|IOException {  int|error externalObj = java_io_FileInputStream_read(self.jObj);  if (externalObj is error) {  IOException e = IOException(message = externalObj.reason(), cause = externalObj);  return e;  } else {  return externalObj;  } }     Note: If a Java exception class is generated as a Ballerina binding object, it would follow the naming convention JException or JError. For instance, the binding object’s name for java.io.FileNotFoundException would be as JFileNotFoundException.   Packaging Java Libraries with Ballerina Programs    Tip: As a prerequisite for this section, see . When you compile a Ballerina program with ballerina build <root-module>, the compiler creates an executable JAR file and when you compile a Ballerina module with ballerina build -c <module>, the compiler creates a BALO file. In both cases, the Ballerina compiler produces self-contained archives. There are situations in which you need to package JAR files with these archives. The most common example would be packing the corresponding JDBC driver.   There are two kinds of Ballerina projects:   Produces executable programs  Contains one or more Ballerina modules and at least one of them has to be a root module.  A root module has a main method and/or one or more services.  Build the project with ballerina build <root-module> or use ballerina build -a if there is more than one root module.  The best practice is to maintain a single root module in a Ballerina project.  Produces Ballerina library modules  Contains one or more Ballerina library modules.  Build the modules with ballerina build -c <module> or ballerina build -c -a to build all modules.  Usually, the compiled library modules are pushed to Ballerina central.  How you package JAR files with compiled archives is the same in both kinds of projects. Therefore, a sample Ballerina project, which produces an executable is used here.  Here, is a Ballerina project layout of a microservice called “order management”. The module ordermgt - the root module - contains a RESTFul service, which exposes resource functions to create, retrieve, update, and cancel orders. The dbutils module offers utility functions, which use a MySQL database to store orders.  ordermgt_service/ ├── Ballerina.toml └── javalibs/  └── mysql-connector-java-<version>.jar └── src/  └── ordermgt/  └── dbutils/   The Java MySQL connector is placed inside the javalibs directory. You are free to store the JAR files anywhere in your file system. This example places those JAR files inside the project directory. As a best practice, maintain Java libraries inside the project. The Ballerina.toml file, which marks a directory as a Ballerina project lives at the root of the project. It is also a manifest file that contains project information, dependent Ballerina module information, and platform-specific library information. Java libraries are considered as platform-specific libraries. Here, is how you can specify a JAR file dependency in theBallerina.toml.  [platform] target = \"java8\" [[platform.libraries]] # Absolute or relative path to the JAR file path = \"<path-to-jar-file-1>\" # A comma-separated list of Ballerina module names, which depends on this JAR modules = [\"<ballerina-module-1>\"]  [[platform.libraries]] path = \"<path-to-jar-file-2>\" modules = [\"<ballerina-module-1>\",\"<ballerina-module-2>\"]   Alternatively, you can also specify Maven dependencies as platform-specific libraries. These dependencies specified would then get resolved into the target/platform-libs directory when building the project. You can specify a Maven dependency in the Ballerina.toml file as shown below.  [platform] target = \"java8\"  [[platform.libraries]] # A comma-separated list of Ballerina module names, which depends on this JAR modules = [\"<ballerina-module-1>\"] # Group ID of the Maven dependency groupId = \"<group-id>\" # Artifact ID of the Maven dependency artifactId = \"<artifact-id>\" # Version of the Maven dependency version = \"<version>\"  [[platform.libraries]] modules = [\"<ballerina-module-1>\",\"<ballerina-module-2>\"] groupId = \"<group-id>\" artifactId = \"<artifact-id>\" version = \"<version>\"   Now, let’s look at the contents of the Ballerina.toml file in this project. [platform] target = \"java8\" [[platform.libraries]] path = \"./javalibs/mysql-connector-java-<version>.jar\" modules = [\"ordermgt\"]   Or, if you are adding it as a Maven dependency, it would take the following form. [platform] target = \"java8\"  \t[[platform.libraries]] \tmodules = [\"ordermgt\"] \tgroupId = \"mysql\" \tartifactId = \"mysql-connector-java\" \tversion = \"<version>\"   If your project has only one root module, then you can attach all the JAR file dependencies to your root module as the best practice.  If your project is a Ballerina library module project, then you should specify the JAR file dependencies in each Ballerina module if that module depends on the JAR file.  Now, use ballerina build ordermgt to build an executable JAR. This command packages all JARs specified in your Ballerina.toml with the executable JAR file.  Ballerina FFI Let’s look at the list of language features that enable Ballerina developers to call foreign code written in other programming languages. E.g., while the jBallerina compiler allows you to call any Java code, the nBallerina compiler will allow you to call any C Code.  The External Function Body Usually, the body or the implementation of a function is specified in the same source file. The part, which is enclosed by curly braces is called the function body.  function doSomething(int i) returns string { \t... }   Ballerina also allows you to define a function without a function body and marks it with the external keyword to express that the implementation is not provided by the Ballerina source file.  function doSomething(int i) returns string = external;   Now, let’s see how you can link this function with a foreign function.  import ballerina/java;  function doSomething(int i) returns string = @java:Method { \tname: \"doSomethingInJava\" \t'class: \"a.b.c.Foo\" } external;   The @java:Method annotation instructs the jBallerina compiler to link with the doSomethingInJava static method in the Java class a.b.c.Foo. There are a set of annotations and other utilities available in the ballerina/java module to make Java interoperability work. This guide covers most of them.  The Handle Type The handle type describes a reference to an externally-managed storage. These values can only be created by a Ballerina function with an external function body. Within the context of jBallerina, a handle type variable can refer to any Java reference type value: a Java object, an array, or the null value.  Consider the randomUUID method in the Java UUID class, which gives you a UUID object. This is the Java method signature.  static UUID randomUUID()   Here, is the corresponding Ballerina function that returns a value of the handle type.  import ballerina/java;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  'class: \"java.util.UUID\" } external;   In Java, you can assign the null value to any variable of a reference type. Therefore, a handle type variable may also refer to the Java null.  The following section describes various aspects of Java interoperability in Ballerina. You can copy and paste the following examples into a .bal file and run it using the ballerina run <file_name.bal> command.  Calling Java Programs from Ballerina The following subsections explain how to call Java code from Ballerina.    Instantiating Java Classes Let’s look at how you can create Java objects in a Ballerina program. The @java:Constructor annotation instructs the compiler to link a Ballerina function with a Java constructor.  The ArrayDeque class in the java.util package has a default constructor. The following Ballerina code creates a new ArrayDeque object. As you can see, the newArrayDeque function is linked with the default constructor. This function returns a handle value and it refers the constructed ArrayDeque instance.  import ballerina/java;  public function main() {  handle arrayDeque = newArrayDeque(); }  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;   You can also create a wrapper Ballerina object for Java classes as follows.  import ballerina/java;  public function main() {  ArrayDeque ad = new; }  type ArrayDeque object {  private handle jObj;   function __init(){  self.jObj = newArrayDeque(); } };  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;      Note: that these @java:* annotations cannot be attached to Ballerina object methods at the moment.   Dealing with Overloaded Constructors When there are two constructors with the same number of arguments available, you need to specify the exact constructor that you want to link with the Ballerina function. The ArrayDeque class contains three constructors and the last two are overloaded ones.  public ArrayDeque(); public ArrayDeque(int numElements); public ArrayDeque(Collection<? extends E> c);   Here, is the updated Ballerina code.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function newArrayDequeWithSize(int numElements) returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;  function newArrayDequeWithCollection(handle c) returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\",  paramTypes: [\"java.util.Collection\"] } external;   The ‘paramTypes’ Field You can use the paramTypes field to resolve the exact overloaded method. This field is defined as follows.  # The `Class` type represents a fully-qualified Java class name. public type Class string;  # The `ArrayType` represents a Java array type. It is used to specify parameter # types in the `Constructor` and `Method` annotations. # # + class - Element class of the array type # + dimensions - Dimensions of the array type public type ArrayType record {|  Class class;  byte dimensions; |};  (Class | ArrayType)[] paramTypes?;   As per the above definition, paramTypes field takes an array of Java classes or array types. The following table contains more details.    Java Type  Description  Example  Primitive  The Java class name of a primitive type is the same as the name of the primitive type.  The boolean.class.getName() expression evaluates to “boolean”. Similarly, the int.class.getName() expression evaluates to “int”.  Class  Fully-qualified class name  “java.lang.String”  Array  Use the ArrayType record defined above to specify Java array types in overloaded methods.  Method signature: void append(boolean[] states, long l, String[][] args); The corresponding value of the paramField: paramField: [{class:”boolean”, dimensions: 1}, “long” {class:”java.lang.String”, dimensions: 2}]  For more details, look at the following example.  public Builder(Person[][] list, int index); public Builder(Student[][] list, int index);   Here, is the corresponding Ballerina code.  import ballerina/java;  function builderWithPersonList(handle list, int index) returns handle = @java:Constructor {  'class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Person\", dimensions:2}, \"int\"] } external;  function builderWithStudentList(handle list, int index) returns handle = @java:Constructor {  'class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Student\", dimensions:2}, \"int\"] } external;   Calling Java Methods You can use the java:@Method annotation to link Ballerina functions with Java static and instance methods. There is a small but important difference in calling Java static methods vs calling instance methods.  Calling Static Methods Let’s first look at how to call a static method. The “java.util.UUID” class has a static method with the static UUID randomString() signature.  import ballerina/java; import ballerina/io;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  'class: \"java.util.UUID\" } external;  public function main() {  handle uuid = randomUUID();  io:println(uuid); }   The name field is optional here. If the Ballerina function name is the same as the Java method name, you don’t have to specify the name field.  function randomUUID() returns handle = @java:Method {  'class: \"java.util.UUID\" } external;   Calling Instance Methods Now, let’s look at how to call Java instance methods using the same ArrayDeque class in the java.util package. It can be used as a stack with its pop and push instance methods with the following method signatures.  E pop(); void push(E e);   Here, are the corresponding Ballerina functions that are linked to these methods.  function pop(handle arrayDequeObj) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  function push(handle arrayDequeObj, handle e) = @java:Method {  'class: \"java.util.ArrayDeque\" } external; If you compare these functions with the Java method signatures, you would notice the additional handle arrayDequeObj parameter in Ballerina functions. Let’s look at a sample usage to understand the reason.  public function main() {  // Create a new instance of `ArrayDeque`.  handle arrayDequeObj = newArrayDeque();   // Convert a Ballerina string to a Java string.  string str = “Ballerina”  handle handleStr = java:fromString(str);   push(arrayDequeObj, handleStr);  handle e = pop(arrayDequeObj); }   As you can see, you need to first construct an instance of the ArrayDeque class. The arrayDequeObj variable refers to an ArrayDeque object. Then, you need to pass this variable to both the pop and push functions because the corresponding Java methods are instance methods of theArrayDeque class. Therefore, you need an instance of the ArrayDeque class in order to invoke its instance methods. You can think of the arrayDequeObj variable as the method receiver.  Calling Methods Asynchronously  Ballerina internally uses a fixed number of threads. Therefore, when calling a Java method, it should return in a reasonable time frame in order to avoid starvation in the Ballerina code execution.  If the given Java method executes a time consuming (i.e., blocking) task such as an IO operation, better to do that in a separate thread while yielding the original thread to continue the Ballerina code execution. In this case, Ballerina Scheduler needs to be informed that the work is being completed asynchronously by invoking the markAsync method in the BalEnv object. When the work is completed, the complete method has to be called with the return value.    Note: The original return value is ignored.  public static long getFileCountRecursively(BalEnv env, BString path) {  BalFuture balFuture = env.markAsync();  new Thread(() -> {  long result = // slow operation ;  balFuture.complete(result);  }).start(); // in a production system this can be a thread pool/nio pool  return -38263; // this value is ignored  }  public function getFileCountRecursively(string path) returns int = @java:Method {  'class:\"my/test/DirOperations\" } external;   Mapping Java Classes into Ballerina Objects The following pattern is useful if you want to present a clearer Ballerina API, which calls to the underneath Java code. This pattern creates wrapper Ballerina objects for each Java class that you want to expose via your API.  Imagine that you want to design an API to manipulate a stack of string values by using the Java ArrayDeque utility. You can create a Ballerina object type as follows.  public type StringStack object {  private handle jObj;   public function __init() {  self.jObj = newArrayDeque();  }   public function push(string element) {  push(self.jObj, java:fromString(element));  }   public function pop() returns string {  handle handleEle = pop(self.jObj);  // Let's talk about error handling and null satefy later in this guide  // This example uses an empty string for now.  return java:toString(handleEle) ?: \"\";   } };  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  function push(handle receiver, handle element) = @java:Method {  'class: \"java.util.ArrayDeque\" } external;   This object presents a much clearer API compared to the previous API. Here, is a sample usage of this object.  public function main() {  StringStack stack = new();  stack.push(\"Ballerina\"); string element = stack.pop(); }   Calling Overloaded Java Methods The “Instantiate Java classes” section presents how to deal with overloaded constructors in the. You need to use the same approach to deal with overloaded Java methods. Let’s try to call the overloaded append methods in the `java.lang.StringBuffer class. Here, is a subset of those methods.  StringBuffer append(boolean b); StringBuffer append(int i); StringBuffer append(String str); StringBuffer append(StringBuffer sb); StringBuffer append(char[] str);   Here, is the set of Ballerina functions that are linked with the above Java methods. Notice the usage of the paramTypes annotation field. You can find more details of this field in the “Instantiate Java classes” section.  function appendBool(handle sbObj, boolean b) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"boolean\"],  'class: \"java.lang.StringBuffer\" } external;  function appendInt(handle sbObj, int i) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"int\"],  'class: \"java.lang.StringBuffer\" } external;  function appendCharArray(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [{class: \"char\", dimensions: 1}],  'class: \"java.lang.StringBuffer\" } external;  function appendString(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.String\"],  'class: \"java.lang.StringBuffer\" } external;  function appendStringBuffer(handle sbObj, handle sb) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.StringBuffer\"],  'class: \"java.lang.StringBuffer\" } external;   Java Exceptions as Ballerina Errors A function call in Ballerina may complete abruptly by returning an error or by raising a panic. Panics are rare in Ballerina. The best practice is to handle errors in your normal control flow. Raising a panic is similar to throwing a Java exception. The trap action will stop a panic and give you the control back in Ballerina and the try-catch statement does the same in Java.  Errors in Ballerina belong to the built-int type error. The error type can be considered as a distinct type from all other types: The error type does not belong to the any type, which is the supertype of all other Ballerina types. Therefore, errors are explicit in Ballerina programs and it is almost impossible to ignore them. For more details, see BBEs.  How do Java exceptions are mapped to Ballerina errors? A Java function call may complete abruptly by throwing either a checked exception or an unchecked exception. Unchecked exceptions are usually not part of the Java method signature unlike the checked exceptions.  Java interoperability layer in Ballerina handles checked exceptions differently from unchecked exceptions as explained below. Java unchecked exceptions If the linked Java method throws an unchecked exception, then the corresponding Ballerina function will complete abruptly by raising a panic.  The following example tries to pop an element out of an empty queue. The pop method in the ArrayDeque class throws an unchecked java.util.NoSuchElementException exception in such cases. This exception will cause the Ballerina pop function to raise a panic.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = pop(arrayDeque); }   Here, is the output:  error: java.util.NoSuchElementException at array_deque:pop(array_deque.bal:65535)  array_deque:main(array_deque.bal:13)   You can use the trap action to stop the propagation of the panic and to get an error value.  public function main() {  handle arrayDeque = newArrayDeque();  handle | error element = trap pop(arrayDeque);  if element is error {  io:println(element.reason());  io:println(element.detail());  io:println(element.stackTrace().callStack);  } else {  // .....  } } Java Checked Exceptions Let’s see how you can call a Java method that throws a checked exception. As illustrated in the following example, the corresponding Ballerina function should have the error type as part of its return type.  The java.util.zip.ZipFile class is used to read entries in a ZIP file. There are many constructors in this class. Here, the constructor that takes the file name as an argument is used.  public ZipFile(String name) throws IOException   Since this Java constructor throws a checked exception, the newZipfile Ballerina function returns ZipFile instances or an error.  import ballerina/java;  function newZipFile(handle filename) returns handle | error = @java:Constructor {  'class: \"java.util.zip.ZipFile\",  paramTypes: [\"java.lang.String\"] } external;  public function main() {  handle|error zipFile = newZipFile(java:fromString(\"some_file.zip\")); }   Mapping a Java Exception to a Ballerina Error Value Now, let’s briefly look at how a Java exception is converted to a Ballerina error value at runtime. A Ballerina error value contains three components: a reason, a detail, and stack trace.  The reason:   This is a string identifier for the error category.  In this case, the reason value is set to the fully-qualified Java class name of the exception.  Unchecked: Class name of of the thrown unchecked exception  Checked: Class name of the exception that is declared in the method signature  The detail:   The message field is set to e.getMessage().  The cause field is set to the Ballerina error that represents this Java exception’s cause.   Null Safety Ballerina provides strict null safety compared to Java with optional types. The Java null reference can be assigned to any reference type. However, in Ballerina, you cannot assign the nil value to a variable unless the variable’s type is an optional type.  As explained above, Ballerina handle values cannot be created in Ballerina code. They are created and returned by foreign functions and a variable of the handle type refers to a Java reference value. Since Java null is also a valid reference value, this variable can refer to a Java null value.  Let’s look at an example, which deals with Java null. The following code uses the peek method in the ArrayDeque class. Peek retrieves but does not remove the head of the queue or returns null if the queue is empty.  import ballerina/java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function peek(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  // Linked with the `java.lang.Object.toString()` method in Java. function toString(handle objInstance) returns handle = @java:Method {  'class: \"java.lang.Object\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque);  Handle str = toString(element); }   Since the queue is empty in this case, peek should return null i.e., element should refer to Java null. The output of this program will be as follows.   error: org.ballerinalang.jvm.values.ErrorValue message={ballerina}JavaNullReferenceError \tat array_deque:toString(array_deque.bal:19)  array_deque:main(array_deque.bal:27)   This is equivalent to a Java NPE. In such situations, you should check for null using the java:isNull() function. Here, is the modified example.  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque); if java:isNull(element) {  // handle this case  } else {  handle str = toString(element);  } }   There are situations in which you need to pass a Java null to a method or store it in a data structure. In such situations, you can create a handle value that refers to a Java null as follows.  handle nullValue = java:createNull();   Mapping Java Types to Ballerina Types and Vice Versa Mapping Java Types to Ballerina Types The following table summarizes how Java types are mapped to corresponding Ballerina types. This is applicable when mapping a return type of a Java method to a Ballerina type.    Java type  Ballerina type  Notes  Any reference type including “null type”  handle  boolean  boolean  byte  byte, int, float  widening conversion when byte -> int and byte -> float  short  int, float  widening conversion  char  int, float  widening conversion  int  int, float  widening conversion  long  int, float  widening conversion when long -> float  float  float  widening conversion  double  float  Mapping Ballerina Types to Java Types The following table summarizes how Ballerina types are mapped to corresponding Java types. These rules are applicable when mapping a Ballerina function argument to a Java method/constructor parameter.    Ballerina type  Java type  Notes  handle  Any reference type  As specified by the Java method/constructor signature  boolean  boolean  byte  byte, short, char, int, long, float, double  Widening conversion from byte -> short, char, int, long, float, double  int  byte, char, short, int, long  Narrowing conversion when int -> byte, char, short, and int  float  byte, char, short, int, long, float, double  Narrowing conversion when float -> byte, char, short, int, long, float  Access or Mutate Java Fields The @java:FieldGet and @java:FieldSet annotations allow you to read and update the value of a Java static or instance field respectively. The most common use case is to read a value of a Java static constant.  import ballerina/java;  public function pi() returns float = @java:FieldGet {  name:\"PI\",  'class:\"java/lang/Math\" } external;  public function main() {  float r = 4;  float l = 2 * pi() * r; }   In this example, the pi() function returns the value of the java.lang.Math.PI static field. This uses the annotation field name to specify the name of the field. Likewise, if you want to access an instance field, you need to pass the relevant object instance as discussed in the instance methods section.  The @java:FieldSet annotation has the same structure as the above.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/annotations_documentation_and_comments/","name":"Annotations, Documentation and Comments","summary":"The sections below include the coding conventions with respect to annotations, documentation, and comments.Table of contents        Example,Example,Example,Example,Example,andExample,Example,Example,Example,\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can ...","content":"/  /  /  / Annotations, Documentation and Comments  Annotations, Documentation and Comments  The sections below include the coding conventions with respect to annotations, documentation, and comments.  Table of contents Annotations   Do not have spaces around the @ symbol.  Indent annotations to align them with the starting position of the owner (statement or definition).   Example,  // Service annotations are indented to align it with the starting position of the service. @http:ServiceConfig {  ... } service greetingService on new http:Listener(8080) {  // Resource annotation is indented to align it with the starting position of the resource.  @http:ResourceConfig {  ...  }  resource function hello(http:Caller caller, http:Request req) returns error? {  ...  } }     Each annotation attribute (i.e., key-value pairs) should block indent on its own line..   Example,  @http:ServiceConfig {  basePath: \"greet\",  methods: [\"GET\"] }     If an annotation is empty, place it in a single line and do not have spaces between both braces.   Example,  @http:ServiceConfig {}     If you are annotating a parameter or a return type, the annotation should be added inline to the parameter or the return type.   Example,  // Parameter annotation. public function secureFunction1(@sensitive string secureInName, @sensitive int secureInId, string insecureIn) {  ... }  public function secureFunction2(@sensitive string secureInName,  @sensitive int secureInId, string insecureIn) {  ... }  // Return type annotation. public function taintedReturn1() returns @tainted string {  ... }  public function taintedReturn2() returns @tainted string {  ... }  Comments   Use // for both single-line and multi-line comments.   Example,  // This is a single-line comment.   and  // Copyright (c) 2019 WSO2 Inc. (http://www.wso2.org) All Rights Reserved. // // WSO2 Inc. licenses this file to you under the Apache License, // Version 2.0 (the \"License\"); you may not use this file except // in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License.     Add a single space between the // and the content.  If the comment is in its own line, then indent it considering its context (i.e., top-level or in a block).   Example,  // This is a top-level comment.  function func1() {  // This is a block-level comment. }  function func2() {  if (true) {  if (true) {  // This is a nested if block-level comment.  }  } }     If the comment is in line with the code, add a space before it.   Example,   type People record {}; // Inline comment  function func1() {  int a = 0; // Inline comment }    Documentation   Always, indent them to align with the starting position of the owner.  Add a space after the # symbol.  Add an empty line after the description.   Example,  # Description. # # + value - value input parameter # + return - return a integer value function getValue(int value) returns int {  return value; }     Add only one space after the parameter marker (+), divider (-), and return.  Begin the param identifier and description with a single space.   Example,  # Description. # # + value - Parameter description # + return - Return value description function getValue(int value) returns int {...}  # Description. @http:ServiceConfig {...} service greet on new http:Listener(8080) {  # Description.  #  # + caller - Parameter description.  # + request - Parameter description.  @http:ResourceConfig {...}  resource function sayHello(http:Caller caller, http:Request request) {...} }   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/expressions/","name":"Expressions","summary":"The sections below include the coding conventions with respect to expressions.Table of contents        Do not keep spaces between the function name and opening parentheses (.If it is unable to keep the function invocation in a single line due to it exceeding the max line length, ...","content":"/  /  /  / Expressions  Expressions  The sections below include the coding conventions with respect to expressions.  Table of contents Function Invocation    Do not keep spaces between the function name and opening parentheses (.  If it is unable to keep the function invocation in a single line due to it exceeding the max line length, split each argument to its own block-indented line.  Example,   setAgeForEmployee(  employeeName,  employeeID  );   Record Literal    If empty, keep it as an empty block.   Example,  Person p = {};     In a record literal, arrange the fields in a single line. Then, add a space after the comma and leave no spaces between the braces and fields.   Example,  Person p = {name: \"john\", age: 20};     Do not keep any spaces between the key and the colon. Also, Keep only one space between the colon and the value.   Example,  Person person = {  name: \"john\", // in this field Key is the \"name\" and value is \"john\". };     You can define the fields in new lines. If so, make sure all the fields are in a separate line and they are block-indented.   Do’s  Person p = {  name: \"john\",  age: 20 };   Don’ts  Person p = {name: \"john\",  age: 20};  //Or  Person p = { name: \"john\", age: 20 };  //Or  Person p = {  name: \"john\",  age: 20};   Map Literal    For Map literals, follow the same formatting guidelines as .   Example,   // Inline map literal. map<string> mapOfString1 = {name: \"john\", id: \"0\"};  // Mulitline map literal. map<string> mapOfString2 = {  name: \"john\",  id: \"0\" }   Tuple    Always, place a tuple in a single line.   Example,  [string, int] tuple = [\"john\", 20];     If a tuple exceeds the maximum line length limit, move the whole tuple to a new line and indent with four spaces from the starting position of the statement or definition.   Example,  (string, int) tuple = (nameOfEmployee, ageOfTheEmployee);   Array Literal    Place simple arrays in a single line.  Do not keep any spaces between the opening bracket, value, and the closing bracket.   Example,  string[] names = [\"john\", \"doe\", \"jane\", \"doe\"];     If an array cannot be placed on a single line due to it exceeding the max line length, split each value in the array to its own block-indented line.   Example,   string[] names = [  \"john\",  \"doe\",  \"jane\",  \"doe\" ];  Type Casting    Do not keep spaces between the type and the angle brackets (i.e., <string>).  Do not keep spaces between the closing angle bracket and value reference, which will be casted.   Example,  string name = <string>json.name;     Avoid line breaks in type casting.   Do’s  <string>   Don’ts  <  string >   Table Literal    Follow formatting when formatting a table block.   Example,  table<Employee> employee1 = table {  {key id, name, address} };  table<Employee> employee2 = table {  {  key id,  name,  address  },  [{\"1\", \"test\", \"No:123 hty RD\"}, {\"1\", \"john\", \"No:123\"}] };  table<Employee> employee3 = table {  {id, name, address},  [  {\"1\", \"john\", \"No:123\"},  {\"2\", \"jane\", \"No:342\"}  ]  };  table<Employee> employee4 = table {  {id, name, address},  [  {  \"1\",  \"john\",  \"No:123\"  },  {\"2\", \"jane\", \"No:342\"}  ] }   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/operators_keywords_and_types/","name":"Operators, Keywords, and Types","summary":"The sections below include the coding conventions with respect to operators, keywords, and types.Table of contents        Example,Example,Do’sDon’tsExample,Example,Example,Example,Example,\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can ...","content":"/  /  /  / Operators, Keywords, and Types  Operators, Keywords, and Types  The sections below include the coding conventions with respect to operators, keywords, and types.  Table of contents Keywords and Types   Do not keep spaces between the type and the pipe operator when it is in a union type (e.g., string|int).   Example,  type method \"POST\"|\"GET\"|\"PUT\";  (int|string) variable = 0;  function getValue(string key) returns (string|error) {  ... }  function getName() returns string|error {  (string|error) valueOrError = getValue(\"name\");  ... }     Do not keep spaces between the type and the optional operator ?.   Example,  string? name;     Avoid line breaks in constrained types.   Do’s   map<int|string> // map reference type   Don’ts  map<  int  |  string > Operators   Keep only a single space before and after the = operator.   Example,  int a = 0;     Do not keep spaces around the semicolon ;.  Do not keep spaces between the unary operator and the expression.   Example,  a = -a;     Keep a single space before and after any binary or ternary operator.   Example,  var fullName = firstName + lastName;  string|() name = isNameAvailable() ? getName() : \"Unknown\";  var elvisOperator = name ?: \"Unknown\";     Keep a single space before and after a compound operator such as -= and +=.   Example,  name += lastName;     When accessing a function, object, or record from another module, do not keep spaces around :.   Example,  io:println(\"john\"); http:Response res = new();   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/","name":"Coding Conventions","summary":"This Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.Table of contents        You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can ...","content":"/  /  / Coding Conventions  Coding Conventions  This Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.  Table of contents You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured to match your coding style.   Indentation and Line Length   Use four spaces (not tabs) for each level of indentation.  Keep the maximum length of a line to 120 characters.     Note: You can configure tools and plugins to use tabs when indenting and to change the number of maximum characters of the line length.   Line Spacing    Use only a single space to separate keywords, types, and identifiers.   Do’s  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Don’ts  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Few exceptions for this rule are:   Do not keep spaces around a type when it is enclosed using angle brackets <string>.   Example,  map<string> names = {};     Do not keep spaces between the type and the opening bracket in the array definition string[].   Example,   string[] names = [];     If it is a list of values separated by commas, add only a single space after each comma and don’t add spaces before the comma.   Example,  [string, int, boolean] tupleVar = [\"\", 0, false];  int[] arrayOfInteger = [1, 2, 3, 4];  map<string> stringMap = {one: st1, two: st2, three: st3};  Person personRecord = {name:\"marcus\", id: 0};  function foo(string name, int id) {}  service hello on ep1, ep2 {...}   Blank Lines  Separate both statements and top-level definitions by zero or one blank lines.  Example,  import ballerina/http; import ballerina/io;  const string CITY = \"Colombo\"; const int CITY_NO = 1;  function getName() returns string {  string firstName = \"john\";  string lastName = \"doe\";  return firstName + lastName; }  function setName(string name) {} function setAge(int age) {}     Note: You can configure tools and plugins to change the number of minimum and maximum blank lines used when formatting.   Blocks   Opening curly braces of a block should be placed inline.   Do’s  if (true) { }  function setName(string name) {  }   Don’ts  if (true) {  }  function setName(string name) {  }     Add a single space before the opening curly braces.   Example,   function func1() {  if (true) {} }      If a block is empty, do not keep spaces in between the opening and closing braces.   Example,  function func1() {}     Indent all the statements inside a block to be at the same level.  Indent the closing brace of a block to align it with the starting position of the block statement.   Example,  if (false) {  ... }  match a {  ... }   Parentheses and Brackets   Do not have spaces after opening parentheses/bracket and before closing parentheses/bracket.   Example,  [string, int] tupleVar = [\"\", 0];  function setValue(string value) {...}  setValue(\"value\");     To define empty parentheses, do not keep spaces between the opening and closing parentheses ().   Example,  int|() result = getResult();   Line Breaks    Have only one statement in a line.  When splitting lines, which contain operator(s), split them right before an operator.   Example,  // Binary operations. string s = \"added \" + People.name  + \" in to database.\";  // Function invocation. string s = person  .getName();  // Binary operations in if condition if (isNameAvailable && (i == 1)) {  }     When splitting lines, which contains separator(s), split them right after a separator.   Example,  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     If there isn’t any operator or separator to break the line from, move the whole expression to a new line.   Example,  // String literal. string s1 =  \"My name is not in this description\";  // Function invocation. string s2 =  getPersonNameWithUpperCaseLetters();     If a line exceeds the max line length, start from the end of the line and come towards the start of the line until you find a point, which matches the above rules to break the line.  Indent split lines with relation to the starting position of the statement or definition.   Example,  if (isNameAvailable && (i == 1)) {  }  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     However, if you cannot add the type-casting expression or statement with the constrained type in a single line due to it exceeding the max line length,  move the casting type with the operators to a new line.   Example,   string name =  <string>json.name;     keep the constrained type on the same line by splitting the statement from a point before the constraint type.   Example,  map<int|string> registry = {  name: \"marcus\" };  table<Employee> employee = table {  {key id, name, address}  };   Top-Level Definitions  For style guidelines on imports, service definition, object definition, record definition, referencing record or abstract object, etc., see .  Operators, Keywords, and Types  For style guidelines on operators, keywords, and types, see .  Statements  For style guidelines on statements such as if, match, transaction etc., see .  Expressions  For style guidelines on function invocation, literals, tuple, type casting etc. see .  Annotations, Documentation, and Comments  For style guidelines on annotations, documentation, and comments, see .  \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/statements/","name":"Statements","summary":"The sections below include the coding conventions with respect to statements.Table of contents        Do’sDon’tsExample,Example,Example,If the pattern body is empty, then keep it as an empty block.Example,Example,This website uses cookies so that we can provide you with the best user experience. Read our  to find ...","content":"/  /  /  / Statements  Statements  The sections below include the coding conventions with respect to statements.  Table of contents If Statement    Always enclose the condition with parentheses in the If statement.   Do’s  if (true) {  ... } else if (false) {  ... }   Don’ts  if true {  ... } else if false {  ... }     Keep the else and else if keywords in the same line with the matching if or else if block’s closing brace separated only by a single space.   Empty Block    Do not have any empty if, else if, or else blocks.  If empty, add an empty line between the opening and closing braces.   Example,  if (inProperSallaryRange) {  } else if (inSallaryRange) {  } else {  }   Match Statement  Match Patterns Clause    Block indent each pattern clause in its own line.  Keep a single space before and after the => sign.  If a pattern clause contains only one statement, place it in the same line as the pattern clause enclosing it with curly braces.   Example,  function foo(string|int|boolean a) returns string {  match a {  12 => {  return \"Value is '12'\";  }  }  return \"Value is 'Default'\"; }     If a pattern clause has more than one statement, block indent each statement in its own line.   Example,  match x {  var (s, i) if s is string => {  io:println(\"string\");  }  var (s, i) if s is int => {  io:println(\"int\");  } }     If the pattern body is empty, then keep it as an empty block.   Example,  match x {  var (s, i) if s is string => {}  var (s, i) if s is int => {} }   Transaction Statement    Start each optional clause (onretry, committed, and aborted) in the same line as the closing brace of the matching clause.  If transaction, onretry, committed, and aborted blocks are empty, add an empty line between the braces.   Example,  function func1() {  transaction with retries = 2 {  } onretry {  } aborted {  } committed {  } }     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/coding-conventions/top-level-definitions/","name":"Top-Level Definitions","summary":"The sections below include the coding conventions with respect to top-level definitions.Table of contents        Do’sDon’tsExample,Example,Example,Example,Example,Example,Example,Example,Example,Block indent each of the field definitions (including the Rest field) in their own line.Example,Example,Example:\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our ...","content":"/  /  /  / Top-Level Definitions  Top-Level Definitions  The sections below include the coding conventions with respect to top-level definitions.  Table of contents General Practices    Do not indent the top-level definitions.   Do’s   import ballerina/http;  const int MIN_AGE = 20; int repetitions = 0;  service hello on ep1 {  ... }    Don’ts  // This import is indented correctly. import ballerina/http; const int MIN_AGE = 20; // Not indented correctly.  int repetitions = 0; // Not indented correctly.  // Not indented correctly. service hello on ep1 {  ...  }  Imports    Do not keep spaces between the organization name, divider /, and module name.   Example,  import ballerina/http;     Imports should be sorted alphabetically, first by the organization name and then by the module name.   Function Definition   Do not keep spaces between the function name and the open parentheses ( of the function signature.   Example,  function func1() {}     If the function has an object attached to it, do not keep spaces around the Dot .. Also, keep a single space between the function keyword and the name of the object.   Example,  function Person.getName() {}     If the function needs to be split into new lines due to it exceeding the max line length,  can break lines from the parameter list by moving a parameter value only to a new line and indenting it with four spaces from the starting position of the function.  Example,  function getAddress(int value,  string name) returns (string|()) {  ... }     can break before the returns keyword and indent it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name)  returns (string|()) {  ... } can break after the returns keyword by moving the return value to a new line  and indenting it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name) returns  (string|()) {  ... } Service Definition    Keep the listener inline with the service signature.   Example,  service hello on new http:Listener(9090) {  ... }     When formatting resource functions and function definitions, block indent each element and follow the .   Example,  service hello on ep1, ep2 {  resource function sayHello(http:Caller caller, http:Request req) returns error? {  http:Response res = new;  res.setPayload(self.getGreeting());  _ = caller->respond(res);  }  function getGreeting() returns string {  return \"Hello\";  } }     Block indent each function definition, resource definition, and field definition inside a service definition.   Object Definition    Block indent each field definition and each function definition on their own line.  Init function should be placed before all the other functions.  For function definitions in the object definition, follow the .   Example,  type Person object {  // Object field definitions.  public boolean isMarried = false;  int age;  string name;  // Object init function.  function __init(string name, int age = 0) {  self.age = age;  self.name = name;  }  // Object function definitions.  function getName() returns string {  return self.name;  }  function setIsMarried(boolean isMarried) {  self.isMarried = isMarried;  }  function getIsMarried() returns boolean {  return self.isMarried;  } }   Record Definition Block indent each of the field definitions (including the Rest field) in their own line.  Example,  type Person record {  string name;  int...; }  // or  type Person record {|  int id;  string name; |}   Referencing Record or Abstract Object   Do not keep spaces between the *, the abstract object name, or the record name.   Example,  *Person;    Also, block-indent.   Example:  type UserId record {  string id = \"\"; };  type User record {  *UserId; // Reference to UserId record.  string name = \"john\";  int age = 20; };  // or type Person abstract object {  string name;  // Object function definitions.  function getName() returns string; };  type Employee object {  *Person; // Reference to Person abstract object.   function __init() {  self.name = \"asd\";  }   function getName() returns string {  return self.name;  } };   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/deployment/aws-lambda/","name":"AWS Lambda","summary":"The AWS Lambda extension provides the functionality to expose a Ballerina function as an AWS Lambda function.Table of contents        Exposing a Ballerina function as an AWS Lambda function is done by importing the ballerinax/awslambda module and simply annotating the Ballerina function with the awslambda:Function annotation. ...","content":"/  /  /  / AWS Lambda  AWS Lambda  The AWS Lambda extension provides the functionality to expose a Ballerina function as an AWS Lambda function.  Table of contents Exposing a Ballerina function as an AWS Lambda function is done by importing the ballerinax/awslambda module and simply annotating the Ballerina function with the awslambda:Function annotation. Also, the Ballerina function must have the following signature: function (awslambda:Context, json|EventType) returns json|error.  Writing a Function  The following code presents a few examples on how to expose functions in AWS Lambda, which contain a generic json event input and other functions, which provide the event information using domain-specific event types.  import ballerinax/awslambda; import ballerina/crypto;  @awslambda:Function public function hash(awslambda:Context ctx, json input) returns json|error {  return crypto:hashSha256(input.toJsonString().toBytes()).toBase16(); }  @awslambda:Function public function notifySQS(awslambda:Context ctx, awslambda:SQSEvent event) returns json {  return event.Records[0].body; }  @awslambda:Function public function notifyS3(awslambda:Context ctx, awslambda:S3Event event) returns json {  return event.Records[0].s3.'object.key; }  @awslambda:Function public function notifyDynamoDB(awslambda:Context ctx, awslambda:DynamoDBEvent event) returns json {  return event.Records[0].dynamodb.Keys.toString(); }  @awslambda:Function public function notifySES(awslambda:Context ctx, awslambda:SESEvent event) returns json {  return event.Records[0].ses.mail.commonHeaders.subject; }  @awslambda:Function public function apigwRequest(awslambda:Context ctx, awslambda:APIGatewayProxyRequest request) {  io:println(\"Path: \", request.path); }   The first parameter with the object contains the information and operations related to the current function execution in AWS Lambda such as the request ID and the remaining execution time.  The second parameter contains the input request data. This input value will vary depending on the source, which invoked the function (e.g., an AWS S3 bucket update event).  The return type of the function is json|error, which means in a successful scenario, the function can return a json value with the response, or else in an error situation, the function will return an error value, which provides information on the error to the system. You can also provide functions, which do not return anything at all, which implicitly signals a successful execution without a returning result.  Building the Function  The AWS Lambda functionality is implemented as a compiler extension. Thus, the artifact generation happens automatically when you build a Ballerina module. Let’s see how this works by building the above code.  $ ballerina build functions.bal Compiling source \tfunctions.bal  Generating executables \tfunctions.jar \t@awslambda:Function: echo, uuid, ctxinfo, notifySQS, notifyS3, notifyDynamoDB, notifySES, apigwRequest  \tRun the following command to deploy each Ballerina AWS Lambda function: \taws lambda create-function --function-name <FUNCTION_NAME> --zip-file fileb://aws-ballerina-lambda-functions.zip --handler functions.<FUNCTION_NAME> --runtime provided --role <LAMBDA_ROLE_ARN> --layers arn:aws:lambda:<REGION_ID>:141896495686:layer:ballerina:2  \tRun the following command to re-deploy an updated Ballerina AWS Lambda function: \taws lambda update-function-code --function-name <FUNCTION_NAME> --zip-file fileb://aws-ballerina-lambda-functions.zip   Deploying the Function  Ballerina’s AWS Lambda functionality is implemented as a custom AWS Lambda layer. As shown in the above instructions output, this information is provided when the function is created. The compiler generates the aws-ballerina-lambda-functions.zip file, which encapsulates all the AWS Lambda functions that are generated. This ZIP file can be used with the AWS web console, or the to deploy the functions. An for the user must be created with the AWSLambdaBasicExecutionRole permission in order to deploy the AWS Lambda functions. The created AWS Lambda Role ARN is required when deploying the functions through the CLI.  A sample execution to deploy the hash function as an AWS Lambda is shown below.  $ aws lambda create-function --function-name hash --zip-file fileb://aws-ballerina-lambda-functions.zip --handler functions.hash --runtime provided --role arn:aws:iam::908363916138:role/lambda-role --layers arn:aws:lambda:us-west-1:141896495686:layer:ballerina:2 {  \"FunctionName\": \"hash\",  \"FunctionArn\": \"arn:aws:lambda:us-west-1:908363916138:function:hash\",  \"Runtime\": \"provided\",  \"Role\": \"arn:aws:iam::908363916138:role/lambda-role\",  \"Handler\": \"functions.hash\",  \"CodeSize\": 22160569,  \"Description\": \"\",  \"Timeout\": 3,  \"MemorySize\": 128,  \"LastModified\": \"2020-07-14T06:54:41.647+0000\",  \"CodeSha256\": \"zXHpr2VC8Anauvox1dD8MichiH/55wKkY7RtaUe21dM=\",  \"Version\": \"$LATEST\",  \"TracingConfig\": {  \"Mode\": \"PassThrough\"  },  \"RevisionId\": \"d5400f01-f3b8-478b-9269-73c44f4537aa\",  \"Layers\": [  {  \"Arn\": \"arn:aws:lambda:us-west-1:141896495686:layer:ballerina:2\",  \"CodeSize\": 697  }  ] }   Invoking the Function  The deployed AWS Lambda function can be tested by invoking it directly using the CLI.  $ aws lambda invoke --function-name hash --payload '{\"x\":5}' response.txt {  \"StatusCode\": 200,  \"ExecutedVersion\": \"$LATEST\" }  $ cat response.txt \"dd9446a11b2021b753a5df48d11f339055375b59cd81d7559d36b652aaff849d\"   What’s Next?  For more information on how to connect external event sources such as Amazon DynamoDB and Amazon S3 to Lambda Functions, go to .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/deployment/azure-functions/","name":"Azure Functions","summary":"The Azure Functions extension provides the functionality to expose a Ballerina function as a serverless function in the Azure Functions platform.Table of contents        This is done by importing the ballerinax/azure.functions module and simply annotating the Ballerina function with the functions:Function annotation.An Azure Function consists of ...","content":"/  /  /  / Azure Functions  Azure Functions  The Azure Functions extension provides the functionality to expose a Ballerina function as a serverless function in the Azure Functions platform.  Table of contents This is done by importing the ballerinax/azure.functions module and simply annotating the Ballerina function with the functions:Function annotation.  Triggers and Bindings  An Azure Function consists of a trigger and optional bindings. A trigger defines how a function is invoked. A binding is an approach in which you can declaratively connect other resources to the function. There are input and output bindings. An input binding is a source of data into the function. An output binding allows to output data from the function out to an external resource. For more information, go to .  The following Azure Functions triggers and bindings are currently supported in Ballerina:   HTTP and binding  Queue and binding  Blob , binding, and binding  Twilio SMS binding  CosmosDB , binding, and binding  Timer Writing a Function  The following Ballerina code gives an example of using an HTTP trigger to invoke the function, a queue output binding to write an entry to a queue, and also an HTTP output binding to respond back to the caller with a message.  import ballerinax/azure.functions as af;  @af:Function public function fromHttpToQueue(af:Context ctx, @af:HTTPTrigger { authLevel: \"anonymous\" } af:HTTPRequest req, @af:QueueOutput { queueName: \"queue1\" } af:StringOutputBinding msg) returns @af:HTTPOutput af:HTTPBinding {  msg.value = req.body;  return { statusCode: 200, payload: \"Request: \" + req.toString() }; }   The first parameter with the object contains the information and operations related to the current function execution in Azure Functions such as the execution metadata and logging actions to be used by the function. This parameter is optional and can exist at any position in the parameter list of the function. The second parameter with the HTTPTrigger annotation signals that this function is going to have an HTTP trigger and that its details should be stored in the given HTTPRequest value. Then, you also declare that you will be having a queue output binding by the usage of the QueueOutput annotation with a string result by defining a StringOutputBinding parameter. Also, you declare an HTTP output binding by annotating the HTTPBinding return type with the HTTPOutput annotation. This HTTP output binding can also be given by defining as a parameter as well with the same annotation. In this manner, you can mix and match any combination of triggers and input/output bindings with or without the execution context object when defining an Azure Function.  Building the Function  The Azure Functions functionality is implemented as a compiler extension. Thus, the artifact generation happens automatically when you build a Ballerina module. Let’s see how this works by building the above code.  $ ballerina build functions.bal Compiling source \tfunctions.bal  Generating executables \tfunctions.jar \t@azure.functions:Function: fromHttpToQueue  \tRun the following command to deploy Ballerina Azure Functions: \taz functionapp deployment source config-zip -g <resource_group> -n <function_app_name> --src azure-functions.zip   Deploying the Function  In order to deploy a Ballerina function in Azure Functions, the following prerequisites must be met.    Create an Azure with the given resource group with the following requirements:  Runtime stack - Java  Hosting operating system - Windows (default; Linux is not supported in Azure for custom handlers at the moment)  Install the The created resource group and the function app name should be provided to the placeholders shown in the above-generated usage instructions from the compiler.  A custom file for the Azure Functions deployment can be optionally provided by placing a host.json file in the current working directory in which the Ballerina build is done. The required host.json properties are provided/overridden by the values derived from the source code by the compiler extension.  A sample execution to deploy the functions to Azure Functions is shown below.  $ az functionapp deployment source config-zip -g functions1777 -n functions1777 --src azure-functions.zip Getting scm site credentials for zip deployment Starting zip deployment. This operation can take a while to complete ... Deployment endpoint responded with status code 202 {  \"active\": false,  \"author\": \"N/A\",  \"author_email\": \"N/A\",  \"complete\": true,  \"deployer\": \"ZipDeploy\",  \"end_time\": \"2020-07-15T07:32:35.5311903Z\",  \"id\": \"e56a20038b864c5c8432aa7d1c26bfbd\",  \"is_readonly\": true,  \"is_temp\": false,  \"last_success_end_time\": \"2020-07-15T07:32:35.5311903Z\",  \"log_url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest/log\",  \"message\": \"Created via a push deployment\",  \"progress\": \"\",  \"provisioningState\": null,  \"received_time\": \"2020-07-15T07:32:21.9780071Z\",  \"site_name\": \"functions1777\",  \"start_time\": \"2020-07-15T07:32:23.2044517Z\",  \"status\": 4,  \"status_text\": \"\",  \"url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest\" }   Invoking the Function  The deployed Azure Function can be tested by invoking it using an HTTP client such as CURL:  $ curl -d \"Hello!\" https://functions1777.azurewebsites.net/api/fromHttpToQueue Request: url=https://functions1777.azurewebsites.net/api/fromHttpToQueue method=POST query= headers=Accept=*/* Connection=Keep-Alive Content-Length=6 Content-Type=application/x-www-form-urlencoded Host=functions1777.azurewebsites.net Max-Forwards=9 User-Agent=curl/7.64.0 X-WAWS-Unencoded-URL=/api/fromHttpToQueue CLIENT-IP=10.0.128.31:47794 X-ARR-LOG-ID=c905b483-af19-4cf2-9ce0-0741e5998a98 X-SITE-DEPLOYMENT-ID=functions1777 WAS-DEFAULT-HOSTNAME=functions1777.azurewebsites.net X-Original-URL=/api/fromHttpToQueue X-Forwarded-For=45.30.94.9:47450 X-ARR-SSL=2048|256|C=US, S=Washington, L=Redmond, O=Microsoft Corporation, OU=Microsoft IT, CN=Microsoft IT TLS CA 5|CN=*.azurewebsites.net X-Forwarded-Proto=https X-AppService-Proto=https X-Forwarded-TlsVersion=1.2 DISGUISED-HOST=functions1777.azurewebsites.net params= identities=[{\"AuthenticationType\":null,\"IsAuthenticated\":false,\"Actor\":null,\"BootstrapContext\":null,\"Claims\":[],\"Label\":null,\"Name\":null,\"NameClaimType\":\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\"RoleClaimType\":\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"}] body=Hello!   What’s Next?  For a full sample with all the supported Azure Functions triggers and bindings in Ballerina, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/deployment/docker/","name":"Docker","summary":"Docker helps to package applications and their dependencies in a binary image, which can run in various locations whether on-premise, in a public cloud, or in a private cloud.Table of contents        To create a Docker image, you have to create a Dockerfile by choosing a ...","content":"/  /  /  / Docker  Docker  Docker helps to package applications and their dependencies in a binary image, which can run in various locations whether on-premise, in a public cloud, or in a private cloud.  Table of contents To create a Docker image, you have to create a Dockerfile by choosing a suitable base image, bundling all dependencies, copying the application binary, and setting the execution command with proper permissions. To create optimized images, youhave to follow a set of . Otherwise, the image that is built will be large in size, less secure, and have many other shortcomings.  The Ballerina compiler is capable of creating optimized Docker images out of the application source code. This guide includes step-by-step instructions on different use cases and executing the corresponding sample source code.  Enabling Docker Support  Docker support is inbuilt and comes by default in any Ballerina distribution. You can enable Docker artifact generation by adding annotations to your Ballerina code. Follow the steps below to enable Docker support.    Import the Docker extension module in your Ballerina code (e.g., import ballerina/docker;).  Add the relevant annotations within the code (e.g., @docker:Config {}).  Build the Ballerina source file/project (e.g., ballerina build source.bal).  Use Cases  Running a Ballerina Service in a Docker Container  This use case shows how to run a Ballerina service in a Docker container. The sample below demonstrates running a simple Ballerina hello world service in a Docker container.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code  hello_world_docker.bal  import ballerina/http; import ballerina/docker;  @docker:Config {} service hello on new http:Listener(9090){  resource function sayHello(http:Caller caller,http:Request request) returns error? {  check caller->respond(\"Hello World!\");  } }    Steps to Run    Compile the hello_world_docker.bal file.   > ballerina build hello_world_docker.bal Compiling source  hello_world_docker.bal   Generating executables  hello_world_docker.jar   Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 hello_world_docker:latest    The artifacts files below will be generated with the build process.   > tree  .  ├── docker  │ └── Dockerfile  ├── hello_world_docker.bal  └── hello_world_docker.jar   1 directory, 3 files   The build process automatically generates a Dockerfile with the following content:   # Auto Generated Dockerfile  FROM ballerina/jre8:v1   LABEL maintainer=\"dev@ballerina.io\"   RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*   WORKDIR /home/ballerina   COPY hello_world_docker.jar /home/ballerina   USER ballerina   CMD java -jar hello_world_docker.jar   Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  hello_world_docker latest e48123737a65 7 minutes ago 134MB   Since the annotation is not configured to have a custom Docker image name and tag, the build process will create a Docker image with the default values: the file name of the generated .jar file with the latest tag (e.g., hello_world_docker:latest).  Run the Docker image as a container (use the below command printed in step 1).   > docker run -d -p 9090:9090 hello_world_docker:latest  32461676d3c22848088390483a414e5b1d11a7a73c2296eccb18e6c9f27c41c0  Verify that the Docker container is running.   > docker ps  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  32461676d3c2 hello_world_docker:latest \"/bin/sh -c 'java -j…\" About a minute ago Up About a minute 0.0.0.0:9090->9090/tcp lucid_turing  Access the hello world service with the cURL command.   > curl http://localhost:9090/hello/sayHello Hello World!  Clean up the used artifacts.   Stop / kill running docker container  > docker kill 32461676d3c2  32461676d3c2   Remove docker container files  > docker em 32461676d3c2   Remove docker image  > docker rmi e48123737a65  Creating a Custom Ballerina Docker Image and Pushing it Automatically to the Docker Registry  This use case shows how to run a simple Ballerina hello world service in a Docker container with annotation configurations, which can be used to create a Docker image with a custom image-name and tag, and then automatically push the created image to the Docker registry.  Setting Up the Prerequisites    A machine with installed  A account   Sample Source Code  custom_docker_name.bal  import ballerina/http; import ballerina/docker;  @docker:Config {  push: true,  registry: \"index.docker.io/$env{DOCKER_USERNAME}\",  name: \"helloworld\",  tag: \"v1.0.0\",  username: \"$env{DOCKER_USERNAME}\",  password: \"$env{DOCKER_PASSWORD}\" } service hello on new http:Listener(9090){  resource function sayHello(http:Caller caller,http:Request request) returns error? {  check caller->respond(\"Hello World!\");  } }   In this sample, the following properties are set in the @docker:Config annotation.    push : enable pushing the Docker image to the registry  registry\t: Docker registry URL  name : name of the Docker image  tag : Docker image tag (version)  username\t: username of the Docker registry  password\t: password of the Docker registry     The $env variable is used to read the environment variable values from the system.   Steps to Run    Export the username and password of Docker (registry).   export DOCKER_USERNAME=<username>  export DOCKER_PASSWORD=<password>  Compile the custom_docker_name.bal file.   > ballerina build custom_docker_name.bal  Compiling source  custom_docker_name.bal   Generating executables  custom_docker_name.jar   Generating docker artifacts...  @docker - complete 3/3 Run the following command to start a Docker container:  docker run -d -p 9090:9090 index.docker.io/lakwarus/helloworld:v1.0.0    Verify that the Docker image is created.   REPOSITORY TAG IMAGE ID CREATED SIZE  lakwarus/helloworld v1.0.0 7e76efdd33e4 20 minutes ago 134MB  Log into and verify that the image is pushed.   Running a Ballerina HTTPS Service in a Docker Container  An HTTP endpoint can be configured to communicate through HTTPS as well. To secure an endpoint using HTTPS, it needs to be configured with a keystore, a certificate, and a private key for the endpoint. When running this HTTPS service as a Docker container, it is required to copy the keystore with the custom certificate that is used to configure the HTTPS endpoint.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code  The sample below uses a separate listener endpoint and it is configured with a custom keystore. In addition to the @docker:Config annotation, the @docker:Expose annotation is used with the listener endpoint object, which helps to expose the correct service ports when creating the Docker container.  https_service_in_docker.bal   import ballerina/http; import ballerina/docker;  @docker:Expose {} listener http:Listener helloWorldEP = new(9095, {  secureSocket: {  keyStore: {  path: \"./ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @docker:Config {  name: \"https-helloworld\" } service hello on helloWorldEP {  resource function sayHello(http:Caller caller,http:Request request) returns error? {  check caller->respond(\"Hello World!\");  } }   Steps to Run    Compile the https_service_in_docker.bal file.   > ballerina build https_service_in_docker.bal Compiling source  https_service_in_docker.bal   Generating executables  https_service_in_docker.jar   Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9095:9095 https-helloworld:latest    The artifact files below will be generated with the build process.   > tree  .  ├── ballerinaKeystore.p12  ├── docker  │ ├── Dockerfile  │ └── ballerinaKeystore.p12  ├── https_service_in_docker.bal  └── https_service_in_docker.jar   1 directory, 5 files   Note: It has copied the correct keystore used in the source code into the Docker folder and generated the Dockerfile with the content below.  # Auto Generated Dockerfile  FROM ballerina/jre8:v1   LABEL maintainer=\"dev@ballerina.io\"   RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*   WORKDIR /home/ballerina   COPY https_service_in_docker.jar /home/ballerina  COPY ballerinaKeystore.p12 ./ballerinaKeystore.p12   EXPOSE 9095  USER ballerina   CMD java -jar https_service_in_docker.jar   The Ballerina compiler automatically adds a line to the Dockerfile to copy the required keystore into the Docker image.  Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  https-helloworld latest ed9bff9fabd7 15 minutes ago 134MB  Run the Docker image as a container (use the command below printed in step 1).   > docker run -d -p 9095:9095 https-helloworld:latest  25dfb84f1c9f3459baf7a4791f9de3cae260d9963e580802253621919d0bd2fb  Verify that the Docker container is running.   > docker ps  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  25dfb84f1c9f https-helloworld:latest \"/bin/sh -c 'java -j…\" 45 seconds ago Up 45 seconds 0.0.0.0:9095->9095/tcp charming_visvesvaraya  Access the hello world service with the cURL command.   curl -k https://localhost:9095/hello/sayHello  Hello World!  Note: The cURL command is used with the -k option because self-signed certificates are used in the keystore.  Clean up the used artifacts.   > docker kill 25dfb84f1c9f  25dfb84f1c9f   > docker rm 25dfb84f1c9f  25dfb84f1c9f   > docker rmi ed9bff9fabd7  Untagged: https-helloworld:latest  Copying Additional Files to the Ballerina Docker Image  In some use cases, you need to process files in your applications. When these applications are run in a Docker container, you might need to copy these additional files into the image or mount them as external volume. This use case shows how to copy additional files into the Docker image while compiling the Ballerina source code.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code  copy_file.bal  import ballerina/http; import ballerina/io; import ballerina/docker;  @docker:Expose {} listener http:Listener helloEP = new(9090);  @docker:Config {} @docker:CopyFiles {  files: [  { sourceFile: \"./name.txt\", target: \"/home/ballerina/name.txt\" }  ] } service hello on helloEP {  resource function greet(http:Caller caller, http:Request request) returns error? {  http:Response response = new;  string payload = readFile(\"./name.txt\");  response.setTextPayload(\"Hello \" + <@untainted> payload + \"\\n\");  check caller->respond(response);  } }  function readFile(string filePath) returns string {  io:ReadableByteChannel bchannel = checkpanic io:openReadableFile(filePath);  io:ReadableCharacterChannel cChannel = new io:ReadableCharacterChannel(bchannel, \"UTF-8\");  var readOutput = cChannel.read(50);  if (readOutput is string) {  return <@untainted> readOutput;  } else {  return \"Error: Unable to read file\";  } }   This sample sends a greeting to the caller by getting the name from a text file. When this is run in a container, you need to copy the name.txt file into the Docker image. The @docker:CopyFiles annotation is used for this and you can give multiple files by following the syntax below.  name.txt  @docker:CopyFiles {  files: [  { sourceFile: \"./name.txt\", target: \"/home/ballerina/name.txt\" }, \t{ sourceFile: \"./abc.txt\", target: \"/home/ballerina/abc.txt\" }  ] }     Note: In addition to the above, if you want to copy driver files such as JDBC, you can create a Ballerina project, add following entires to its Ballerina.toml file, and change the path to the JDBC driver appropriately.   Ballerina.toml  [project] org-name= \"sample\" version= \"0.1.0\"  [platform] target = \"java8\"   [[platform.libraries]]  artafactId = \"mysql-connector-java\"  version = \"8.0.17\"  path = \"/path/to/mysql-connector-java-8.0.17.jar\"   Steps to Run    Create a name.txt file in the same directory in which the copy_file.bal file resides.   > echo Ballerina > ./name.txt  Compile the copy_file.bal file.   > ballerina build copy_file.bal Compiling source  copy_file.bal   Generating executables  copy_file.jar   Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 copy_file:latest  The artifacts files below will be generated with the build process.   > tree  .  ├── copy_file.bal  ├── copy_file.jar  ├── docker  │ ├── Dockerfile  │ └── name.txt  └── name.txt   1 directory, 5 files  Note: The generated Dockerfile includes the COPY command to copy files that are defined by the @docker:CopyFiles annotation.  # Auto Generated Dockerfile  FROM ballerina/jre8:v1   LABEL maintainer=\"dev@ballerina.io\"   RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*   WORKDIR /home/ballerina   COPY copy_file.jar /home/ballerina  COPY name.txt /home/ballerina/name.txt   EXPOSE 9090  USER ballerina   CMD java -jar copy_file.jar  Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  copy_file latest cc198c0af86e 6 minutes ago 134MB  Run the Docker image as a container (use the command below printed in step 1).   > docker run -d -p 9090:9090 copy_file:latest  d9f72d8ef6b2f27df099cc3e57676aeb3110c330004b5539e557ec49cf50878a  Verify that the Docker container is running.   > docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  d9f72d8ef6b2 copy_file:latest \"/bin/sh -c 'java -j…\" 15 seconds ago Up 15 seconds 0.0.0.0:9090->9090/tcp inspiring_joliot  Access the hello world service with the cURL command below.   > curl http://localhost:9090/hello/greet  Hello Ballerina  Clean up the used artifacts.   > docker kill d9f72d8ef6b2  d9f72d8ef6b2   > docker rm d9f72d8ef6b2  d9f72d8ef6b2   > docker rmi cc198c0af86e  Using a Custom Base Image to Build Ballerina Docker Images  Ballerina ships a base image (e.g., ballerina/jre8:v1) with some security hardening. It is used to build Docker images with the user’s application code. However, sometimes, you might need to use your own Docker base image depending on your company policies or any additional requirements. This use case shows how to use a custom Docker base image to build Ballerina Docker images with the application code.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code  base_image.bal  import ballerina/http; import ballerina/docker;  @docker:Config {  name: \"helloworld_custom_baseimage\",  baseImage: \"openjdk:8-jre-alpine\" } service hello on new http:Listener(9090){  resource function sayHello(http:Caller caller,http:Request request) returns error? {  check caller->respond(\"Hello World!\");  } }     Note: This sample uses openjdk:8-jre-alpine as the custom Docker image by using the baseImage property in the @docker:Config annotation.   Steps to Run    Compile the base_image.bal file.   > ballerina build base_image.bal Compiling source  base_image.bal  Generating executables  base_image.jar  Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 helloworld_custom_baseimage:latest  The artifact files below will be generated with the build process.   tree . ├── base_image.bal ├── base_image.jar └── docker  └── Dockerfile  1 directory, 3 files  The Dockerfile will be generated as follows.   Note: The FROM section of the Dockerfile has the base image, which is defined by the @docker:Config annotation.  # Auto Generated Dockerfile FROM openjdk:8-jre-alpine  LABEL maintainer=\"dev@ballerina.io\"  WORKDIR /home/ballerina  COPY base_image.jar /home/ballerina  EXPOSE 9090 CMD java -jar base_image.jar  Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  helloworld_custom_baseimage latest 4468889e4ed0 11 minutes ago 109MB  Run the Docker image as a container (use the command below printed in step 1).   > docker run -d -p 9090:9090 helloworld_custom_baseimage:latest  0c31cfaf483493988ee9ace73f6bcf9188a80d33ac3640052265c316058ec55a   Verify that the Docker container is running.   > docker ps  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  0c31cfaf4834 helloworld_custom_baseimage:latest \"/bin/sh -c 'java -j…\" 17 seconds ago Up 16 seconds 0.0.0.0:9090->9090/tcp charming_hypatia   Access the hello world service with the cURL command below.   > curl http://localhost:9090/hello/sayHello  Hello World!  Clean up the used artifacts.   > docker kill 0c31cfaf4834  0c31cfaf4834   > docker rm 0c31cfaf4834  0c31cfaf4834   > docker rmi 4468889e4ed0  Untagged: helloworld_custom_baseimage:latest  Overriding the CMD of the Generated Ballerina Dockerfile  The Ballerina Docker image builder uses the generic CMD command to execute the created JAR file. However, sometimes, you might need to override the default CMD command. This use case shows how to override the default CMD command.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code  docker_cmd.bal   import ballerina/http; import ballerina/docker;  @docker:Config {  name: \"custome_cmd\",  cmd: \"CMD java -jar ${APP} --b7a.http.accesslog.console=true\" } service hello on new http:Listener(9090){  resource function sayHello(http:Caller caller,http:Request request) returns error? {  check caller->respond(\"Hello World!\");  } }   This sample enables HTTP trace logs by overriding the CMD value of the generated Dockerfile. The cmd field will be as CMD java -jar ${APP} --b7a.http.accesslog.console=true in the @docker:Config{} annotation.  Steps to Run    Compile the base_image.bal file.   > ballerina build docker_cmd.bal  Compiling source  docker_cmd.bal   Generating executables  docker_cmd.jar   Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 custome_cmd:latest  The artifact files below will be generated with the build process.   Note: The CMD line will be updated with the custom command defined in the annotation.  > tree  .  ├── docker  │ └── Dockerfile  ├── docker_cmd.bal  └── docker_cmd.jar   1 directory, 3 files  The Dockerfile will be generated as follows.   # Auto Generated Dockerfile  FROM ballerina/jre8:v1   LABEL maintainer=\"dev@ballerina.io\"   RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*   WORKDIR /home/ballerina   COPY docker_cmd.jar /home/ballerina   EXPOSE 9090  USER ballerina   CMD java -jar docker_cmd.jar --b7a.http.accesslog.console=true  Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  custome_cmd latest 08611185ed10 10 minutes ago 134MB  Run the Docker image as a container (use the command below printed in step 1).   > docker run -d -p 9090:9090 custome_cmd:latest  0f66739200dc07d667229f49b66beaf8135e0f9bb000feea23aaa5f9a7cc1d18  Verify that the Docker container is running.   > docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 0f66739200dc custome_cmd:latest \"/bin/sh -c 'java -j…\" 55 seconds ago Up 55 seconds 0.0.0.0:9090->9090/tcp pensive_jackson  Access the hello world service with the cURL command below.   > curl http://localhost:9090/hello/sayHello  Hello World!  View the HTTP access logs.   > docker logs 0f66739200dc  ballerina: HTTP access log enabled  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090  172.17.0.1 - - [14/Jun/2020:04:38:22 +0000] \"GET /hello/sayHello HTTP/1.1\" 200 12 \"-\" \"curl/7.64.1\" 172.17.0.1 - - [14/Jun/2020:04:38:23 +0000] \"GET /hello/sayHello HTTP/1.1\" 200 12 \"-\" \"curl/7.64.1\"  Clean up the created artifacts.   > docker kill 0f66739200dc  0f66739200dc   > docker rm 0f66739200dc  0f66739200dc   > docker rmi 08611185ed10  Untagged: custome_cmd:latest  Creating Multiple Docker Images Corresponding to Modules of a Ballerina Project  This use case shows how to add the Docker annotation to a Ballerina project to create the corresponding Docker images.  Setting Up the Prerequisites  You need a machine with installed.  Sample Source Code    Ballerina project to call the restaurant:   > ballerina new restaurant  Created new Ballerina project at restaurant   Next:  Move into the project directory and use `ballerina add <module-name>` to  add a new Ballerina module.   The two modules to call and order pizzas and burgers:   > ballerina add pizza  Added new ballerina module at 'src/pizza'   > ballerina add burger Added new ballerina module at 'src/burger'   Source code of src/pizza for the order:   pizza_menu.bal   import ballerina/http;  import ballerina/docker;  @docker:Config {  name: \"pizza\"  }  service pizza on new http:Listener(9090){  resource function menu(http:Caller caller,http:Request request) returns error? {  check result = caller->respond(\"Pizza Menu\");  }  }   Source code of src/burger for the order:   burger_menu.bal   import ballerina/http;  import ballerina/docker;  @docker:Config {  name: \"burger\"  }  service burger on new http:Listener(8080){  resource function menu(http:Caller caller,http:Request request) returns error? {  check result = caller->respond(\"Burger Menu\");  }  }   Steps to Run    Compile the Ballerina project.   > ballerina build -a  Compiling source  lakmal/burger:0.1.0  lakmal/pizza:0.1.0   Creating balos  target/balo/burger-2020r1-any-0.1.0.balo  target/balo/pizza-2020r1-any-0.1.0.balo   Running Tests  lakmal/burger:0.1.0  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  I'm the before suite function!  I'm the before function!  I'm in test function!  I'm the after function!  I'm the after suite function!  [ballerina/http] stopped HTTP/WS listener 0.0.0.0:8080   [pass] testFunction   1 passing  0 failing  0 skipped   lakmal/pizza:0.1.0  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090  I'm the before suite function!  I'm the before function!  I'm in test function!  I'm the after function!  I'm the after suite function!  [ballerina/http] stopped HTTP/WS listener 0.0.0.0:9090   [pass] testFunction   1 passing  0 failing  0 skipped    Generating executables  target/bin/burger.jar  target/bin/pizza.jar   Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 8080:8080 burger:latest    Generating docker artifacts...  @docker - complete 2/2 Run the following command to start a Docker container:  docker run -d -p 9090:9090 pizza:latest  The artifact files below will be generated with the build process.   > tree  .  ├── Ballerina.lock  ├── Ballerina.toml  ├── src  │ ├── burger  │ │ ├── Module.md  │ │ ├── burger_menu.bal  │ │ ├── main.bal  │ │ ├── resources  │ │ └── tests  │ │ ├── main_test.bal  │ │ └── resources  │ └── pizza  │ ├── Module.md  │ ├── main.bal  │ ├── pizza_menu.bal  │ ├── resources  │ └── tests  │ ├── main_test.bal  │ └── resources  └── target  ├── balo  │ ├── burger-2020r1-any-0.1.0.balo  │ └── pizza-2020r1-any-0.1.0.balo  ├── bin  │ ├── burger.jar  │ └── pizza.jar  ├── caches  │ ├── bir_cache  │ │ └── lakmal  │ │ ├── burger  │ │ │ └── 0.1.0  │ │ │ └── burger.bir  │ │ └── pizza  │ │ └── 0.1.0  │ │ └── pizza.bir  │ ├── jar_cache  │ │ └── lakmal  │ │ ├── burger  │ │ │ └── 0.1.0  │ │ │ ├── lakmal-burger-0.1.0-testable.jar  │ │ │ └── lakmal-burger-0.1.0.jar  │ │ └── pizza  │ │ └── 0.1.0  │ │ ├── lakmal-pizza-0.1.0-testable.jar  │ │ └── lakmal-pizza-0.1.0.jar  │ └── json_cache  │ └── lakmal  │ ├── burger  │ │ └── 0.1.0  │ │ └── test_suit.json  │ └── pizza  │ └── 0.1.0  │ └── test_suit.json  └── docker  ├── burger  │ └── Dockerfile  └── pizza  └── Dockerfile   34 directories, 24 files  Verify that the Docker image is created.   > docker images  REPOSITORY TAG IMAGE ID CREATED SIZE  pizza latest 72d12aa57bc1 2 minutes ago 134MB  burger latest d3facfd62996 2 minutes ago 134MB  Run the Docker image as a container (use the command below printed in step 1).   > docker run -d -p 8080:8080 burger:latest  1d3b98286a45c2feeae607719c1a58d1c6b9daa57889cff37894cb42490d15de   > docker run -d -p 9090:9090 pizza:latest  c6bfd238515265fb2909d74c3d862830712019c0681f75e7400e7a90833ce84a  Verify that the Docker container is running.   > docker ps  CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES  c6bfd2385152 pizza:latest \"/bin/sh -c 'java -j…\" 15 seconds ago Up 14 seconds 0.0.0.0:9090->9090/tcp romantic_lovelace  1d3b98286a45 burger:latest \"/bin/sh -c 'java -j…\" 47 seconds ago Up 46 seconds 0.0.0.0:8080->8080/tcp priceless_rhodes  Access the pizza service and burger service with the cURL command below.   > curl http://localhost:9090/pizza/menu  Pizza Menu   > curl http://localhost:8080/burger/menu  Burger Menu  Clean up the created artifacts.   > docker kill c6bfd2385152  C6bfd2385152  > docker kill 1d3b98286a45  1d3b98286a45   > docker rm c6bfd2385152  C6bfd2385152  > docker rm 1d3b98286a45  1d3b98286a45    > docker rmi 72d12aa57bc1  Untagged: pizza:latest  > docker rmi d3facfd62996  Untagged: burger:latest  Troubleshooting  Mini-kube users should configure the annotations below in every sample with valid values.  @docker:Config {  dockerHost: \"tcp://192.168.99.100:2376\",  dockerCertPath: \"/Users/lakwarus/.minikube/certs\" }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/deployment/kubernetes/","name":"Kubernetes","summary":"The Kubernetes builder extension offers native support for running Ballerina programs on Kubernetes with the use of annotations that you can include as part of your service code.Table of contents        The Kubernetes builder extension takes care of the creation of the Docker images, so you ...","content":"/  /  /  / Kubernetes  Kubernetes  The Kubernetes builder extension offers native support for running Ballerina programs on Kubernetes with the use of annotations that you can include as part of your service code.  Table of contents The Kubernetes builder extension takes care of the creation of the Docker images, so you don’t need to explicitly create Docker images prior to deployment on Kubernetes.  Supported Configurations  The following Kubernetes configurations are supported:   Kubernetes deployment support  Kubernetes service support  Kubernetes liveness probe support  Kubernetes readiness probe support  Kubernetes ingress support  Kubernetes horizontal pod autoscaler support  Docker image generation  Docker push support with remote Docker registry  Kubernetes secret support  Kubernetes config map support  Kubernetes persistent volume claim support  Kubernetes resource quotas  Istio gateways support  Istio virtual services support  OpenShift build config and image stream support  OpenShift route support   Using Kubernetes Annotations  The following Ballerina code section explains how you can use some of these Kubernetes capabilities by using Kubernetes annotation support in Ballerina.  import ballerina/config; import ballerina/http; import ballerina/kubernetes; import ballerina/log;  @kubernetes:Ingress {  hostname: \"ballerina.guides.io\",  name: \"ballerina-guides-user-retrieval-ingress\" } @kubernetes:Service {  serviceType: \"NodePort\",  name: \"ballerina-guides-user-retrieval-service\" } listener http:Listener userRetrievalEP = new (9090, config = {  secureSocket: {  keyStore: {  path: \"./security/ballerinaKeystore.p12\",  password: config:getAsString(\"keystore-password\")  }  } });  @kubernetes:ConfigMap {  conf: \"service-config.toml\" } @kubernetes:Deployment {  image: \"ballerina.guides.io/user_retrieval_service:v1.0\",  name: \"ballerina-guides-user-retrieval-service\" } @http:ServiceConfig {  basePath: \"/users\" } service userRetrievalService on userRetrievalEP {  @http:ResourceConfig {  methods: [\"GET\"],  path: \"/{userId}\"  }  resource function getUserInfo(http:Caller caller, http:Request request, string userId) {  string name = config:getAsString(string `${<@untainted>userId}.name`);  string email = config:getAsString(string `${<@untainted>userId}.email`);   // check if user exists  json payload = { message: \"user not found\" };  if (name != \"\" && email != \"\") {  payload = { name: name, email: email  };  }   var responseResult = caller->respond(payload);  if (responseResult is error) {  log:printError(\"error responding back to client.\", responseResult);  }  } }   Sample content of service-config.toml:  keystore-password=\"ballerina\"  [john] name=\"John Doe\" email=\"john@ballerina.com\"  [jane] name=\"Jane Doe\" email=\"jane@ballerina.com\"   Here, @kubernetes:Deployment is used to specify the Docker image name, which will be created as part of building this service.  The @kubernetes:Service {} annotation will create a Kubernetes service that will expose the Ballerina service running on a Pod.  In addition, you can use @kubernetes:Ingress, which is the external interface to access your service (with path / and host name ballerina.guides.io).  Minikube users please see the for additional configurations required for Minikube.  Create a folder called security and copy the . This is to secure the endpoint of the service.  Building the Deployed Service  Now, you can use the following command to build the Ballerina service that we developed above. This will also create the corresponding Docker image and the Kubernetes artifacts using the Kubernetes annotations that you have configured above.  $ ballerina build user_retrieval_service.bal Compiling source  user_retrieval_service.bal  Generating executables  user_retrieval_service.jar  Generating artifacts...   @kubernetes:Service - complete 1/1  @kubernetes:Ingress - complete 1/1  @kubernetes:Secret - complete 1/1  @kubernetes:ConfigMap - complete 1/1  @kubernetes:Deployment - complete 1/1  @kubernetes:Docker - complete 2/2 @kubernetes:Helm - complete 1/1   Run the following command to deploy the Kubernetes artifacts: kubectl apply -f ./kubernetes   Run the following command to install the application using Helm: helm install --name ballerina-guides-user-retrieval-service ./kubernetes/ballerina-guides-user-retrieval-service    You can use the docker images command to verify that the Docker image specified in the @kubernetes:Deployment was created. The Kubernetes artifacts related to your service will be generated in addition to the .jar file.  $ tree ├── service-config.toml ├── user_retrieval_service.bal ├── user_retrieval_service.jar ├── security │ └── ballerinaKeystore.p12 ├── docker │ └── Dockerfile ├── kubernetes │ ├── ballerina-guides-user-retrieval-service │ │ ├── Chart.yaml │ │ └── templates │ │ └── user_retrieval_service.yaml │ └── user_retrieval_service.yaml    Creating the Kubernetes Deployment  Now, you can create the Kubernetes deployment using:  $ kubectl apply -f ./kubernetes service/ballerina-guides-user-retrieval-service created ingress.extensions/ballerina-guides-user-retrieval-ingress created secret/userretrievalep-keystore created configmap/userretrievalservice-ballerina-conf-config-map created deployment.apps/ballerina-guides-user-retrieval-service created  You can verify Kubernetes deployment, service, and ingress are running properly by using the following Kubernetes commands.  $ kubectl get pods NAME READY STATUS RESTARTS AGE ballerina-guides-user-retrieval-service-7cfd8b6874-nkdw9 1/1 Running 0 4s  This is the container based on the deployment annotation. This container has the .jar file, secrets, config-maps, and dependencies wrapped within.  $ kubectl get svc NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ballerina-guides-user-retrieval-service NodePort 10.96.96.140 <none> 9090:31417/TCP  This is the Kubernetes service that exposes the listener endpoint.  $ kubectl get ingress NAME HOSTS ADDRESS PORTS AGE ballerina-guides-user-retrieval-ingress ballerina.guides.io localhost 80, 443 38s  This is the Kubernetes nginx rule that exposes the hostname to the outside world.  $ kubectl get secrets NAME TYPE DATA AGE userretrievalep-keystore Opaque 1 3m45s  The secrets are generated automatically for endpoint keystores.  $ kubectl get configmap NAME DATA AGE userretrievalservice-ballerina-conf-config-map 1 4m38s  This is the config-map created for the service-config.toml file, as the conf: \"service-config.toml\" attribute is used. At run time, it is equivalent to: $ ballerina run user_retrieval_service.jar --b7a.config.file=service-config.toml The Kubernetes extension automatically passes the config file to the Ballerina program.  If everything is successfully deployed, you can invoke the service either via Node port or ingress.  Accessing via Node Port $ curl -k https://localhost:31417/users/john {\"name\":\"John Doe\", \"email\":\"john@ballerina.com\"}   Accessing via Ingress  Add an /etc/hosts entry to match hostname.  127.0.0.1 ballerina.guides.io   Setup the NGINX Ingress Controller.  kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.27.0/deploy/static/mandatory.yaml kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.27.0/deploy/static/provider/cloud-generic.yaml kubectl patch deployments -n ingress-nginx nginx-ingress-controller -p '{\"spec\":{\"template\":{\"spec\":{\"containers\":[{\"name\":\"nginx-ingress-controller\",\"args\":[\"\\/nginx-ingress-controller\",\"--configmap=$(POD_NAMESPACE)\\/nginx-configuration\",\"--tcp-services-configmap=$(POD_NAMESPACE)\\/tcp-services\",\"--udp-services-configmap=$(POD_NAMESPACE)\\/udp-services\",\"--publish-service=$(POD_NAMESPACE)\\/ingress-nginx\",\"--annotations-prefix=nginx.ingress.kubernetes.io\",\"--annotations-prefix=nginx.ingress.kubernetes.io\",\"--enable-ssl-passthrough\"]}]}}}}'   Accessing the Service  $ curl -kv https://ballerina.guides.io/users/jane {\"name\":\"Jane Doe\", \"email\":\"jane@ballerina.com\"}   Supported Kubernetes Annotations  @kubernetes:Deployment{}   Supported with Ballerina services, listeners and functions.     Annotation Name  Description  Default value  name  Name of the deployment  -deployment or -deployment  labels  Labels for deployment  { app: }  annotations  Annotations for deployment  {}  dockerHost  Docker host IP and Docker PORT.(e.g “tcp://192.168.99.100:2376”)  DOCKER_HOST environment variable. If DOCKER_HOST is unavailable, use “unix:///var/run/docker.sock” for Unix or use “npipe:////./pipe/docker_engine” for Windows 10 or uses “localhost:2375”  dockerCertPath  Docker cert path  DOCKER_CERT_PATH environment variable  registry  Docker registry URL  null  username  Username for the Docker registry  null  password  Password for the Docker registry  null  baseImage  Base image to create the Docker image  ballerina/jre8:v1  image  Docker image with tag  :latest. If field `registry` is set ,then it will be prepended to the Docker image name as /:latest  buildImage  Building the Docker image  true  push  Push the Docker image to registry. This will be effective if the buildImage field of the image is true  false  copyFiles  Copy external files of the Docker image  null  singleYAML  Generate a single YAML file for all K8s resources  true  namespace  Namespace of the deployment  null  replicas  Number of replicas  1  livenessProbe  Enable or disable liveness probe  false  readinessProbe  Enable or disable readiness probe  false  imagePullPolicy  Docker image pull policy  IfNotPresent  env  List of environment variables  null  podAnnotations  Pod annotations  {}  podTolerations  Pod tolerations  {}  buildExtension  Extension for building Docker images and artifacts  null  dependsOn  Listeners on which this deployment depends  null  imagePullSecrets  Image pull secret’s value  null  strategy  Update strategy  null  @kubernetes:Service{}   Supported by Ballerina services and listeners.     Annotation Name  Description  Default value  name  Name of the Service  -service  labels  Labels for the service  { app: }  portName  Name for the port  The protocol of the listener  port  Service port  Port of the Ballerina service  targetPort  Target pod(s) port  Port of the Ballerina service  nodePort  NodePort to expose the service  None  sessionAffinity  Pod session affinity  None  serviceType  Service type of the service  ClusterIP  @kubernetes:Ingress{}   Supported by Ballerina services and listeners.     Annotation Name  Description  Default value  name  Name of the ingress  -ingress  labels  Labels for the service  { app: }  annotations  Map of additional annotations  null  hostname  Host name of the ingress  .com or .com  path  Resource path.  /  targetPath  This will use for rewriting the URL.  null  ingressClass  Ingress class  nginx  enableTLS  Enable ingress TLS  false  @kubernetes:HPA{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the Horizontal Pod Autoscaler  -hpa  labels  Labels for the service  { app: }  annotations  Map of annotations  null  minReplicas  Minimum number of replicas  Number of replicas in the deployment  maxReplicas  Maximum number of replicas  minReplicas + 1  cpuPrecentage  CPU percentage to start scaling  50  @kubernetes:Secret{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the secret mount  -secret  labels  Labels for the service  { app: }  annotations  Map of annotations  null  mountPath  Path to mount on container  null  readOnly  Is mount read only  true  data  Paths to data files  null  @kubernetes:ConfigMap{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the configmap volume mount  <service_name>-config-map  mountPath  Path to mount on container  null  readOnly  Is mount read only  true  ballerinaConf  Ballerina conf file location  null  data  Paths to data files  null  @kubernetes:PersistentVolumeClaim{}   Supported by Ballerina services and functions.     Annotation Name  Description  Default value  name  Name of the volume mount  null  mountPath  Path to mount on container  null  readOnly  Is mount read only  false  accessMode  Access mode  ReadWriteOnce  volumeClaimSize  Size of the volume claim  null  @kubernetes:Job{}   Supported with the Ballerina main() function.     Annotation Name  Description  Default value  name  Name of the job  -job or -job  labels  Labels for the job  { app: }  annotations  Metadata Annotations map  {}  dockerHost  Docker host IP and Docker PORT.(e.g “tcp://192.168.99.100:2376”)  DOCKER_HOST environment variable. If DOCKER_HOST is unavailable, use “unix:///var/run/docker.sock” for Unix or use “npipe:////./pipe/docker_engine” for Windows 10 or uses “localhost:2375”  dockerCertPath  Docker cert path  DOCKER_CERT_PATH environment variable  registry  Docker registry URL  null  username  Username for the Docker registry  null  password  Password for the Docker registry  null  baseImage  Base image to create the Docker image  ballerina/jre8:v1  image  Docker image with tag  :latest. If field `registry` is set, then it will be prepended to the Docker image name as /:latest  buildImage  Building the Docker image  true  push  Push the Docker image to registry. This will be effective if the buildImage field of the image is true  false  copyFiles  Copy external files for the Docker image  null  singleYAML  Generate a single YAML file for all K8s resources  true  namespace  Namespace for the Job  default  imagePullPolicy  Docker image pull policy  IfNotPresent  env  List of the environment variables  null  restartPolicy  Restart policy  Never  backoffLimit  Backoff limit  3  activeDeadlineSeconds  Active deadline seconds  20  schedule  Schedule for CRON jobs  none  imagePullSecrets  Image pull secret’s value  null  Extending Ballerina Deployment and Annotations Ballerina can be augmented with your own annotations that represent your own unique deployment artifacts. You can also write builder extensions that generate these files during compilation. Refer to the example at https://github.com/ballerinax/hello.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/documenting-ballerina-code/","name":"Documenting Ballerina Code","summary":"Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.Table of contents        Developers can write the documentation in line with the ...","content":"/  /  / Documenting Ballerina Code  Documenting Ballerina Code  Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.  Table of contents Generating Documentation for Modules  Developers can write the documentation in line with the Ballerina source code using the lightweight markup language. They can document special constructs such as parameters, return values, fields, etc. within the code using documentation attributes. Once the code is documented, developers can generate a basic HTML version of their Ballerina modules using the ballerina doc command. Developers are encouraged to have their custom themes and styles, to have a standard presentation of their Ballerina documentation.  Ballerina documentation design and usage is aligned with project and module semantics of Ballerina. You can generate documentation for modules using the ballerina doc command.    Ballerina programmers can place the documentation inline with the source code using the documentation syntax.  Ballerina type definitions, global variables, annotations, listeners, etc. can be documented using the documentation syntax.  Fields, parameters, return values, etc. can be marked using documentation attributes.  HTML documents can be generated using the ballerina doc command for each Ballerina module and if you have custom handlebars templates, you can use them to generate the HTMLs.   Writing Ballerina Documentation  Ballerina Flavored Markdown documentation is a first-class syntax in the Ballerina language. The # at the beginning of a line denotes a line of documentation. If necessary, you can have multiple lines of documentation, which you can group together.  # <documentation line 1> # <documentation line 2> # ...   When you write documentation, you can use the markdown documentation syntax given above. For example:  # Provides the HTTP actions for interacting with an HTTP server. Apart from the standard # HTTP methods, `forward()` and `execute()` functions are provided. # ...   The supported structure of documentation syntax is as follows:  # <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + return - <return_parameter_description_line_1> # <return_parameter_description_line_2>     Tip: Always, add a full stop at the end of a function description. However, for the parameter and return type descriptions, omit the full stop if you have only one sentence. If there are multiple sentences, add the full stop at the end of each sentence. For example,   # Description of the function. # # + i - One sentence only # + s - Sentence one. Sentence two. # + return - Return description public function foo(int i, string s) returns boolean {  return true; }   Sample Usage  # Submits an HTTP request to a service with the specified HTTP verb. # The `submit()` function does not give out a `Response` as the result, # rather it returns an `HttpFuture`, which can be used to do further # interactions with the endpoint. # # Example: # ```ballerina # HttpFuture future = myMsg.submit(\"GET\", \"/test\", req); # ``` # # + httpVerb - The HTTP verb value # + path - The resource path # + request - An HTTP outbound request message # + return - An `HttpFuture` that represents an asynchronous service invocation # or an `error` if the submission fails public function submit(@sensitive string httpVerb, string path, Request request) returns HttpFuture|error;   Documenting a Module  A Ballerina module can have a Module.md file, which describes the module and its usage.  A typical project structure of a Ballerina project is like this:  /  Ballerina.toml # Configuration that defines project intent  src  module1/ # The source in this directory will be named “<org-name>/module1”  Module.md # Optional, contains descriptive metadata for display at  # Ballerina Central  *.bal  [tests/] # Module-specific unit and integration tests  [resources/] # Module-specific resources   modules.can.include.dots.in.dir.name/  Module.md  *.bal  [tests/]  [resources/]   [resources/] # Resources included with every module in the project   target/ # Compiled executables and other artifacts end up here   The ballerina doc command will read the Module.md and prepend the above to the generated HTML file.  Check for sample HTML that has Module.md content at the top, followed by the other module constructs.  Generating Ballerina Documentation  Ballerina provides a doc command, which can be executed against a given Ballerina project. This command will result in generating the Ballerina documentation as HTML files, for all the modules in the project.  First, let’s create a new Ballerina project:  $ ballerina new myproject Created new Ballerina project at myproject   Next, move into the project directory and execute ballerina add <module-name> to add a new Ballerina module.  $ cd myproject/ $ ballerina add math Added new ballerina module at 'src/math' $ ballerina add world Added new ballerina module at 'src/world'  Now, let’s add a function to the math module to be documented. Copy and paste the following code into the myproject/src/math/main.bal file.  # Calculates the value of the 'a' raised to the power of 'b'. # ```ballerina # float aPowerB = math:pow(3.2, 2.4); # ``` # # + a - Base value # + b - Exponential value # + return - Calculated exponential value public isolated function pow(float a, float b) returns float {  return 0; }  Add the following class definition to the world module. Copy and paste the following code in to the myproject/src/world/main.bal/ file.  # Represents a person object. # # + name - Name of the person # + age - Age of the person in years # + address - Address of the person # + wealth - Account balance of the person public class Person {  public string name = \"\";  public int age;  public string address;  public float wealth = 0;   # Gets invoked to initialize the `Person` object.  #  # + name - Name of the person for the constructor  # + age - Age of the person for the constructor  public function init(string name, int age) {  }   # Get the address of the person.  #  # + return - New address of the person  public function getAddress() returns string {  return self.address ;  }   # Add the wealth of the person.  #  # + amt - Amount to be added  # + rate - Interest rate  public function addWealth(int[] amt, float rate=1.5) {  } }  Now, let’s generate documentation of the project: $ ballerina doc -a  Output: Compiling source  foo/math:0.1.0  foo/world:0.1.0  Generating API Documentation  target/apidocs   target/apidocs/ folder would contain following; $ ls target/apidocs/ index.html math world ...     index.html - contains an index page of all the modules in the Ballerina project  math - contains the documentation of the module named math  world - contains the documentation of the module named world   If you want to generate documentation for a selected Ballerina module, then you can execute the following command from the Ballerina project root directory:  $ ballerina doc <module_name>   For other options, run ballerina doc --help.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/extending-with-compiler-extensions/","name":"Extending with Compiler Extensions","summary":"The sections below include information about extending with compiler extensions.Table of contents        Annotations can be used to provide structured metadata about a particular construct. Annotations are not executable. However, they can be used to alter the behavior of constructs they are attached to.Annotations can be ...","content":"/  /  / Extending with Compiler Extensions  Extending with Compiler Extensions  The sections below include information about extending with compiler extensions.  Table of contents Annotations  Annotations can be used to provide structured metadata about a particular construct. Annotations are not executable. However, they can be used to alter the behavior of constructs they are attached to.  Annotations can be attached to:   services and resources  type definitions  function definitions  function parameters  function return  module-level variables and constants  annotations  listeners  workers  type cast expressions   The Ballerina compiler can be extended using compiler extensions (if required) for additional verification or processing (e.g. modifications, artifact generation etc.). Such custom extensions provided will be executed at the end of the compilation phase before generating the Ballerina Intermediate Representation (BIR). A compiler extension can make use of the metadata provided via annotations to introduce additional behavior to the compilation process.  The ballerina/docker and ballerina/kubernetes modules make use of custom annotations. They introduce new annotations such as @docker:Config and @kubernetes:Deployment that can be attached to certain constructs in a Ballerina source file. The respective compiler extensions then run a post-compilation process that reads these annotations and generates the Docker and Kubernetes deployment artifacts.    Note: Currently, there are two caveats when writing compiler extensions:  The Ballerina Compiler is written in Java 8. Therefore, you will need JDK 1.8.  End users will have to install the extension manually.  Hello World: The Annotation Way  In this guide, we will take a look at how to create a custom annotation and how to write a compiler extension to read and act upon our custom annotation. The custom annotation (i.e. @hello:Greeting) is attachable to functions. It has an attribute called salutation, which will be read by the compiler extension and written to a file when building the program. The annotation can be shared with others by publishing it to . Currently, there isn’t a mechanism for sharing compiler extensions. The compiler extension has to be copied to the <BALLERINA_HOME>/bre/lib directory.  The end user would be able to write a program such as the following:  import foo/hello;  @hello:Greeting {  salutation: \"Guten Tag!\" } function add(int x, int y) returns int {  return x + y; }  public function main() {  var sum = add(10, 20); }   At the end of the build, the user should be able to see a <module_name>.txt file in the target/greetings/ directory.  Defining a Custom Annotation  Creating the Annotation Create a new Ballerina project and add a module named hello. For this instance, add a single source file named annotation.bal and remove other boilerplate code and files. Your project structure should look similar to the following: . ├── Ballerina.toml └── src  └── hello  └── annotation.bal   Add the following code to define the @hello:Greeting annotation in the annotation.bal file.  # This record defines the fields of the @hello:Greeting annotation. # # + salutation - The greeting message public type HelloConfiguration record {|  string salutation = \"Hello!\"; |};  # Define an annotation named `Greeting`. Its type is `HelloConfiguration` and it can be # attached to functions. public annotation HelloConfiguration Greeting on function;   Now, build this annotation. The -c flag is used since this module will only be used as a library. $ ballerina build -c hello   If all went well, a /target directory should be created with the built artifacts. target/ ├── balo │ └── hello-2019r3-any-0.1.0.balo ├── caches │ ├── bir_cache │ │ └── foo │ │ └── hello │ │ └── 0.1.0 │ │ └── hello.bir │ └── jar_cache │ └── foo │ └── hello │ └── 0.1.0 │ └── foo-hello-0.1.0.jar └── tmp  └── foo-hello-0.1.0.jar   Verifying the Annotation  At this stage, you can use the annotation in a program to verify the correctness of what was done so far. To do so, create a demo project, add our hello module as a dependency, and attach it to a function. Your program should compile without any errors.  The demo project structure looks like the following: . ├── Ballerina.toml └── src  └── greet  └── greeting.bal   Add the foo/hello module as a path dependency in the Ballerina.toml file.  [project] org-name = \"bar\" version = \"0.1.0\"  [dependencies] \"foo/hello\" = { path = \"<path_to_annotation_project_dir>/hello-annot/target/balo/hello-2019r3-any-0.1.0.balo\" }   Add a function to the greeting.bal file. Note that the function is annotated using the @hello:Greeting annotation.  import foo/hello;  @hello:Greeting {  salutation: \"Guten Tag!\" } function add(int x, int y) returns int {  return x + y; }  public function main() {  var sum = add(10, 20); }   Building the greet module should produce an executable named greet.jar in the target/bin directory.  Writing the Compiler Extension  The Ballerina compiler can be extended through compiler extensions if there are additional verifications or tasks you would like to perform. Such custom extensions will be executed towards the end of the compilation phase. A compiler extension can be created by implementing the CompilerPlugin interface provided by the org.ballerinalang.compiler.plugins package. It defines the following methods, which the user can implement to add additional verifications.   void process(PackageNode packageNode)  void process(BLangTestablePackage testablePackageNode)  void process(ServiceNode serviceNode, List<AnnotationAttachmentNode> annotations)  void process(TypeDefinition typeDefinition, List<AnnotationAttachmentNode> annotations)  void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations)  void process(SimpleVariableNode variableNode, List<AnnotationAttachmentNode> annotations)  void process(AnnotationNode annotationNode, List<AnnotationAttachmentNode> annotations)  void codeGenerated(PackageID packageID, Path binaryPath)   Each of the process() methods correspond to annotable constructs of the language. The codegenerated() method gets invoked once the code generation phase is completed. The org.ballerinalang.compiler.plugins package also provides a convenience class named AbstractCompilerPlugin with empty implementations for the above methods.  The extension will read the salutation field of the @hello:Greeting annotation and write its value to a file in the /target directory.  Setting Up the Project  Start by creating a Java project for the extension. It needs two classes: HelloPlugin and HelloModel. Also, create a resource file named org.ballerinalang.compiler.plugins.CompilerPlugin in the resources/META-INF/services directory. This file should contain the fully-qualified class name of the extension class (which in this case, is xyz.foo.hello.HelloPlugin). src/ └── main  ├── java  │ └── xyz  │ └── foo  │ └── hello  │ ├── HelloModel.java  │ └── HelloPlugin.java  └── resources  └── META-INF  └── services  └── org.ballerinalang.compiler.plugins.CompilerPlugin   The only dependency you will need for this extension is the ballerina-lang project. Add the following Maven repository to your project to get the ballerina-lang dependency.   http://maven.wso2.org/nexus/content/repositories/releases/   Given below is a sample build.gradle file for the project.  plugins {  id 'java' }  group 'xyz.foo' version '1.0-SNAPSHOT'  sourceCompatibility = 1.8  repositories {  maven {  url \"http://maven.wso2.org/nexus/content/repositories/releases/\"  } }  dependencies {  implementation group: 'org.ballerinalang', name: 'ballerina-lang', version: '1.0.0' }   Adding the Code for the Extension  Add the following code to the HelloPlugin.java file.  import org.ballerinalang.compiler.plugins.AbstractCompilerPlugin; import org.ballerinalang.compiler.plugins.SupportedAnnotationPackages; import org.ballerinalang.model.elements.PackageID; import org.ballerinalang.model.tree.AnnotationAttachmentNode; import org.ballerinalang.model.tree.FunctionNode; import org.ballerinalang.util.diagnostic.Diagnostic; import org.ballerinalang.util.diagnostic.DiagnosticLog; import org.wso2.ballerinalang.compiler.tree.BLangAnnotationAttachment; import org.wso2.ballerinalang.compiler.tree.expressions.BLangLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral; import org.wso2.ballerinalang.compiler.tree.expressions.BLangRecordLiteral.BLangRecordKeyValue;  import java.io.File; import java.io.IOException; import java.nio.charset.StandardCharsets; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.StandardOpenOption; import java.util.List;  /**  * Compiler extension to generate greetings.  */ // This annotation specifies that this compiler extension should only be enabled when the mentioned module is used. @SupportedAnnotationPackages(  value = \"foo/hello:0.1.0\" ) public class HelloPlugin extends AbstractCompilerPlugin {   private DiagnosticLog dlog;   @Override  public void init(DiagnosticLog diagnosticLog) {  this.dlog = diagnosticLog;  }   // The annotation is attached to functions. Therefore, the process() method is overridden for functions.  @Override  public void process(FunctionNode functionNode, List<AnnotationAttachmentNode> annotations) {  // Iterate through the annotations attached to the service.  for (AnnotationAttachmentNode annotation : annotations) {  // The `annotations` list contains all the annotations attached to the service.  // Since only the `@hello:Greeting` annotation is considered, skip the other annotations.  if (!\"Greeting\".equals(annotation.getAnnotationName().getValue())) {  continue;  }   // Retrieve the fields of the annotation value.  List<BLangRecordKeyValue> annotFields =  ((BLangRecordLiteral) ((BLangAnnotationAttachment) annotation).expr).getKeyValuePairs();   // In this particular case, there is no need to iterate through the list since the `@hello:Greeting` annotation only has  // one field. Therefore, take the first element of the fields list.  BLangRecordKeyValue salutationField = annotFields.get(0);  String annotFieldValue = ((BLangLiteral) salutationField.getValue()).getValue().toString();  String greeting = String.format(\"%s from %s()\\n\", annotFieldValue, functionNode.getName().getValue());  HelloModel.getInstance().setGreeting(greeting);  }  }   // The `codeGenerated()` method gets invoked once the executable is built. The greeting is written to a text file  // with the same name as the executable and in the same directory as the executable.  @Override  public void codeGenerated(PackageID packageID, Path binaryPath) {  String fileName = binaryPath.getFileName().toString().replace(\".jar\", \".txt\");  Path greetingsPath = Paths.get(\"target\", \"greetings\", fileName);  String greeting = HelloModel.getInstance().getGreetings();  try {  System.out.println(\"\\nGenerating greetings\");  System.out.println(\"\\t\" + greetingsPath.toString());  writeToFile(greeting, greetingsPath);  } catch (IOException e) {  dlog.logDiagnostic(Diagnostic.Kind.ERROR, null, e.getMessage());  }  }   private void writeToFile(String greetings, Path targetFilePath) throws IOException {  File newFile = targetFilePath.toFile();   if (newFile.exists()) {  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8), StandardOpenOption.APPEND);  return;  }   if (newFile.getParentFile().mkdirs()) {  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8));  return;  }  Files.write(targetFilePath, greetings.getBytes(StandardCharsets.UTF_8));  } }   Add the following code to the HelloModel.java file.  class HelloModel {   private static HelloModel instance = new HelloModel();  private String greeting;   private HelloModel() {  }   static HelloModel getInstance() {  return instance;  }   String getGreetings() {  return greeting;  }   void setGreeting(String greeting) {  this.greeting = greeting;  } }   Finally, build the extension and place the resulting JAR file inside the <BALLERINA_HOME>/distributions/jballerina-<BALLERINA_VERSION>/bre/lib/ directory.  Putting it All Together  Now, build your hello world project again. You should see an additional step logged in the console for generating the greeting.  $ ballerina build greet Compiling source \tbar/greet:0.1.0  Creating balos \ttarget/balo/greet-2019r3-any-0.1.0.balo  Running tests \tbar/greet:0.1.0 \tNo tests found  Generating executables \ttarget/bin/greet.jar  Generating greetings \ttarget/greetings/greet.txt   The target/greetings/greet.txt file should contain the following text: Guten Tag! from add()  Learning More About Writing Compiler Extensions  The example considered in this how-to guide is a basic compiler extension. If you are looking for something which goes beyond this, take a look at the compiler extensions written for generating Docker and Kubernetes artifacts.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/generating-ballerina-code-for-protocol-buffer-definitions/","name":"Generating Ballerina Code for Protocol Buffer Definitions","summary":"The 'Protocol Buffers to Ballerina' tool provides capabilities to generate Ballerina source code for Protocol Buffer definitions.Table of contents        The code generation tool can produce ballerina stub and ballerina service/client template files.In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you ...","content":"/  /  / Generating Ballerina Code for Protocol Buffer Definitions  Generating Ballerina Code for Protocol Buffer Definitions  The 'Protocol Buffers to Ballerina' tool provides capabilities to generate Ballerina source code for Protocol Buffer definitions.  Table of contents Usage of the Tool  The code generation tool can produce ballerina stub and ballerina service/client template files.    In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you can only use this tool to generate Ballerina source code for gRPC service definitions.   CLI Command  You can generate Ballerina source code using the following command:  ./ballerina grpc --input <proto-file-path> [--output <path>] [--mode client | service]   CLI Command Options  --input - Path of the input .proto file. This is a mandatory field. You need to provide the path of the definition  file.  --output - Location of the generated Ballerina source files. This is an optional field. If the output path is not specified, the output will be written to a directory corresponding to the package in the Protocol  Buffers definition. If the package is not specified, the output will be written to a ‘temp’ directory in the current location.  --mode - Set the mode (client or service) to generate code samples. If not specified, only the stub file is  generated.  Sample  The below example shows how you can generate Ballerina source code from the following Protocol Buffers definition (in the helloworld_service.proto file).  syntax = \"proto3\";  service helloWorld {  rpc sayHello(HelloRequest) returns (HelloResponse); }  message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; }   Executing the Sample    Execute the below command to generate the service template file.  $ ballerina grpc --input helloworld_service.proto --mode service --output service  Once you execute the command, the service template file (helloWorld_sample_service.bal) is generated inside the service directory.  Note: If you have multiple services in a Protocol Buffers definition, this command will generate a stub file with common message types and a service template file for each service definition. This is to avoid duplicating message types in all the service files.  Execute the below command to generate the client/service stub and client template.  $ ballerina grpc --input helloworld_service.proto --mode client --output client  Once you execute the command, the stub file(helloworld_service_pb.bal) and the service template file (helloWorld_sample_client.bal) are generated inside the client directory.  Execute the below command to generate only the client/service stub.  $ ballerina grpc --input helloworld_service.proto --output stubs  Once you execute the command, only the stub file (helloworld_service_pb.bal) is generated inside the stubs directory.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/","name":"Let’s Learn Ballerina!","summary":"Ballerina is a comprehensive language that is easy to grasp for anyone with prior ...","content":"/  / Let’s learn Ballerina!  Let’s Learn Ballerina!  Ballerina is a comprehensive language that is easy to grasp for anyone with prior programming experience. Start learning with the material below.  Gear Yourself Up  Download Ballerina, set the tools up, and take the Quick Tour.   Take Ballerina for a Spin  Try out the Ballerina By Examples and use the Playground.   Sharpen Your Skills  Learn more about Ballerina by exploring its features.   Know it Inside Out  Master Ballerina by reading through the reference materials.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/installing-ballerina/","name":"Installing Ballerina","summary":"The sections below include information about installing Ballerina.Table of contents        Follow the instructions below to install the latest Ballerina version using the installer. The installer will automatically uninstall the old Ballerina version if you have one already installed.Info: Ballerina installers support operating systems such as ...","content":"/  /  / Installing Ballerina  Installing Ballerina  The sections below include information about installing Ballerina.  Table of contents Installing Ballerina via Installers  Follow the instructions below to install the latest Ballerina version using the installer. The installer will automatically uninstall the old Ballerina version if you have one already installed.    Info: Ballerina installers support operating systems such as Windows, Ubuntu, Red Hat Enterprise Linux, macOS, and Cent OS. If you are using an unsupported operating system, .   Installing on macOS   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the /Library/Ballerina directory.    Info: Alternatively, you can execute the command below to install Ballerina in macOS using Homebrew. Homebrew installs the Ballerina distribution in the /usr/local/Cellar/ballerina/<BALLERINA-VERSION>/libexec directory.   brew install ballerina  The package automatically sets your PATH environment variable for you. You may need to restart any open Terminal sessions for the change to take effect.  Installing on Windows   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the C:\\Program Files\\Ballerina directory.  The installer should put the C:\\Program Files\\Ballerina\\<BALLERINA-DIRECTORY>\\bin directory in your PATH environment variable. You may have to restart any open command prompts for the change to take effect.  Installing on Linux   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the /usr/lib64/ballerinadirectory.    Info: Alternatively, you can use either of the commands below to install Ballerina using the downloaded DEB or RPM file. Replace the ballerina-linux-installer-x64-<BALLERINA-VERSION>.deb or ballerina-linux-installer-x64<BALLERINA-VERSION>.rpm with the actual file path.   For example, for the DEB file: dpkg -i ballerina-linux-installer-x64-1.2.4.deb For example, for the RPM file: rpm -i ballerina-linux-installer-x64-1.2.4.rpm Installing via the Ballerina Language ZIP File    Note: Before you install Ballerina using the ZIP file, ensure that you have a supported Java Runtime Environment (JRE) installed. It is recommended to use the version 1.8 or above.     and unzip it to a preferred location using an archiver tool of your choice. This creates a directory named ballerina- in your system.  Follow either of the steps below depending on your operating system to configure your system environment to run Ballerina:  For Linux or macOS: set the PATH environment variable to point to the bin directory of the unzipped Ballerina distribution.  For Windows: add a new environment variable specifying the following values:  Variable name: PATH  Variable value: The location of the bin directory of the unzipped Ballerina distribution. For example, C:\\Program Files\\Ballerina\\ballerina-<VERSION>\\bin  Updating Ballerina  If you already have a jBallerina version above 1.1.0 installed, you can use the update tool to update to the latest jBallerina version by executing either of the commands below.    Command  Description  ballerina dist update  Update to the latest patch version of the active distribution  ballerina dist pull jballerina-<JBALLERINA-VERSION>  Fetch a specific distribution and set it as the active version  For more information, see .  Building from Source  Alternatively, follow the instructions below to build Ballerina from the source.  Setting Up the Prerequisites  You need to download and install the below to build the Ballerina modules.   Java SE Development Kit (JDK) version 8 (from one of the following locations)  Note: Set the JAVA_HOME environment variable to the path name of the directory into which you installed JDK.  Obtaining the Source Code Follow the steps below to obtain the Ballerina source code.    Execute the command below to clone the source repository.   git clone --recursive https://github.com/ballerina-platform/ballerina-lang.git  Tip: If you have already forked the repository to your GitHub account, then execute the below command replacing <YOUR-GITHUB-USERNAME> with your Git username.  git clone --recursive https://github.com/<YOUR-GITHUB-USERNAME>/ballerina-lang.git  Execute the command below to update the Git submodules.   git submodule update --init  Building the Source  Follow the steps below to build the project of the obtained source.    Navigate to the root directory of the Ballerina repo (i.e., <BALLERINA_PROJECT_ROOT>) and execute one of the Gradle commands below to build the project using Gradle.   On Unix/macOS: ./gradlew build  Windows: gradlew build  Extract the built Ballerina distributions created in the locations below:   Runtime only: <BALLERINA_PROJECT_ROOT>/distribution/zip/jballerina/build/distributions/jballerina-<version>-SNAPSHOT.zip  Runtime and tools (e.g., Ballerina Language Server): <BALLERINA_PROJECT_ROOT>/distribution/zip/jballerina-tools/build/distributions/jballerina-tools-<version>-SNAPSHOT.zip  Note: If you face an IOException error stating “Too many open files”, this is due to the default number of possible open files being set to a lower number on your operating system than required for Ballerina to be compiled. You may have to increase the number of open files/file descriptors (FD) on your operating system to 1000000 (or higher).   Uninstalling Ballerina  Usually, the installation location is /Library/Ballerina/distributions in macOS, /usr/lib64/Ballerina/distributions in Linux, and C:\\Program Files\\Ballerina\\distributions in Windows. You can either remove a particular jBallerina version or all the jBallerina versions installed in these locations.  To remove:    a specific jBallerina version (via the update tool): execute ballerina dist remove  all the installed jBallerina versions: delete the /../Ballerina directory in the respective installation location   What’s Next?  Once you have successfully installed Ballerina, click the links below to set up your IDE.    Tip: To get help when you work with Ballerina, see .     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/keeping-ballerina-up-to-date/","name":"Keeping Ballerina Up to Date","summary":"This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases.Table of contents        If you haven’t installed Ballerina yet, see the .This section introduces various terms used throughout this guide. We recommend that you read this section ...","content":"/  /  / Keeping Ballerina Up to Date  Keeping Ballerina Up to Date  This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases.  Table of contents If you haven’t installed Ballerina yet, see the .  Terminology  This section introduces various terms used throughout this guide. We recommend that you read this section before proceeding to the next.  The Ballerina Tool  Ballerina is a command-line tool for managing Ballerina source code. It helps you to manage Ballerina projects and modules, test, build and run programs, etc.  It also enables you to easily install, update and switch among Ballerina distributions. The main focus of this guide is to teach you how, but first, let’s talk about Ballerina distributions.  Ballerina Distributions    The language specification defines the syntax and semantics of Ballerina programming language. Ballerina compiler is a software program that validates the Ballerina source code and translates it to an executable program. There exist a production-ready official compiler called jBallerina. We also have a plan to do a native compiler called nBallerina.  jBallerina  Ballerina compiler that targets the JVM.  The most stable and production-ready compiler.  nBallerina  Ballerina compiler that targets platforms such as Linux, Windows and Mac OS.  Not available yet.  Ballerina distribution is a term that we use to refer to jBallerina and nBallerina compilers.  Release Channels  Ballerina distributions are released on two different release channels at the moment: patch releases and minor releases. Both these channels distribute stable versions. We don’t yet have a release channel for nightly builds that give you access to the latest, perhaps unstable features.  Ballerina distribution releases strictly follow with major.minor.patch version numbers.  Patch Release Channel  This channel gives you access to patch releases of Ballerina distributions that contain bug fixes and fixes for critical stability and security issues. These releases are strictly time-bound and happen every two weeks. Occasionally, you would see on-demand patch releases as well.  Example patch releases: jballerina-1.0.6, jballerina-1.1.5, jballerina-1.1.10  Minor Release Channel  This channel gives you access to feature releases of Ballerina distributions. Ballerina programs that you’ve written today should continue to work on these minor releases.  Example minor releases: jballerina 1.1.0, jballerina 1.2.0, jballerina 1.3.0  Release Maintenance    We maintain a minor release 1.x.0 by issuing a series of patch releases 1.x.y. The maintenance of a particular minor release stops when there are two newer minor releases available.  In other words, patch releases for jBallerina 1.x.0 stop when jBallerina 1.(x+2).0 is released. E.g., when jBallerina 1.2 is available, we stop maintaining jBallerina 1.0.0.   Keeping Ballerina Up to Date  Now that you are familiar with the terminology, let’s look at how you can keep your Ballerina distributions up to date.    The first step is to install Ballerina. Visit our guide for details. Once the installation is complete, you would see the following directory structure inside the installation directory.   . ├── bin/ │ └── ballerina ├── lib/ │ └── ballerina-command-0.8.0.jar ├── dependencies/ │ └── jdk8u202-b08-jre/ └── distributions/  ├── ballerina-version  ├── jballerina-1.0.5/  ├── jballerina-1.1.0/  └── jballerina-1.1.1/   “distributions” is the directory where we maintain all your installed distributions.  The “active” Distribution    One only distribution from the above list can be active at a given time.  The Ballerina Tool delegates most of the user requests to the active distribution. The commands such as build, test, run, pull, and push are delegated to the active distribution, while the commands such as dist and version are handled by the tool itself. E.g., when you invoke ballerina build, the Ballerina Tool dispatches this request to the active distribution.  You can change the active distribution at any time. Refer the section for more details.   The ‘ballerina dist’ Command  The Ballerina Tool comes with various subcommands to help you manage Ballerina source code. The ballerina dist and ballerina update commands are the ones that will be explained in this guide. The ballerina dist command allows you to manage Ballerina distributions whereas the ballerina update command updates the tool itself.  The dist command has few other subcommands. Here is the output of ballerina help dist.  → ballerina help dist NAME  ballerina-dist - Manage Ballerina distributions  SYNOPSIS  ballerina dist <command> <-h | --help>  ballerina dist <command> [<args>]   DESCRIPTION  Dist enables you to install, update, and switch among Ballerina distributions  from patch and minor release channels.   OPTIONS  -h, --help  Print usage details of a command.   BALLERINA COMMANDS  Here is a list of available subcommands:   update Update to the latest patch version of the active distribution  pull Fetch a distribution and set it as the active version  use Set a distribution as the active distribution  list List locally and remotely available distributions  remove Remove distributions in your local environment   Use 'ballerina help dist <command>' for more information on a specific command.   Most of these subcommands are self-explanatory. Therefore, the following sections introduce them briefly.  Update to the Latest Patch Version  The ballerina dist update command updates your active distribution to the latest patch version.  E.g., If the active distribution in your environment is “jballerina-1.1.0” and there exists patch version “jballerina-1.1.4” in our servers, this command will fetch and set it as the active distribution.  → sudo ballerina dist update Fetching the latest patch distribution for 'jballerina-1.0.4' from the remote server... Fetching the 'jballerina-1.0.5' distribution from the remote server... Downloading jballerina-1.0.5 100% [==========================================================] 96/96 MB Successfully set the latest patch distribution 'jballerina-1.0.5' as the active distribution   List Local and Remote Distributions  The ballerina dist list command lists the installed distributions in your local environment. It also lists the distributions available for you to download.  → ballerina dist list Distributions available locally:   jballerina-1.0.5 * jballerina-1.1.0  Distributions available remotely:   jballerina-1.1.0  jballerina-1.0.0  jballerina-1.0.1  jballerina-1.0.2 jballerina-1.0.3  jballerina-1.0.4  Use 'ballerina help dist' for more information on specific commands.    The star (*) indicates the active distribution.  Remove Distributions  The ballerina dist remove <distribution> command allows you to delete a particular distribution from your local environment. If you’ve been updating Ballerina regularly, you may have accumulated many unused distribution versions. This command helps you to clean them up.  → ballerina dist remove jballerina-1.0.5 Distribution 'jballerina-1.0.5' successfully removed   Change the Active Distribution  The ballerina dist use <distribution> command sets a particular distribution version as the active one. See the following workflow.  → ballerina dist use jballerina-1.0.4 'jballerina-1.1.0' successfully set as the active distribution  → ballerina dist list Distributions available locally:   jballerina-1.1.0  jballerina-1.0.5 * jballerina-1.0.4  jballerina-1.0.0 …   Pull a Specific Distribution  The ballerina dist pull <distribution> command downloads a particular distribution and stores it in your local environment. It also sets the fetched distribution as the active distribution.  For jBallerina 1.2.5 and Above (for Update Tool Version 0.8.8 and Above):  → sudo ballerina dist pull 1.2.6 Fetching the 'jballerina-1.2.6' distribution from the remote server... Downloading jballerina-1.2.6 100% [==================================] 96/96 MB 'jballerina-1.2.6' successfully set as the active distribution   For Versions Below jBallerina 1.2.5 (for Update Tool Versions Below 0.8.8):  → sudo ballerina dist pull jballerina-1.2.4 Fetching the 'jballerina-1.2.4' distribution from the remote server... Downloading jballerina-1.2.4 100% [==================================] 96/96 MB 'jballerina-1.2.4' successfully set as the active distribution   Update the Ballerina Tool    The ballerina update command updates the Ballerina Tool itself to the latest version. Ballerina Tool versions are independent of the distribution versions. We expect these tool updates to be rare compared to distribution releases.   → ballerina update Fetching the latest version from the remote server... Downloading ballerina-command-0.8.1 Downloading ballerina-tool-0.8.1 100% [====================================] 1/1 MB  Updated to latest tool version: 0.8.1 Cleaning old files... Ballerina Tool updated successfully    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/observing-ballerina-code/","name":"Observing Ballerina Code","summary":"Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs.Table of contents        Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide observability. Ballerina becomes fully ...","content":"/  /  / Observing Ballerina Code  Observing Ballerina Code  Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs.  Table of contents Providing Observability in Ballerina  Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide observability. Ballerina becomes fully observable by exposing itself via these three methods to various external systems allowing to monitor metrics such as request count and response time statistics, analyze logs, and perform distributed tracing.  HTTP/HTTPS based Ballerina services and any client connectors are observable by default. HTTP/HTTPS and SQL client connectors use semantic tags to make tracing and metrics monitoring more informative.  This guide focuses on enabling Ballerina service observability with some of its default supported systems.  and are used for metrics monitoring, and is used for distributed tracing. Ballerina logs can be fed to any external log monitoring system like to perform log monitoring and analysis.  Observing a Ballerina Service  Follow the steps below to observe a sample Ballerina service.  Step 1 - Setting Up the Prerequisites  Make sure you have already installed to set up external products such as Jaeger, Prometheus, etc. You can follow to install Docker.  Step 2 - Installing and Configuring the External Systems    Setup Prometheus for collecting metrics information by following section on Setup Grafana to visualize metrics by following section on Setup Jaeger analyze tracing as mentioned in section Setup Elastic Stack only if you are interested in analysing logs by following section on Step 3 - Creating a ‘Hello World’ Ballerina Service  Create a Service as shown below and save it as hello_world_service.bal.  import ballerina/http; import ballerina/log;  service hello on new http:Listener(9090) {  resource function sayHello (http:Caller caller, http:Request req) returns error? {  log:printInfo(\"This is a test Info log\");  log:printError(\"This is a test Error log\");  log:printWarn(\"This is a test Warn log\");  http:Response res = new;  res.setPayload(\"Hello, World!\");  check caller->respond(res);  }  }   Step 4 - Observing the ‘Hello World’ Ballerina Service  Observability is disabled by default and can be enabled by using the --b7a.observability.enabled=true flag or updating the configurations.  When Ballerina observability is enabled, Ballerina runtime exposes internal metrics via an HTTP endpoint for metrics monitoring and tracers will be published to Jaeger. Prometheus should be configured to scrape metrics from the metrics HTTP endpoint in Ballerina.  Ballerina logs are logged on to the console. Therefore, the logs need to be redirected to a file, which can then be pushed to to perform the log analysis.  Starting the Service Using a Flag  The Ballerina service is observable with default settings when the --b7a.observability.enabled=true flag is used along with the Ballerina run command to start the service. This lets you collect the distributed tracing information with Jaeger and metrics information with Prometheus.  $ ballerina run hello_world_service.bal --b7a.observability.enabled=true  [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   Redirect the standard output to a file if you want to monitor logs.  For example:  $ nohup ballerina run hello_world_service.bal --b7a.observability.enabled=true > ballerina.log &   Starting the Service Using a Configuration File  Observability of Ballerina service can also be enabled from the configuration. Create a configuration file such as ballerina.conf and add configuration below that starts metrics monitoring and distributed tracing with default settings.  [b7a.observability.metrics] # Flag to enable Metrics enabled=true  [b7a.observability.tracing] # Flag to enable Tracing enabled=true   The created configuration file can be passed to the Ballerina program with --b7a.config.file option along with the path of the configuration file.  $ ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf  [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing tracers to Jaeger on localhost:5775 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   Redirect the standard output to a file if you want to monitor logs.  For example: $ nohup ballerina run hello_world_service.bal --b7a.config.file=<path-to-conf>/ballerina.conf > ballerina.log &   Step 5 - Sending Few Requests  Send few requests to Example cURL command:  $ curl http://localhost:9090/hello/sayHello   Step 6 - Viewing Tracing and Metrics in the Dashboard  View the tracing information on Jaeger via and view metrics information from the Grafana dashboard on .  Sample view of Jaeger dashboard for hello_world_service.bal is shown below. Sample view of Grafana dashboard for hello_world_service.bal is shown below. Step 7 - Visualizing the Logs  If you have configured log analytics, view the logs in Kibana via Monitoring Metrics Metrics help to monitor the runtime behavior of a service. Therefore, metrics are a vital part of monitoring Ballerina services. However, metrics are not the same as analytics. For example, you should not use metrics to do something like per-request billing. Metrics are used to measure what Ballerina service does at runtime to make better decisions using the numbers. The code generates business value when it continuously runs in production. Therefore, it is imperative to continuously measure the code in production.  Metrics, by default, supports Prometheus. In order to support Prometheus, an HTTP endpoint starts with the context of /metrics in default port 9797 when starting the Ballerina service.  Configuring Advanced Metrics for Ballerina This section focuses on the Ballerina configurations that are available for metrics monitoring with Prometheus, and the sample configuration is provided below.  [b7a.observability.metrics] enabled=true reporter=\"prometheus\"  [b7a.observability.metrics.prometheus] port=9797 host=\"0.0.0.0\"   The descriptions of each configuration above are provided below with possible alternate options.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.metrics. enabled  Whether metrics monitoring is enabled (true) or disabled (false)  false  true or false  b7a.observability.metrics. reporter  Reporter name that reports the collected Metrics to the remote metrics server. This is only required to be modified if a custom reporter is implemented and needs to be used.  prometheus  prometheus or if any custom implementation, then name of the reporter.  b7a.observability.metrics. prometheus.port  The value of the port to which the service ‘/metrics’ will bind. This service will be used by Prometheus to scrape the information of the Ballerina service.  9797  Any suitable value for port 0 - 0 - 65535. However, within that range, ports 0 - 1023 are generally reserved for specific purposes, therefore it is advisable to select a port without that range.  b7a.observability.metrics. prometheus.host  The name of the host in which the service ‘/metrics’ will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service.  0.0.0.0  IP or Hostname or 0.0.0.0 of the node in which the Ballerina service is running.  Setting Up the External Systems for Metrics There are mainly two systems involved in collecting and visualizing the metrics. is used to collect the metrics from the Ballerina service and can connect to Prometheus and visualize the metrics in the dashboard.  Setting Up Prometheus   is used as the monitoring system, which pulls out the metrics collected from the Ballerina service ‘/metrics’. This section focuses on the quick installation of Prometheus with Docker, and configure it to collect metrics from Ballerina service with default configurations. Below provided steps needs to be followed to configure Prometheus. There are many other ways to install the Prometheus and you can find possible options from .    Create a prometheus.yml file in the /tmp/ directory.  Add the following content to /tmp/prometheus.yml.  global:  scrape_interval: 15s  evaluation_interval: 15s  scrape_configs:  - job_name: 'prometheus'  static_configs:  - targets: ['a.b.c.d:9797']   Here the targets 'a.b.c.d:9797' should contain the host and port of the /metrics service that’s exposed from Ballerina for metrics collection. Add the IP of the host in which the Ballerina service is running as a.b.c.d and its port (default 9797). For more information, go to the .    Start the Prometheus server in a Docker container with the command below.   $ docker run -p 19090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus     Go to and check whether you can see the Prometheus graph. Ballerina metrics should appear in Prometheus graph’s metrics list when Ballerina service is started.   Setting Up Grafana  Let’s use to visualize metrics in a dashboard. For this, we need to install Grafana, and configure Prometheus as a data source. Follow the steps below to configure Grafana.    Start Grafana as a Docker container with the command below.   $ docker run -d --name=grafana -p 3000:3000 grafana/grafana  For more information, go to .    Go to to access the Grafana dashboard running on Docker.  Log in to the dashboard with the default user, username: admin and password: admin  Add Prometheus as a data source with Browser access configuration as provided below.  Import the Grafana dashboard designed to visualize Ballerina metrics from . This dashboard consists of service and client invocation level metrics in near real-time view.   Ballerina HTTP Service Metrics Dashboard Panel will be as below.   Ballerina HTTP Client Metrics Dashboard Panel will be as below.   Ballerina SQL Client Metrics Dashboard Panel will be as below.   Distributed Tracing  Tracing provides information regarding the roundtrip of a service invocation based on the concept of spans, which are structured in a hierarchy based on the cause and effect concept. Tracers propagate across several services that can be deployed in several nodes, depicting a high-level view of interconnections among services as well, hence coining the term distributed tracing.  A span is a logical unit of work, which encapsulates a start and end time as well as metadata to give more meaning to the unit of work being completed. For example, a span representing a client call to an HTTP endpoint would give the user the latency of the client call and metadata like the HTTP URL being called and HTTP method used. If the span represents an SQL client call, the metadata would include the query being executed.  Tracing gives the user a high-level view of how a single service invocation is processed across several distributed microservices.    Identify service bottlenecks - The user can monitor the latencies and identify when a service invocation slows down, pinpoint where the slowing down happens (by looking at the span latencies) and take action to improve the latency.  Error identification - If an error occurs during the service invocation, it will show up in the list of tracers. The user can easily identify where the error occurred and information of the error will be attached to the relevant span as metadata.   Ballerina supports standards by default. This means that Ballerina services can be traced using OpenTracing implementations like , and . Jaeger is the default tracer of Ballerina.  Semantic tags used by Ballerina also follow the Configuring Advanced Tracing for Ballerina  Tracing can be enabled in Ballerina with --b7a.observability.enabled=true flag as mentioned in the section, as well as configuration option. This section mainly focuses on the configuration options with description and possible values.  The sample configuration that enables tracing, and uses Jaeger as the sample tracer as provided below.  [b7a.observability.tracing] enabled=true name=\"jaeger\"   The table below provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing.enabled  Whether tracing is enabled (true) or disabled (false)  false  true or false  b7a.observability.tracing.name  Tracer name which implements tracer interface.  jaeger  jaeger or zipkin  Using the Jaeger Client Jaeger is the default tracer supported by Ballerina. Below is the sample configuration options that are available in the Jaeger.  [b7a.observability.tracing] enabled=true name=\"jaeger\"  [b7a.observability.tracing.jaeger.sampler] type=\"const\" param=1.0  [b7a.observability.tracing.jaeger.reporter] hostname=\"localhost\" port=5775  [b7a.observability.tracing.jaeger.reporter.flush.interval] ms=2000  [b7a.observability.tracing.jaeger.reporter.max.buffer] spans=1000   The below table provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing. jaeger.reporter.hostname  Hostname of the Jaeger server  localhost  IP or hostname of the Jaeger server. If it is running on the same node as Ballerina, it can be localhost.  b7a.observability.tracing. jaeger.reporter.port  Port of the Jaeger server  5775  The port to which the Jaeger server is listening.  b7a.observability.tracing. jaeger.sampler.type  Type of the sampling methods used in the Jaeger tracer.  const  const, probabilistic, or ratelimiting.  b7a.observability.tracing. jaeger.sampler.param  It is a floating value. Based on the sampler type, the effect of the sampler param varies  1.0  For const 0 (no sampling) or 1 (sample all spans), for probabilistic 0.0 to 1.0, for ratelimiting any positive integer (rate per second).  b7a.observability.tracing. jaeger.reporter.flush.interval.ms  Jaeger client will be sending the spans to the server at this interval.  2000  Any positive integer value.  b7a.observability.tracing. jaeger.reporter.max.buffer.spans  Queue size of the Jaeger client.  2000  Any positive integer value.  Using the Zipkin Client The tracing of Ballerina service can be done via Zipkin as well, but the required dependencies are not included in default Ballerina distribution. Follow the steps below to add the required dependencies to the Ballerina distribution.    Go to and clone the GitHub repository in any preferred location.  Make sure you have installed .  Open the command line and build the repository by using with the command below while being in the root project directory ballerina-observability.  $ mvn clean install     Go to the path - ballerina-observability/tracing-extensions/modules/ballerina-zipkin-extension/target/ and extract distribution.zip.  Copy all the JAR files inside the distribution.zip to ‘bre/lib’ directory in the Ballerina distribution.  Add following configuration to the Ballerina.toml of your module.  [platform] target = \"java8\"   [[platform.libraries]]  artifactId = \"ballerina-zipkin-extension\"  version = \"1.0.0-rc1-SNAPSHOT\"  path = \"/<absolute_path_to>/ballerina-zipkin-extension-1.0.0-rc1-SNAPSHOT.jar\"  groupId = \"org.ballerinalang\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"brave-opentracing\"  version = \"4.17.1\"  path = \"/<absolute_path_to>/brave-4.17.1.jar\"  groupId = \"io.opentracing.brave\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"brave\"  version = \"0.29.0\"  path = \"/<absolute_path_to>/brave-opentracing-0.29.0.jar\"  groupId = \"io.zipkin.brave\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-reporter\"  version = \"2.6.1\"  path = \"/<absolute_path_to>/zipkin-2.6.1.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-reporter-2.5.0.jar\"  groupId = \"io.zipkin.zipkin2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-sender-okhttp3\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-sender-okhttp3-2.5.0.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"zipkin-sender-urlconnection\"  version = \"2.5.0\"  path = \"/<absolute_path_to>/zipkin-sender-urlconnection-2.5.0.jar\"  groupId = \"io.zipkin.reporter2\"  modules = [\"yourModuleName\"]   [[platform.libraries]]  artifactId = \"kotlin-stdlib\"  version = \"1.3.31\"  path = \"/<absolute_path_to>/kotlin-stdlib-1.3.31.jar\"  groupId = \"org.jetbrains.kotlin\"  modules = [\"yourModuleName\"]     Change the following configuration name to Zipkin. This ensures that all tracers are sent to Zipkin instead of the default Jaeger tracer.   [b7a.observability.tracing] name=\"zipkin\"     The following configuration is a sample configuration option available for Zipkin tracer.   [b7a.observability.tracing.zipkin.reporter] hostname=\"localhost\" port=9411  [b7a.observability.tracing.zipkin.reporter.api] context=\"/api/v2/spans\" version=\"v2\"  [b7a.observability.tracing.zipkin.reporter.compression] enabled=true   The table below provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  b7a.observability.tracing.zipkin. reporter.hostname  Hostname of the Zipkin server  localhost  IP or hostname of the Zipkin server. If it is running on the same node as Ballerina, it can be localhost.  b7a.observability.tracing.zipkin. reporter.port  Port of the Zipkin server  9411  The port that the Zipkin server is listening to.  b7a.observability.tracing.zipkin. reporter.api.context  API context of the Zipkin server  /api/v2/spans  The API context of the Zipkin API. For V1 API, the context will be /api/v1/spans, and for V2 API, the context will be /api/v2/spans for default Zipkin server.  b7a.observability.tracing.zipkin. reporter.api.version  API version of the Zipkin API  v2  v1 or v2.  b7a.observability.tracing.zipkin. reporter.compression.enabled  Enable the compression for the spans request  true  true or false.  Setting Up the External Systems for Tracing Ballerina by default supports Jaerger and Zipkin for distributed tracing. This section focuses on configuring the Jaeger and Zipkin with Dockers as a quick installation.  Setting Up the Jaeger Server Jaeger is the default distributed tracing system that is supported. There are many possible ways to deploy Jaeger and you can find more information on this . Here we focus on all in one deployment with Docker.    Install Jaeger via Docker and start the Docker container by executing the command below.   $ docker run -d -p5775:5775/udp -p6831:6831/udp -p6832:6832/udp -p5778:5778 -p16686:16686 -p14268:14268 jaegertracing/all-in-one:latest     Go to and load the web UI of the Jaeger to make sure it is functioning properly.   The image below is the sample tracing information you can see from Jaeger.    Setting Up the Zipkin Server Similar to Jaeger, Zipkin is another distributed tracing system that is supported by the Ballerina. There are many different configurations and deployment exist for Zipkin, please go to for more information. Here we focus on all in one deployment with Docker.    Install Zipkin via Docker and start the Docker container by executing following command.   $ docker run -d -p 9411:9411 openzipkin/zipkin     Go to and load the web UI of the Zipkin to make sure it is functioning properly. The sample Zipkin dashboard for the hello world sample in the is shown below.     Distributed Logging Ballerina distributed logging and analysis is supported by Elastic Stack. Ballerina has a log module for logging in to the console. In order to monitor the logs, the Ballerina standard output needs to be redirected to a file.  This can be done by running the Ballerina service as below.  $ nohup ballerina run hello_world_service.bal > ballerina.log &   You can view the logs with command below.  $ tail -f ~/wso2-ballerina/workspace/ballerina.log   Setting Up the External Systems for Log Analytics  Setting Up Elastic Stack The elastic stack comprises of the following components.    Beats - Multiple agents that ship data to Logstash or Elasticsearch. In our context, Filebeat will ship the Ballerina logs to Logstash. Filebeat should be a container running on the same host as the Ballerina service. This is so that the log file (ballerina.log) can be mounted to the Filebeat container.  Logstash - Used to process and structure the log files received from Filebeat and send them to Elasticsearch.  Elasticsearch - Storage and indexing of the logs received by Logstash.  Kibana - Visualizes the data stored in Elasticsearch   Elasticsearch and Kibana are provided as Alternatively, Docker containers can be used to set up Elasticsearch and Kibana as well.    Download the Docker images using the following commands.   # Elasticsearch Image $ docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.1 # Kibana Image $ docker pull docker.elastic.co/kibana/kibana:6.5.1 # Filebeat Image $ docker pull docker.elastic.co/beats/filebeat:6.5.1 # Logstash Image $ docker pull docker.elastic.co/logstash/logstash:6.5.1     Start Elasticsearch and Kibana containers by executing the following commands.   $ docker run -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.5.1 $ docker run -p 5601:5601 -h kibana --name kibana --link elasticsearch:elasticsearch docker.elastic.co/kibana/kibana:6.5.1   If you run on Linux you may have to increase the vm.max_map_count for the Elasticsearch container to start. Execute the following command to do that.  $ sudo sysctl -w vm.max_map_count=262144     Create a logstash.conf file in the /tmp/pipeline/ directory and include the following content in the file.   input {  beats {  port => 5044  } } filter {  grok {  match => { \"message\" => \"%{TIMESTAMP_ISO8601:date}%{SPACE}%{WORD:logLevel}%{SPACE}\\[%{GREEDYDATA:module}\\]%{SPACE}\\-%{SPACE}%{GREEDYDATA:logMessage}\"}  } } output {  elasticsearch {  hosts => \"elasticsearch:9200\"  index => \"ballerina\"  document_type => \"ballerina_logs\"  } }   Here the 3 stages are specified in the pipeline. Input is specified as beats and listens to port 5044. A grok filter is used to structure the Ballerina logs and the output is specified to push to Elasticsearch on elasticsearch:9200.    Start the Logstash container by the following command.   $ docker run -h logstash --name logstash --link elasticsearch:elasticsearch -it --rm -v /tmp/pipeline:/usr/share/logstash/pipeline/ -p 5044:5044 docker.elastic.co/logstash/logstash:6.5.1     Configure Filebeat to ship the Ballerina logs. Create a filebeat.yml file in the /tmp/ directory and include the following content in the file.   filebeat.prospectors: - type: log  paths:  - /usr/share/filebeat/ballerina.log output.logstash:  hosts: [\"logstash:5044\"]     Start the Filebeat container with the following command.   The -v flag is used for bind mounting, where the container will read the file from the host machine. Provide the path to the ballerina.log file, to be bind-mounted to the filebeat container.  $ docker run -v /tmp/filebeat.yml:/usr/share/filebeat/filebeat.yml -v /<path-to-ballerina.log>/ballerina.log:/usr/share/filebeat/ballerina.log --link logstash:logstash docker.elastic.co/beats/filebeat:6.5.1     Access Kibana to visualize the logs at . Add an index named ballerina and click on Discover to visualize the logs.     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/publishing-modules-to-ballerina-central/","name":"Publishing Modules to Ballerina Central","summary":"The sections below include information about publishing modules to Ballerina Central.Table of contents        Pushing a module uploads it to .Before you push your module, you must enter your Ballerina Central access token in Settings.toml in your home repository (<USER_HOME>/.ballerina/).To get your token, register on Ballerina ...","content":"/  /  / Publishing Modules to Ballerina Central  Publishing Modules to Ballerina Central  The sections below include information about publishing modules to Ballerina Central.  Table of contents The CLI Command  Pushing a module uploads it to .  ballerina push <module-name>   Setting Up  Before you push your module, you must enter your Ballerina Central access token in Settings.toml in your home repository (<USER_HOME>/.ballerina/).  To get your token, register on Ballerina Central and visit the user dashboard at .  If you are connected to the internet via an HTTP proxy, add the following section to Settings.toml and change accordingly.  [proxy] host = \"localhost\" port = \"3128\" username = \"\" password = \"\"   Organizations  When you push a module to Ballerina Central, the runtime validates organizations for the user against the org-name defined in your module’s Ballerina.toml file. Therefore, when you have more than one organization in Ballerina Central, be sure to pick the organization name that you intend to push the module into and set that as the org-name in the Ballerina.toml file inside the project directory.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/quick-tour/","name":"Ballerina Quick Tour","summary":"Now, that you know a little bit of Ballerina, let's take it for a spin!Table of contents            Write a simple Hello World HTTP service in a file with the .bal extension.Now, you can run the service by running the following command.You ...","content":"/  /  / Ballerina Quick Tour  Ballerina Quick Tour  Now, that you know a little bit of Ballerina, let's take it for a spin!  Table of contents Installing Ballerina    Ballerina based on the Operating System you are using.  Follow the instructions given on the page to set it up.  Follow the instructions given on the page or the page to set up your preferred editor for Ballerina.   Writing a Service, Running It, and Invoking It  Write a simple Hello World HTTP service in a file with the .bal extension.  import ballerina/http; import ballerina/io;  # A service representing a network-accessible API # bound to port `9090`. service hello on new http:Listener(9090) {   # A resource representing an invokable API method  # accessible at `/hello/sayHello`.  #  # + caller - the client invoking this resource  # + request - the inbound request  resource function sayHello(http:Caller caller, http:Request request) {   // Sends a response back to the caller.  error? result = caller->respond(\"Hello Ballerina!\");  if (result is error) {  io:println(\"Error in responding: \", result);  }  } }   Now, you can run the service by running the following command.  $ ballerina run hello_world.bal   You get the following output.  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   This means your service is up and running. You can invoke the service using an HTTP client. In this case, we use cURL.  $ curl http://localhost:9090/hello/sayHello     Tip: If you do not have cURL installed, you can download it from .   You get the following response.  Hello Ballerina!   Alternatively, you can use a Ballerina HTTP client to invoke the service.  Using a Client to Interact with a Network-Accessible Service  A Ballerina client is a component, which interacts with a network-accessible service. It aggregates one or more actions that can be executed on the network-accessible service and accepts configuration parameters related to the network-accessible service.  There are two kinds of clients in Ballerina, inbound (or ingress) and outbound (or egress) clients. An outbound client object can be used to send messages to a network service.  Having said that, let’s see how you can use a Ballerina client to invoke the Hello World service.  First, you need to create the client with the relevant endpoint URL as follows. We will use a Ballerina program with a main function, which will perform the invocation.    Note: returning error? allows you to use the check keyword to avoid handling errors explicitly. This is only done to keep the code simple. However, in real production code, you may have to handle those errors explicitly.   http:Client helloClient = new(\"http://localhost:9090/hello\");   As the next step, add the below code to do a GET request to the Hello World service.  http:Response helloResp = check helloClient->get(\"/sayHello\");   The remote call would return an http:Response if successful, or an error on failure. If successful, attempt retrieving the payload as a string and print the payload.  io:println(check helloResp.getTextPayload());   The complete source code should look similar to the following:  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client helloClient = new(\"http://localhost:9090/hello\");  http:Response helloResp = check helloClient->get(\"/sayHello\");  io:println(check helloResp.getTextPayload()); }   Make sure the service is up and running.  Now, you can run the .bal file containing the main function that invokes the service.  $ ballerina run hello_client.bal   This would produce the following output.  Hello Ballerina!   Similarly, you can use a Ballerina HTTP client to interact with any HTTP service.  Now, let’s look at a simple HTTP client that retrieves sunrise/sunset time details for Colombo.  Create a client with the relevant endpoint URL as follows.  http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\");   As the next step, add the below code to do a GET request to the sunrise-sunset backend.  http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\");   Now, add the below code snippet to retrieve the payload and print it.  json sunrisePayload = check sunriseResp.getJsonPayload(); io:println(sunrisePayload);   The complete source code should look similar to the following:  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client sunriseApi = new(\"http://api.sunrise-sunset.org\");  http:Response sunriseResp = check sunriseApi->get(\"/json?lat=6.9349969&lng=79.8538463\");  json sunrisePayload = check sunriseResp.getJsonPayload();  io:println(sunrisePayload); }   Now, you can invoke the service using this client by running the following command.  $ ballerina run sunrise_client.bal   This should print out the sunrise/sunset details.  What’s Next?  Now, that you have taken Ballerina around for a quick tour, you can explore Ballerina more.    Go through the to learn Ballerina incrementally with commented examples that cover every nuance of the syntax.  Star the and show appreciation to the Ballerina maintainers for their work. Also, watch the repo to keep track of Ballerina issues.  \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/running-ballerina-code/","name":"Running Ballerina Code","summary":"The sections below include information on running Ballerina programs.Table of contents        A Ballerina application can have:A  function that runs as a terminating process.A , which is a hosted non-terminating process.Both of these are considered as entry points for program execution.These applications can be structured ...","content":"/  /  / Running Ballerina Code  Running Ballerina Code  The sections below include information on running Ballerina programs.  Table of contents Understanding the Structure  A Ballerina application can have:    A function that runs as a terminating process.  A , which is a hosted non-terminating process.  Both of these are considered as entry points for program execution.  These applications can be structured into a single program file or a Ballerina module. A collection of modules can be managed together with versioning and dependency management as part of a Ballerina project.  Source files and modules can contain zero or more entry points, and the runtime engine has precedence and sequence rules for choosing which entry point to execute.  Running Standalone Source Code A single Ballerina source code file can be placed into any folder.  If the source file contains at least one entry point, it can be executed using the run command.  $ ballerina run foo.bal   You can compile a source file with an entry point into an executable jar.  $ ballerina build [-o outputfilename.jar] foo.bal   And you can run .jar files directly: $ ballerina run filename.jar   Running a Project A project is a folder that manages modules as part of common versioning, dependency management, build, and execution. You can build and run items collectively or individually as modules. See for in-depth structuring of projects.  Build all modules of a project: $ ballerina build   Build a single module in a project: $ ballerina build <module-name>   Options for running programs with entry points in a project: $ ballerina run main.bal $ ballerina run main.jar   Configuring Your Ballerina Runtimes  Ballerina Runtime Configuration Files  A Ballerina runtime can be configured using configuration parameters, which are arbitrary key/value pairs with structure. The ballerina/config module provides an API for sourcing configuration parameters and using them within your source code. See for details.  The configuration APIs accept a key and an optional default value. If a mapping does not exist for the specified key, the default value is returned as the configuration value. The default values of these optional configurations are the default values of the return types of the functions.  Sourcing Parameters Into Ballerina Programs Configuration parameters for your programs and apps can be defined on the CLI, as an environment variable, or from a configuration file, with loading and override precedence in the same order.  Sourcing CLI Parameters Consider the following example, which reads a Ballerina config value and prints it.  import ballerina/io; import ballerina/config;  public function main() {  string name = config:getAsString(\"hello.user.name\");  io:println(\"Hello, \" + name + \" !\"); }   The config key is hello.user.name. To pass a value to this config from the CLI, we can use --key=value format as the following command. $ ballerina run main.bal --hello.user.name=Ballerina Hello, Ballerina !   Sourcing Configuration Values  The value can be passed as a config file as well. A configuration file should conform to the format. Ballerina only supports the following features of TOML: value types (string, int, float, and boolean), tables, and nested tables. Given below is a sample ballerina.conf:  [hello.user] name=\"Ballerina\"   When running a program with config API lookups, Ballerina looks for a ballerina.conf file in the directory where the source files are located.  If ballerina.conf resides in the same directory as main.bal, balllerina run can be used without any argument. $ ballerina run main.bal Hello, Ballerina !  To explicitly specify a configuration file, use the --b7a.config.file property. The path to the configuration file can be either an absolute or a relative path. $ ballerina run main.bal --b7a.config.file=path/to/conf/file/custom-config-file-name.conf Hello, Ballerina !   Configuring Secrets as Configuration Items Ballerina provides support for encrypting sensitive data such as passwords and allows access to them securely through the configuration API in the code.  Creating a Secured Value The ballerina encrypt command will encrypt parameters that can be securely sourced from your code files. For example, let’s create a secure parameter named Ballerina with the value 12345 as the secret.  $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the runtime config: <key>=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\"  Or add to the runtime command line: --<key>=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}   Using the Secured Value at Runtime The secured value can be placed in a config file as a value or passed on the command line.  [hello.user] name=\"@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=}\"   or (Enter secret 12345 when prompted.):  $ ballerina run main.bal --hello.user.name=@encrypted:{Z1CfAJwCEzmv2JNXIPnR/9AXHqOJqnDaaAQ7HsggGLQ=} ballerina: enter secret for config value decryption:  Hello, Ballerina !   Decrypting the Value If a configuration contains an encrypted value, Ballerina looks for a secret.txt file in the directory where the source files are located. The secret.txt should contain the secret used to encrypt the value. The secret.txt file will be deleted after it is read.  $ echo 12345 > secret.txt $ ballerina run main.bal --b7a.config.file=ballerina.conf Hello, Ballerina !   Alternatively, you can pass the path to this secret.txt file as a flag via the CLI as follows:   ballerina run main.bal --b7a.config.secret=<PATH_TO_SECRET_FILE>   If the secret.txt file is not present, then CLI prompts the user for the secret. Enter secret 12345 when prompted. $ ballerina run main.bal --b7a.config.file=ballerina.conf ballerina: enter secret for config value decryption:  Hello, Ballerina !    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-intellij-idea/","name":"Setting up IntelliJ IDEA","summary":"The IntelliJ Ballerina plugin provides the Ballerina development capabilities in IntelliJ IDEA. The below sections include instructions on how to download, install, and use the features of the IntelliJ plugin.Table of contents        You need  installed.Note: Your IntelliJ IDE version should be compatible with the ...","content":"/  /  / Setting up IntelliJ IDEA  Setting up IntelliJ IDEA  The IntelliJ Ballerina plugin provides the Ballerina development capabilities in IntelliJ IDEA. The below sections include instructions on how to download, install, and use the features of the IntelliJ plugin.  Table of contents Setting Up the Prerequisites  You need installed.    Note: Your IntelliJ IDE version should be compatible with the corresponding Ballerina plugin version (i.e., the same as the Ballerina distribution version) as shown in the below table.     Plugin Version  Platform Version Compatibility  0.8.0 - 0.8.2  IntelliJ IDEA 2016.3 - 2016.4  0.8.3 - 0.981.0  IntelliJ IDEA 2016.3 - 2017.2  0.982.0 - 0.991.0  IntelliJ IDEA 2017.3 - 2018.2  0.991.1 - 1.2.1  IntelliJ IDEA 2018.3 - 2019.3  1.2.2+  IntelliJ IDEA 2018.3+  Installing the Plugin  Use either of the below approaches to install the IntelliJ Ballerina plugin.    Installing via the IntelliJ IDE    Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins.  Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins.  In the search bar, type “Ballerina” and press the Enter key.  Click Install, and then click Accept.  Click Restart IDE, and then click Restart.     This downloads the plugin and installs it.  Installing Using the ZIP File  Follow the steps below to install the plugin using its ZIP file.    Obtaining the ZIP File  Follow either of the below approaches to obtain the ZIP file of the Ballerina plugin.    Downloading from the JetBrains Plugin Repository  Download the .  Building from the Source  Follow the steps below to obtain the ZIP file by building it from its source.    Clone the GitHub repo.  In a new Command Line tab, navigate to the source directory of the plugin (i.e., the <CLONED_BALLERINA_DIRECTORY>/tool-plugins/intellij directory), and execute the below command.  Info: In the above step,<CLONED_BALLERINA_DIRECTORY> refers to the path of the ballerina-lang Git repository, which you cloned locally. Tip: You need to install the to execute the below command.  ./gradlew buildPlugin  This creates the /build/distributions/ballerina-intellij-idea-plugin-[VERSION].zip file locally in the <CLONED_BALLERINA_DIRECTORY>/tool-plugins/intellij directory.  Installing the ZIP File via the IDE  After obtaining the ZIP file using either of the above approaches, follow the steps below to install it using the IntelliJ IDE.    Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Plugins.  Tip: If you are using Ubuntu/Windows, click File, click Settings, and then click Plugins.  Click the cogwheel icon, and then click Install plugin from disk….  Browse and select the ZIP file of the plugin you downloaded.  Important: Make sure you install the ZIP file and not the extracted JAR files. This is because the ZIP file contains an additional library that is required by the plugin to function as expected.  Click the Installed tab, click Restart IDE, and then click Restart.     Using the Plugin  The below sections include information on using the IntelliJ Ballerina plugin to write Ballerina programs.    Using the Features of the Plugin  The below sections include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-intellij-idea/using-intellij-plugin-features/","name":"Using the features of the IntelliJ plugin","summary":"The sections below include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.Table of contents        You can run Ballerina main/service programs with a single click without adding or changing any configurations.The sections below include instructions on how ...","content":"/  /  /  / Using the features of the IntelliJ plugin  Using the features of the IntelliJ plugin  The sections below include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.  Table of contents Running Ballerina Programs  You can run Ballerina main/service programs with a single click without adding or changing any configurations.  The sections below include instructions on how to run different elements of a Ballerina file.    Running the ‘Main’ Method  Follow the steps below to run the main function of a Ballerina file.    Click the green color icon located near the main function.   Click the corresponding **Run ** command.   This executes the main function of the Ballerina file and displays the output in the Run window.      Tip: Alternatively, you can right-click on the name of the file and run the main method of it.   Running Ballerina Services  Follow the steps below to run a service of a Ballerina file.    Click the green color icon located near the definition of the service.  Click the corresponding **Run **** command.  This starts the service and displays the output in the Run window. If you have multiple services in the Ballerina file, this starts all of them.      Tip: Alternatively, you can right-click on the name of the file and run the service(s) of it.   Debugging Ballerina Programs  You can debug Ballerina main/service programs with a few clicks.    Troubleshooting   Stepping over code lines in non-blocking paths (eg: action invocations) will not pause VM on the next line  workaround: manually put a breakpoint to the next line  There are some cases where stepping over gives unexpected behavior  Eg: When there are multiple workers and a wait expression waiting for them, even though step over hit and pass wait line in source, workers are not yet finished execution.  Viewing the Sequence Diagram  The underlying language semantics of Ballerina were designed by modeling how independent parties communicate via structured interactions. Subsequently, every Ballerina program can be displayed as a sequence diagram of its flow including endpoints as well as synchronous and asynchronous calls.  To view the sequence diagram of a Ballerina file, click the () in the top right corner of the IDE window as shown in the below example.    Importing Modules on the Fly  You can add import declarations to your Ballerina programs on the fly. When you select the module name from the lookup list, the module declaration will be added automatically.    Importing Unambiguous Modules  When you copy and paste Ballerina code to IntelliJ, this feature allows you to import unambiguous imports. You can apply these imports by clicking on the module name and pressing Alt + Enter keys.    Note: This is disabled by default since this might cause issues if the file contains grammar mistakes. Follow the steps below to enable it.  Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Languages and Frameworks.  Tip: If you are using Windows, click File, click Settings, and then click Languages and Frameworks.  Click Ballerina and then click Auto Import.  Select the Add unambiguous imports on the fly checkbox and click OK.  Formatting Ballerina Codes  You can reformat the Ballerina codes by pressing the Ctrl+Alt+L keys.    Viewing Documentation  You can view the documentation of a function, remote function, etc., by pressing the Ctrl+Q keys or by hovering over the element while pressing the Ctrl key.    Adding Annotation Fields via Suggestions  You can add annotation fields to your code using the annotation field names that are suggested inside annotation attachments.    Using File Templates  Three types of Ballerina file templates are available.    Ballerina Main - contains a sample main program  Ballerina Service - contains a sample service  Empty File - contains an empty file     Using Code Snippet Templates  Code snippet templates contain boilerplate codes and allows you to write your code efficiently.    Checking Spellings  The spell-checker is enabled for all identifiers. You can rename all of the definitions and references as well.    Analyzing Semantics  The Ballerina IDEA plugin provides capabilities to diagnose and analyze the semantics of your Ballerina programs through the Ballerina Language Server.    Code Folding  You expand/collapse the following Ballerina code segments using the icons in the IntelliJ IDE.    imports  services  objects  records  functions and object functions  annotations  markdown documentation  multiline comments     Go to Definition  This option allows you to view the definition of a selected variable, function, an object etc., within the same file, in a separate file, in the same module, or in a file of a different module, of the same project or of the .    What’s Next?    For more information on the IntelliJ IDEA Ballerina plugin, see .  For information on all the tools and IDEs that are supported by Ballerina, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-intellij-idea/using-the-intellij-plugin/","name":"Using the IntelliJ Ballerina Plugin","summary":"The sections below include information to start using the IntelliJ Ballerina plugin after installing it.Table of contents        Follow the steps below to create a new Ballerina project.Open IntelliJ, click File in the top menu, click New, and then click Project.Select Ballerina as the type of ...","content":"/  /  /  / Using the IntelliJ Ballerina Plugin  Using the IntelliJ Ballerina Plugin  The sections below include information to start using the IntelliJ Ballerina plugin after installing it.  Table of contents Creating a New Ballerina Project  Follow the steps below to create a new Ballerina project.    Open IntelliJ, click File in the top menu, click New, and then click Project.  Select Ballerina as the type of the project, and click Next.   Select a Ballerina SDK for the project, and click Next.   Tip: If you do not have an already-configured Ballerina SDK to select, click Configure, select the location of the Ballerina distribution, click Open, and then click Next to continue with the project creation. However, if you do not configure, the plugin will auto detect the Ballerina Home by executing the ballerina home command.  Enter a name for the project, a location to save it, and click Finish.   Now, you have successfully created a new Ballerina project.    Setting Up Ballerina SDK for an Existing Project  Follow the steps below to set up Ballerina SDK for an existing project.    Open the Project to which you want to set up a Ballerina SDK.  In the IDE, click File in the top menu, and then click Project Structure.   If you do not have an already-configured Ballerina SDK, in the Project tab, click New under Project SDK:, click Ballerina SDK, and then click OK.   Tip: If you have already-configured Ballerina SDKs, select one under Project SDK:, and click OK to continue.  Select the location of the Ballerina distribution and click Open.   Click Apply to save the changes.   Tip This prompts a restart request. Click Restart to apply the changes.  Now, you have successfully added the Ballerina SDK to an existing project.  Creating a New Ballerina File  Follow the steps below to create a new Ballerina file within a Ballerina project.    Right-click on the name of the project, click New, and then click Ballerina File.   Enter a name for the file, and click OK.   Tip: In this example, since the default Main template is selected as the Kind, it creates a new file with a main function.  Now, you have successfully created a new Ballerina file with a main function.    Configuring the Plugin Settings  Ballerina Home Auto Detection  In order to automatically detect the Ballerina Home that is being used (without setting up a Ballerina SDK), enable the Settings -> Languages and Frameworks -> Ballerina -> Ballerina Home Auto Detection option.    Experimental Features  Ballerina Language Specification supports a set of experimental features such as the transactions syntax. In order to be compatible with the experimental features and for supporting language intelligence in IntelliJ plugin, enable the Allow Experimental option in Settings -> Languages and Frameworks -> Ballerina -> Experimental Features.    Language Server Debug Logs  In order to view the plugin debug logs, enable the Settings -> Languages and Frameworks -> Ballerina -> Language Server Debug Logs option.  Then, the language server debug logs will be added to the IDEA log files. (Click Help -> Show Log In Files option to view them).    What’s Next?  Next, for information on using the features of the IntelliJ Ballerina plugin, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/documentation-viewer/","name":"Documentation Viewer","summary":"The VS Code Ballerina extension is shipped with a Documentation Viewer. You can add documentation for the functions and other public entities in your module for the reference of other users of it.Table of contents        The Documentation Viewer represents the documented entities in a file ...","content":"/  /  /  / Documentation Viewer  Documentation Viewer  The VS Code Ballerina extension is shipped with a Documentation Viewer. You can add documentation for the functions and other public entities in your module for the reference of other users of it.  Table of contents Launching the Documentation Viewer  The Documentation Viewer represents the documented entities in a file in an organized manner. Follow the steps below to launch the Documentation Viewer.    Click View in the top menu and click Command Palette.  In the search box, type “Show” and click Ballerina: Show Documentation Preview.     What’s Next?    For information on the next capability of the VS Code Ballerina plugin, see .  For information on the VS Code Ballerina extension, see .     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/graphical-editor/","name":"Graphical View","summary":"A rich set of visualization tools will immensely enhance your development experience especially in the integration space. The Graphical Editor of the VS Code Ballerina extension allows you to design your integration scenario graphically. Thus, by using it, you can visualize your code in a sequence diagram, which presents the ...","content":"/  /  /  / Graphical View  Graphical View  A rich set of visualization tools will immensely enhance your development experience especially in the integration space. The Graphical Editor of the VS Code Ballerina extension allows you to design your integration scenario graphically. Thus, by using it, you can visualize your code in a sequence diagram, which presents the endpoint interactions and parallel invocations that happen in the code. The sections below discuss how to use the Graphical Editor and explore its capabilities.  Table of contents Launching the Graphical View  The below are the two types of Graphical Views you can find in the VSCode extension.  Launching the Project Overview  This gives a graphical representation of a grouping of the content in the project modules. Click the name of the entity under BALLERINA PROJECT OVERVIEW to view its graphical representation.    Launching the File Overview  This gives a graphical representation of the content of the current Ballerina file. Use one of the methods to view it.    Click the Show File Overview icon in the top right corner.   Select the Show File Overview command option from the Command Palette.  Exploring the Features of the Graphical View  The below sections include information to explore the features of the Graphical Editor.    Viewing the Source  From the design view, you can jump to the respective source segment as shown below.    Expanding the Diagram View  You can expand the Diagram View to show not only the control flow but also to show more fine-grained statements of the constructs.    What’s Next?    For information on the next capability of the VS Code Ballerina plugin, see .  For information on the VS Code Ballerina extension, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/","name":"Setting Up Visual Studio Code","summary":"The VS Code Ballerina extension provides the Ballerina development capabilities in VS Code. The below sections include instructions on how to download, install, and use the features of the VS Code extension.Table of contents        Download the .Use either of the below approaches to install the ...","content":"/  /  / Setting Up Visual Studio Code  Setting Up Visual Studio Code  The VS Code Ballerina extension provides the Ballerina development capabilities in VS Code. The below sections include instructions on how to download, install, and use the features of the VS Code extension.  Table of contents Downloading VS Code  Download the .  Installing the Extension  Use either of the below approaches to install the VS Code Ballerina extension.    Tip: If you installed a new Ballerina version recently, you might need to restart the VS Code Editor to pick the new Ballerina version. If you are using Mac OS, press ‘Command+Q’ keys to quit the app and reopen it.     Installing via the VS Code Editor  Click Extensions on the left-most menu of the editor, search for the Ballerina extension, and click Install.    Tip: Click Reload to reload the editor to apply the change.     This downloads the extension and installs it.  Installing by Downloading the Extension    Download the .  Follow either of the below approaches to install the extension.  Installing via the VS Code Editor    Click View in the top menu of the editor and click Command Palette.  In the search bar, type “vsix” and click Extensions: Install from VSIX….  Browse and select the VSIX file of the extension you downloaded.     Installing via the Command Line In a new Command Line tab, execute the below command. $ code --install-extension <BALLERINA-EXTENSION-DIRECTORY>    Tip: In the above command, <BALLERINA_EXTENSION-DIRECTORY> refers to the path in which you saved the Ballerina extension directory (i.e., the VSIX file) you downloaded.   Using the Extension    Tip: Ballerina Language Specification supports a set of experimental features such as transactions syntax. In order to be compatible with the experimental features and for supporting language intelligence in VS Code Extension, enable the Allow Experimental option in user settings.   The sections below include information on the various capabilities that are facilitated by the VS Code Ballerina Extension for the development process.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/language-intelligence/","name":"Language Intelligence","summary":"The VS Code Ballerina extension brings in language intelligence to enhance the development experience and increase its efficiency. Language intelligence is built in to the extension via a Language Server implementation, which consists of the below language intelligence options.Table of contents        When there are syntax ...","content":"/  /  /  / Language Intelligence  Language Intelligence  The VS Code Ballerina extension brings in language intelligence to enhance the development experience and increase its efficiency. Language intelligence is built in to the extension via a Language Server implementation, which consists of the below language intelligence options.  Table of contents Semantic and Syntactic Diagnostics  When there are syntax or semantic errors in your code, you will be notified with appropriate diagnostics during the development time.    Tip: The detailed description that appears when you hover over the lines underlined in red will be consistent with the error message that you get during compile-time.     Suggestions and Auto-Completion  The extension provides you with suggestions on keywords, variables, and code snippets of language constructs (such as functions, services, and iterable constructs etc.,).      Tip: You can use these suggestions to access the contents of the modules available in your Ballerina home repo as well as in the Ballerina distribution.   Code Actions  These allow you to perform the below tasks easily based on the diagnostics and the current scope where the cursor resides.    Add documentation for an entity such as a function, service, resource, object, record etc.,  Add documentation for all the available entities in the current file  Add missing imports  Create variable definitions  Create an undefined function   For example, you can add documentation for a function as shown below.    Hover Support  Hover support provides you quick access to information about a certain entity.  For example, if you hover over a function name, you can view its description, information about its parameters, and the description of its return type as shown below.      Tip: Likewise, if you hover over an entity name of an object or a record, you can view the description of the object/record as well as descriptions of its fields.   Go to definition  This option allows you to view the definition of a selected variable, function, an object etc., within the same file, in a separate file, in the same module, or in a file of a different module, of the same project or of the .    What’s Next?    For information on the next capability of the VS Code Ballerina extension, see .  For information on the VS Code Ballerina extension, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/run-all-tests/","name":"Run all Tests","summary":"This option allows you to run all the tests that belong to multiple modules of your project.Table of contents        Follow the steps below to do this.This website uses cookies so that we can provide you with the best user experience. Read our  to find ...","content":"/  /  /  / Run all Tests  Run all Tests  This option allows you to run all the tests that belong to multiple modules of your project.  Table of contents Running All Tests  Follow the steps below to do this.    Click View in the top menu and click Command Palette.  In the search box, type “Ballerina” and click Ballerina: Run All Tests.     What’s Next?    For information on the Ballerina VSCode extension, see .  For information on all the tools and IDEs that are supported by Ballerina, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/setting-up-visual-studio-code/run-and-debug/","name":"Run and Debug","summary":"The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger. Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.Table of contents        Follow the steps below to start ...","content":"/  /  /  / Run and Debug  Run and Debug  The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger. Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.  Table of contents Starting a Debug Session  Follow the steps below to start a debug session.    Click the Debug icon in the left menu or press the Control + Shift + D keys, to launch the Debugger view.  Add the debug points you require by clicking on the respective line numbers of the file.  Click No Configurations and select Add Configuration….  Click Ballerina Debug. This opens the launch.json file. You can edit this file to change the debug configuration options as required.  Click on the name of the file that you want to debug.  Click the Start Debugging icon.   You view the output in the DEBUG CONSOLE.    For more information on debugging your code using VS Code, go to .  Troubleshooting   Stepping over code lines in non-blocking paths (eg: action invocations) will not pause VM on the next line  workaround: manually put a breakpoint to the next line  There are some cases where stepping over gives unexpected behavior  E.g., when there are multiple workers and a wait expression waiting for them, even though it steps over to hit and pass the wait line in the source, the workers may not have finished the execution yet.  What’s Next?    For information on the next capability of the VS Code Ballerina extension, see .  For information on the VS Code Ballerina extension, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/structuring-ballerina-code/","name":"Structuring Ballerina Code","summary":"This document demonstrates the development of a Ballerina project and shows how to use the `Ballerina Tool` to fetch, build, and install Ballerina modules.Table of contents        These commands work with repositories that are both local and remote.Ballerina Central is a globally hosted module management system ...","content":"/  /  / Structuring Ballerina Code  Structuring Ballerina Code  This document demonstrates the development of a Ballerina project and shows how to use the `Ballerina Tool` to fetch, build, and install Ballerina modules.  Table of contents Organizing Your Code    These commands work with repositories that are both local and remote.   Ballerina Central is a globally hosted module management system that is used to discover, download, and publish modules.  The Ballerina Tool requires you to organize your code in a specific way. This document explains the simplest way to get it up and running with a Ballerina installation.    Ballerina programmers can either place their code into a single source code file or in a project directory.  A Ballerina program residing in a single source code file should have a .bal extension and an entry point (i.e., either a main method or a service).  A Ballerina program is a compiled and linked binary.  A module is a directory that contains Ballerina source code files.  A repository is a versioned collection of compiled or source code modules.  A project atomically manages a collection of modules.   Programs A program is a runtime executable ending with a .jar extension. A program is the transitive closure of one Ballerina module without including ballerina/* modules, since those are dynamically linked within Ballerina’s runtime engine during execution. A module, which is a program compiles into a file with a .jar extension. Otherwise, it is treated as a to-be-linked library that ends with a .balo extension.  To generate an executable .jar file, the program’s module must contain either a main() function (a process entry point) or a service (a network-accessible API).  A program can import dependent modules that are stored within a repository.  Suppose you have the following structure:  /local/ballerina/src  sample.bal   The sample.bal file contains both a main() entry point and a service:  import ballerina/http; import ballerina/io; import ballerina/log;  public function main() {  io:println(\"Hello, World!\"); }  service hello on new http:Listener(9090) {  resource function sayHello (http:Caller caller, http:Request req) {  http:Response res = new;  res.setPayload(\"Hello, World!\");  var respondResult = caller->respond(res);  if (respondResult is error) {  log:printError(\"Error sending response\", err = respondResult);  }  } }   Building and Running Programs To generate an executable .jar, you can build a Ballerina program, which contains a main() function or a service(s):  $ cd /local/ballerina/src $ ballerina build sample.bal  # This generates 'sample.jar'.   You can use the following command to run the main() function or services in a generated .jar file: $ ballerina run sample.jar   Modules A module is a directory, which contains Ballerina source code files and is part of a namespace. Modules facilitate collaboration, sharing, and reuse. Modules can include functions, clients, constants, annotations, services, and objects. To share a module among programs, projects, and users, you need to push the module into a repository.  Modules:   May or may not have a version However, modules cannot be pushed into a registry for sharing without a version Are referenced by <org-name>/<module-name> where <org-name> is a namespace from within a repository.   Module names can contain alphanumeric characters including dots (.). Dots in a module name has no meaning other than the last segment after the final dot being used as a default alias within your source code.  Importing Modules Your Ballerina source files can import modules:  import [<org-name>]/<module-name> [as <identifier>];   When you import a module, you can use its functions, annotations, and other objects in your code. You can also reference the objects with a qualified identifier followed by a colon (:). For example, <identifier>:<module-object>.  Identifiers are either derived or explicit. The default identifier is either the module name or if the module name has dots (.) included, then the last word after the last dot. For example, import ballerina/http; will have http:as the derived identifier, and the module import ballerinax/java.jdbc would have jdbc: as the default identifier.  You can have an explicit identifier by using the as <identifier> syntax.  import ballerina/http;  // The listener comes from the imported module. service hello on new http:Listener(9090) {   // The 'Request' object comes from the imported module.  resource function sayHello (http:Caller caller, http:Request req) {  ...  } }   Or you can override the default identifier: import ballerina/http as network;  service hello on new network:Listener(9090) {   // The 'Request' object comes from the imported module.  resource function sayHello (network:Caller caller, network:Request req) {  ...  } }   Module Version Dependency If your source file or module is a part of a project, then you can explicitly manage version dependencies of imported modules within the project by defining it in the Ballerina.toml file:  [dependencies] \"wso2/twitter\" = \"2.3.4\" \"wso2/github\" = { path = \"path/to/github.balo\", version = \"1.2.3\"}  Often, you would want to depend on a module of another project, which you have not pushed to the Ballerina Central. This can be achieved using a path dependency as shown above with the wso2/github dependency.  If an import version is not specified in Ballerina.toml, the compiler will use the latest module version from a repository, if one exists.  import foo/http;  public function main() {  http:Person x = http:getPerson(); }   Compiled Modules A compiled module is the compiled representation of a single module of Ballerina code, which includes transitive dependencies into the compiled unit.  Modules can only be created, versioned, and pushed into a repository as part of a project.  Running Compiled Modules An entry point such as a main() or a service that is compiled as part of a named module is automatically linked into a .jar. You can run the compiled module .jar:  ballerina run module.jar   Projects   A project is a directory, which atomically manages a collection of modules. It has:  A user-managed manifest file, Ballerina.toml  An src folder with module source code  Projects are managed atomically. Therefore, dependency management, compilation, unit tests, and artifact generation are done collectively across the source code files and modules defined within a project.  Creating a Project You can create a project using the ballerina new command:  ballerina new <project-name>   The new command will create a project directory with the given name. A Ballerina project cannot reside in another Ballerina project. If you run ballerina new from inside a Ballerina project directory or from inside a sub-directory of a Ballerina project, it will give an error.  It will create the Ballerina.toml file and src folder.  Adding a Module Once the project is initialized, a module can be created inside the project using the ballerina add command. Each subdirectory of the project src folder defines a single module. The subdirectory’s name will be used to name the module.  ballerina add <module-name>   The folders tests/ and resources/ are reserved folder names within the module. The tests/ folder contains unit test files of the module and the resources/ folder contains the resources of the module that will be available at runtime. Any additional subdirectories within the module have no semantic meaning and can be used by the developer for organizing files. The module subdirectories can have as many Ballerina source files and all will be included within the module when it is built.  Project Structure /  project-name/  .gitignore  Ballerina.lock # Generated during the build and used to rebuild identical binary  Ballerina.toml # Configuration, which defines project intent  src/  module1/ # The source in this directory will be named “<org-name>/module1”  Module.md # Contains descriptive metadata for display at Ballerina Central  main.bal # Contains the default main method  *.bal # In this dir and recursively in subdirs except tests/ and resources/  [tests/] # Module-specific unit and integration tests  main_test.bal # The test file for main  [resources] # Resources for the tests  [resources/] # Module-specific resources module2/  Module.md  *.bal  [tests/]  [resources/] target/ # Compiled executables and other artifacts end up here  balo/ # BALO files, one per each module, will be created here  bin/ # Executables will be created here  caches/  bir_cache/  jar_cache/   Building a Project A project should be built if it is required to generate the executable JAR files from the modules in the project. The executable JAR files will be generated only if there are entry points (main method or a service) in the module. Building a project will build all modules found in the project’s root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution.  ballerina build -a   Building a Module You can build a single module contained within a project:  ballerina build <module-name>  Use the --skip-tests flag with the ballerina build command to skip running the tests during the build process.  ballerina build --skip-tests <module-name>   Compiling a Project A project should be compiled if it is required to generate the libraries (i.e., BALOs) from the modules in the project. Compiling a project will compile all the modules found in the project’s root folder. Building a project runs through phases including dependency resolution, compilation, artifact generation, and unit test execution.  ballerina build -c -a   Compiling a Module You can build a single module contained within a project:  ballerina build -c <module-name>  Use the --skip-tests flag with the ballerina compile command to skip running the tests during the compile process.  ballerina build -c --skip-tests <module-name>   Versioning a Module Modules in a project are assigned their version from within the Ballerina.toml file:  # The current version, obeying [semver](https://semver.org/) version = \"string\"   All modules built in a project are assigned the same version. If you need two modules to have different versions, then those modules should be placed into different projects.  Version labels must follow .  Assigning an Organization Name to a Module A module is assigned an <org-name> when it is pushed into a repository. The <org-name> is defined in the Ballerina.toml and all modules in the same project are assigned the same organization name:  # Org name assigned to modules when installed into a repository org-name = \"foo\"   Module Caches  Caches  Ballerina will maintain several caches to speed up the compile and build process. Following artifacts will be cached by Ballerina.    BALO files fetched from Central.  BIR files generated during the compilation.  JAR file generated during the compilation   Here, the BALO cache will be common across any version of Ballerina and the BIR and JAR caches will be specific to the Ballerina version.  BALO Cache  BALO cache is responsible for keeping BALOs of dependent modules. There is a BALO cache inside the Ballerina distribution, which contains the BALOs of libraries that will get packed into the distribution. There is another cache at the user’s home repository, which is used to cache the BALOs fetched from Central.  BIR Cache  BIR files of the standard library that gets packed into a distribution are generated during the distribution build time. The BIR files of the other dependencies will be kept inside the target directory when compiling a Ballerina project.  JAR Cache  The JAR files generated during the build will be kept inside the target directory when building a Ballerina project. The JAR file will be generated only if there is an entry point (main function or service) within the module.  Module Repository - Ballerina Central A repository is a collection of compiled Ballerina modules. A repository helps to organize modules used by multiple programs by managing their versions and assets in a central location. [Ballerina Central] (http://central.ballerina.io) is the only module repository for Ballerina developers.  Organizations An organization is a logical name used for grouping modules together under a common namespace within a repository.  All modules installed into a repository must have an organization name. Any installation or pushing of a module into a repository will fail without an organization name.  Organization names can contain lowercase alphanumeric characters and underscores. None of the characters in an organization name has any semantic meaning.  The organization names ballerina and ballerinax are reserved for system use. Modules in ballerina and ballerinax are included within the system distribution.  At Ballerina Central, every account is assigned a personal organization name, which is chosen by a user when creating their account initially or is derived from the email address of the user.  When pushing a module from a local computer into Ballerina Central, the user’s organization name in the Ballerina Central MUST match the <org-name> assigned in the Ballerina.toml file. If the names do not match, then the push operation will fail. This enforcement may seem arbitrary. However, it is a simple way to ensure organization naming consistency across remote and local development environments.  Pulling Remote Modules You can install modules that exist in Ballerina Central into your BALO cache in the home directory via “pulling” them. Pulling a module discovers and downloads the module source and binaries from Ballerina Central and installs them into the BALO cache.  ballerina pull <org-name>/<module-name>[:<version>]   If a version is not specified for the module to be pulled, the latest version of the module will be pulled from the Ballerina Central. Projects that perform dependency analysis will automatically pull modules into the BALO cache in the home directory.  Pushing Modules “Pushing” a module uploads the associated module files and installs the module into Ballerina Central.  The org-name and the version of the module will be read from the manifest file Ballerina.toml inside the project. It is required to build the module before pushing it to Ballerina Central.  # Push a single module ballerina push <module-name>  Configuring Ballerina Central Access  Ballerina Central requires an account in order to push modules. Your account is represented by a CLI token that is installed into your local Ballerina configuration file, i.e., ~/.ballerina/Settings.toml. The CLI token is automatically installed into this file the first time you perform a ballerina push as Ballerina redirects to an OAuth authorization screen, configures your account, and then copies your CLI token from Ballerina Central into your local CLI configuration. To get your token, register on Ballerina Central and visit the .  Every push of the same module into Ballerina Central REQUIRES a new version even for minor text updates. This policy is enforced to ensure that projects, which make use of dependencies cannot experience accidental behavior drift across two versions of the same module given the same version. Essentially, there is no way to “update” a module for a specific version in Ballerina Central.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/testing-ballerina-code/executing-tests/","name":"Executing Tests","summary":"The sections below include information about executing tests in Ballerina.Table of contents        Tests will be automatically executed when you run the build command or you can explicitly run them using the test command.Execute tests within the specified module with the following command.Execute tests in the ...","content":"/  /  /  / Executing Tests  Executing Tests  The sections below include information about executing tests in Ballerina.  Table of contents Executing Tests Using CLI Commands  Tests will be automatically executed when you run the build command or you can explicitly run them using the test command.  Execute tests within the specified module with the following command.  $ ballerina test <module_name>   Execute tests in the entire project using the –all option.  $ ballerina test --all   List all test groups in a given module.  $ ballerina test --list-groups <module_name>   Run only the tests belonging to the given group(s) in the current project.  $ ballerina test --groups <group_1>,<group_2> --all   Run the tests in the current project excluding the given group(s).  $ ballerina test --disable-groups <group_1> --all   Run only the given test function(s) in the current project.  $ ballerina test --tests <test_function> --all   Generate an HTML test report.  $ ballerina test --test-report <module-name> | -a | --all   Generate the HTML test report with code coverage information.  $ ballerina test --code-coverage <module-name> | -a | --all   For more options of the test command, run the following.  $ ballerina test --help  Test Report  By default, a summary of the test statuses is printed in the console at the end of the test execution. In addition to the results printed in the console, an HTML test report can be generated by passing the --test-report flag in the Ballerina command. The link to the file will be printed in the console at the end of the test execution.  The test report contains the total passed, failed, and skipped tests of the entire project and of the individual modules.  Example:  $ ballerina test --test-report --all   A sample view of the test report is shown below.    Code Coverage Report  The Ballerina test framework provides an option to analyze the code coverage of a standard Ballerina project. This feature provides details about the coverage of the program source code by the tests executed.  You can pass the --code-coverage flag in the test execution command and generate the code coverage report at the end of the test execution. The generated file is an extended version of the test report. In addition to the test results, this file would contain details about the source code coverage at different levels.    Project-level coverage as an average  Module-level coverage as an average  Individual source file coverage   The code coverage only includes the Ballerina source files being tested and not any files under the tests/ directory.  Example:  $ ballerina test --code-coverage --all   A sample view of the code coverage report is shown below.     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/testing-ballerina-code/mocking/","name":"Mocking","summary":"Mocking is useful to control the behavior of functions and objects to control the communication with other modules and external endpoints. A mock can be created by defining return values or replacing the entire object or function with a user-defined equivalent. This feature will help you to test the Ballerina ...","content":"/  /  /  / Mocking  Mocking  Mocking is useful to control the behavior of functions and objects to control the communication with other modules and external endpoints. A mock can be created by defining return values or replacing the entire object or function with a user-defined equivalent. This feature will help you to test the Ballerina code independently from other modules and external endpoints.  Table of contents Mocking Objects  The Test module provides capabilities to mock an object for unit testing. This allows you to control the behavior of the object member functions and values of member fields via stubbing or replacing the entire object with a user-defined equivalent. This feature will help you to test the Ballerina code independently from other modules and external endpoints.  Mocking objects can be done in two ways.    Creating a test double (providing an equivalent object in place of the real)  Stubbing the member function or member variable (specifying the behavior of the functions and values of the variables)   Creating a Test Double  You can write a custom mock object and substitute it in place of the real object. The custom object should be made structurally equivalent to the real object via the mocking features in the test module.  Example:  Let’s make changes to the example in the to define a test  double for the clientEndpont object.    Note: Only the get function is implemented since it is the only function used in the sample. Attempting to call  any other member function of the clientEndpoint will result in a runtime error.   main_test.bal  import ballerina/test; import ballerina/http;  // An instance of this object can be used as the test double for the `clientEndpoint`. public type MockHttpClient client object {  public remote function get(@untainted string path, public http:RequestMessage message = ()) returns http:Response|http:ClientError {   http:Response response = new;  response.statusCode = 500;  return response;  } };  @test:Config {} public function testGetRandomJoke() {  // create and assign a test double to the `clientEndpoint` object  clientEndpoint=<http:Client>test:mock(http:Client, new MockHttpClient());   // invoke the function to test  string|error result = getRandomJoke(\"Sheldon\");   // verify that the function returns an error  test:assertTrue(result is error); }   Stubbing Member Functions and Variables of an Object  Instead of creating a test double, you may also choose to create a default mock object and stub the functions to return a specific value or to do nothing.  Example:  The example in the shows how the get function of the client object can be stubbed to return a value. Let’s make changes to that example to get a random joke from a specific category (e.g., food or movies).  main.bal  import ballerina/io; import ballerina/http; import ballerina/stringutils;  http:Client clientEndpoint = new(\"https://api.chucknorris.io/jokes/\");  // This function performs a `get` request to the Chuck Norris API and returns a random joke // or an error if the API invocations fail. function getRandomJoke(string name, string category = \"food\") returns string|error {  http:Response response = checkpanic clientEndpoint->get(\"/categories\");   // Check if the provided category is available  if (response.statusCode == http:STATUS_OK) {  json[] categories = <json[]>response.getJsonPayload();  if (!isCategoryAvailable(categories, category)) {  error err = error(\"'\" + category + \"' is not a valid category.\");  io:println(err.message());  return err;  }  } else {  return createError(response);  }   // Get a random joke from the provided category  response = checkpanic clientEndpoint->get(\"/random?category=\" + category);  if (response.statusCode == http:STATUS_OK) {  json payload = <json>response.getJsonPayload();  json joke = <json>payload.value;  string replacedText = stringutils:replace(joke.toJsonString(), \"Chuck Norris\", name);  return replacedText;  } else {  return createError(response);  } }   utils.bal  The util functions below are used to validate the categories and construct errors based on the HTTP response.  import ballerina/io; import ballerina/http;  // This function checks if the provided category is a valid one. function isCategoryAvailable(json[] categories, string category) returns boolean {  foreach var cat in categories {  if (cat.toJsonString() == category) {  return true;  }  }  return false; }  // Returns an error based on the HTTP response. function createError(http:Response response) returns error {  error err = error(\"error occurred while sending GET request\");  io:println(err.message(), \", status code: \", response.statusCode);  return err; }   test_utils.bal  The util functions below are used to construct mock responses required for testing.  import ballerina/http;  // Returns a mock HTTP response to be used for the random joke API invocation. function getMockResponse() returns http:Response {  http:Response mockResponse = new;  json mockPayload = {\"value\":\"When Chuck Norris wants an egg, he cracks open a chicken.\"};  mockResponse.setPayload(mockPayload);  return mockResponse; }  // Returns a mock response to be used for the category API invocation. function getCategoriesResponse() returns http:Response {  http:Response categoriesRes = new;  json[] payload = [\"animal\",\"food\",\"history\",\"money\",\"movie\"];  categoriesRes.setJsonPayload(payload);  return categoriesRes; }   Stubbing to Return a Specific Value  main_test.bal  This test stubs the behavior of the get function to return a specific value in 2 ways:    Stubbing to return a specific value in general  Stubbing to return a specific value based on the input   import ballerina/test; import ballerina/http;  @test:Config {} public function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint` object  clientEndpoint = <http:Client>test:mock(http:Client);   // Stub to return the specified mock response when the `get` function is called.  test:prepare(clientEndpoint).when(\"get\").thenReturn(getMockResponse());   // Stub to return the specified mock response when the specified argument is passed.  test:prepare(clientEndpoint).when(\"get\").withArguments(\"/categories\")  .thenReturn(getCategoriesResponse());   // Invoke the function to test.  string result = checkpanic getRandomJoke(\"Sheldon\");   // Verify the return value against the expected string.  test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\"); }   Stubbing with Multiple Values to Return Sequentially for Each Function Call  main_test.bal  This test stubs the behavior of the get function to return a specified sequence of values for each get function  invocation (i.e., the first call to the get function will return the first argument and the second call will return the second  argument).  import ballerina/test; import ballerina/http;  @test:Config {} public function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint` object.  clientEndpoint = <http:Client>test:mock(http:Client);   // Stub to return the corresponding value for each invocation test:prepare(clientEndpoint).when(\"get\")  .thenReturnSequence(getCategoriesResponse(), getMockResponse());   // Invoke the function to test  string result = checkpanic getRandomJoke(\"Sheldon\");   // Verify the return value against the expected string  test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\"); }   Stubbing a Member Variable  main_test.bal  This test shows how to stub a member variable value of the clientEndpoint object.  import ballerina/test; import ballerina/http;  @test:Config {} function testMemberVariable() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint` object.  clientEndpoint = <http:Client>test:mock(http:Client);   // Stub the value of the `url` variable to return the specified string.  test:prepare(clientEndpoint).getMember(\"url\").thenReturn(\"https://foo.com/\");   // Verify if the specified value is set.  test:assertEquals(clientEndpoint.url, \"https://foo.com/\"); }   Stubbing to Do Nothing  If a function has an optional or no return type specified, this function can be mocked to do nothing when writing  test cases.  Example:  main.bal  import ballerina/email; import ballerina/io;  email:SmtpClient smtpClient = new (\"localhost\", \"admin\",\"admin\");  // This function sends out emails to specified email addresses and returns an error if sending failed. function sendNotification(string[] emailIds) returns error? {  email:Email msg = {  'from: \"builder@abc.com\",  subject: \"Error Alert ...\",  to: emailIds,  body: \"\"  };  email:Error? response = smtpClient->send(msg);  if (response is error) { \tio:println(\"error while sending the email: \" + response.message());  return response;  } }  main_test.bal  This test stubs the behavior of the send function to do nothing for testing the sendNotification function.  import ballerina/test; import ballerina/email;  @test:Config {} function testSendNotification() {  string[] emailIds = [\"user1@test.com\", \"user2@test.com\"];   // Create a default mock SMTP client and assign it to the `smtpClient` object.  smtpClient = <email:SmtpClient>test:mock(email:SmtpClient);   // Stub to do nothing when the`send` function is invoked.  test:prepare(smtpClient).when(\"send\").doNothing();   // Invoke the function to test and verify that no error occurred.  test:assertEquals(sendNotification(emailIds), ()); }   Mocking Functions  The Ballerina test framework provides the capability to mock a function. You can easily mock a function in a module that you are testing or a function of an imported module by using the mocking feature. This feature will help you to test your Ballerina code independently from other modules and functions.  The object specified with the @test:Mock {} annotation will be considered as a mock function, which gets triggered in place of the real function.    moduleName : “<moduleName>“ - (optional) Name of the module in which the function to be mocked resides in. If the function is within the same module, this can be left blank or “.” (no module) can be passed. If the function is in a different module but within the same project, just passing the module name will suffice. For functions in completely separate modules, the fully-qualified module name must be passed, which includes the orgName and the version i.e., orgName/module:version. For native functions, the Ballerina module needs to be specified.  functionName : “<functionName>“ - Name of the function to be mocked.  Example:  main.bal  // This function returns the result provided by the `intAdd` function. public function addValues(int a, int b) returns int {  return intAdd(a, b); }  // This function adds two integers and returns the result. public function intAdd(int a, int b) returns int {  return (a + b); }   main_test.bal  This is the initialization of the mock function, which should be called in place of the intAdd function.  import ballerina/test;  @test:Mock { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();   After the initialization, the following options can be used to stub the behaviour of a function written in the  module being tested.  Stubbing to Return a Specific Value  This test stubs the behavior of the get function to return a specific value in 2 ways:    Stubbing to return a specific value in general  Stubbing to return a specific value based on the input   import ballerina/test;  @test:Config {} function testReturn() {  // Stub to return the specified value when the `intAdd` is invoked.  test:when(intAddMockFn).thenReturn(20);  // Stub to return the specified value when the `intAdd` is invoked with the specified arguments.  test:when(intAddMockFn).withArguments(0, 0).thenReturn(-1);  test:assertEquals(addValues(10, 6), 20, msg = \"function mocking failed\");  test:assertEquals(addValues(0, 0), -1, msg = \"function mocking with arguments failed\"); }   Stubbing to Invoke Another Function in Place of the Real  This test stubs the behavior of the intAdd function to substitute it with a user-defined mock function.  import ballerina/test;  @test:Config {} function testCall() {  // Stub to call another function when `intAdd` is called.  test:when(intAddMockFn).call(\"mockIntAdd\");  test:assertEquals(addValues(11, 6), 5, msg = \"function mocking failed\"); }  // The mock function to be used in place of the `intAdd` function public function mockIntAdd(int a, int b) returns int {  return (a - b); }   This test stubs the behaviour of an imported function to substitute it with a user-defined mock function.  @test:Mock {  // This specifies a mock function that should replace the  // imported function `math:sqrt`.  moduleName: \"ballerina/math\",  functionName: \"sqrt\" } test:MockFunction sqrtMockFn = new();  // This is a mock function, which can be called in place of the `math:sqrt` function. function mockSqrt(float val) returns float {  return 125.0; }  @test:Config {} function testCall() {  // This stubs the calls to `math:sqrt` function  // to invoke the specified function.  test:when(sqrtMockFn).call(\"mockSqrt\");  test:assertEquals(math:sqrt(25), 125.0); }   What’s Next?  Now, that you are aware of the details on writing tests, learn the different options that can be used when .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/testing-ballerina-code/testing-quick-start/","name":"Quick Start","summary":"The Ballerina Language has a built-in robust test framework, which allows you to achieve multiple levels of the test pyramid including unit testing, integration testing, and end to end testing.  It provides features such as assertions, data providers, mocking, and code coverage, which enable the programmers to write comprehensive ...","content":"/  /  /  / Quick Start  Quick Start  The Ballerina Language has a built-in robust test framework, which allows you to achieve multiple levels of the test pyramid including unit testing, integration testing, and end to end testing. It provides features such as assertions, data providers, mocking, and code coverage, which enable the programmers to write comprehensive tests.  Table of contents Writing a simple function  To get started, let’s write a simple Ballerina function and test it.    First, let’s create a Ballerina project and add a new module. Use the ballerina new command to create the project. For more information on the command, see .   The standard project will have the structure below.   project-name/  Ballerina.toml src/  module1/ main.bal Module.md  [resources/]  tests/  main_test.bal  [resources] Now, let’s write the function, which handles sending a get request in the main.bal file of the module you just  created.   // main.bal  import ballerina/io;  import ballerina/http;  import ballerina/stringutils;  http:Client clientEndpoint = new(\"https://api.chucknorris.io/jokes/\");  // This function performs a `get` request to the Chuck Norris API and returns a random joke // with the name replaced by the provided name or an error if the API invocation fails.  function getRandomJoke(string name) returns string|error {  http:Response|error result = clientEndpoint->get(\"/random\");  http:Response response = <http:Response>result;  if (response.statusCode == http:STATUS_OK) {  json payload = <json>response.getJsonPayload();  json joke = <json>payload.value;  string replacedText = stringutils:replace(joke.toJsonString(), \"Chuck Norris\", name);  return replacedText;  } else {  error err = error(\"error occurred while sending GET request\");  io:println(err.message(),  \", status code: \", response.statusCode,  \", reason: \", response.getJsonPayload());  return err;  }  }  Now, let’s write a simple test case to verify the behavior of the main function in the main_test.bal file.   // main_test.bal  import ballerina/io;  import ballerina/test;  import ballerina/http;  // This test function tests the behavior of the `getRandomJoke` when  // the API returns a successful response.  @test:Config {}  function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint`  clientEndpoint = test:mock(http:Client);  // Stub the behavior of the `get` function to return the specified mock response.  test:prepare(clientEndpoint).when(\"get\").thenReturn(getMockResponse());  // Invoke the function to test.  string result = checkpanic getRandomJoke(\"Sheldon\");  io:println(result);  // Verify the return value. test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\");  }  // Returns a mock HTTP response to be used for the jokes API invocation.  function getMockResponse() returns http:Response {  http:Response mockResponse = new;  json mockPayload = {\"value\":\"When Chuck Norris wants an egg, he cracks open a chicken.\"};  mockResponse.setPayload(mockPayload);  return mockResponse;  }   Finally, let’s execute the tests using the following command.   $ ballerina test --code-coverage --all   This will print an output similar to the following.   Compiling source  foo/joke:0.1.0  Creating balos  target/balo/joke-2020r2-any-0.1.0.balo  Running Tests with Coverage  foo/joke:0.1.0  When Sheldon wants an egg, he cracks open a chicken.  [pass] testGetRandomJoke  1 passing  0 failing  0 skipped  Generating Test Report  target/test_results.json  View the test report at: file:///home/foo/test/sample-project/target/report/index.html  What’s Next?  Now, that you have an understanding of how a test case can be written and executed, you can dive deep into the available  features in .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/testing-ballerina-code/writing-tests/","name":"Writing Tests","summary":"The sections below include information about writing tests in Ballerina.Table of contents        Unit tests bound to a module need to be placed in a sub folder called tests/ within the module. In a standard\n Ballerina project, a module is mapped to a test suite. All ...","content":"/  /  /  / Writing Tests  Writing Tests  The sections below include information about writing tests in Ballerina.  Table of contents Project Structure  project-name/  Ballerina.toml  src/  module1/  main.bal  Module.md [resources/] tests/ # Module-specific tests  main_test.bal # The test file for main.bal  [resources] # Resources for the tests   Test Source Files  Unit tests bound to a module need to be placed in a sub folder called tests/ within the module. In a standard  Ballerina project, a module is mapped to a test suite. All tests within a module’s tests/ subfolder are considered to be part of the same test suite.  The test source files could have any name. The test functions are just Ballerina functions, which use a special annotation to mark the function as a test. Test functions must be specified with the @test:Config {} annotation and there is no restriction on the test function name.  Test Resources  The resources sub directory found within the tests/ directory is meant to contain any files or resources that are exclusively required for testing. You can access the resource files either using the absolute path or using the path relative to the project root.  Defining a Test  The test module provides the necessary annotations to construct a test suite. Therefore, importing the test module is essential in order to write Ballerina tests.  import ballerina/test;   Once the test module is imported, the following annotation can be used to write a test function.  @test:Config {}  The function specified after the annotation is a test function. This annotation supports the following value fields.    enable: {true|false} - Enable/disable the test. The default value is true.  before: “<function name>“ - Name of the function to be run just before the test is run. The default value is none.  after: “<function name>“ - Name of the function to be run just after the test is run.  dependsOn: [“<function names>”, …] - List of function names on which the test function depends. The  order in  which the comma-separated list appears has no prominence. In case there needs to be an order, define a sequence of test functions with one pointing to another based on the dependencies using the dependsOn parameter in each one’s config to control the order of the test execution.  dataProvider: “<function name>” - Specifies the name of the function that will be used to provide the value  sets to execute the test against.  groups: [“<test group name”, …] - A comma-separated list of test group names (one or more) to which this test  belongs.   Example:  import ballerina/io; import ballerina/test;  function beforeFunc() {  // This is the function, which will be executed before the Test functions. }  function afterFunc() {  // This is the function, which will be executed after the Test functions. }  // This test function will not be executed. @test:Config {  enable: false } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This test function depends on the `testFunction3`. @test:Config{ before: \"beforeFunc\",  after: \"afterFunc\",  dependsOn: [\"testFunction3\"],  dataProvider:\"dataGen\",  groups: [\"g1\"] } function testFunction2 (int value) returns error? {  test:assertEquals(value, 1, msg = \"value is not correct\"); }   function dataGen() returns (int[][]) {  return [[1]]; }  // This is a random test function. This will randomly execute without depending on the other functions. // However, note that `testFunction3` depends on this. @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   Visibility of Symbols  The functions, services, and the global variables defined in a module are accessible from within the test files. Hence, you cannot redefine a symbol in the test files if it is already declared in the module.  On the other hand, symbols defined in the test files will not be visible inside the module source files. When running tests, the symbols in the module source files will be initialized first followed by the ones in the test files.  Using Assertions  The Ballerina test framework supports the following assertions, which help to verify the expected behaviour of a piece of code. These assertions can be used to decide if the test is passing or failing based on the condition.  assertTrue(boolean expression, string message)  Asserts that the expression is true with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertTrue() {  boolean value = false;  test:assertTrue(value, msg = \"AssertTrue failed\"); }   assertFalse(boolean expression, string message)  Asserts that the expression is false with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }   assertEquals(Any actual, Any expected, string message)  Asserts that the actual is equal to the expected with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"IntAdd function failed\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertNotEquals(Any actual, Any expected, string message)  Asserts that the actual is not equal to the expected with an optional message.  Example:  import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertNotEquals(answer, 8, msg = \"Matches\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertFail(string message)  Fails the test. This is useful to fail a test based on a check for a condition while it is in execution.  Example:  import ballerina/test;  @test:Config {} function foo() {  error? e = trap bar(); // Expecting `bar()` to panic  if (e is error) {  test:assertEquals(e.reason(), \"Invalid Operation\", msg = \"Invalid error reason\"); // Some other assertions  } else {  test:assertFail(msg = \"Expected an error\");  } }   Setup and Teardown  The following test annotations can be used for setup and teardown instructions. These annotations enable executing instructions at different levels.  @test:BeforeSuite {}  The function specified after the annotation will be run once before any of the tests in the test suite is run. This can be used for initializing the test suite level aspects.  Example:  import ballerina/io; import ballerina/test;  // The `BeforeSuite` function is executed before running all the test functions in this module. @test:BeforeSuite function beforeFunc() {  io:println(\"I'm the before suite function!\"); }  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // Test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }   @test:BeforeEach {}  The function specified after the annotation will be run before every test within the test suite is run. This can be used for initializing test-level aspects repeatedly before every test function.  Example:  import ballerina/io; import ballerina/test;  // The `BeforeEach` function, which is executed before each test function @test:BeforeEach function beforeFunc() {  io:println(\"I'm the before function!\"); }  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // Test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // Test function. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   @test:AfterSuite {}  The function specified after the annotation will be run once after all of the tests in the test suite is run. This can be used for cleaning up the test suite level aspects. The test suite covers tests related to a module.  Example:  import ballerina/io; import ballerina/test;  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // The `AfterSuite` function is executed after all the test functions in this module. @test:AfterSuite {} function afterFunc() {  io:println(\"I'm the after suite function!\"); }   Test Configurations  Configurations for testing can be provided using the Config API. For information on using the config library, see  .  What’s Next?  As an integration language, you will be using lots of connectors when writing Ballerina code. Setting up mock  backends for these external endpoints will be a tedious task (e.g., email client, Salesforce client).  The mocking support in Ballerina will allow you to unit test your code without needing to set up mock backends by  allowing you to control what the client objects return without actually sending requests to backends.  To learn about the mocking API, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/using-the-cli-tools/","name":"Using the CLI Tools","summary":"The Ballerina Tool is your one-stop-shop for all the things you do in Ballerina.Table of contents        In the CLI, execute the ballerina help command to view all the actions you can perform with it as shown below.You can use the ballerina command in the below ...","content":"/  /  / Using the CLI Tools  Using the CLI Tools  The Ballerina Tool is your one-stop-shop for all the things you do in Ballerina.  Table of contents Using the Ballerina Tool  In the CLI, execute the ballerina help command to view all the actions you can perform with it as shown below.  → ballerina help NAME  The Ballerina build tool  SYNOPSIS  ballerina <-v | --version>  ballerina [command] <-h | --help>  ballerina <command> [<args>]   DESCRIPTION  Ballerina is a statically typed, concurrent programming language, focusing on network interaction and structured data. It is intended to be the core of a language-centric middleware platform. It has all the general-purpose  functionality expected of a modern programming language, but it also has several unusual aspects that make it  particularly suitable for its intended purpose.   Find more information at: https://ballerina.io/   OPTIONS  -v, --version  Print the Ballerina version information.   -h, --help  Print usage details of a command.   BALLERINA COMMANDS  Here is a list of available subcommands:   Core Commands:  build Compile Ballerina program into an executable  run Build and run Ballerina program  test Run module tests  doc Generate API documentation  clean Clean artifacts generated during the build  format Format Ballerina sources   Module Commands:  pull Pull a module from Ballerina Central  push Upload module to the Ballerina Central  search Search Ballerina Central for modules   Project Commands:  new Create a new Ballerina project  add Create a new Ballerina module in a project   Other Commands:  encrypt Encrypt sensitive data  grpc Generate Ballerina sources for the given protobuf definition  openapi Generate Ballerina sources for the given OpenAPI definition and vice versa.  version Print Ballerina version  bindgen Generate Ballerina bindings for Java APIs   Update Commands:  dist Manage Ballerina distributions  update Update the Ballerina Tool   Use 'ballerina help <command>' for more information on a specific command.   You can use the ballerina command in the below format.    ballerina <THE-COMMAND> <ITS-ARGUEMENTS>     Tip: You can view details of any of the commands below by executing ballerina help <COMMAND>. For example, the below is the output of the ballerina help pull command.   → ballerina help pull NAME  ballerina-pull - Fetch modules from Ballerina Central  SYNOPSIS  ballerina pull <org-name>/<module-name>[:<version>]   DESCRIPTION  Pull downloads the specified module from Ballerina Central  along with its dependencies. It then caches this module at  '.ballerina' directory in user home.   Ballerina Central is a module repository hosted at  https://central.ballerina.io/. A module repository organizes modules  into a three-level hierarchy: organization, module name, and version.  Organizations are unique within a repository and can be mapped to an  individual user or organization registered with the repository.   EXAMPLES  Pull the latest version of 'gmail' connector in 'wso2' organization  from Ballerina Central.  $ ballerina pull wso2/gmail   Pull the '1.1.0' version of 'gmail' connector in 'wso2' organization  from Ballerina Central.  $ ballerina pull wso2/gmail:1.1.0   Core Commands  These everyday commands are your best friends! They address the very basics of programming in Ballerina such as compiling, running, testing programs, and generating their documentation.    build Compile a Ballerina program, a single BAL file, an entire project, or a single root module into an executable JAR file.    run Build and run a Ballerina program, a single BAL file, a module, an entire project, or a previously-built program. For more information, see .    test Run tests of a particular module or all the modules of a Ballerina project. For more information, see .    doc Generate API documents for all public symbols of a Ballerina module or project. For more information, see .    clean Clean all artifacts generated by the build command for a project.    format Format Ballerina source files as per the .    Module Commands  These commands allow you to work with the Ballerina Central to share Ballerina modules with others in a safe, secure, and dependable way.    pull Pull a module from Ballerina Central.    push Upload a module to Ballerina Central. For more information, see .    search Search Ballerina Central for modules.     Project Commands  Ballerina projects are the way to organize real-world Ballerina development tasks.    new Create a Ballerina project. For more information, see .    add Create a new Ballerina module in a project. For more information, see .     Other Commands  These powerful supporting tools extend Ballerina to various ecosystem technologies that are inherently cloud-native. This functionality will grow over time and will even be developer extensible in the future.    encrypt Use this tool to encrypt sensitive data and pass them to a Ballerina program via the configuration system.    grpc This is the gRPC stub/skeleton generation tool. For more information, see .   openapi This is the OpenAPI (Swagger) stub/skeleton generation tool. For more information, see .   version Tells you the version of the distribution you are currently using, the language specification version on which it is based, and the update tool version, which is currently in use.   bindgen Use this tool for auto-generating Ballerina bridge code for Java APIs. For more information, see .   help Prints the usage details of any Ballerina command (e.g., `ballerina help pull`).     Update Commands    dist Manage Ballerina distributions. For more information, see .    update Update the Ballerina Tool. For more information, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/using-the-openapi-tools/","name":"Using the OpenAPI Tools","summary":"OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start the development of a service documented in an ...","content":"/  /  / Using the OpenAPI Tools  Using the OpenAPI Tools  OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start the development of a service documented in an OpenAPI contract in Ballerina by generating Ballerina service and client skeletons.  Table of contents Using the Capabilities of the OpenAPI Tools  The OpenAPI tools provide the following capabilities.    Generate the Ballerina Service or Client code for a given OpenAPI definition.  Generate the client stub for an existing Ballerina service at build time.  Export the OpenAPI definition of a Ballerina service.   The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generation. Code generation from OpenAPI to Ballerina can produce ballerina mock services and ballerina client stubs.  For build time client stub generation, annotation support is provided.  Mock Service from OpenAPI  ballerina openapi gen-service <moduleName>:<serviceName> <openapi_contract>  [-c: copy-contract] [-o: outputFile]   Generates a Ballerina service for the OpenAPI file.  This generated service is a mock version of the actual Ballerina service. Generated sources contain the service definition in src/<module-name>/ and the OpenAPI contract that used to generate will be copied to src/<module-name>/resources.  Client Stub from OpenAPI  ballerina openapi gen-client [<moduleName>]:<clientName> <openapi-contract> [-o <dir-path> | --output <dir-path>]   Generates a Ballerina client stub for the service defined in a OpenAPI file.  This client can be used in client applications to call the service defined in the OpenAPI file.  Service to OpenAPI Export  ballerina openapi gen-contract [<moduleName>:]<serviceName> [-i: <ballerinaFile> | --ballerina-file <ballerina-file>] [-o: <openapi-contract> | --output <openapi-contract>] [-s | --skip-bind]   Export the Ballerina service to a definition of OpenApi Specification 3.0. For the export to work properly, the input Ballerina service should be defined using basic service and resource level HTTP annotations.  Client Stub for Service Generates a Ballerina client stub to communicate with a Ballerina service.  All endpoint(s) that are used for client stub generation should be marked with the @openapi:ClientEndpoint annotation. If not, there might be errors during client stub generation. Endpoints that are not marked with this annotation are not picked for client stub generation. The @openapi:ClientConfig { generate: true } annotation is used to enable or disable client stub generation per service.  Samples  Mock Service from OpenAPI Sample ballerina openapi gen-service helloworld:helloService hello_service.yaml   This will generate a Ballerina service, for hello_service.yaml OpenAPI contract, named helloService in the module named helloworld. This command should be executed inside a Ballerina project.  Client Stub from OpenAPI Sample  ballerina openapi gen-client hello_client hello_service.yaml   This will generate a Client named hello_client in a module named client for the service documented in hello_service.yaml. This command should be executed inside a Ballerina project.  OpenAPI from Service Sample  ballerina openapi gen-contract helloworld:helloService -i src/helloworld/helloService.bal   This will generate the OpenAPI contract for the Ballerina service hello which is in hello.bal Ballerina file.  Client Stub from Service Sample  Apply annotation to say that client generation is enabled by adding @openapi:ClientConfig { generate: true } and point the client endpoint to be applied on generation by adding @openapi:ClientEndpoint annotation to the client endpoint.  import ballerina/http; import ballerina/log; import ballerina/openapi;  // Define this endpoint as a selected endpoint for client generation. @openapi:ClientEndpoint listener http:Listener helloEp = new(9090);  // Enable client code generation for this service. @openapi:ClientConfig {  generate: true } @http:ServiceConfig {  basePath: \"/sample\" } service Hello on helloEp { @http:ResourceConfig {  methods: [\"GET\"],  path: \"/hello\"  }  resource function hello(http:Caller caller, http:Request req) {  http:Response res = new;  res.setPayload(\"Hello\");  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error when responding\", err = result);  }  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/1.2/learn/writing-secure-ballerina-code/","name":"Writing Secure Ballerina Code","summary":"The sections below include information on the different security features and controls available within Ballerina. Also, they provide guidelines on writing secure Ballerina programs.Table of contents        This approach makes it unnecessary for developers to review best practice coding lists that itemize how to avoid security ...","content":"/  /  / Writing Secure Ballerina Code  Writing Secure Ballerina Code  The sections below include information on the different security features and controls available within Ballerina. Also, they provide guidelines on writing secure Ballerina programs.  Table of contents Secure by Design  This approach makes it unnecessary for developers to review best practice coding lists that itemize how to avoid security vulnerabilities. The Ballerina compiler ensures that Ballerina programs do not introduce security vulnerabilities.  A taint analysis mechanism is used to achieve this.  Parameters in function calls can be designated as security-sensitive. The compiler will generate an error if you pass untrusted data (tainted data) into a security-sensitive parameter:  tainted value passed to sensitive parameter 'sqlQuery'   We require developers to explicitly mark all values passed into security-sensitive parameters as ‘trusted’. This explicit check forces developers and code reviewers to verify that the values being passed into the parameter are not vulnerable to a security violation.  Ballerina standard library makes sure untrusted data cannot be used with security-sensitive parameters such as SQL queries, file paths, file name, permission flags, request URLs and configuration keys preventing vulnerabilities including:    SQL Injection  Path Manipulation  File Manipulation  Unauthorized File Access  Unvalidated Redirect (Open Redirect)   Ensuring Security of Ballerina Standard Libraries  Security-sensitive functions and remote methods of Ballerina standard libraries are annotated with the @untainted parameter annotation. This denotes that untrusted (tainted) data should not be passed to the parameter.  For example, the sqlQuery parameter of the ballerinax/java.jdbc select remote method is annotated as @untainted.  public remote function select(@untainted string sqlQuery, typedesc<record{}>? recordType, Param... parameters) returns @tainted table<record {}>|Error   The following example constructs an SQL query with a tainted argument:  import ballerinax/java.jdbc;  type ResultStudent record {  string name; };  public function main(string... args) {   jdbc:Client testDB = new({  url: \"jdbc:mysql://localhost:3306/testdb\",  username: \"test\",  password: \"test\",  poolOptions: { maximumPoolSize: 5 },  dbOptions: { useSSL: false }  });   // Construct student ID based on user input.  string studentId = \"S_\" + args[0];   // Execute select query using the untrusted (tainted) student ID  var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" + studentId,  ResultStudent);  testDB.stop(); }   The Ballerina compiler will generate an error:  tainted value passed to sensitive parameter 'sqlQuery'   In order to compile, the program is modified to use query parameters:  jdbc:Parameter paramId = {sqlType:jdbc:TYPE_VARCHAR, value:studentId}; var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = ?\", ResultStudent,  paramId);   Command-line arguments passed to Ballerina programs and inputs received through service resources are considered as tainted. Additionally, return values of certain functions are marked with the @tainted annotation to denote that the resulting value should be considered untrusted data.  For example, the select remote method of the java:jdbc client highlighted above returns a @tainted table<record {}>|Error. This means that any value read from a database is considered untrusted.  When the Ballerina compiler can determine that a function is returning tainted data without tainted data being passed in as parameters to that function, it is required to annotate the function’s return type as @tainted. If not, the function author has to clean up the data before returning it. For instance, if you are to read from the database and return that result, you either need to annotate that function’s return type as @tainted or you have to clean up and make sure the returned data is not tainted.  Securely Using Tainted Data with Security-Sensitive Parameters  There can be certain situations where a tainted value must be passed into a security-sensitive parameter. In such situations, it is essential to do proper data validation or data sanitization to make sure the input does not result in a security threat. Once proper controls are in place, the @untainted annotation can be used with a type cast operator to denote that the value is trusted:  // Execute select query using the untrusted (tainted) student ID boolean isValid = isNumeric(studentId); if (isValid) {  var dt = testDB->select(\"SELECT NAME FROM STUDENT WHERE ID = \" +  <@untainted> studentId, ResultStudent); } // ...   Additionally, return values can be annotated with@untainted. This denotes that the return value should be trusted (even if the return value is derived from tainted data):  // Execute the select query using the untrusted (tainted) student ID function sanitizeSortColumn (string columnName) returns @untainted string {  string sanitizedSortColumn = columnName;  // Insert sanitization logic to ensure that the return value is safe.  return sanitizedSortColumn; } // ...   Securing Passwords and Secrets  Ballerina provides an API to access configuration values from different sources. For more information, see .  Configuration values containing passwords or secrets should be encrypted. The Ballerina Config API will decrypt such configuration values when being accessed.  Use the following command to encrypt a configuration value:  $ ballerina encrypt   The encrypt command will prompt for the plain-text value to be encrypted and an encryption secret.  $ ballerina encrypt Enter value: Enter secret: Re-enter secret to verify: Add the following to the configuration file: <key>=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\"  Or provide it as a command line argument: --<key>=@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}   Ballerina uses AES, CBC mode with PKCS#5 padding for encryption. The generated encrypted value should be used in place of the plain-text configuration value.  For example, contents of a configuration file that includes a secret value should look as follows:  api.secret=\"@encrypted:{hcBLnR+b4iaGS9PEtCMSQOUXJQTQo+zknNxCkpZ0t7w=}\" api.provider=\"not-a-security-sensitive-value\"   When running a Ballerina program that uses encrypted configuration values, Ballerina will require the secret used during the encryption process to perform the decryption.  Ballerina will first look for a file named secret.txt. If such a file exists, Ballerina will read the decryption secret from the file and immediately remove the file to make sure the secret cannot be accessed afterward. If the secret file is not present, the Ballerina program will prompt for the decryption secret.  The file based approach is useful in automated deployments. The file containing the decryption secret can be deployed along with the Ballerina program. The name and the path of the secret file can be configured using the ballerina.config.secret runtime parameter:  $ ballerina run --b7a.config.secret=path/to/secret/file securing_configuration_values.bal   Authentication and Authorization  Inbound Authentication and Authorization  Ballerina HTTP services can be configured to enforce authentication and authorization. Ballerina has built-in support for the following inbound authentication mechanisms whereas it is possible to add custom mechanisms:    Basic authentication  JWT authentication  OAuth2 authentication  LDAP authentication   Ballerina inbound authentication is abstracted out into 2 layers called http:InboundAuthHandler and auth:InboundAuthProvider.  The auth:InboundAuthProvider is a protocol-independent entity that only knows how to authenticate a user when the necessary information is provided. The http:InboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well.  The http:InboundAuthHandler is used to perform HTTP-level actions, which are extracting the required HTTP header or body, extracting the credentials out of it, passing them into the associated auth:InboundAuthProvider, and getting the credentials validated. The auth:InboundAuthProvider is used to validate the credentials passed by the http:InboundAuthHandler.  In a particular authentication scheme, the implemented instance of the auth:InboundAuthProvider is initialized with the required configurations and it is passed to the implemented instance of the http:InboundAuthHandler.  Next, the implemented instance of the http:InboundAuthHandler is passed to the http:Listener configuration as follows, and the listener is initialized with authentication.  The following example represents how a listener is secured with Basic Auth with the above-mentioned configurations.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }     Note: It is a must to use HTTPS when enforcing authentication and authorization checks, to ensure the confidentiality of sensitive authentication data.   Optionally, the scopes attribute is configured for the authorization as follows. If it is not specified, that means the service is authorized for any authenticated user.  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  scopes: [\"test-scope\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Inbound Advanced Use Cases  Using Multiple Auth Handlers  The authHandlers can be configured for advanced use cases, which use multiple auth handlers as follows:  Case 1: Auth should be successful for authHandler1 OR authHandler1. authHandlers: [authHandler1, authHandler2]  Case 2: Auth should be successful for authHandler1 AND authHandler12. authHandlers: [[authHandler1], [authHandler2]]  Case 3: Auth should be successful for ((authHandler1 OR authHandler2) AND (authHandler3 OR authHandler4)). authHandlers: [[authHandler1, authHandler2], [authHandler3, authHandler4]]  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler1, authHandler2]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Using Multiple Scopes  The scopes can be configured for advanced use cases as follows:  Case 1: Auth should be successful for scope-1 OR scope-2. scopes: [\"scopes-1\", \"scopes-2\"]  Case 2: Auth should be successful for scope-1 AND scope-2. scopes: [[\"scopes-1\"], [\"scopes-2\"]]  Case 3: Auth should be successful for ((scope-1 OR scope-2) AND (scope-3 OR scope-4)). scopes: [[\"scopes-1\", \"scopes-2\"], [\"scopes-3\", \"scopes-4\"]]  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  scopes: [\"scopes-1\", \"scopes-2\"]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   Per-Resource and Per-Service Customization  The security enforcements can be customized by the @http:ServiceConfig annotation and the @http:ResourceConfig annotation.  For example, authentication and authorization can be modified for a particular service as follows by configuring the auth attribute of the @http:ServiceConfig.   Authentication can be disabled only for a particular service by using the enabled attribute  The authentication mechanism can be changed for a particular service by using the authHandlers attribute  Authorization scopes can be changed for a particular service by using the scopes attribute   @http:ServiceConfig {  basePath: \"/hello\",  auth: {  enabled: false,  authHandlers: [authHandlerA],  scopes: [\"scope-A\"]  } } service helloWorld on secureHelloWorldEp { // ... }   Further, authentication and authorization can be modified for a particular resource as follows by configuring the auth attribute of the @http:ResourceConfig:  @http:ResourceConfig {  basePath: \"/\",  auth: {  enabled: false,  authHandlers: [authHandlerA],  scopes: [\"scope-A\"]  } } resource function sayHello (http:Caller caller, http:Request req) { // ... }   The same configuration patterns used for the listener-level configurations are applied for authHandlers and the scopes attributes in service-level configurations and resource-level configurations.  Implementing Inbound Custom Authentication Mechanism  The user can implement a custom version of AuthHandler and AuthProvider with the use of the object-equivalency pattern as follows. With that, the http:Listener can be enforced with custom authentication and authorization mechanisms.  public type InboundCustomAuthHandler object {   *http:InboundAuthHandler;   public function canProcess(http:Request req) returns @tainted boolean {  // Custom logic to check whether the request can be processed.  }  public function process(http:Request req) returns boolean|http:AuthenticationError {  // Custom logic to process the request, extract the credentials, and get them validated from the AuthProvider.  } };   public type InboundCustomAuthProvider object {   *auth:InboundAuthProvider;   public function authenticate(string credential) returns boolean|auth:Error {  // Custom logic to authenticate the given credentials.  } };   Disable HTTPS Enforcement  The enforcement of HTTPS can be disabled by configuring the value mandateSecureSocket into false as follows:  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  mandateSecureSocket: false  } }); service helloWorld on secureHelloWorldEp { // .... }   Modify Authorization or Authentication Filter Index  The authn/authz filters are engaged as the top most filters of the filter array, which is configured in the HTTP listener configuration. The uer can configure the index of the authn/authz filters if it is needed to engage a custom filter before the authn/authz filters.  The position attribute represents the authn/authz filter position of the filter array. The position values starts from 0 and it is set to 0 implicitly.  The following example engages the authn/authz filters in between the customFilter1 and customFilter2. Then, the internally-updated filter chain would be [customFilter1, authnFilter, authzFilter, customFilter2].  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [authHandler],  position: 1  },  filters: [customFilter1, customFilter2],  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); service helloWorld on secureHelloWorldEp { // .... }   JWT Inbound Authentication and Authorization  Ballerina supports JWT Authentication and Authorization for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value which is Bearer <token>. Then the extracted credential will be passed to the initialized AuthProvider and validated. The jwt:InboundJwtAuthProvider is used to validate the credentials (JWT) passed by the AuthHandler against the jwt:JwtValidatorConfig provided by the user.  JWT validation requires several additional configurations for the jwt:JwtValidatorConfig including:    issuer - The issuer of the JWT  audience - The audience value for the current service  clockSkewInSeconds - Clock skew in seconds that can be used to avoid token validation failures due to clock synchronization problems  trustStoreConfig - JWT trust store configurations  trustStore - Trust store used for signature verification  certificateAlias - Token-signed public key certificate alias  jwtCache - Cache used to store parsed JWT information as CachedJwt   The jwt:JwtValidatorConfig record should be provided into the jwt:InboundJwtAuthProvider when initializing. The initialized jwt:InboundJwtAuthProvider is passed to the `http:BearerAuthHandler.    Note: For demonstration purposes, the ballerinaTruststore.p12 included with Ballerina runtime is used. In a production deployment, the truststore should only contain the public key certificates of the trusted JWT issuers.   import ballerina/http; import ballerina/jwt; import ballerina/config;  jwt:InboundJwtAuthProvider jwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  trustStoreConfig: {  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [jwtAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\",  auth:{  scopes:[\"hello\"],  enabled: true  }  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   If a request is made with a valid, signed JWT but without the expected scope, an authorization failure will occur. An example of a JWT without the scope attribute is as follows.  {  \"sub\": \"ballerina\",  \"iss\": \"ballerina\",  \"exp\": 2818415019,  \"iat\": 1524575019,  \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\",  \"aud\": [  \"ballerina\",  \"Ballerina.org\",  \"ballerina.io\"  ] }   curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5yWQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJ pbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwian RpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiY mFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdfQ.X2mHWCr8A5UaJFvjSPUammACnTzFsTdre-P5y WQgrwLBmfcpr9JaUuq4sEwp6to3xSKN7u9QKqRLuWH1SlcphDQn6kdF1ZrCgXRQ0HQTilZQU1hllZ4c 7yMNtMgMIaPgEBrStLX1Ufr6LpDkTA4VeaPCSqstHt9WbRzIoPQ1fCxjvHBP17ShiGPRza9p_Z4t897 s40aQMKbKLqLQ8rEaYAcsoRBXYyUhb_PRS-YZtIdo7iVmkMVFjYjHvmYbpYhNo57Z1Y5dNa8h8-4ON4 CXzcJ1RzuyuFVz1a3YL3gWTsiliVmno7vKyRo8utirDRIPi0dPJPuWi2uMtJkqdkpzJQ >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request with a correct “scope” attribute will result in a successful invocation. An example of a JWT that has the correct “scope” attribute is as follows.  {  \"sub\": \"ballerina\",  \"iss\": \"ballerina\",  \"exp\": 2818415019,  \"iat\": 1524575019,  \"jti\": \"f5aded50585c46f2b8ca233d0c2a3c9d\",  \"aud\": [  \"ballerina\",  \"ballerina.org\",  \"ballerina.io\"  ],  \"scope\": \"hello\" }   curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZXJpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwianRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwiYmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BYCbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2ey_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2-mAEcstgiHVw'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJiYWxsZX JpbmEiLCJpc3MiOiJiYWxsZXJpbmEiLCJleHAiOjI4MTg0MTUwMTksImlhdCI6MTUyNDU3NTAxOSwia nRpIjoiZjVhZGVkNTA1ODVjNDZmMmI4Y2EyMzNkMGMyYTNjOWQiLCJhdWQiOlsiYmFsbGVyaW5hIiwi YmFsbGVyaW5hLm9yZyIsImJhbGxlcmluYS5pbyJdLCJzY29wZSI6ImhlbGxvIn0.bNoqz9_DzgeKSK6 ru3DnKL7NiNbY32ksXPYrh6Jp0_O3ST7WfXMs9WVkx6Q2TiYukMAGrnMUFrJnrJvZwC3glAmRBrl4BY CbQ0c5mCbgM9qhhCjC1tBA50rjtLAtRW-JTRpCKS0B9_EmlVKfvXPKDLIpM5hnfhOin1R3lJCPspJ2e y_Ho6fDhsKE3DZgssvgPgI9PBItnkipQ3CqqXWhV-RFBkVBEGPDYXTUVGbXhdNOBSwKw5ZoVJrCUiNG 5XD0K4sgN9udVTi3EMKNMnVQaq399k6RYPAy3vIhByS6QZtRjOG8X93WJw-9GLiHvcabuid80lnrs2- mAEcstgiHVw >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   OAuth2 Inbound Authentication and Authorization  Ballerina supports OAuth2 Authentication and Authorization for services. The http:BearerAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is the Bearer <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get them validated. The oauth2:InboundOAuth2Provider is used to validate the credentials passed by the AuthHandler against the introspection endpoint configured at oauth2:IntrospectionServerConfig, which is provided by the user.  OAuth2 token validation requires several additional configurations for the oauth2:IntrospectionServerConfig including:    url - URL of the introspection server  tokenTypeHint - A hint about the type of the token submitted for introspection  clientConfig - HTTP client configurations, which calls the introspection server   The oauth2:IntrospectionServerConfig record should be provided into the oauth2:InboundOAuth2Provider when initializing and the initialized oauth2:InboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:InboundOAuth2Provider oauth2Provider = new({  url: \"https://localhost:9196/oauth2/token/introspect\",  tokenTypeHint: \"access_token\" }); http:BearerAuthHandler oauth2Handler = new(oauth2Provider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [oauth2Handler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\" } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   Although a request is made with valid authentication information, if the introspection endpoint does not respond either with the scope attribute of the response JSON payload or with an unexpected scope attribute, an authorization failure will occur.  curl -k -v https://localhost:9091/hello -H \"Authorization:Bearer <token>\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request, which gets a successful response from the introspection endpoint with a correct “scope” attribute will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   LDAP Inbound Authentication and Authorization  Ballerina supports LDAP Authentication and Authorization for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credentials from the header value, which is Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider to get validated. The ldap:InboundLdapAuthProvider is used to validate the credentials passed by the AuthHandler against the LDAP server configured at ldap:LdapConnectionConfig, which is provided by the user.  LDAP token validation requires several additional configurations for the ldap:LdapConnectionConfig including:    domainName - Unique name to identify the user store  connectionURL - Connection URL to the LDAP server  connectionName - The username to connect to the LDAP server  connectionPassword - Password for the ConnectionName user  userSearchBase - DN of the context or object under which the user entries are stored in the LDAP server  userEntryObjectClass - Object class used to construct user entries  userNameAttribute - The attribute used for uniquely identifying a user entry  userNameSearchFilter - Filtering criteria used to search for a particular user entry  userNameListFilter - Filtering criteria for searching user entries in the LDAP server  groupSearchBase - DN of the context or object under which the group entries are stored in the LDAP server  groupEntryObjectClass - Object class used to construct group entries  groupNameAttribute - The attribute used for uniquely identifying a group entry  groupNameSearchFilter - Filtering criteria used to search for a particular group entry  groupNameListFilter - Filtering criteria for searching group entries in the LDAP server  membershipAttribute - Define the attribute that contains the distinguished names (DN) of user objects that are in a group  userRolesCacheEnabled - To indicate whether to cache the role list of a user  connectionPoolingEnabled - Define whether LDAP connection pooling is enabled  connectionTimeoutInMillis - Timeout in making the initial LDAP connection  readTimeoutInMillis - Read timeout in milliseconds for LDAP operations  retryAttempts - Retry the authentication request if a timeout happened  secureClientSocket - The SSL configurations for the LDAP client socket. This needs to be configured in order to communicate through LDAPs   The ldap:LdapConnectionConfig record should be provided into the ldap:InboundLdapAuthProvider when initializing and the initialized ldap:InboundLdapAuthProvider is passed to the http:BasicAuthHandler.  import ballerina/http; import ballerina/ldap; import ballerina/config;  ldap:LdapConnectionConfig ldapConfig = {  domainName: \"ballerina.io\",  connectionURL: \"ldap://localhost:20100\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeoutInMillis: 5000,  readTimeoutInMillis: 60000,  retryAttempts: 3 }; ldap:InboundLdapAuthProvider ldapAuthProvider = new(ldapConfig, \"ldap01\"); http:BasicAuthHandler ldapAuthHandler = new(ldapAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [ldapAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur:  curl -k -v https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-type: text/plain < Authentication failure   If a request is made with valid authentication information but the LDAP server responds with an empty group list or unexpected scopes, an authorization failure will occur.  curl -k -v https://localhost:9091/hello -H \"Authorization: Basic <token>\"  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization:Bearer <token> >  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   A request, which gets a successful response from the LDAP server for the “scope” request will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Basic <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> >  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!   Basic Auth Inbound Authentication and Authorization  Ballerina supports Basic Authentication and Authorization for services. The http:BasicAuthHandler is used to extract the HTTP Authorization header from the request and extract the credential from the header value, which is the Basic <token>. Then, the extracted credentials will be passed to the initialized AuthProvider and gets validated. The jwt:InboundBasicAuthProvider is used to read the user information from the configuration file and authenticate the credentials passed by the AuthHandler.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider basicAuthProvider = new; http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [basicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Hello, World!\");  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, users and scopes should be configured through a configuration file. The following example file introduces two users. The generalUser has no scopes and the admin user has the hello scope.  sample-users.toml [b7a.users]  [b7a.users.generalUser] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\"  [b7a.users.admin] password=\"@encrypted:{pIQrB9YfCQK1eIWH5d6UaZXA3zr+60JxSBcpa2PY7a8=}\" scopes=\"hello\"   Restart the service using the following command.  ballerina run --config sample-users.toml basic_auth_sample.bal   Since passwords are encrypted, the Config API will request the decryption key. Use ballerina as the decryption key in this sample.  Also, the passwords can be hashed and provided with the configuration file. The following example file introduces three users along with the passwords hashed with sha256, sha384, and sha512 hashing algorithms.  sample-users.toml [b7a.users]  [b7a.users.userA] password=\"@sha256:{cd2eb0837c9b4c962c22d2ff8b5441b7b45805887f051d39bf133b583baf6860}\"  [b7a.users.userB] password=\"@sha384:{1249e15f035ed34786a328d9fdb2689ab24f7c7b253d1b7f66ed92a679d663dd502d7beda59973e8c91a728b929fc8cd}\"  [b7a.users.userC] password=\"@sha512:{9057ff1aa9509b2a0af624d687461d2bbeb07e2f37d953b1ce4a9dc921a7f19c45dc35d7c5363b373792add57d0d7dc41596e1c585d6ef7844cdf8ae87af443f}\"   Once the service is restarted with the first configuration file in place, the generalUser will not be able to invoke the service due to authorization failure:  curl -k -v -u generalUser:password https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */*  < HTTP/1.1 403 Forbidden < content-type: text/plain < Authorization failure   ‘Admin’ users will be able to invoke the service:  curl -k -v -u admin:password https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < Hello, World!     Outbound Authentication and Authorization  The Ballerina HTTP client can be configured to send authentication and authorization information to the endpoint being invoked. Ballerina has built-in support for the following outbound authentication mechanisms, whereas it is possible to add custom mechanisms:    Basic authentication  JWT authentication  OAuth2 authentication   Ballerina outbound authentication is also abstracted out into 2 layers called http:OutboundAuthHandler and auth:OutboundAuthProvider.  The auth:OutboundAuthProvider is a protocol-independent entity, which only knows how to generate credentials with the necessary information provided by the user. The http:OutboundAuthHandler can be protocol dependent. Even-though the current focus is on HTTP, the ballerina/auth module can operate with other protocols as well.  The auth:OutboundAuthProvider is used to create the credentials according to the provided configurations. The http:OutboundAuthHandler is used to get the created credentials from the auth:OutboundAuthProvider and perform HTTP-level actions, which are adding the required HTTP headers or body using the received credentials.  In a particular authentication scheme, the implemented instance of the auth:OutboundAuthProvider is initialized with required configurations and it is passed to the implemented instance of the http:OutboundAuthHandler.  Next, the implemented instance of the http:OutboundAuthHandler is passed to the http:Client configuration as follows, and the client is initialized with authentication.  The following example represents how a client is secured with Basic Auth with the above-mentioned configurations.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:OutboundBasicProvider basicAuthProvider = new({  username: \"user\",  password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  http:Client secureHelloWorldClient = new(\"https://localhost:9092\", {  auth: {  authHandler: basicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });     Note: It is better to use HTTPS when enforcing authentication and authorization checks to ensure the confidentiality of sensitive authentication data.   Outbound Advanced Use Cases  Implementing Outbound Custom Authentication Mechanism  The user can implement a custom version of the AuthHandler and AuthProvider with the use of the object equivalency pattern as follows. With that, the http:Client can be enforced with custom authentication and authorization mechanisms.  public type OutboundCustomAuthHandler object {   *http:OutboundAuthHandler;   public function prepare(http:Request req) returns http:Request|http:AuthenticationError {  // Custom logic to prepare the request.  }   public function inspect(http:Request req, http:Response resp) returns http:Request|http:AuthenticationError? {  // Custom logic to inspect the request after the initial outbound call.  } };   public type OutboundCustomAuthProvider object {   *auth:OutboundAuthProvider;   public function generateToken() returns string|auth:Error {  // Custom logic to generate the token. }   public function inspect(map<anydata> data) returns string|auth:Error? {  // Custom logic to inspect the data map received from the AuthHandler. } };   JWT Outbound Authentication  Ballerina supports JWT Authentication for clients. The jwt:OutboundJwtAuthProvider is used to issue a JWT against the jwt:JwtIssuerConfig provided by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>.  JWT issuing requires several additional configurations for the jwt:JwtIssuerConfig including:    username - JWT token username  issuer - JWT token issuer  audience - JWT token audience  customClaims - Map of custom claims  expTime - JWT token expiry time  keyStoreConfig - JWT key store configurations  keyStore - Keystore to be used in JWT signing  keyAlias - Signing key alias  keyPassword - Signing key password  signingAlg - JWT signing algorithm  jwt:RS256 - The RSA-SHA256 algorithm  jwt:RS384 - The RSA-SHA384 algorithm  jwt:RS512 - The RSA-SHA512 algorithm  jwt:NONE - Unsecured JWTs (no signing)  Thejwt:JwtIssuerConfig record should be provided into the jwt:OutboundJwtAuthProvider when initializing and the initialized jwt:OutboundJwtAuthProvider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/jwt; import ballerina/config;  jwt:OutboundJwtAuthProvider jwtAuthProvider = new({  username: \"ballerinaUser\",  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler jwtAuthHandler = new(jwtAuthProvider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: jwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   The http:Client defined in the program calls the the http:Listener, which is secured with JWT authentication (For more information, see the example added under JWT inbound authentication).  OAuth2 Outbound Authentication  Ballerina supports OAuth2 Authentication for clients. It supports the Client Credentials grant type, Password grant type, and Direct Token mode, in which, the credentials can be provided manually and after that refreshing is handled internally.  The oauth2:OutboundOAuth2Provider is used to create a token against the configuration provided by the user. It can be the oauth2:ClientCredentialsGrantConfig, oauth2:PasswordGrantConfig, or oauth2:DirectTokenConfig according to the grant type that is required by the user. The http:BearerAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Bearer <token>.  Client Credentials Grant Type  OAuth2 token issuing requires several additional configurations for the oauth2:ClientCredentialsGrantConfig including:    tokenUrl - Token URL for the authorization endpoint  clientId - Client ID for the client credentials grant authentication  clientSecret - Client secret for the client credentials grant authentication  scopes - Scope of the access request  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER | NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations,which calls the authorization endpoint   The oauth2:ClientCredentialsGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  tokenUrl: \"https://localhost:9196/oauth2/token/authorize\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"] }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Password Grant Type  OAuth2 token issuing requires several additional configurations for the oauth2:PasswordGrantConfig including:    tokenUrl - Token URL for the authorization endpoint  username - Username for password grant authentication  password - Password for password grant authentication  clientId - Client ID for password grant authentication  clientSecret - Client secret for password grant authentication  scopes - Scope of the access request  refreshConfig - Configurations for refreshing the access token  refreshUrl - Refresh token URL for the refresh token server  scopes - Scope of the access request  credentialBearer - How authentication credentials are sent to the authorization endpoint  clientConfig - HTTP client configurations, which calls the authorization endpoint  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER|NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which calls the authorization endpoint   The oauth2:PasswordGrantConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2; import ballerina/config;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  tokenUrl: \"https://localhost:9196/oauth2/token/authorize\",  username: \"johndoe\",  password: \"A3ddj3w\",  clientId: \"3MVG9YDQS5WtC11paU2WcQjBB3L5w4gz52uriT8ksZ3nUVjKvrfQMrU4uvZohTftxStwNEW4cfStBEGRxRL68\",  clientSecret: \"9205371918321623741\",  scopes: [\"token-scope1\", \"token-scope2\"],  refreshConfig: {  refreshUrl: \"https://localhost:9196/oauth2/token/refresh\",  scopes: [\"token-scope1\", \"token-scope2\"]  } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Direct Token Mode  OAuth2 token issuing requires several additional configurations for the oauth2:DirectTokenConfig including:    accessToken - Access token for the authorization endpoint  refreshConfig - Configurations for refreshing the access token  refreshUrl - Refresh token URL for the refresh token server  refreshToken - Refresh token for the refresh token server  clientId - Client ID for authentication with the authorization endpoint  clientSecret - Client secret for authentication with the authorization endpoint  scopes - Scope of the access request  credentialBearer - How authentication credentials are sent to the authorization endpoint  clientConfig - HTTP client configurations, which calls the authorization endpoint  clockSkewInSeconds - Clock skew in seconds  retryRequest - Retry the request if the initial request returns a 401 response  credentialBearer - How authentication credentials are sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER|NO_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  The oauth2:DirectTokenConfig record should be provided into the oauth2:OutboundOAuth2Provider when initializing and the initialized oauth2:OutboundOAuth2Provider is passed to the http:BearerAuthHandler.  import ballerina/http; import ballerina/oauth2;  oauth2:OutboundOAuth2Provider oauth2Provider = new({  accessToken: \"34060588-dd4e-36a5-ad93-440cc77a1cfb\",  refreshConfig: {  refreshToken: \"15160398-ae07-71b1-aea1-411ece712e59\",  refreshUrl: \"https://ballerina.io/sample/refresh\",  clientId: \"rgfKVdnMQnJSSr_pKFTxj3apiwYa\",  clientSecret: \"BRebJ0aqfclQB9v7yZwhj0JfW0ga\"  } }); http:BearerAuthHandler oauth2AuthHandler = new(oauth2Provider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: oauth2AuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Basic Auth Outbound Authentication  Ballerina supports Basic Authentication for clients. The auth:OutboundBasicAuthProvider is used to create a token against the auth:Credential provided by the user. The http:BasicAuthHandler is used to add the HTTP Authorization header with the value received from the AuthProvider as the Basic <token>.  Token issuing requires several additional configurations for the auth:Credential config including:    username - The username for Basic authentication  password - The password for Basic authentication   The auth:Credential record should be provided into the auth:OutboundBasicAuthProvider when initializing and the initialized auth:OutboundBasicAuthProvider is passed to the http:BasicAuthHandler.  import ballerina/auth; import ballerina/http; import ballerina/config;  auth:OutboundBasicProvider basicAuthProvider = new({  username: \"user\",  password: \"ballerina\" }); http:BasicAuthHandler basicAuthHandler = new(basicAuthProvider);  http:Client downstreamServiceEP = new(\"https://localhost:9091\", {  auth: {  authHandler: basicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });   Token Propagation for Outbound Authentication  Ballerina supports token propagation for outbound authentication. The token propagation happens if the user does not provide any configuration when initializing the auth:OutboundAuthProvider.  The auth:OutboundAuthProvider reads the token/username from the runtime:InvocationContext according to the outbound authentication scheme and uses that for the outbound request. The runtime:InvocationContext is initialized based on the authentication information from the inbound request.  Example One  The following program has an http:Client secured with Basic authentication and it is configured inside an http:Listener secured with Basic authentication. The auth:OutboundBasicAuthProvider is initialized without providing any configurations. Therefore, the program gets the token from the runtime:InvocationContext and uses it for the outbound request. If the downstream service is also secured with Basic authentication and as same as the upstream service, the user does not need to configure the client.    Note: This scenario is the same for all the scenarios in which both the upstream and downstream services are secured using the same authentication scheme and clients are also configured using the same authentication scheme but without any configurations. The token propagation happens internally.   import ballerina/auth; import ballerina/http; import ballerina/config;  auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  auth:OutboundBasicAuthProvider outboundBasicAuthProvider = new; http:BasicAuthHandler outboundBasicAuthHandler = new(outboundBasicAuthProvider);  http:Client downstreamClientEP = new(\"https://localhost:9092\", {  auth: {  authHandler: outboundBasicAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) returns error? {  // http:Request req = new;  http:Response response = check downstreamClientEP->get(\"/downstream\");  checkpanic caller->respond(response);  } }  // ---------------------------------------------- // Following code creates the downstream service // ----------------------------------------------  listener http:Listener downstreamServiceEp = new(9092, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/downstream\" } service downStreamService on downstreamServiceEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function downStreamResource(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\"));  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, create a configuration file as follows:  sample-users.toml [b7a.users]  [b7a.users.tom] password=\"123\" scopes=\"hello\"   Start the service using the following command after creating the sample-users.toml file.  ballerina run --config sample-users.toml example.bal   The Tom user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service.  curl -k -v -u tom:123 https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Basic dG9tOjEyMw==   Example Two  The following program has an http:Client secured with JWT authentication and it is configured inside an http:Listener secured with Basic Authentication. The jwt:OutboundJwtAuthProvider is initialized using the provides configurations but without the username. Therefore, the program gets the username from the runtime:InvocationContext, which is set based on the inbound authentication information and uses it for the outbound request. In this example, the downstream service is secured using JWT authentication and expects a JWT issued against the user authenticating by the upstream service (protected by Basic authentication). Ballerina can dynamically issue such JWT while propagating the user information internally.  import ballerina/auth; import ballerina/http; import ballerina/jwt; import ballerina/config;  auth:InboundBasicAuthProvider inboundBasicAuthProvider = new; http:BasicAuthHandler inboundBasicAuthHandler = new(inboundBasicAuthProvider);  listener http:Listener secureHelloWorldEp = new(9091, {  auth: {  authHandlers: [inboundBasicAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  jwt:OutboundJwtAuthProvider outboundJwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  keyStoreConfig: {  keyAlias: \"ballerina\",  keyPassword: \"ballerina\",  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } }); http:BearerAuthHandler outboundJwtAuthHandler = new(outboundJwtAuthProvider);  http:Client downstreamClientEP = new(\"https://localhost:9092\", {  auth: {  authHandler: outboundJwtAuthHandler  },  secureSocket: {  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/hello\",  auth: {  scopes: [\"hello\"]  } } service helloWorld on secureHelloWorldEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function sayHello(http:Caller caller, http:Request req) returns error? {  // http:Request req = new;  http:Response response = check downstreamClientEP->get(\"/downstream\");  checkpanic caller->respond(response);  } }  // ---------------------------------------------- // Following code creates the downstream service // ----------------------------------------------  jwt:InboundJwtAuthProvider inboundJwtAuthProvider = new({  issuer: \"ballerina\",  audience: [\"ballerina.io\"],  certificateAlias: \"ballerina\",  trustStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaTruststore.p12\",  password: \"ballerina\"  } }); http:BearerAuthHandler inboundJwtAuthHandler = new(inboundJwtAuthProvider);  listener http:Listener downstreamServiceEp = new(9092, {  auth: {  authHandlers: [inboundJwtAuthHandler]  },  secureSocket: {  keyStore: {  path: config:getAsString(\"b7a.home\") + \"/bre/security/ballerinaKeystore.p12\",  password: \"ballerina\"  }  } });  @http:ServiceConfig {  basePath: \"/downstream\" } service downStreamService on downstreamServiceEp {   @http:ResourceConfig {  methods: [\"GET\"],  path: \"/\"  }  resource function downStreamResource(http:Caller caller, http:Request req) {  http:Response resp = new;  resp.setTextPayload(\"Downstream service received authenticated request with the token: \" + req.getHeader(\"Authorization\"));  checkpanic caller->respond(resp);  } }   To enforce Basic Authentication, create a configuration file as follows:  sample-users.toml [b7a.users]  [b7a.users.tom] password=\"123\" scopes=\"hello\"   Start the service using the following command after creating the sample-users.toml file.  ballerina run --config sample-users.toml example.bal   The ‘Tom’ user will be able to invoke the /hello resource and invoke the Basic Auth protected downstream service.  curl -k -v -u tom:123 https://localhost:9091/hello  > GET /hello HTTP/1.1 > Host: localhost:9091 > Authorization: Basic dG9tOjEyMw== > User-Agent: curl/7.60.0 > Accept: */*  < HTTP/1.1 200 OK < content-type: text/plain < content-length: 602 < Downstream service received authenticated request with the token: Bearer eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QifQ==.eyJzdWIiOiJ0b20iLCAiaXNzIjoiYmFsbGVyaW5hIiwgImV4cCI6MTU2NTUwMzUzNywgImlhdCI6MTU2NTUwMzIzNywgImp0aSI6ImJhMjczNTM5LTcxZWItNDExOC04MzNiLTQyNDlhMjY0MmZmNCIsICJhdWQiOlsiYmFsbGVyaW5hLmlvIl19.OwMHPrQfjpIujHSAIq3ycKsP4SYTR2nW9lBHXBOgIZV6-FcM1Lxz8xtjY1AwcIAd_L4XmiODN_5HYUluZb3jDj1F6ZeI4FQeTKygiGgJs_nTww56bHFQXPe9_IW1zxRGM8G51cJBKxTH6YsOTXgNVhcGoe5f-kaESmGze-XLCnCXgj0GYnG2ECnejSHRh89gjWMyfyMFRDhioPi9IYZEQGIFBQzrModFWXNKQZh5vxaF5KW4KWXLTRgrBX8uY2IIS6S80nf83oaUlrrApieaGf88cwSqOjGjaPpxj3I810qGa996ZVE3P5DkzgxrJYHrJMwcVgBX7sgDFUUcD3RrEA==    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/code-of-conduct.html","name":"The Ballerina Contributor Covenant Code of Conduct","summary":"This code of conduct aims at establishing a baseline standard of behavior to provide a safe and comfortable environment for all members of the Ballerina community who are originated from different backgrounds.Table of contents            We as members, contributors, and leaders pledge ...","content":"/ The Ballerina Contributor Covenant Code of Conduct  The Ballerina Contributor Covenant Code of Conduct  This code of conduct aims at establishing a baseline standard of behavior to provide a safe and comfortable environment for all members of the Ballerina community who are originated from different backgrounds.  Table of contents Our pledge  We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.  We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.  Our standards  Examples of behavior that contributes to creating a positive environment for the Ballerina community include:    Demonstrating empathy and kindness toward other people  Being respectful of differing opinions, viewpoints, and experiences  Giving and gracefully accepting constructive feedback  Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience  Focusing on what is best not just for us as individuals, but for the overall community   Examples of unacceptable behavior by participants include:    The use of sexualized language or imagery, and sexual attention or advances of any kind  Trolling, insulting or derogatory comments, and personal or political attacks  Public or private harassment  Publishing others’ private information, such as a physical or email address, without their explicit permission  Other conduct, which could reasonably be considered inappropriate in a professional setting   Our responsibilities  Project maintainers are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.  Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this code of conduct, and will communicate reasons for moderation decisions when appropriate.  Scope  This code of conduct applies both within project spaces and in public spaces, and also applies when an individual is officially representing the project or its community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.  Enforcement  Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the project team responsible for enforcement at legal@wso2.com. All complaints will be reviewed and investigated promptly and fairly.  All project/community leaders are obligated to respect the privacy and security of the reporter of any incident.  Enforcement guidelines  Project/Community leaders will follow the below Community Impact Guidelines in determining the consequences for any action they deem in violation of this code of conduct:  1. Correction     Community Impact Consequence Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community. A private, written warning from project/community leaders providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.     2. Warning     Community Impact Consequence A violation through a single incident or series of actions. A warning with consequences for continued behavior. No interaction with the people involved including unsolicited interaction with those enforcing the code of conduct for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.     3. Temporary ban     Community Impact Consequence A serious violation of community standards including sustained inappropriate behavior. A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved including unsolicited interaction with those enforcing the code of conduct is allowed during this period. Violating these terms may lead to a permanent ban.     4. Permanent ban     Community Impact Consequence Demonstrating a pattern of violation of community standards including sustained inappropriate behavior, harassment of an individual, or aggression towards or disparagement of classes of individuals. A permanent ban from any sort of public interaction within the project community.     Attribution  This code of conduct is adapted from the .        Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/","name":"The Ballerina Community","summary":"We warmly welcome all contributors to the Ballerina community to help establish Ballerina as a truly community-owned resource!Table of contents            The Ballerina community has been bootstrapped by  via sponsorship of the design & implementation of the Ballerina platform. Ballerina is ...","content":"/ The Ballerina Community  The Ballerina Community  We warmly welcome all contributors to the Ballerina community to help establish Ballerina as a truly community-owned resource!  Table of contents Join Ballerina Events  Upcoming Events  StackConf  Automatic Microservices Observability with Open-Source Programming Language: Ballerina  Past Events  GIDS Live  Cloud Native Middleware as a Programming Language  GIDS Live  Automatic Microservices Observability with Open-Source Programming Language: Ballerina  Lunch & Learn  Ballerina: OS Cloud-native Programming Language  Open Source Summit Japan  Ballerina: An Open-Source Cloud-Native Programming Language  API World Virtual  Code to Kubernetes: Deployment Shouldn’t be an Afterthought  API World Virtual  Automatic Microservices Observability with Ballerina  Open Source Automation Days  Code to Kubernetes: Deployment Shouldn’t be an Afterthought  Cloud Colombo  Ballerina - A Cloud Native Programming Language  DeveloperWeek Global: Cloud  Code to Kubernetes: Deployment Shouldn’t Be an Afterthought  DeveloperWeek Global: Cloud  Code to Kubernetes: Languages of Infrastructure  Nova Code Camp  Let’s Dance Together! Ballerina  San Diego Cloud Native Computing Meetup  Ballerina – An Open-Source, Cloud-Native Programming Language for Microservices  Cloud DC Meetup  Cloud Native Development with Ballerina  DevOps Pro Europe 2020  [Talk] Code to Cloud  DevOps Pro Europe 2020  [Talk] Ballerina: The Cloud-Native and DevOps Friendly Programming Language  DevOps Pro Europe 2020  [Workshop] Ballerina: Cloud Native Middleware as a Programming Language  Kubernetes for Developers Meetup  Ballerinas & Zebras in Kubernetes  DeveloperWeek 2020  Conquering Network-Distributed Applications Using the Ballerina Programming Language  Cloud-Native and Kubernetes Meetup in Silicon Valley  An Introduction to the Ballerina Programming Language  Paris Open Source Summit  Ballerina - A Modern Cloud-based Open Source Programming Language  Downtown San Jose DevOps Meetup  Ballerina - A Programming Language for Cloud and DevOps  WSO2 Summit London  Ballerina — Cloud-native Middleware as a Programming Language  DeveloperWeek Austin  Microservices in Practice with Ballerina, Kubernetes and Istio  WSO2 Summit Bern  Ballerina — Cloud-native Middleware as a Programming Language  Java Colombo Meetup  The better java for Java microservice developers  API World  Efficient Microservices Deployment Pipelines  WSO2 Summit San Francisco  Ballerina — Cloud-native Middleware as a Programming Language  Columbus Microservices Meetup  Effective Microservices Development with Ballerina  Columbus Microservices Meetup  Ballerina in Real-World Use-Case  WSO2 Summit New York  Ballerina - Cloud Native Middleware as a Programming Language  ApacheCon North America 2019  Ballerina - Re-inventing Middleware in a Programming Language  ApacheCon North America 2019  Conquering Network Distributed Applications Using the Ballerina Programming Language  Cloud-Native and Kubernetes Meetup in Silicon Valley  An Introduction to the Ballerina Programming Language  The Ballerina community has been bootstrapped by via sponsorship of the design & implementation of the Ballerina platform. Ballerina is a fully open source project with all source code licensed under the and the specifications licensed under the license.  Try Out Ballerina   and try out writing Ballerina code on your own.  Subscribe to the Newsletter    We curate a periodic newsletter on Ballerina with hand-picked content and regular updates on the language.        Interested? Subscribe to it below:    Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Join the Community Call  The Ballerina team is now hosting monthly recorded Community Calls! These are interactive meetings that will explore Ballerina use cases. These calls give you direct access to our Engineers and other community members to question or discuss about Ballerina and your projects.    Get information on the .  Be notified about the .  Check out the recordings of all our .  Get involved in our next Community Call by .  Seek Help  We are happy to help! Come engage with us on any channel that works for you.    Report Issues  Hit a bump on the road? Report an issue in the relevant repo out of the GitHub repos listed below. We want to fix all bugs!    Compiler, runtime, or tooling: repo  Standard Library: repo  Language specification: repo  Website: repo  Security flaw: send an email to . For details, see the .   Help Us Grow  If you like the experience so far, help us to spread the word.    Star the and show appreciation to the Ballerina maintainers for their work. Also, watch the repo to keep track of Ballerina issues. Thank you!  \"Star\"\"Watch\"   Follow us on Twitter: . Tweet with the “#ballerinalang” hashtag.  Share the wealth by publishing your Ballerina module on so that the whole community can benefit from your work.  Write your own blog and submit it to be published in our .  Buzz us on if you want to organize a local meetup or hackathon. WSO2 will get right on it and help with presentation/training content, logistics, swag, and some funds for munchies.  Download any file of the to use for content or swag.  Use the to wrap Ballerina commands inside GitHub Actions.     Contribute to Ballerina  Join us and contribute to the source code to make Ballerina better! To be aware of the ground rules as you start, see the . Happy contributing!        Join Ballerina Events Click to see information about past and upcoming Ballerina events.    Upcoming Events  Past Events     June 15 - 16, 2021 Online Automatic Microservices Observability with Open-Source Programming Language: Ballerina Anjana Fernando, Director - Developer Relations, WSO2  April 27 - 30, 2021 Online Cloud Native Middleware as a Programming Language  Anjana Fernando, Senior Director - Solutions Architecture, WSO2  April 27 - 30, 2021 Online Automatic Microservices Observability with Open-Source Programming Language: Ballerina  Anjana Fernando, Senior Director - Solutions Architecture, WSO2  February 5, 2021 Online Ballerina: OS Cloud-native Programming Language Caludio Guidi, Jolie Evangelist and Project Co-Leader Anjana Fernando, Senior Director - Solutions Architecture, WSO2  December 2 - 4, 2020  Virtual  Ballerina: An Open-Source Cloud-Native Programming Language  Anjana Fernando, Director - Developer Relations, WSO2  October 28, 2020  Virtual  Code to Kubernetes: Deployment Shouldn't be an Afterthought  Lakmal Warusawithana, Senior Director - Developer Relations, WSO2  October 27 - 29, 2020  Virtual  Automatic Microservices Observability with Ballerina  Anjana Fernando, Director - Developer Relations, WSO2  October 19 - 21, 2020  Munich, Germany  Code to Kubernetes: Deployment Shouldn't be an Afterthought  Lakmal Warusawithana, Senior Director - Developer Relations, WSO2  October 7, 2020  Virtual  Ballerina - A Cloud Native Programming Language  Anjana Fernando, Director - Developer Relations, WSO2  September 30, 2020  Virtual  Code to Kubernetes: Deployment Shouldn't Be an Afterthought  Lakmal Warusawithana, Senior Director - Developer Relations, WSO2  September 29, 2020  Virtual  Code to Kubernetes: Languages of Infrastructure  Anjana Fernando, Director - Developer Relations, WSO2  September 26, 2020  Virtual  Let's Dance Together! Ballerina  Vanjikumaran Sivajothy, Senior Lead Solutions Engineer, WSO2  May 28, 2020  San Diego, California, USA  Ballerina – An Open-Source, Cloud-Native Programming Language for Microservices  Anjana Fernando, Director of Developer Relations, WSO2  May 7, 2020  Online  Cloud Native Development with Ballerina  Jadd Jennings, Hub Solutions Engineer, Oracle Cloud Solution Hub  Dhvani Sheth, Senior Solutions Engineer, Oracle  March 26, 2020  Vilnius, Lithuania  [Talk] Code to Cloud  Lakmal Warusawithana, Senior Director of Developer Relations, WSO2  March 25, 2020  Vilnius, Lithuania  [Talk] Ballerina: The Cloud-Native and DevOps Friendly Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  March 24, 2020  Vilnius, Lithuania  [Workshop] Ballerina: Cloud Native Middleware as a Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  March 10, 2020  San Jose, California, USA  Ballerinas & Zebras in Kubernetes  Lakmal Warusawithana, Senior Director of Developer Relations, WSO2  February 12 - 16, 2020  San Francisco, California, USA  Conquering Network-Distributed Applications Using the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations, WSO2  December 12, 2019  Mountain View, California, USA  An Introduction to the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  December 10 - 11, 2019  Paris, France  Ballerina - A Modern Cloud-based Open Source Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  December 5, 2019  San Jose, California, USA  Ballerina - A Programming Language for Cloud and DevOps  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  November 7, 2019  London, UK  Ballerina — Cloud-native Middleware as a Programming Language  Mauro Niewolski, Senior Solutions Engineer, WSO2  November 5 - 7, 2019  Austin, Texas, USA  Microservices in Practice with Ballerina, Kubernetes and Istio  Lakmal Warusawithana, Senior Director of Developer Relations - CTO Office, WSO2  November 5, 2019  Bern, Switzerland  Ballerina — Cloud-native Middleware as a Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  November 5, 2019  Colombo, Sri Lanka  The better java for Java microservice developers  Sanjiva Weerawarana, Founder and CEO, WSO2  October 8 - 10, 2019  San Jose, California, USA  Efficient Microservices Deployment Pipelines  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  October 8, 2019  San Francisco, California, USA  Ballerina — Cloud-native Middleware as a Programming Language  Sameera Jayasoma, Senior Director, WSO2  September 26, 2019  Columbus, USA  Effective Microservices Development with Ballerina  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  September 26, 2019  Columbus, USA  Ballerina in Real-World Use-Case  Glenn Donaldson & Jim Kittle, Ohio State University  September 24, 2019  New York, USA  Ballerina - Cloud Native Middleware as a Programming Language  Lakmal Warusawithana, Senior Director of Developer Relations - CTO Office, WSO2  September 9 - 12, 2019  Las Vegas, Nevada, USA  Ballerina - Re-inventing Middleware in a Programming Language  Paul Fremantle, CTO and Co-founder, WSO2  September 9 - 12, 2019  Las Vegas, Nevada, USA  Conquering Network Distributed Applications Using the Ballerina Programming Language  Anjana Fernando, Director of Developer Relations - CTO Office, WSO2  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2020-1/","name":"Ballerina Newsletter 2020 Issue #1","summary":"Issue #1 - May 26, 2020This is a periodic newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.\n\t\t\t\t\t\tRethinking ProgrammingEarlier this year, , Vice President of Content Strategy for O'Reilly Media, published an article titled \"\" where he made the case for ...","content":"/  /  / 2020 Issue 1  Ballerina Newsletter 2020 Issue #1    Issue #1 - May 26, 2020   This is a periodic newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Rethinking Programming   Earlier this year, , Vice President of Content Strategy for O'Reilly Media, published an article titled \"\" where he made the case for new thinking in how programming is taught and for creating new, more sophisticated programming tools. His article explores how the programming world is split between highly trained professionals who work on low-level code and people who don’t have a deep background but focus on high-level app development that helps meet business requirements.   Almost all general-purpose programming languages are designed with abstractions and constructs for the former group. As a result, most languages and tools today don’t provide the best programming experience for the latter group.   That’s where Ballerina comes in. While being a general-purpose language, Ballerina introduces a set of new abstractions, tools, and a platform to help cloud-era application developers. Some of its unique features include:   Making networking abstractions like client objects, services, resource functions, and network listeners a part of the language.  A network-friendly, data-oriented type system, which enables developers to model network communications in a convenient way avoiding unnecessary data binding steps.  Built-in cloud support, which gives developers direct source code level control over the generation of cloud deployment artifacts like Dockerfiles, Docker images, and Kubernetes configurations.  Abstractions and syntax for concurrency and network interaction, which have been designed so that there is a close correspondence with sequence diagrams allowing every program to be graphically represented as a sequence diagram.  To learn more about these key features of Ballerina, read Lakmal Warusawithana’s on Rethinking Programming: Language and Platform for Cloud-Era Application Developers.   If you’d like to dive in a bit deeper, check out the following series of articles published on HackerNoon:   What’s New in Ballerina?   We released Ballerina 1.2 on March 20, 2020 with many new features. Here are some feature highlights that are detailed in the :   bring the power of SQL-like query capabilities directly into the language as comprehensions for data processing.  allow you to declare variables that are limited to a scope of an expression on which it is used.  The annotation, which specifies a mechanism to mark Ballerina API elements that are no longer in use.  An improved compiler which significantly reduces the compilation time.  A tool to easily so that you can reuse all your existing Java code from within Ballerina.  We hope you found this information useful. We’ll catch you again soon!   | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2020-2/","name":"Ballerina Newsletter 2020 Issue #2","summary":"Issue #2 - July 7, 2020This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.\n\t\t\t\t\tWhy aren’t my microservices working?In the past few years, we have seen rapid growth in microservice adoption. But as of recent, microservices have been ...","content":"/  /  / 2020 Issue 2  Ballerina Newsletter 2020 Issue #2    Issue #2 - July 7, 2020   This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Why aren’t my microservices working?   In the past few years, we have seen rapid growth in microservice adoption. But as of recent, microservices have been criticized. When they aren’t created and managed properly they can prove to be more detrimental than beneficial. To truly leverage the advantages of agility, scalability, reusability, and efficiency promised by microservices, you need to adopt the right tools and build your architecture in the most optimal manner.   The is a set of guiding principles that help create a higher quality distributed system. A reactive system is responsive, resilient, elastic, and message-driven. You can effectively apply these concepts to the microservices world. More specifically, Ballerina, which was designed from the ground up to have first-class support for microservices, can fulfill this requirement with some easy-to-use developer abstractions. To learn more, read Anjana Fernando’s on Reactive Microservice Done Right.   An effective communication approach between microservices is something you need to think about when designing your system, which includes choosing whether it needs synchronous or asynchronous communication or a mix of both. This should be determined by the nature of your service operations and the performance characteristics you require from the system. Ballerina has core features built-in that can be used to build microservices in either of these two patterns. Read Anjana’s on Practical Microservices Development Patterns: Sync vs. Async to learn more.   Most often, developers design, architect, and implement microservices without thinking about deployment, causing them to underperform in the given execution environment. This happens because deployment is currently not a part of the programming process of creating, building, and running. To solve this, Ballerina has introduced a set of cloud native abstractions and tools into the language to write microservices that just work in platforms like Kubernetes. Read Lakmal Warusawithana’s on Microservices in Practice: Deployment Should Not Be an Afterthought to learn more.   What’s New in Ballerina?   Ballerina 1.0, which was released in September 2019, implemented the 2019-R3 specification. Although this provided us with a good foundation, we needed to make a few changes to make it even better for building integration features like transactions, querying, streams, and improving features like table support, database integration, XML support, and JSON support.   That’s why we released the first preview version of the all-new Ballerina Swan Lake on June 20 (which is backward incompatible with Ballerina 1.2). Ballerina Swan Lake will be a major new version of Ballerina that we plan to release in January 2021. Read our release blog for .   Here are some key features of Ballerina Swan Lake Preview 1:   Immutability in the type system, which guarantees that values stay unchanged  distinct types bring native support for nominal typing into the structural type system in Ballerina  Improved error type design eliminates pain-points in the previous version. The type allows you to define more refined error types that support common error handling use cases  Improved support in the language designed to make it easier and more convenient to write robust applications in Ballerina  Enhanced that bring the power of SQL-like query capabilities directly into the language as comprehensions for data processing  Introducing the type: A new built-in collection type that works like a general-purpose hash table, where the keys are part of the values being stored  Improved Ballerina API that leverages the latest languages features such as stream type, query expressions, and raw templates  The new , which helps you to mock an entire object or a function allowing you to test your code independent of external dependencies  We hope you found this information useful. We’ll catch you again soon!   | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2020-3/","name":"Ballerina Newsletter 2020 Issue #3","summary":"Issue #3 - August 27, 2020This is a periodic newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.\n\t\t\t\t\t\tWhy, When and How to Use gRPC\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tIn the recent past, gRPC has become one of the most prominent communication technologies for microservice and other ...","content":"/  /  / 2020 Issue 3  Ballerina Newsletter 2020 Issue #3    Issue #3 - August 27, 2020   This is a periodic newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Why, When and How to Use gRPC  In the recent past, gRPC has become one of the most prominent communication technologies for microservice and other distributed architectures. It’s a modern remote procedure call (RPC) technology that uses HTTP 2.0 and Protocol Buffers for binary encoding. gRPC enables maximum efficiency in communication in terms of low-latency and tight packing of data, resulting in higher throughput. To learn more about why, when, and how to use gRPC, read Anjana Fernando’s .  gRPC is especially useful for internal service-to-service communication in a microservice architecture because it provides the lowest possible overhead from network communication. Since gRPC is an open standard, all mainstream programming languages support it, making it ideal for working in a polyglot microservice environment. Ballerina has built-in support for gRPC when creating services, stubs, and clients. It maps directly to the language’s service abstractions, making it a natural task when implementing gRPC communication flows. For more information, read Lakmal Warusawithana’s where he explores a real-world use case on how to use Ballerina and Golang when building effective microservices with gRPC.  gRPC supports both client and bi-directional streaming. In client streaming, the client writes a sequence of messages and sends them to the server via a stream. Once the client has finished writing the messages, it waits for the server to read them and return a response. On the other hand, in bi-directional streaming, the client and server each send a sequence of messages using read-write streams that operate independently, allowing them to read and write in any order. Read Daksith Jayasinghe’s on gRPC Client and Bi-directional Streaming with Ballerina Swan Lake for more information.  What’s New in Ballerina?  Ballerina has been listed as one of the top 10 programming languages to learn in 2020 by TechTarget analyst Kerry Doyle. “As organizations move toward a greater reliance on distributed architectures and cloud services, Ballerina offers a simpler approach to API development, network scripting, and composite development,” states Kerry. Read more .     We released the third preview version of Ballerina Swan Lake on August 14. Read the for a full feature list.    \tHere is a summary of the key features in Ballerina Swan Lake Preview 3:   A convenient way to convert between JSON and anydata (plain data) values  order by clause in query expressions to sort a list of elements  Support for executing stored procedures in SQL connectors  Azure functions support  You can download the preview version after the stable release . Do try it out and let us know your feedback via our .      Ballerina Community Call  If you’d like to have a discussion with our engineering team on Ballerina concepts and how you can use it in your projects, join our first-ever community call on Tuesday, September 8, at 9:00 a.m. PDT. For our first call, we will start with a gRPC demo and move into an open discussion.  .  We hope you found this information useful. We’ll catch you again soon!   | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2020-4/","name":"Ballerina Newsletter 2020 Issue #4","summary":"Issue #4 - October 15, 2020This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.\n                     Serverless technology brings ...","content":"/  /  / 2020 Issue 4  Ballerina Newsletter 2020 Issue #4    This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Issue #4 - October 15, 2020  This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Serverless: Bringing Cloud Development to the Masses  Serverless technology brings cloud development closer to the masses. Developers can now focus purely on business logic with little to no concern about how they deploy their applications. Provisioning servers or VMs, and worrying about how to implement scaling and load balancing is a thing of the past. You simply provide your final application, and all the deployment and non-functional requirements are handled by the serverless runtime.  This approach is ideal for asynchronous processing. It allows you to respond to events that are triggered in the system using automatic invocation of serverless functions. Then, by orchestrating the asynchronous message passing and invocation of operations, you can create complex microservice architectures. Serverless technologies fall into two types: Backends as a Service (BaaS) and Functions as a Service (FaaS). To learn more about what serverless is and what each type offers read this .  and are a couple of prominent serverless FaaS technologies. Ballerina has built-in support for these technologies, allowing you to directly convert your Ballerina functions into functions that can be deployed in these serverless environments. The seamless integration of these cloud services with Ballerina functions allow you to conveniently design and model your code. Check out the following articles by Anjana Fernando to see how Ballerina supports the most commonly used serverless technologies:  What’s New in Ballerina?  We released the fourth preview version of Ballerina Swan Lake on September 25. Read the for a full feature list.  Here is a summary of the key features in Ballerina Swan Lake Preview 4:  Revised Ballerina object syntax, which differentiates the object type from the class, from which you can create object values.  Introducing isolated functions to achieve concurrency safety together with readonly values.  Introducing distinct object types offering the functionality similar to what is provided in nominal type systems.  Improvements to quoted identifiers to support arbitrary, non-empty strings as Ballerina identifiers.  You can download the preview version after the stable release . Do try it out and let us know your feedback via our .  Ballerina Community Call  Our next community call is happening on Tuesday, November 10, at 9:00 a.m. PDT. Join the Zoom meeting or YouTube live session to learn about Ballerina features and directly talk with our engineers who build the language. .  You can watch the recordings of our past community calls .  We hope you found this information useful. We’ll catch you again soon!  | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/","name":"Past issues Subscribe","summary":"This is a periodic newsletter on Ballerina with hand-picked content and regular updates on the language.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your browser.  ...","content":"/  / Ballerina Newsletter  This is a periodic newsletter on Ballerina with hand-picked content and regular updates on the language.       Past issues March 3, 2021  December 3, 2020  October 15, 2020  August 27, 2020  July 7, 2020  May 26, 2020        Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2020-5/","name":"Ballerina Newsletter 2020 Issue #5","summary":"Issue #5 - December 3, 2020This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.Data is an integral part of any software system and providing data to the right stakeholders at the right time is key to an ...","content":"/  /  / 2020 Issue 5  Ballerina Newsletter 2020 Issue #5    This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Issue #5 - December 3, 2020   This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.   Data and Transaction Handling in Microservices   Data is an integral part of any software system and providing data to the right stakeholders at the right time is key to an enterprise’s success. Compared to monoliths, handling data in a microservice architecture (MSA) can be complex. A reusable data abstraction layer with data services is usually created so that data can be accessed from multiple disparate microservices. Read this to see how you can use first-class language constructs to easily write data services with maximum agility and no boilerplate code.   Another key aspect to think about is how to handle transactions. Owing to the distributed nature of microservices, there are specific challenges that you need to consider that don’t pertain to monoliths. This includes the need to balance aspects such as data consistency and performance when scaling your solution. In this , we deep-dive into these challenges and explore some best practices of transaction handling for different system requirements.   In MSA, you need to process events from multiple sources and make decisions based on them. Sometimes, these operations and the logic that goes into them can become complicated. Ballerina’s provide a SQL-like syntax to easily write this logic and process event streams to filter, transform, and perform other actions on your data. Learn more in this .  Ballerina also uniquely handles data types like and and integrates them with features like the above-mentioned language-integrated queries. In this , we explore how to handle complex XML filtering and transformation in Ballerina.  The seventh Swan Lake preview release is going out this week! Once it does, we will update the with the full feature list.   Here is a summary of the key features in Ballerina Swan Lake Preview 5 and 7:   Introducing isolated objects to achieve concurrency safety with Ballerina objects  Ballerina executables now require JDK 11  Introducing Ballerina packages: a wholly revamped approach to structuring your code and sharing with Ballerina central  Improved code formatting in IDE plugins and command-line tools  the preview version, try it out and let us via our Slack channel.   If you’d like to have a discussion with our engineering team on Ballerina concepts and how you can use it in your projects, join our community call on Tuesday, December 8, at 9:00 a.m. PDT. In this time’s call, we will discuss the Java interoperability feature in Ballerina. .   We hope you found this information useful. We’ll catch you again soon!   | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/newsletter/2021-1/","name":"Ballerina Newsletter 2021 Issue #1","summary":"Issue #1 - March 3, 2021 is built to inherently make network communication easier, by making networking concepts like client objects, services, resource functions, and listeners a part of the syntax. This allows you to use the language-provided constructs to write network programs that just work. The new Swan Lake ...","content":"/  /  / 2021 Issue 1  Ballerina Newsletter 2021 Issue #1    This is a recurring newsletter of content around Ballerina and related technology topics such as integration, microservices, distributed systems, and cloud computing.  Issue #1 - March 3, 2021  Services and Network Communication in Swan Lake  is built to inherently make network communication easier, by making networking concepts like client objects, services, resource functions, and listeners a part of the syntax. This allows you to use the language-provided constructs to write network programs that just work. The new Swan Lake release introduces many improvements around the services abstraction in the language, and in protocol implementations. Let’s look at some of these!  A Ballerina service’s structure and its semantics are defined by the type of the listener. An example of this is shown in the definition of an below.  Read this on HTTP Deep-Dive with Ballerina: Services to learn the basics of creating an HTTP service and how Ballerina provides a convenient abstraction for defining complex operations.  Ballerina also has a first-class construct to create an object and provide the necessary host and configuration information. Read this on HTTP Deep-Dive With Ballerina: Client Communication where we explore Ballerina’s feature-complete functionality that allows you to implement any HTTP client scenario.  WebSocket is another communication protocol, which is used for efficient full-duplex communication between web browsers and servers over TCP. It fulfills the requirements of dynamic websites while fixing shortcomings of techniques like HTTP. Ballerina’s easy-to-use networking abstractions can also be used to create WebSocket clients and services. Read this on An Introduction to WebSockets with Ballerina to learn more.  has become a prominent technology when implementing data APIs. It provides an efficient and intuitive approach for querying data over the network. It solves potential problems such as data over-fetching and network latency that can arise in a services-based solution. Ballerina provides built-in support for quickly and easily implementing GraphQL services, allowing users to concentrate on the business logic. Learn more in this on GraphQL Made Easy With Ballerina.  For network operations to function optimally, it’s critical to support non-blocking I/O-based communication. Ballerina has a unique concurrency model, based on a lightweight thread model, which supports user-space scheduling for concurrent executions. This makes it possible to implement an efficient non-blocking I/O functionality right from the language primitives. Dive into more details with this on Ballerina Concurrency Model and Non-Blocking I/O.  The second Swan Lake Alpha release happened on Saturday, February 20! Check out the for the full feature list.  Here is a summary of the key features in Ballerina Swan Lake Alpha 1 and 2:  Support for configurability with variables  Support for the list, mapping, and error binding patterns in the statement  Improved user-defined error creation syntax with improved error handling semantics to prevent developers from masking errors  The ballerina command has been renamed to bal  Introducing bal shell command-line tool: The that interactively runs Ballerina code snippets and immediately evaluates their results  Improvements to developer tools such as the VSCode plugin, Debugger, Test Framework, Bindgen Tool, and Documentation  Improvements to the HTTP, WebSocket, gRPC, security, GraphQL, Kafka, NATS, NATS Streaming, RabbitMQ, Time, Runtime, Email, and WebSub standard library modules  Introduction of the new , , , , and standard library modules  the Alpha 2 version, try it out and let us via our Slack channel.  If you’d like to have a discussion with our engineering team on Ballerina concepts and how you can use it in your projects, join our next community call. In our , we discussed in detail about Ballerina Swan Lake’s services and network communication. .  We hope you found this information useful. We’ll catch you again soon!  | Subscribe  Email address  We'll never share your email with anyone else.  Yes, I would like to receive emails from Ballerina to stay up to date on content and new releases.  Subscribe  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/community/slack/","name":"Already a team member?If not, join us!","summary":"Table of contents            Ballerina is an open-source project under  and the work of the Ballerina community.We appreciate your help and participation!Click here: Join the Ballerina community to discuss the project with others. You can:Request an invite below.This website uses cookies ...","content":"/  / Table of contents Ballerina is an open-source project under and the work of the Ballerina community.  We appreciate your help and participation!  Already a team member?  Click here: If not, join us!  Join the Ballerina community to discuss the project with others. You can:    Talk to the core language team and other members of the community.  Learn from others and ask questions.  Share your work and demos.   Request an invite below.   Email Address         Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/","name":"Downloads","summary":"If you already have jBallerina installed, you can use the  to update it to Swan Lake Beta 1. To do this, first, execute the command below to get the Update Tool updated to its latest version. If you are using an Update Tool version below 0.8.14, execute the `ballerina ...","content":"Downloads  Swan Lake Beta 1 (May 26, 2021)  If you already have jBallerina installed, you can use the to update it to Swan Lake Beta 1. To do this, first, execute the command below to get the Update Tool updated to its latest version. bal update  If you are using an Update Tool version below 0.8.14, execute the `ballerina update` command to update it. Next, execute the command below to update to Swan Lake Beta 1.  bal dist pull swan-lake-beta1  For further details, see the . If you are new to Ballerina, download a Ballerina distribution from below based on your operating system and . Windows  Linux macOS  Next, install the Ballerina Visual Studio Code extension from below.  Visual Studio Code  Other Installation Options  Install via the ZIP archive Install from source 1.2.13 (January 6, 2021)  If you already have jBallerina version 1.2.0 or above installed, you can use the to directly update to 1.2.13. To do this, first, execute the command below to get the Update Tool updated to its latest version.  ballerina update  Next, execute the command below to update to jBallerina 1.2.13.  ballerina dist update  For further details, see the .  Windows Installer (msi)  macOS Installer (pkg)  Linux Installer (deb)  Linux Installer (rpm)  Visual Studio Code Plugin (vsix)  Other Installation Options  Install on macOS using Homebrew Install via the ZIP archive Install from source For downloading the VSCode and IntelliJ Ballerina extensions, see and ,  and for installation instructions, see .  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-archived/","name":"Swan Lake Archived Versions","summary":"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your browser.  ...","content":"/  / Swan Lake Archived Versions  Swan Lake Archived Versions  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-alpha2/","name":"Swan Lake Alpha2","summary":"Table of contents      This Alpha2 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added after the Alpha1 ...","content":"/  /  / Swan Lake Alpha2  Swan Lake Alpha2  Table of contents Overview of Ballerina Swan Lake Alpha2  This Alpha2 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added after the Alpha1 release of Ballerina Swan Lake.    Updating Ballerina  You can use the to update to Ballerina Swan Lake Alpha2 as follows.  For Existing Users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    bal update   If you are using an Update Tool version below 0.8.14, execute the ballerina update command to update it. Next, execute the command below to update to Swan Lake Alpha2.    bal dist pull slalpha2   For New Users  If you have not installed Ballerina, then download the to install.  Highlights    Support for mapping and error binding patterns in the match statement  Support for configurable variables of record and table types  Support for decrypting string values using the new lang.config lang library  Improvements to the HTTP, MIME, WebSocket, GraphQL, WebSub, WebSubHub, IO, email, UDP, crypto, and JWT standard library modules  The extension of the Ballerina package distribution file has been changed from .balo to .bala  Improvements to developer tools such as the Language Server and debugger   What is new in Ballerina Swan Lake Alpha2  Language  Support for Mapping and Error Binding Patterns in the Match Statement  Mapping Binding Pattern  The match statement now supports mapping and error binding patterns with var.  match v {  var {a, b} => {  // Matches mappings that contain at least the fields `a` and `b`.  // The values of these fields can be accessed via the variables // `a` and `b` within this block.  io:println(a);  }   var {c: {x: a1, y: a2}, ...rest} => {  // Matches mappings that have a field `c` where its value is // another mapping that contains at least the fields `x` and `y`.  // All of the remaining fields (if any) can be accessed via  // the new variable `rest`.  int length = rest.length();  } }   Error Binding Pattern  match v {  var error(message, error(causeMessage)) => {  // Matches errors that have a cause. // The messages of the matched error and the cause error  // can be accessed via the variables `message` and // `causeMessage` within this block.  io:println(causeMessage);  }   var error(a, code = matchedCode) => {  // Matches errors that have a detail entry with the key `code`.  // The `code` can be accessed using the `matchedCode` variable // within this block.  io:println(matchedCode);  } }   Runtime  Support for Configurable Variables of Record and Table Types  Record Type  Record fields with simple types like int, string, boolean, float, decimal, and arrays of the respective types are now supported.  For example, if the Config.toml file contains the following TOML table,  [Pkg.testUserOne] username = \"john\" password = \"abcd\" scopes = [\"write\"]  [Pkg.testUserTwo] username = \"mary\" password = \"test123\"   it can be loaded as configurable variables of a record type as follows.  type AuthInfo record {  readonly string username;  string password;  string[] scopes?; };  configurable AuthInfo & readonly testUserOne = ?; configurable AuthInfo & readonly testUserTwo = ?;   Table Type  Ballerina now supports configurable variables of type table through TOML arrays of tables.  For example, if the Config.toml file contains the following TOML table array,  [[Pkg.users]] username = \"alice\" password = \"password1\" scopes = [\"scope1\"]  [[Pkg.users]] username = \"bob\" password = \"password2\" scopes = [\"scope1\", \"scope2\"]  [[Pkg.users]] username = \"jack\" password = \"password3\"   it can be loaded as a configurable variable of a table type as follows.  configurable table<AuthInfo> key(username) & readonly users = ?;   Support for Decrypting String Values Using the New Config Lang Library  The bal encrypt command can be used to encrypt plain text values and specify those in the Config.toml file. Then, the config:decryptString() function can be used to decrypt the configurable value.  For example, if the Config.toml file contains the following encrypted string value,  password = \"@encrypted:{ODYUoKSw0xW31eoxa/s2ESdBNgk1gX77txBIgpLC6NQ=}\"   it can be decrypted in the Ballerina code as follows.  import ballerina/lang.config;  configurable string password = ?;  public function main() {  string decryptedPassword = config:decryptString(password); }   Standard Library  HTTP Module Improvements  Introduced Byte Stream Manipulation Functions to the Request and Response  This introduction enables manipulating the payload as a stream of byte[]. The setByteStream() and getByteStream() methods use the Ballerina stream feature.  http:Request request = new; io:ReadableByteChannel byteChannel = check io:openReadableFile(\"path/to/file.tmp\"); stream<io:Block, io:Error> byteStream = check byteChannel.blockStream(8196); request.setByteStream(byteStream);  http:Response response = new; stream<byte[], io:Error>|error str = response.getByteStream();   Introduced the http:Header Annotation to Bind Headers in an Inbound Request  With the introduction of the @http:Header annotation, inbound request headers can be retrieved by binding them to a resource method parameter. Individual headers can be accessed as string or string[] types while a parameter of type http:Headers can be used to access all headers.  service on helloEP {  resource function get hello(@http:Header {name: \"Accept\"} string? acceptHeader, http:Headers allHeaders) {  //...  } }   MIME Module Improvements  Introduced Byte Stream Manipulation Methods to the mime:Entity Class  This introduction enables manipulating the entity body as a stream of byte[].  function setByteStream(stream<byte[], io:Error> byteStream, string contentType = \"application/octet-stream\")  function getByteStream(int arraySize = 8196) returns stream<byte[], io:Error>|mime:ParserError  function getBodyPartsAsStream(int arraySize = 8196) returns stream<byte[], io:Error>|mime:ParserError    WebSocket Module Improvements  Introduced the Sync client. This is the primary client of the WebSocket module. This client is capable of reading and writing messages synchronously.  Reading and Writing Text Messages  websocket:Client wsClient = check new (\"ws://echo.websocket.org\"); var err = wsClient->writeTextMessage(\"Text message\"); string textResp = check wsClient->readTextMessage();   Reading and Writing Binary Messages  websocket:Client wsClient = check new (\"ws://echo.websocket.org\"); var err = wsClient->writeBinaryMessage(\"Binary message\".toBytes()); byte[] byteResp = check wsClient->readBinaryMessage();   GraphQL Module Improvements  Ballerina GraphQL listeners can now be configured using the same configurations as the listener configurations in http:Listener. Additionally, a GraphQL service can be secured by defining a maxQueryDepth as an annotation to restrict the depth of a query before execution.  import ballerina/graphql;  graphql:ListenerConfiguration configs = {  // http listener configurations }; listener graphql:Listener graphqlListener = new (9090, configs);  @graphql:ServiceConfiguration {maxQueryDepth: 3} service /graphql on graphqlListener {  // Service definition }   WebSub Module Improvements  Included functionality to the websub:SubscriberService to respond with user-defined custom payloads/header parameters in error scenarios.  import ballerina/websub;  listener websub:Listener subscriberListener = new (9001);  service /subscriber on subscriberListener {  remote function onSubscriptionValidationDenied(websub:SubscriptionDeniedError msg) returns websub:Acknowledgement? {  websub:Acknowledgement ack = {  headers: {  \"Content-Encoding\": \"gzip\"  },  body: {  \"message\": \"Successfully processed request\"  }  };  return ack;  }   remote function onSubscriptionVerification(websub:SubscriptionVerification msg) returns websub:SubscriptionVerificationSuccess|websub:SubscriptionVerificationError {  if (msg.hubTopic == \"https://www.sample.topic\") {  return error websub:SubscriptionVerificationError(\"Hub topic not supported\", headers = {\"Content-Encoding\": \"gzip\"}, body = {\"message\": \"Hub topic not supported\"});  } else {  return {};  }  }   remote function onEventNotification(websub:ContentDistributionMessage event) returns websub:Acknowledgement|  websub:SubscriptionDeletedError? {  return error websub:SubscriptionDeletedError(\"Subscriber wants to unsubscribe\", headers = {\"Content-Encoding\": \"gzip\"}, body = {\"message\": \"Unsubscribing from the topic\"});  } }   WebSubHub Module Improvements  Included functionality to the websubhub:Service to respond with user-defined custom payloads/header parameters in error scenarios.  import ballerina/websubhub;  service /websubhub on new websubhub:Listener(9091) {  remote function onRegisterTopic(websubhub:TopicRegistration message) returns websubhub:TopicRegistrationSuccess|websubhub:TopicRegistrationError {  if (message.topic == \"https://sub.topic.com\") {  websubhub:TopicRegistrationSuccess successResult = {body: <map<string>>{isSuccess: \"true\"}};  return successResult;  } else {  return error websubhub:TopicRegistrationError(\"Topic registration failed!\", headers = {\"Content-Encoding\": \"gzip\"}, body = {\"hub.additional.details\": \"Feature is not supported in the hub\"});  }  }   // Other remote methods... }   IO Module Improvements  Introduce a parameter of type XmlWriteOptions to specify the entity type and the document type declaration.  public function fileWriteXml(@untainted string path, xml content, *XmlWriteOptions xmlOptions, FileWriteOption fileWriteOption = OVERWRITE) returns Error? { }  Example  import ballerina/io;  public function main() returns error? {  xml content = xml `<note>  <to>Tove</to>  <from>Jani</from>  <heading>Reminder</heading>  <body>Don't forget me this weekend!</body>  </note>`;  string publicId = \"-//W3C//DTD HTML 4.01 Transitional//EN\";  string systemId = \"http://www.w3.org/TR/html4/loose.dtd\";  var writeResult = io:fileWriteXml(\"./xmlFileWithDoc.xml\", content, doctype = {  system: systemId,  'public: publicId  }); }   Output <!DOCTYPE note PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"> <note>  <to>Tove</to>  <from>Jani</from>  <heading>Reminder</heading>  <body>Don't forget me this weekend!</body> </note>  Email Module Improvements    Make the body field of the email:Message record optional. This enables sending an email with only the htmlBody field set without a text-typed body field.  Add mime:Entity type to the union type of the attachments field in the email:Message record. That enables attaching a single MIME Entity as an attachment. This email:Message record change would appear as follows.  public type Message record {|  // ... other fields  mime:Entity|Attachment|(mime:Entity|Attachment)[] attachments?; |};     The above-mentioned changes related to the body and attachments fields are updated in the email:Options record as given below in order to facilitate the same in the sendEmail method in the email:SmtpClient.   public type Options record {|  // ... other fields  string body?;  mime:Entity|Attachment|(mime:Entity|Attachment)[] attachments?; |};     Remove the properties field representing custom properties from all Email module related configuration records: email:SmtpConfig, email:PopConfig, email:ImapConfig, email:PopListenerConfig, and email:ImapListenerConfig.  The mail.smtp.ssl.checkserveridentity custom property was passed as an entry in the properties to enable/disable the server certificate’s hostname verification. As the properties field is removed from the API, from this release onwards, the verifyHostName boolean field is introduced to the secureSocket record for all the configurations related to the Email module.  This email:SecureSocket record change would appear as follows.  public type SecureSocket record {|  // ... other fields  boolean verifyHostname = true; |};   UDP Module Improvements    The sendDatagram method will now send multiple datagrams if the size of the byte[] value provided as the data field of the datagram exceeds 8KB.  Returning Datagram from the onDatagram or onBytes remote methods also sends multiple datagrams if the size of the byte[] value provided (as the data field of the datagram) exceeds 8KB.  Crypto Module Improvements  Added support to decode private keys from .key files and public keys from .cert files and updated the APIs for decoding private/public keys. This enables reading private/public keys from PEM files.  JWT Module Improvements  Extended the private key support for JWT signature generation and public cert support for JWT signature validation.  Log Module Improvements  Introduced a configuration in the log module to set the output format to JSON. You need to add the entry below in the Config.toml file to set the output format to JSON.  [log] format = \"json\"   Code to Cloud    The Kubernetes.toml file is renamed to Cloud.toml.  The --cloud=docker build option is implemented. This will build the Dockerfile and Docker image without generating the Kubernetes artifacts.   Developer Tools  Language Server  Implemented renaming support in the Language Server. Now, VSCode users are able to select a symbol and rename all occurrences within the same module as well as across modules.  Debugger  Added variable paging support. With this feature, the Ballerina variables, which contain a large number of child variables will be shown in a paged view in the debug variable presentation.  Ballerina Shell REPL [EXPERIMENTAL]    Fixed the REPL expression output to output the toBalString() result.  Improved the REPL parser to support some partial snippets such as the example cases below.  Template strings will allow continuing on new lines.  The CLI will wait for more input if the last character was an operator.  The CLI will not wait for unclosed double quotes.  Enabled REPL to exit on Ctrl+D.   Breaking Changes    Member access on a value of type table now returns () if the table does not contain a member with the specified key. Otherwise, the result is the member in the table value with the given key.   import ballerina/io;  type Employee record {  readonly string name;  int id; };  public function main() {  table<Employee> key(name) employeeTable = table [  {name: \"Mike\", id: 1234},  {name: \"John\", id: 4567}  ];  Employee? emp1 = employeeTable[\"John\"];  io:println(emp1); // {\"name\":\"John\",\"id\":4567}  Employee? emp2 = employeeTable[\"Kate\"];  io:println(emp2 is ()); // true }     Iterating over xml in a from clause in query expressions now returns xml and iterating over xml<T> returns T.   import ballerina/io;  public function main() {  xml authorList = xml `<authorList>  <author>  <name>Sir Arthur Conan Doyle</name>  <country>UK</country>  </author>  <author>  <name>Dan Brown</name>  <country>US</country>  </author>  </authorList>`;  xml authors = from xml y in authorList/<author>/<name>  select y;  io:println(authors); //<name>Sir Arthur Conan Doyle</name><name>Dan Brown</name> }     Variables of types readonly and value:Cloneable cannot be assigned to any since they may contain values of type error.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-beta1/RELEASE_NOTE.html","name":"Ballerina","summary":"The jBallerina 1.2.13 patch release improves upon the 1.2.13 release by introducing the features listed below and addressing a number of  and .You can use the  to update to jBallerina 1.2.13 as follows.If you are already using jBallerina version 1.2.0, or above, you can directly update your distribution ...","content":"Overview of jBallerina 1.2.13 The jBallerina 1.2.13 patch release improves upon the 1.2.13 release by introducing the features listed below and addressing a number of and .  Updating Ballerina  You can use the to update to jBallerina 1.2.13 as follows.  For existing users  If you are already using jBallerina version 1.2.0, or above, you can directly update your distribution to jBallerina 1.2.13 by executing the following command:    $ ballerina dist update   However, you need to use the following commands instead of the above if you have installed:    jBallerina 1.2.0 but switched to a previous version: $ ballerina dist pull jballerina-1.2.13  a jBallerina version below 1.1.0: install via the For new users  If you have not installed jBallerina, then download the to install.  Highlights  What is new in Ballerina Swan Lake Preview Language -  Runtime -  Standard Library   Developer Tools  Debugger    Added remote debugging support for the command, which runs the Ballerina executable JAR.  Added support for debugging single Ballerina tests in Visual Studio Code."},{"page":"/downloads/swan-lake-release-notes/swan-lake-alpha3/","name":"Swan Lake Alpha3","summary":"Table of contents      The Ballerina Swan Lake Alpha3 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added ...","content":"/  /  / Swan Lake Alpha3  Swan Lake Alpha3  Table of contents Overview of Ballerina Swan Lake Alpha3  The Ballerina Swan Lake Alpha3 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added after the Alpha2 release of Ballerina Swan Lake.    Updating Ballerina  If you are already using Ballerina, you can directly update your distribution to Ballerina Swan Lake Alpha3 using the . To do this, first, execute the command below to get the update tool updated to its latest version.    bal update   If you are using an Update Tool version below 0.8.14, execute the ballerina update command to update it. Next, execute the command below to update to Swan Lake Alpha3.    bal dist pull slalpha3   Installing Ballerina  If you are a new user, then download the to install.  What is New in Ballerina Swan Lake Alpha3  Language  Support for Module-level Variables with List, Mapping, and Error Binding Patterns  Variable declarations with list, mapping, or error binding patterns are now allowed at the module level. Unlike simple variables, these variables must be initialized in the declaration.  Also, these variable declarations cannot contain the isolated or configurable qualifier.  type Person record {|  string name;  boolean married; |};  function getList() returns [int, float] => [1, 2.5];  function getPerson() returns Person => {name: \"John\", married: true};  function getError() returns error => error(\"error message\", code = 1001, fatal = true);  // Module-level variable declaration with a list binding pattern. [int, float] [a, b] = getList();  // Module-level variable declaration with a mapping binding pattern. Person {name: firstName, married: isMarried} = getPerson();  // Module-level variable declaration with an error binding pattern. error error(message, code = errCode) = getError();   Support for Module-level Public Variables  Module-level variables can now be declared as public using the public qualifier. Such variables will be visible outside the modules in which they are declared.  Isolated variables and variables declared with var cannot be declared as public variables.  public string name = \"Ballerina\";  public [int, float] [a, b] = [1, 2.5];   Improvement to Annotation Attachment with Empty Mapping Constructor Expression  If the type of the annotation is a mapping type for which an empty mapping constructor is valid, the mapping constructor expression is no longer mandatory in the annotation attachment.  The absence of the mapping constructor expression in such an annotation attachment is equivalent to specifying a mapping constructor expression with no fields. type Annot record {|  int[] i = []; |};  public annotation Annot v1 on function;  @v1 // Same as `@v1 {}` public function main() { }   Introduction of the function Function Type Descriptor to Represent Any Function  A new function type descriptor has been introduced to represent all function values.  import ballerina/io;  function add(int v1, int v2) returns int => v1 + v2;  function compare(int v1, int v2) returns boolean => v1 < v2;  public function main() {  // A variable of type `function` can hold any function value.  function f = add;  io:println(\"Process (add, 1, 2): \", process(f, 1, 2)); // Prints `Process (add, 1, 2): 3`  io:println(\"Process (compare, 1, 2): \", process(compare, 1, 2)); // Prints `Process (compare, 1, 2): 0` }  function process(function func, int v1, int v2) returns int {  // A function of type `function` cannot be called directly.  // A function value assigned to a `function`-typed variable  // can only be called after the type is narrowed to the relevant type.  if (func is function (int, int) returns int) {  return func(v1, v2);  }  return 0; }   New Lang Library Functions  New xml:text() function  This function can be used to select all the items in a sequence that are of type xml:Text.  xml name = xml `<name>Dan<middleName>Gerhard</middleName><!-- This is a comment -->Brown</name>`; xml:Text nameText = (name/*).text(); io:println(nameText); // \"DanBrown\"   Bug Fixes  To view bug fixes, see the .  Runtime  New runtime Java API to create errors  A new runtime Java API is introduced to create errors. BError createError(Module module, String errorTypeName, BString message, BError cause, Object details)  The createDistinctError API has been deprecated and should not be used to create distinct errors. The new createError API can be used instead.  Bug Fixes  To view bug fixes, see the .  Standard Library  Log Package Updates  Introduced additional log levels and log functions  Introduced 2 additional log levels: DEBUG and WARN. The printDebug and printWarn functions in the ballerina/log module can be used to publish logs at the respective log levels. The print function was renamed to printInfo.  To set the global log level, place the entry given below in the Config.toml file: [log] level = \"[LOG_LEVEL]\"   Each module can also be assigned its own log level. To assign a log level to a module, provide the following entry in the Config.toml file: [[log.modules]] name = \"[ORG_NAME]/[MODULE_NAME]\" level = \"[LOG_LEVEL]\"   OS Package Updates    Removed the exec function.   Task Package Updates  The module has been revamped by removing the Scheduler and Listener classes and introducing the following functions to schedule and manage the job either one-time or periodically.    Configures the scheduler worker pool with the worker count and max waiting time.   import ballerina/task;  task:Error? output = task:configureWorkerPool(6, 7000);     Schedules the job at a specified time.   import ballerina/task; import ballerina/time;  class MyJob {  *task:Job;   public function execute() {  // logic goes here  } }  time:ZoneOffset zoneOffset = {hours: 5, minutes: 30}; time:Civil time = {  year: 2021,  month: 4,  day: 12,  hour: 23,  minute: 20,  second: 50.52,  timeAbbrev: \"Asia/Colombo\",  utcOffset: zoneOffset }; task:Error|task:JobId id = task:scheduleOneTimeJob(new MyJob(), time);     Schedules the recurring job according to the given duration.   import ballerina/task;  class MyJob {  *task:Job;   public function execute() {  // logic goes here  } } task:Error|task:JobId id = task:scheduleJobRecurByFrequency(new MyJob(), 1);     Unschedules the particular job.   import ballerina/task;  task:Error? result = task:unscheduleJob(id);     Pauses all the jobs.   import ballerina/task;  task:Error? result = task:pauseAllJobs();     Resumes all the jobs.   import ballerina/task;  task:Error? result = task:resumeAllJobs();     Pauses the particular job.   import ballerina/task;  task:Error? result = task:pauseJob(id);     Resumes the particular job.   import ballerina/task;  task:Error? result = task:resumeJob(id);     Gets all the running jobs.   import ballerina/task;  task:JobId[] jobIds = task:getRunningJobs();   Time Package Updates  Revamped the entire time package as follows:    Introduced the time:Utc record to represent the UTC timestamp.  Introduced the time:Civil record to represent the localized time.  Added necessary APIs to do time generation, manipulations, and conversions.   Steps for migration from the previous version to the current version are listed .  Cache Package Updates    Introduced the new EvictionPolicy configuration to set the eviction policy in the CacheConfig record.   The EvictionPolicy record has been introduced with the option LRU as the module only supports the LRU eviction policy to evict the cache data when the cache is full.    Removed the AbstractEvictionPolicy object type.   This object type had the common APIs for the cache eviction functionalities to implement a custom eviction policy. It has been removed with the introduction of the above configuration.  New xmldata Package  A new module is added to convert data in XML format to JSON format and vice-versa.    Converts a JSON object to an XML representation.   import ballerina/xmldata;  json data = {  name: \"John\",  age: 30 }; xml|xmldata:Error x = xmldata:fromJson(data);     Converts an XML value to its JSON representation.   import ballerina/xmldata;  json|xmldata:Error j = xmldata:toJson(xml `foo`);   Removed jsonutils, xmlutils, runtime, and reflect Packages  The jsonutils, xmlutils, runtime, and reflect packages were removed from Standard Libraries.  The XML/JSON conversation APIs in jsonutils and xmltutils packages are now supported by the xmldata package.  HTTP Package Updates    Changed the return types of the client methods to depend on the targetType argument. The default targetType is http:Response.   http:Client myClient = check new (\"http://localhost:9090”); http:Response response = check myClient->post(\"/backend/getResponse\", \"want response\"); json jsonPayload = check myClient->post(\"/backend/getJson\", \"want json\", targetType = json); xml xmlPayload = check myClient->post(\"/backend/getXml\", \"want xml\", targetType = xml);     Introduced a header map as an optional argument for non-entity-body client remote methods (GET, HEAD, OPTIONS).   http:Client myClient = check new (\"http://localhost:9090”); map<string|string[]> accHeaders = { \"Accept\" : \"application/json\" }; var response = myclient->get(\"/some/endpoint\", accHeaders);     Introduced header map and media type as optional arguments for entity-body client remote methods (POST, PUT, PATCH, DELETE, EXECUTE).   http:Client myClient = check new (\"http://localhost:9090”); json payload = {}; map<string|string[]> accHeaders = { \"Accept\" : \"application/json\" }; var response = myclient->post(\"/some/endpoint\", payload, headers = accHeaders);     Improved the data types of outbound request/response payloads which can be set directly.   type RequestMessage Request|string|xml|json[]|byte[]|int|float|decimal|boolean|map<json>|table<map<json>>|  table<map<json>>[]|mime:Entity[]|stream<byte[], io:Error>|();  type ResponseMessage Response|string|xml|json[]|byte[]|int|float|decimal|boolean|map<json>|table<map<json>>|  table<map<json>>[]|mime:Entity[]|stream<byte[], io:Error>|();     Marked HTTP client remote methods as isolated.  Introduced module error inheritance and remove error union types.  WebSocket Package Updates    Introduced auth support for the WebSocket client. The bearer token, Basic Auth, JWT, and OAuth2 support have been introduced with the WebSocket client declarative authentication.  Introduced HTTP cookie support for the WebSocket client.  http:Cookie cookie = new (\"username\", \"name\"); http:Cookie[] httpCookies = [cookie];  websocket:ClientConfiguration clientConf = {  cookies: httpCookies };  websocket:Client wsClient = check new (\"ws://localhost:21316/ws\", config = clientConf);     Made the websocket:Caller optional in WebSocket service remote functions.  Introduced support to send text, binary, and pong messages by returning them from the remote methods. Text/binary data can now be sent to the peer by returning a string or a byte[] value from the onTextMessage and onBinaryMessage remote methods. Also, a pong frame can be sent to the peer by returning a byte[] value from the onPing remote method.  remote function onTextMessage(string text) returns string {  return \"Hello World!\"; }   remote function onPing(byte[] pingData) returns byte[] {  return pingData; }     Removed the support for the websocket:AsyncClient.   GraphQL Package Updates    Added the support for hierarchical resource paths. The Ballerina GraphQL resources now can have hierarchical resource paths. Each intermediate resource path then maps to a new type in the generated schema.   import ballerina/graphql;  service /graphql on new Listener(9104) {  isolated resource function get profile/name/first() returns string {  return \"Sherlock\";  }   isolated resource function get profile/name/last() returns string {  return \"Holmes\";  }   isolated resource function get profile/age() returns int {  return 40;  } }     Supported resource functions to return optional types.   The Ballerina GraphQL resources now can return optional types.  resource function get profile/name/first(int id) returns string? {  if id == 0 {  return \"sherlock\";  } }   Email Package Updates    Enabled read/listen for multiple emails in a single TCP connection.   Each POP3 or IMAP client/listener creation initiates the connection. Then, the email sending, receiving, or listening operations can be performed many times. Finally, the client/listener has to be closed.  POP3 Client Example  email:PopClient popClient = check new (\"pop.email.com\", \"reader@email.com\",\"pass456\"); email:Message? emailResponse = check popClient->receiveMessage(); check popClient->close();   A similar format is used in the IMAP client.  POP3 Service Example  service object {} emailObserver = service object {  remote function onMessage(Message emailMessage) {   }   remote function onError(Error emailError) {   }   remote function onClose(Error? closeError) {   }  };   Note how the close() method calls the onClose method in the service.    Made email body a mandatory field in sendEmail method API.  Renamed email sending method names removing Email in each of them Renamed sendEmail as send, sendEmailMessage as sendMessage, receiveEmailMessage as receiveMessage and onEmailMessage as onMessage.  Set the default from address of the email:Message record from the SmtpClient authentication field, username. Earlier, the username for authentication was decoupled from the message data. Now, the from field is made optional and the default value will be set from the username.  Made POP3 and IMAP clients as blocking clients by providing an optional timeout argument. The time unit is in seconds and the data type is decimal. The default value is 0 in which the inbuilt polling interval is 100 milliseconds. A sample client code is as follows.  email:Message|email:Error? email = popClient->receiveMessage(timeout = 2);   In the PopListener and ImapListener configurations, the polling interval is not set with the decimal type in seconds to the pollingInterval field, which was earlier named as pollingIntervalInMillis.  Renamed the email:SmtpConfig, email:PopConfig, email:ImapConfig, email:PopListenerConfig, and email:ImapListenerConfiguration as email:SmtpConfiguration, email:PopConfiguration, email:ImapConfiguration, email:PopListenerConfiguration, and email:ImapListenerConfiguration respectively.  Removed the cronExpression field from the email:ImapListenerConfig and email:PopListenerConfig.  Made the body field of the send method mandatory in the email:SmtpClient.   WebSub Package Updates    Introduced a websub-listener configuration for the websub-listener.   import ballerina/websub;  websub:ListenerConfiguration configs = {  secureSocket: {  key: {  certFile: \"../resource/path/to/public.crt\", keyFile: \"../resource/path/to/private.key\"  }  } // any additional configurations related to http-listener };  service /subscriber on new websub:Listener(9090, configs) {  // resources }   WebSubHub Package Updates    Included HTTP Headers parameter into the WebSub Hub API.   import ballerina/websubhub; import ballerina/http;  listener websubhub:Listener hubListener = new(9095);  service /websubhub on new websubhub:Listener(9090) {  remote function onRegisterTopic(TopicRegistration message, http:Headers requestHeaders)  returns TopicRegistrationSuccess|TopicRegistrationError {  return {};  }  // http:Headers parameter will be an optional parameter for all the API endpoints }     Introduced pre-initialized constant responses to be used in the websubhub:Service implementation.   import ballerina/websubhub;  service /websubhub on new websubhub:Listener(9090) {   remote function onRegisterTopic(websubhub:TopicRegistration message)  returns websubhub:TopicRegistrationSuccess {  log:print(\"Received topic-registration request \", message = message);  return websubhub:TOPIC_REGISTRATION_SUCCESS;  }   // implement other service methods }     Initializing the websubhub:HubClient with the client configurations.   import ballerina/websubhub;  websubhub:ClientConfiguration config = {  retryConfig: {  interval: 3,  count: 3,  backOffFactor: 2.0,  maxWaitInterval: 20,  statusCodes: [500]  },  timeout: 2  };  HubClient hubClientEP = check new(subscriptionMsg, config);  websubhub:ContentDistributionMessage msg = {content: \"This is sample content delivery\"};  var publishResponse = hubClientEP->notifyContentDistribution(msg);     Introduced the websubhub-listener configuration to configure a websubhub listener.   import ballerina/websubhub;  websubhub:ListenerConfiguration configs = {  secureSocket: {  key: {  certFile: \"../resource/path/to/public.crt\", keyFile: \"../resource/path/to/private.key\"  }  }  // any additional configurations related to http-listener };  service /hub on new websubhub:Listener(9090, configs) {  // resources }   Security Updates    Renamed the ballerina/encoding module as ballerina/url and updated the APIs.   import ballerina/url;  string|url:Error encoded = url:encode(\"http://localhost:9090\", \"UTF-8\"); string|url:Error decoded = url:decode(\"http%3A%2F%2Flocalhost%3A9090\", \"UTF-8\");     The Ballerina HTTP listener can be configured to authenticate and authorize the inbound requests with a Basic Auth file user store.  Improved client and listener SecureSocket APIs of HTTP, gRPC, WebSocket, GraphQL, WebSub, WebSubHub, TCP, Email, NATS, STAN, and RabbitMQ modules.  public type ListenerSecureSocket record {|  crypto:KeyStore|CertKey key;  record {|  VerifyClient verifyClient = REQUIRE;  crypto:TrustStore|string cert;  |} mutualSsl?;  record {|  Protocol name;  string[] versions = [];  |} protocol?;  record {|  CertValidationType type = OCSP_STAPLING;  int cacheSize;  decimal cacheValidityPeriod;  |} certValidation?;  string[] ciphers = [];  boolean shareSession = true;  decimal handshakeTimeout?;  decimal sessionTimeout?; |};  public type ClientSecureSocket record {|  boolean enable = true;  crypto:TrustStore|string cert?;  crypto:KeyStore|CertKey key?;  record {|  Protocol name;  string[] versions = [];  |} protocol?;  record {|  CertValidationType type = OCSP_STAPLING;  int cacheSize;  decimal cacheValidityPeriod;  |} certValidation?;  string[] ciphers?;  boolean verifyHostName = true;  boolean shareSession = true;  decimal handshakeTimeout?;  decimal sessionTimeout?; |};  public type CertKey record {|  string certFile;  string keyFile;  string keyPassword?; |};  public enum VerifyClient {  REQUIRE,  OPTIONAL }  public enum Protocol {  SSL,  TLS,  DTLS }  public enum CertValidationType {  OCSP_CRL,  OCSP_STAPLING }     Improved the SecureSocket configuration of the JDK11 client of the JWT and OAuth2 modules.  Added support for OAuth2 client authentication of the JDK11 client, which is used to call an authorization endpoint.  TCP Package Updates    Introduced SSL/TLS support for both the client and listener.   import ballerina/tcp;  public function main() returns error? {  tcp:Client socketClient = check new (\"localhost\", 9002, secureSocket = {  cert: \"../resource/path/to/public.crt\",  protocol: {  name: tcp:TLS,  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  });   string msg = \"Hello Ballerina Echo from secure client\";  byte[] msgByteArray = msg.toBytes();  check socketClient->writeBytes(msgByteArray);   readonly & byte[] receivedData = check socketClient->readBytes();   check socketClient->close(); }   import ballerina/tcp; import ballerina/io;  tcp:ListenerSecureSocket listenerSecureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  },  protocol: {  name: tcp:TLS,  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"] }  service on new tcp:Listener(9002, secureSocket = listenerSecureSocket) {   isolated remote function onConnect(tcp:Caller caller) returns tcp:ConnectionService {  io:println(\"Client connected to secureEchoServer: \", caller.remotePort);  return new EchoService(caller);  } }  service class EchoService {  remote function onBytes(readonly & byte[] data) returns (readonly & byte[])|tcp:Error? {  io:println(\"Echo: \", 'string:fromBytes(data));  return data;  } }     Included a tcp:Caller as an optional parameter in the onBytes() method.   service class EchoService {  remote function onBytes(tcp:Caller caller, readonly & byte[] data) returns (readonly & byte[])|tcp:Error? {  io:println(\"Echo: \", 'string:fromBytes(data));  check caller->writeBytes(data);  } }     Renamed tcp:ListenerConfig and tcp:ClientConfig to tcp:ListenerConfiguration and tcp:ClientConfiguration   UDP Package Updates    Renamed udp:ListenerConfig and udp:ClientConfig to udp:ListenerConfiguration and udp:ClientConfiguration   Kafka Package Updates    Renamed the sendProducerRecord function in the client object Producer to send.  Renamed the flushRecords function in the client object Producer to ’flush.  Replaced the kafka:ConsumerError and kafka:ProducerError with kafka:Error.  NATS Package Updates    Renamed the ConnectionConfig record to ConnectionConfiguration.  Included url as a field in the ConnectionConfiguration record.  Changed the ConnectionConfiguration in the client and listener init functions to an included record parameter. This allows the record field values to be passed as named parameters.  STAN Package Updates    Renamed the StreamingConfig record to StreamingConfiguration.  Included the url as a field in the StreamingConfiguration record.  Changed the StreamingConfiguration in the client and listener init functions to an included record parameter. This allows the record field values to be passed as named parameters.  RabbitMQ Package Updates    Renamed the ConnectionConfig record to ConnectionConfiguration.   Common Standard Library Updates    All the timeout configurations are converted to accept decimal values and the time unit is in seconds.   Code to Cloud    Removed Docker annotation support.   Bug Fixes  To view bug fixes, see the .  Ballerina Packages  Introduced Local Repository Support    Apart from the Ballerina Central remote repository, you can now push packages to the local repository which can be found at <user-home>/.ballerina/repositories/local. Refer to the section on changes to CLI commands for information regarding pushing to the local repository.  To use a package from the local repository, the ‘repository’ has to be specified in the TOML table of the relevant dependency in the Dependencies.toml file.   E.g., to test a developed package before pushing it to Ballerina Central, build and push it to the local repository using the push command and add it to the Dependencies.toml file of the depending package as shown below.  [[dependency]] org = \"ballerinax\" name = \"googleapis_sheets\" version = \"1.0.0\" repository = \"local\"   Developer Tools  CLI  Changes to CLI Commands    Build and test commands  Support for providing [(--key=value)...] is removed from bal build.  Run command  Providing the project path to the run command is now optional. The default source root is the present working directory similar to how the build command works.  Program arguments should be followed by the end-of-options delimiter --.  New and init commands  Introduced creation of the Pacakge.md file for a library template. Passing the --template lib flag will create the Package.md file in addition to the Ballerina.toml file and the source BAL files.  Push command  Introduced pushing to the local repository. Passing --repository=local will push the Ballerina archive (.bala) to the local repository. For information about local repository support, see the .  Run bal help <command> to get more information on the command changes.  CLI Auto-Completion  Installing On Linux Bash  Set up auto-completion in the current bash shell.  source <(bal completion bash)  Set up auto-completion permanently in the bash shell.  echo \"source <(bal completion bash)\" >> ~/.bashrc  Installing On Mac Bash  Set up auto-completion permanently in the bash shell.  echo \"$(bal completion bash)\" >> ~/.bash_profile  Test Framework    Moved the Project Test Suite execution to a single JVM. Changed from running each Test Suite in a JVM instance. This improves the user experience when debugging tests. It no longer prompts to debug each test suite of a project.  Support for seamless integration of CICD tools by adding inbuilt path fixes to the JaCoCo XML generated for Ballerina packages.   Debugger    Added conditional breakpoint support. (Conditional expressions can now be configured for Ballerina breakpoints in the Visual Studio Code Debug view).  Added support to configure environment variables in the launch mode.  Added expression evaluation support for type cast expressions.   OpenAPI    Added JSON file generation support to the Ballerina to OpenAPI command.   bal openapi -i <ballerina file> --json     Added improvements for handling the Ballerina resource method response type in the OpenAPI to Ballerina command.   Bindgen Tool    Improved the generated bindings with the use of distinct type classes.  Improved the internal mechanism used to generate the bindings. Previous handlebars-based implementation is now changed to a syntax-tree-based implementation.   Documentation    Moved the standard library API documentation out to from the Ballerina Website.   Language Server   The Ballerina Language Server now supports telemetry-based crash reporting. This was enabled through the LSP protocol’s . If you wish to disable Ballerina Telemetry, uncheck the Ballerina: Enable Telemetry setting from VSCode.   To view bug fixes, see the .  Ballerina Shell    The Ballerina Shell now supports redefining module-level definitions and variable declarations.   =$ int i = 3; =$ string j = \"Hi\"; =$ string i = \"Hello\"; // Same variable can be redefined     A new /remove command has been introduced to be used from within the Ballerina Shell to remove one or more declarations from the snippet memory.   =$ int i = 3; =$ string j = \"Hi\"; =$ /remove i j =$ i | error: undefined symbol 'i' | i | ^ | Compilation aborted due to errors.     Ballerina Shell can now load definitions and declarations from a file. The file to load from can be specified using the -f or --file command-line options when launching the Ballerina Shell. Alternatively, the /file command can also be used for this purpose from within the Shell.   $ bal shell -f my_file.bal   The --force-dumb command-line option will now have only a long option and the short option -f is now used to load from a file.    The Ballerina Shell now supports cyclic type definitions and list binding patterns.  The Ballerina Shell now preserves qualifiers such as the final qualifier of a variable declaration.  Debugger  Now, the debugger supports conditional breakpoints. Conditional expressions can be configured for Ballerina breakpoints in the VSCode debug view.  Breaking Changes   == and != equality expressions can no longer be used with variables of type readonly.  Implicit conversion from xml:Text to string is no longer supported.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-alpha1/","name":"Swan Lake Alpha1","summary":"Table of contents      This Alpha1 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added after the eighth ...","content":"/  /  / Swan Lake Alpha1  Swan Lake Alpha1  Table of contents Overview of Ballerina Swan Lake Alpha1  This Alpha1 release includes the language features planned for the Ballerina Swan Lake release. Moreover, this release includes improvements and bug fixes to the compiler, runtime, standard library, and developer tooling. This release note lists only the features and updates added after the eighth preview of Ballerina Swan Lake.    Updating Ballerina  You can use the update tool to update to Ballerina Swan Lake Alpha1 as follows.  For Existing Users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    ballerina update   From now onwards, the ballerina command has to be issued as bal. Next, execute the command below to update to Swan Lake Alpha1.    bal dist pull slalpha1   However, if you are using a Ballerina version below 1.1.0, install via the .  For New Users  If you have not installed Ballerina, then download the to install.  Highlights    Support for intersection types with errors  Support for more match patterns in the match statement  Support for cyclic union type descriptors  Changes to casting and toString/toBalString with errors  Changes to object-type and record-type inclusions  Improved listener declaration  The ballerina command has been renamed to bal  Introduction of hierarchical package names  Introduction of the Dependencies.toml file  Introduction of REPL support for Ballerina via the bal shell command  Improvements to developer tools such as the Language Server, Project API, Debugger, Test Framework, Bindgen Tool, Maven Resolver, and Documentation  Improvements to the HTTP, WebSocket, gRPC, security, GraphQL, Kafka, NATS, NATS Streaming, RabbitMQ, Time, Runtime, Email, and WebSub standard library modules  Introduction of the new Random, RegEx, TCP, UDP, and WebSubHub standard library modules  Code action and code completion support for Code to Cloud libraries in the VS Code plugin   What is New in Ballerina Swan Lake Alpha1  Language  Intersection Type Support for Errors  Intersection types are now allowed with error types. An error value will belong to the intersection type (E1 & E2) only if it belongs to each member error type (E1 and E2) of the intersection.  type InvalidCodeError error<record { int code; }>;  type UnavailableError error<record { string[] alternatives; }>;  type Error error<record { int code; string[] alternatives; boolean fatal; }>;  public function main() {  Error err = error Error(\"InvalidCode\", code = 1234, alternatives = [\"ballerina.io\"], fatal = true);   // Since `Error` is a subtype of both `InvalidCodeError` and `UnavailableError`  // it is a subtype of the intersection type of `InvalidCodeError` and `UnavailableError`.  // Thus `err` can be assigned to a variable of type `InvalidCodeError & UnavailableError`.  InvalidCodeError & UnavailableError intersection = err; }   Support for Passing a Closed Record as the Rest Argument  A closed record can be used as the rest argument in a function or method call. This is the same as passing each field in the record value as a named argument.  import ballerina/io;  type SalaryDetails record {|  int annualIncrement = 20;  float bonusRate?; |};  function printSalaryDetails(int baseSalary, int annualIncrement, float bonusRate = 0.02) {  io:println(\"Base Salary: \", baseSalary, \" | Annual Increment: \", annualIncrement, \" | Bonus Rate: \", bonusRate); }  public function main() {  SalaryDetails details = {  annualIncrement: 30,  bonusRate: 0.03  };  // Same as `printSalaryDetails(2500, annualIncrement = 30, bonusRate = 0.03);`  printSalaryDetails(2500, ...details);   details = {};  // Same as `printSalaryDetails(2500, annualIncrement = 20);`  printSalaryDetails(2500, ...details); }   Support for the Empty XML Value  Previously, it was possible to define a value of type xml<never> (i.e., the empty XML value) only using the concat XML lang library method.  xml<never> emptyXmlValue = <xml<never>>'xml:concat();   It is now possible to directly create the empty XML value.  xml<never> emptyXmlValue = xml ``;   Improvements to the Match Statement  Support for More Match Patterns  List Match Pattern match v {  var [a, b] => {  // Matches lists with 2 elements.  } var [a, [b, c], d]|var [a, b , c, d] => {  // Matches // - lists with 3 elements where the second element is a list of 2 elements or  // - lists with 4 elements  } }   Mapping Match Pattern match v {  {a: \"hello\", b: \"world\"} => {  // Match mappings that contain the field `a` with  // value \"hello\" and field `b` with value \"world\".  }  {a: var x} => {  // Match mappings that contain the field `a`.  // The value is assigned to the variable `x`  // and can be assigned within the block.  io:println(x);  } }   Error Match Pattern match v {  error (\"Message\") => {  // Match errors with \"Message\" as the error message.  }  error () => {  // Match all errors.  } }   Improved Type Narrowing Within Match Statements  When code is executed through each match-clause, the type of the matched expression is narrowed. In the example below, the type of v in the last match clause is narrowed to string.  function getString(boolean|int|string v) returns string {  match v {  var a if a is int|boolean => {  return a.toString();  }  _ => {  return v; // Type of `v` is `string` here.  }  } }   Support for Cyclic Union Types  Cyclic union types are now supported. A cyclic union type descriptor can directly refer to its identifier in its type descriptor.  type Integers int|Integers[]|map<Integers>;  Integers intValue = 5; Integers intArray = [1, 2, 3, 4]; Integers intMap = {i: 1, j: 2}; Integers integers = [intValue, intArray, intMap];   Updated Syntax for User-Defined Error Construction  The error constructor expression now requires the error keyword to construct a user-defined error.  Previous Syntax: MyError myError = MyError(\"Message\");   New Syntax: MyError myError = error MyError(\"Message\");   Changes to Casting with Errors  Errors cannot be cast away (i.e., if the value that is being cast can be an error, the type to which the cast is attempted should also have a subtype of error).  The following was allowed previously.  function foo() returns string|int|error {  return error(\"Error Message\"); }  public function main() {  string s = <string>foo(); // Cast without considering the error. }   This is now disallowed and can be rewritten as follows.    Using checkpanic - This will preserve the panic behavior (but with a different error - the previous error was a cast error. Now, it will be the actual error returned by foo()).   function foo() returns string|int|error {  return error(\"Error Message\");  }   public function main() {  // Use`checkpanic` to panic if `foo()` returns an error and then attempt the cast.  string s = <string>checkpanic foo();  }   Using check - Alternatively, if the function’s return type allows returning the error, check can be used before attempting the cast to return the error instead of panicking.   function foo() returns string|int|error {  return error(\"Error Message\");  }   public function main() returns error? {  // Use`check` to return the error if `foo()` returns an error, and then attempt the cast.  string s = <string>check foo();  }   Changes to toString and toBalString with Errors  It was previously possible to call toString() and toBalString() on unions of errors and non-errors.  function print(any|error val) {  string s = val.toString(); }   This has now been disallowed and the error scenarios need to be handled explicitly. The above example can be rewritten as follows.  function print(any|error val) {  string s = val is error ? val.toString() : val.toString(); }   Changes to Object Type Inclusion with Qualifiers    When object type inclusion is used with an object type descriptor with qualifiers (isolated, client, service), it is now mandatory for the object in which the inclusion is done to also have these qualifiers.  Object type descriptors can no longer use object type inclusion with readonly classes.  Classes can use object type inclusion with readonly classes only if the including classes themselves are readonly classes.  The type reference in an object constructor expression can refer to a readonly class only if the object being constructed is readonly.   Changes to Record Type Inclusion with Rest Descriptors  Record type inclusion now copies the rest descriptor from the included type to the including type. The including type may override the rest descriptor.  type Configuration record {|  int id;  decimal...; |};  type DefaultConfiguration record {|  // The rest descriptor is also copied.  *Configuration;  boolean active; |};  DefaultConfiguration config = {  id: 1000,  active: true,  // Additional fields of type `decimal` can be specified since the rest descriptor  // is copied from `Configuration`.  \"factor\": 1.0,  \"index\": 0.0 };   The rest descriptor of the DefaultConfiguration is of type decimal.  type Configuration record {|  int id;  decimal...; |};  type InclusiveConfiguration record {  // Since `InclusiveConfiguration` is an inclusive record type descriptor the // `anydata` rest descriptor overrides the rest descriptor from `Configuration`.  *Configuration;  boolean active; };  InclusiveConfiguration inclusiveConfig = {  id: 1002,  active: true,  // Additional fields of type `anydata` can be specified since the rest descriptor  // is overridden as `anydata`.  \"factor\": 1.0,  \"owner\": \"admin\" };  type ExclusiveConfiguration record {|  // The record type descriptor of `ExclusiveConfiguration` overrides the rest // descriptor from `Configuration`, making the rest descriptor of `ExclusiveConfiguration` // be of type `boolean`.  *Configuration;  boolean active;  boolean...; |};  ExclusiveConfiguration exclusiveConfig = {  id: 1003,  active: false,  // Additional fields of type `boolean` can be specified since the rest descriptor is overridden.  \"allow\": true };   The rest descriptor type of the InclusiveConfiguration is anydata and that of the ExclusiveConfiguration is boolean. The including records override the rest descriptor from the included record.  Improved Listener Declaration  The listener declaration is improved to allow using listener classes that may return an error on initialization. This allows the following listener declaration where the init method of Listener may return an error.  listener lsn = new Listener();   Before this change, listener authors had to use panic in the init method instead of returning an error if the listener object failed to initialize.  If the initialization of the listener object returns an error, module initialization will fail.  listener lsn = new Listener();  public class Listener {   public isolated function 'start() returns error? {  }   public isolated function gracefulStop() returns error? {  }   public isolated function immediateStop() returns error? {  }   public isolated function detach(service object {} s) returns error? {  }   public isolated function attach(service object {} s, string[]|string? name = ()) returns error? {  }   public function init() returns error? {  ...  // Return an error if initialization failed due to some reason.  if (objectInitFailed) {  return error(\"Listener initialization failed\");  }  } }   Previous Syntax: listener lsn = new Listener();  public class Listener {  ...  ...  // listener life cycle methods   public function init() {  ...  // object init failed due to some reason  if (object_init_failed) {  panic error(\"Listener initialization failed\");  }  } }   Referring Lang Library Modules Without Using Quoted Identifiers  Lang library module prefixes can now be used without the initial quote. For example, both the approaches below are now supported.  int a = int:sum(1, 2);   int a = 'int:sum(1, 2);   Improved Lang Library Methods  Introduction of the includes Method  A new lang library method named includes, which tests whether a string value includes another string value has been added to the ballerina/lang.string library. It accepts an optional second argument to indicate the index to start searching from. It returns true only if the string contains the other string at an index greater or equal to the start index. The value false will be returned otherwise.  string str = \"Ballerina Programming Language\"; boolean includes = str.includes(\"Language\", 10);   Introduction of the sleep Method  A new sleep method, which pauses the execution of the current strand for a specified time in seconds has been added to the ballerina/lang.runtime library.  runtime:sleep(2.0);   Introduction of the getStackTrace Method  A new getStackTrace method has been introduced in the ballerina/lang.runtime library to get a stack trace for the current call stack for the specified execution point. It returns an array of stack frames.  runtime:StackFrame[] stackFrames = runtime:getStackTrace();   Introduction of the Cloneable Type  A new type named Cloneable has been introduced to the ballerina/lang.value library. This is a cyclic union type. This type represents the values on which clone and cloneReadOnly can be applied on.  public type Cloneable readonly|xml|Cloneable[]|map<Cloneable>|table<map<Cloneable>>;   Rename of the ballerina/java Module  The ballerina/java module is renamed to ballerina/jballerina.java.  Packages  Introduction of Hierarchical Package Names  Now, the package name can take the form of package-name := identifier(.identifer)* meaning the dot (.) is allowed in the package name.  The following is a valid Ballerina.toml file.  [package] org = \"ballerinax\" name = \"observe.prometheus\" version = \"1.0.0\"   Introduction of the Dependencies TOML file  This is a dedicated file to maintain all the dependencies, which is expected to be created in the package root directory. All the dependencies which were previously declared in the Ballerina.toml file should be moved to this file now.  A valid Dependencies.toml file will be as follows.  [[dependency]] org = \"ballerina\" name = \"io\" version = \"0.5.5\"  [[dependency]] org = \"ballerina\" name = \"log\" version = \"1.0.5\"   Support to Accept an Empty Ballerina TOML File  A valid Ballerina package can now contain an empty Ballerina.toml file. This makes it easier to convert an application/service written in a standalone Ballerina file to a Ballerina package.  Runtime  New APIs are added for creating immutable Ballerina records and arrays from Java.  The new ValueCreator.createReadonlyArrayValue API creates a new readonly Ballerina array from the given Java array and the ValueCreator.createReadonlyRecordValue creates a new readonly Ballerina record.  Configurable  The configurable feature is improved to support variables with decimal and arrays of int, float, string, boolean, and decimal types.  For example if the Config.toml file contains the following arrays,  ints = [1,2,3] strings = [\"red\", \"yellow\", \"green\"]   they can be loaded as follows.  configurable int[] & readonly ints = ?; configurable string[] & readonly strings = ?;   Configurations can be provided at runtime using the Config.toml file in the current working directory or by exporting the file path using the BALCONFIGFILE environment variable. For the tests, configurations can be overridden by having a Config.toml file inside the tests directory.  Developer Tools  Language Server    Find all Reference Support  CodeLens support for DocumentThis is available to auto-generate documentation for public documentable constructs  CodeAction for ChangeVariableType is available to solve incompatible variable assignments   Project API  TOML and MD files are made a part of the Project API.  Debugger    Enhanced table variable presentation with the support to view child entries  Introduced type test expression evaluation support   Test Framework  Support for function pointers in the @test:Config {} annotation. The fields before, after, dependsOn and dataProvider, which previously expected the name of the function as a string, now accept function pointers instead.  Bindgen Tool Introduced a -m|--modules flag to generate module-level mappings for Java packages generated using the Bindgen tool.  Maven Resolver Introduced support for specifying custom Maven repositories in the Ballerina.toml file. The configuration below can be used for this purpose.  [[platform.java11.repository]] id = \"<maven-repository-id>\" url = \"<maven-repository-url>\" username = \"<github-username>\" password = \"<github-PAT>\"   Ballerina Shell REPL [EXPERIMENTAL]  Introduced Read-Evaluate-Print-Loop (REPL) support for Ballerina, which can be accessed via the bal shell command. Shell runs a REPL instance of Ballerina to enable running snippets of code. An example shell session is shown below:  > bal shell Welcome to Ballerina Shell REPL. Type /exit to exit and /help to list available commands.  =$ any a = 10  =$ a is int  =$ function add(int x, int y) returns int => x + y  =$ add(3, 4) 7  =$ /exit | Bye!!!   Documentation  Now, documentation URLs follow the orgName/packageName/version/moduleName structure.  Standard Library  HTTP Module Improvements  Allow Multiple Return Types for the Resource Method  The resource method can return anydata type, an http:Response object, StatusCode records along with error?. Instead of using an http:Caller, the response can be sent similarly by returning from the method.  When returning anydata, the @http:Payload annotation can be used to specify the content type of the response additionally. Otherwise, the default content type of the respective return value type will be added.  service on new http:Listener(8080) {  resource function get hello () returns string {  return \"Hello\"; // Content type defaults to `text/plain`  }   resource function get goodbye () returns @http:Payload {mediaType: \"text/plain+id\"} string {  return \"\\\"Goodbye!\\\"\";  } }   Introduce Status Code Response Records  With the introduction of records for the most commonly used status codes, the response can be sent inline.  service on helloEP {  resource function get hello () returns http:Ok? {  return {body: \"Hello world\", headers: {\"x-test\": \"123abc\"}, mediaType: \"text/plain\"};  } }   Introduce the Response Limit Configuration  The http:Client facilitates validations on inbound responses based on size limits. Each response that exceeds the limits will be returned as an error.  http:Client clientEP = new (\"http://localhost:9092/hello\", config = {responseLimits: {  maxStatusLineLength: 50,  maxHeaderSize: 1000,  maxEntityBodySize: 50  }});   Improve Listener/Client Return Type to Union with Error  Listener and client initialization may return an error now. When the listener is used in a listener declaration, module initialization will fail if the listener initialization returns an error.  New Syntax:  http:Listener|http:ListenerError ep = new (9090); http:Client|http:ClientError myClient = new (\"http://localhost:9100\", {httpVersion: \"2.0\"});   Improve the getHeader() and getHeaders() return types to Union with Error  New Syntax:  string|error value = request.getHeader(\"Content-Type\"); string[]|error values = request.getHeaders(\"Accept\");   Remove Status Code Related http:Caller Methods  The http:Caller remote methods such as ok(), created(), accepted(), noContent(), badRequest(), notFound(), and internalServerError() were removed along with the response record introduction  WebSocket Module Improvements    The Websocket module has been moved out of the HTTP module. Therefore, the import should be changed from ballerina/http to ballerina/websocket.  Introduced a new listener as follows for the WebSocket module. listener websocket:Listener wsListener = new(9090);  This module now has the two types of services below that are mandatory to work with WebSockets.  websocket:UpgradeService - This handles the HTTP to WebSocket upgrade. This service has a single get resource, which returns a websocket:Service or an error. Optionally, this takes in the http:Request parameter. To accept the WebSocket upgrade, this resource should return a websocket:Service. Or else, to cancel the WebSocket upgrade, it must return a websocket:UpgradeError.  websocket:Service - This handles the events after the WebSocket upgrade. This service has a predefined set of remote methods like onTextMessage, onBinaryMessage, onError, onPing, onPong, onOpen, onClose. Once the connection is successfully updated to a WebSocket connection, upon receiving WebSocket frames/messages, those will get dispatched to these remote methods.  New Syntax:  import ballerina/http; import ballerina/websocket;  service / basic on new websocket:Listener(9000) {  resource function get .(http:Request req) returns websocket:Service|websocket:UpgradeError {  return new WsService();  } } service class WsService { *websocket:Service;  remote function onOpen(websocket:Caller caller) {  }  remote function onTextMessage(websocket:Caller caller, string text) {  }  remote function onBinaryMessage(websocket:Caller caller, byte[] b) {  } }   The onTextMessage and onBinaryMessage will take in the complete WebSocket message. Unlike earlier versions, onTextMessage doesn’t support data binding. WebSocket messages dispatched to this remote method will only be in the string format.  The websocket:Caller has writeTextMessage, writeBinaryMessage, ping, pong, and, close as remote methods. Unlike earlier versions, writeTextMessage doesn’t support data binding. Complete messages only in the string format will be accepted by this.  New Syntax:  caller->writeTextMessage(text); caller->writeBinaryMessage(byteArr);     Introduced a WebSocket Async client  The WebSocket module now has a websocket:AsyncClient. This client can take in a websocket:Service as a callback service to receive WebSocket messages at the client initialization. This service has a predefined set of remote methods like onTextMessage, onBinaryMessage, onError, onPing, onPong, onOpen, and onClose.   New Syntax   import ballerina/websocket;   public function main() returns websocket:Error? {  websocket:AsyncClient wsClientEp = check new (\"ws://echo.websocket.org\", new ClientService());  var err = wsClientEp->writeTextMessage(\"Hello World!\");  }   service class ClientService {  *websocket:Service;  remote function onTextMessage(websocket:Caller conn, string text) {  }  }    The websocket:AsyncClient has the writeTextMessage, writeBinaryMessage, ping, pong, and close remote methods.   New Syntax:   asyncClient>writeTextMessage(text);  asyncClient>writeBinaryMessage(byteArr);   Improved the listener/client return type to union with error  Listener and client initialization may return an error now. When the listener is used in a listener declaration, module initialization will fail if the listener initialization returns an error.   New Syntax:   websocket:Listener|websocket:Error ep = new (9090); websocket:AsyncClient|websocket:Error wsClient = new (\"ws://echo.websocket.org\");   gRPC Module Improvements  Service Changes    Enable returning specific data types directly from the remote methods (even record types and streams).  service \"Chat\" on ep {  remote function chat(stream<string, error?> clientStream) returns stream<string, error?> {  }  }   Add support to send/receive custom headers in the request/response path.   Client Changes    Clients have the capability to receive a stream object in the server streaming scenario.  stream<string, grpc:Error?> result = check endpoint->chat(\"WSO2\");   In the client and bidirectional streaming use cases, it returns a streaming client that has the capability to read and write data.  grpc:StreamingClient streamingClient = check endpoint->chat();  // Send messages  check streamingClient->send(msg);  // Receives messages  var result = streamingClient->receive();   Added the support to send/receive custom headers in the request/response path.   Protobuf Tool    Generate a custom caller object from the Protobuf tool  Generate a custom streaming client from the Protobuf tool  Update the Protobuf tool to generate specific types using langlib data types   Security Improvements  Ballerina listener authentication and authorization, and client authentication were completely redesigned. The new design is compatible with most of the standard libraries like HTTP, gRPC, WebSocket, etc.,  HTTP Listener Authentication and Authorization  A Ballerina HTTP listener can be configured to authenticate and authorize the inbound requests. Ballerina has built-in support for the following listener authentication mechanisms.    Basic authentication  LDAP user store  JWT authentication  OAuth2 authentication   For more information, see .  HTTP Client Authentication  The Ballerina HTTP client can be configured to send authentication information to the endpoint being invoked. Ballerina has built-in support for the following client authentication mechanisms.    Basic authentication  JWT authentication  Self-signed JWT  Bearer token  OAuth2 authentication  Client credentials grant type  Password grant type  Direct token type   For more information, see .  GraphQL Module Improvements  Introspection Support  Ballerina GraphQL services now support introspection queries on the schema.  Improved Resource Methods  GraphQL resources may now return error values.  Common Changes in Messaging Modules    The resource methods are changed to remote methods in the new listener APIs.  The service name is given as a string with the new Ballerina language changes.   TCP Module Improvements  The Socket module is replaced by the TCP module. Therefore, the import statement needs to be changed from ballerina/socket to ballerina/tcp.  New APIs for the client and listener are introduced in the TCP module.  Client Changes    tcp:Client initialization may now return tcp:Error if an error occurs while initializing the client.  The name of the write method changed to writeBytes. You don’t have to explicitly write a while loop to ensure the data is written completely as before. Instead, the writeBytes method ensures to write the data completely.  The name of the read method changed to readBytes. This method now returns readonly & byte[] instead of [byte[], int].   New Syntax:  import ballerina/tcp;  public function main() returns tcp:Error? {   tcp:Client socketClient = check new (\"localhost\", 3000);   check socketClient->writeBytes(“Hello Ballerina”.toBytes());   readonly & byte[] receivedData = check socketClient->readBytes();   check socketClient->close(); }   Service and Listener Changes  New Syntax:  listener tcp:Listener socketListener = new (9090);   The service type with resource methods is removed from the module. The new implementation has the following two types of services.    tcp:Service which handles a TCP connection. This service has a predefined onConnect remote method that returns tcp:ConnectionService or tcp:Error?.  tcp: ConnectionService which handles the traffic between the client and server. This can have the following optional remote methods.  remote function onBytes(readonly & byte[] data) returns Error? { }  remote function onClose() returns Error? { }  remote function onError(readonly & Error err) returns Error? { }  The read method is removed from tcp:Caller. Also, the write method of Caller is renamed to writeBytes, which is similar to the Client’s writeBytes method.  New Syntax:  import ballerina/tcp;  service on new tcp:Listener(3000) {  remote function onConnect(tcp:Caller caller) returns tcp:ConnectionService {  return new TCPService(caller);  } }  service class TCPService {  tcp:Caller caller;   public function init(tcp:Caller c) {  self.caller = c;  }   remote function onBytes(readonly & byte[] data) returns byte[]|tcp:Error? {  return data;  }   remote function onClose() returns tcp:Error? {  }   remote function onError(readonly & tcp:Error err) returns tcp:Error? {  } }   UDP Module Improvements  The UDP module has been moved out of the Socket module. Therefore, it is required to change the import from ballerina/socket to ballerina/udp.  Client Changes    udp:Client initialization may now return udp:Error if an error occurred while initializing the client.  The name of the sendTo method changed to sendDatagram. This takes a udp:Datagram as a parameter. You don’t need to explicitly write a while loop to ensure the data is written completely. The writeBytes method ensures to write the data completely.  The name of the receiveFrom method changed to receiveDatagram. This now returns readonly & udp:Datagram instead of [byte[], int, socket:Address].   New Syntax:   import ballerina/udp;   public function main() returns udp:Error? {  udp:Client socketClient = check new;  udp:Datagram datagram = {  remoteHost: \"localhost\",  remotePort: 48829,  data: \"Hello Ballerina\".toBytes()  };  check socketClient->sendDatagram(datagram);  readonly & udp:Datagram result = check socketClient->receiveDatagram();  check socketClient->close();  }    Introduced ConnectClient and Listener to the new UDP module as follows.   ConnectClient:   import ballerina/udp;   public function main() returns udp:Error? {  udp:ConnectClient socketClient = check new (\"localhost\", 48829);  check socketClient->writeBytes(\"Hello Ballerina\".toBytes());  readonly & byte[] result = check socketClient->readBytes();  check socketClient->close();  }    Listener:   import ballerina/udp;   service on new udp:Listener(48829) {   remote function onBytes(readonly & byte[] data, udp:Caller caller) returns (readonly & byte[])|udp:Error? {  return data;  }   remote function onError(readonly & udp:Error err) {  }  }   Kafka Module Improvements  Client Changes    The kafka:Consumer is separated into kafka:Listener (asynchronous) and kafka:Consumer (synchronous).  The return type of the init methods of the kafka:Producer and kafka:Consumer is changed to Error?.  The subscribeToPattern() method of the kafka:Consumer is changed to subscribeWithPattern().  A new record type named ProducerRecord is introduced for sending messages.   public type ProducerRecord record {|  string topic;  byte[] key?;  byte[] value;  int timestamp?;  int partition?;  |};   The send() method of the kafka:Producer is changed to sendProducerRecord(ProducerRecord producerRecord). An example of sending a message with the new API is given below.   string message = \"Hello World, Ballerina\";  kafkaProducer->sendProducerRecord({topic: \"test-kafka-topic\",  value: message.toBytes()});   Service and Listener Changes    The return type of the init method of kafka:Listener is changed to Error?.  Has a single type of service that supports the remote method below:  onConsumerRecord(kafka:Caller caller, kafka:ConsumerRecord[] record) {}  The kafka:Caller is introduced to remote functions to commit offsets of the consumed records.  The new syntax with the service changes is given below.   listener kafka:Listener kafkaListener = new (consumerConfigs);   service kafka:Service on kafkaListener {  remote function onConsumerRecord(kafka:Caller caller, kafka:ConsumerRecord[] records) {  // Process consumed records  }  }   NATS Module Improvements    The ballerinax/nats module is split into two packages as ballerinax/nats (NATS client) and ballerinax/stan (NATS Streaming client).  The nats:Connection object is removed entirely.  The nats:Producer client is renamed to nats:Client.  The return type of the nats:Client client is changed to Error?.  The nats:Message object is changed into a record type.   public type Message record {|  byte[] content;  string subject;  string replyTo?;  |};   The publish() method of the nats:Producer is changed to publishMessage(Message message) of the nats:Client. An example of sending a message with the new API is given below.   string message = \"Hello from Ballerina\";   nats:Client natsClient = check new;   check natsClient->publishMessage({  content: message.toBytes(),  subject: \"demo.bbe.subject\"  });   Service and Listener Changes    The return type of the init method of nats:Listener is changed to Error?.  Has a single type of service that supports the two types of remote functions below:  onMessage(nats:Message message) {}  onRequest(nats:Message message) returns anydata {}  A new onRequest remote method is introduced to directly reply to a message by returning a value if the replyTo subject is present.  If the subject name is not given in the @nats:ServiceConfig, the name of the service is considered as the subject name.  The new syntax with the service changes is given below.   import ballerinax/nats;   listener nats:Listener subscription = new;   @nats:ServiceConfig {subject: \"demo.bbe.*\"}  service nats:Service on subscription {   remote function onMessage(nats:Message message) {  }  }   NATS Streaming Module Improvements  A new package named ballerinax/stan is introduced to handle the NATS Streaming Server related functionality.  Client Changes    nats:Connection is removed entirely from the NATS Streaming client as well.  stan:Client is introduced to handle the client-side functionality.  An example of sending messages using the new ballerinax/stan package to a NATS Streaming server is given below.   import ballerinax/stan;   public function main() returns error? {  string message = \"Hello from Ballerina\";  stan:Client stanClient = check new;  string result = check stanClient->publishMessage({  content: message.toBytes(),  subject: \"demo\"  });  }   Service and Listener Changes    The return type of the init method of stan:Listener is Error?.  Has a single type of service that supports the onMessage remote method below:  onMessage(nats:Message message) {}  If the subject name is not given in the @stan:ServiceConfig, the name of the service is considered as the subject name.  The new syntax with the service changes is given below.   import ballerinax/stan;   listener stan:Listener lis = new;   @stan:ServiceConfig {subject: \"demo\"}  service stan:Service on lis {  remote function onMessage(stan:Message message) {  }  }   RabbitMQ Module Improvements  Client Changes    rabbitmq:Connection is removed entirely.  rabbitmq:Channel is renamed to rabbitmq:Client, which will handle the client-side functionality. The init method of rabbitmq:Client returns Error?.  The rabbitmq:Message object is changed into a record type.   public type Message record {|  byte[] content;  string routingKey;  string exchange = \"\";  int deliveryTag?;  BasicProperties properties?;  |};   The queueDeclare() method of rabbtimq:Channel is split into queueDeclare() and queueAutoGenerate() of rabbtimq:Client.  The basicPublish() method of rabbitmq:Channel is changed to publishMessage(Message message) of the rabbitmq:Client. An example of sending a message with the new API is given below.   import ballerinax/rabbitmq;   public function main() returns error? {  rabbitmq:Client newClient = check new;   check newClient->queueDeclare(\"MyQueue\");   string message = \"Hello from Ballerina\";  check newClient->publishMessage({  content: message.toBytes(),  routingKey: \"MyQueue\"  });  }   Service and Listener Changes    The return type of the init method of rabbitmq:Listener is changed to Error?.  Has a single type of service that supports the three types of remote functions below:  onMessage(rabbitmq:Message message) {}  onMessage(rabbitmq:Message message, rabbitmq:Caller caller) {}  onRequest(rabbitmq:Message message) returns anydata {}  A new onRequest method is introduced to directly reply to a message by returning a value if the replyTo subject is present.  If the subject name is not given in the @rabbitmq:ServiceConfig, the name of the service is considered as the subject name.  The new syntax with the service changes is given below.   import ballerinax/rabbitmq;   listener rabbitmq:Listener channelListener = new;   @rabbitmq:ServiceConfig {queueName: \"MyQueue\"}  service rabbitmq:Service on channelListener {  remote function onMessage(rabbitmq:Message message) {  }  }   Time Module Improvements  The improvements below have been introduced to the ballerina/time module.    Added support for commonly-used date-time formatters in the time:format() and time:parse() APIs.  The hours, minutes, seconds, milliseconds, and zone ID parameters of the time:createTime() method have been made defaultable.  Introduced a new time:Duration record type to represent a chunk of time.  Modified the time:addDuration() and time:subtractDuration() methods to accept the time:Duration records to be added/subtracted.  Introduced a new time:getDifference() method to calculate the difference between two time:Time records.  Introduced a new time:getTimezones() method to retrieve the timezone IDs supported by the underlying native code.  Introduced an enum to represent the days of the week and modified the time:getWeekday() method to return this enum.   Runtime Module Improvements  The methods below have been removed from the runtime module since these methods have moved to the lang:runtime lang library.    sleep  getCallStack   Email Module Improvements  Common Changes for Client and Server Configurations    email:Email is changed to email:Message.  Attachment support is improved to support file attachments directly with its content type. The new email:Attachment record is as follows.  public type Attachment record {|  string filePath; string contentType; |};     The email:Message record is modified to accept either a string or a string[] for the to, cc, bcc, and replyTo fields to add flexibility. An optional htmlBody field is added to support the HTML body. The new record is as follows.   Note how the attachments field is modified.  public type Message record {|  string|string[] to;  string subject;  string 'from;  string body;  string htmlBody?;  string|string[] cc?;  string|string[] bcc?;  string|string[] replyTo?;  string contentType?;  map<string> headers?;  string sender?;  Attachment|(mime:Entity|Attachment)[] attachments?;  |}   The enableSsl boolean field is replaced with the security field to enable different types of transport-layer security. This new parameter is an enumeration with the START_TLS_AUTO|START_TLS_ALWAYS|START_TLS_NEVER|SSL options. The default/undefined value is SSL.  Self-signed certificate support is added while default SSL/TLS support is restricted to self-signed certificates with relevant configurations and CA-certified certificates. Hostname verification is made mandatory for SSL/TLS support. Anyway, hostname verification can be disabled with the configuration by passing the value of the mail.smtp.ssl.checkserveridentity property as ”false”.  Client Changes    A new sendEmail method is added to the email:SmtpClient API to send emails directly without creating the email:Email record supporting extra fields as named optional parameters. An example of sending an email with the new API is given below.   Error? response = smtpClient->sendEmail(toAddresses, subject, fromAddress, body, cc = ccAddresses, bcc = bccAddresses, htmlBody = htmlBody, contentType = contentType, headers = {header1_name: \"header1_value\"}, sender = sender, replyTo = replyToAddresses, attachments = bodyParts);   The read method of email:ImapClient, email:PopClient, and email:Listener (i.e., new email:PopListener and email:ImapListener) are changed to receiveEmailMessage.  All client initializations return an email:Error when an error occurs during the initialization.  Service and Listener Related Changes    All listener initializations return an email:Error when an error occurs during the initialization.  The email:Listener is split into the email:PopListener and email:ImapListener. Therefore, the protocol field is removed from the new protocol-specific listeners. The email:PopConfig or email:ImapConfig that were used as fields for the email:Listener are not required for the new API implementation. Protocol configuration related fields are made parts of the new listeners.  The resource methods are changed to remote methods in the new listener APIs.  The service name is given as a string with the new Ballerina language changes.  The onMessage method of the email:Listener (i.e., new email:PopListener and email:ImapListener) is changed to onEmailMessage.  The pollingInterval field of the email:Listener is changed to pollingIntervalInMillis in the new listener APIs. That makes it consistent across other Ballerina modules, in which time durations are configured in milliseconds.  A sample POP3 listener is given below.   New Syntax:   listener email:PopListener emailListener = new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  pollingIntervalInMillis: 2000,  port: 995  });   service \"emailObserver\" on emailListener {   remote function onEmailMessage(email:Message emailMessage) {   }   remote function onError(email:Error emailError) {  }  }   WebSub Module Improvements  Hub-Related Changes    Default implementation for the websub:Hub has been removed from the module.  API specification for the WebSub Hub is moved to the .   Publisher-Related Changes    The implementation related to the websub:PublisherClient is moved to the websubhub module.   Subscriber-Related Changes    The two new configurations below are introduced to the @websub:SubscriberServiceConfiguration for hub/topic discovery.  accept - The expected media type  acceptLanguage - The expected language type  API specification for the @websub:SubscriberService is updated with the changes below.  The onIntentVerification and onNotification methods are removed.  The onSubscriptionVerification, onEventNotification, and onSubscriptionValidationDenied methods are introduced.  The updated websub:SubscriberService sample implementation is as follows.   listener websub:Listener testListener = new (9090);   @websub:SubscriberServiceConfig {  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"],  leaseSeconds: 36000,  secret: \"Kslk30SNF2AChs2\"  }  service /subscriber on testListener {  remote function onSubscriptionValidationDenied(SubscriptionDeniedError msg) returns Acknowledgement {  // execute subscription validation denied action  }   remote function onSubscriptionVerification(SubscriptionVerification msg) returns SubscriptionVerificationSuccess|  SubscriptionVerificationError {  // execute subscription verification action  }   remote function onEventNotification(ContentDistributionMessage event) {  // execute event notification received action  }  }   Introduced New Modules  Random  The ballerina/random module provides functions related to random number generation.  RegEx  The ballerina/regex module provides RegEx utilities such as checking whether a string matches a given RegEx, replacing substrings, and splitting strings based on a RegEx.  WebSubHub    This module contains the API specifications and implementations related to the WebSub Hub, WebSub Hub Client, and WebSub Publisher.  This is an inter-dependent module for the websub module.   Hub Implementation    The default websub:Hub implementation has been removed and language-specific API abstraction is defined in the websubhub:Service.  Updated WebSub Hub sample implementation to comply with the new API specification is as follows.   listener websubhub:Listener hubListener = new (9001);   service /websubhub on hubListener {  remote function onRegisterTopic(websubhub:TopicRegistration message) returns websubhub:TopicRegistrationSuccess|websubhub:TopicRegistrationError {  // implement action to execute on topic-registration  }  remote function onDeregisterTopic(websubhub:TopicDeregistration message) returns websubhub:TopicDeregistrationSuccess|websubhub:TopicDeregistrationError {  // implement action to execute on topic-deregistration  }  remote function onUpdateMessage(websubhub:UpdateMessage msg) returns websubhub:Acknowledgement|websubhub:UpdateMessageError {  // implement action to execute on content-update for topic  }  remote function onSubscription(websubhub:Subscription msg) returns websubhub:SubscriptionAccepted|websubhub:SubscriptionPermanentRedirect|  websubhub:SubscriptionTemporaryRedirect|websubhub:BadSubscriptionError|  websubhub:InternalSubscriptionError {  // implement action to execute on new subscription  }  remote function onSubscriptionValidation(websubhub:Subscription msg) returns websubhub:SubscriptionDeniedError? {  // implement action to execute on subscription validation  }  remote function onSubscriptionIntentVerified(websubhub:VerifiedSubscription msg) {  // implement action to execute on subscription intent verification  }  remote function onUnsubscription(websubhub:Unsubscription msg) returns websubhub:UnsubscriptionAccepted|websubhub:BadUnsubscriptionError|  websubhub:InternalUnsubscriptionError {  // implement action to execute on unsubscription  }  remote function onUnsubscriptionValidation(websubhub:Unsubscription msg) returns websubhub:UnsubscriptionDeniedError? {  // implement action to execute on unsubscription validation  }  remote function onUnsubscriptionIntentVerified(websubhub:VerifiedUnsubscription msg) {  // implement action to execute on unsubscription intent verification  }  } Hub Client Implementation    websubhub:Client is introduced to distribute the updated content to subscribers.  The example below is a sample use-case of the WebSub Hub Client.   service /websubhub on hubListener {  remote function onSubscriptionIntentVerified(websubhub:VerifiedSubscription msg) {   // Client configuration (e.g., retry config) can be passed if required.  websubhub:HubClient hubclient = check new (msg);  var responseFuture = start notifySubscriber(hubclient);  }   function notifySubscriber(websubhub:HubClient hubclient) returns error? {  while (true) {  // Fetch the messages to be delivered. ContentDistributionSuccess | SubscriptionDeletedError | error publishResponse = check hubclient->notifyContentDistribution({content: \"This is sample content delivery\"});  }  }  }   Publisher Implementation  websub:PublisherClient is moved to ballerina/websubhub and can now be used as websubhub:PublisherClient.  Removed Modules  Config  The configuration use cases are now covered under the configurable language feature.  Math  The APIs related to random number generation were moved to the new random module. The rest of the APIs have replacements in the lang.float and lang.int packages.  Stringutils  The regex-related APIs that were supported by this module have been moved to the new regex module. The rest of the APIs have replacements in the langlib packages.  Rename System Module to OS  The previous ballerina/system module is now renamed to ballerina/os. All the Operating System independent functionalities are included in this module.  Observability    A new extension model, which separates each extension into a separate module is introduced.  Observability can be included in the final JAR by adding the following configuration in the Ballerina.toml file.   [build-options] observabilityIncluded=true  The observability extension can be packaged by adding an import to the module in the code as shown in the example below.   import ballerinax/prometheus as _;   Prometheus and Jaeger extensions are introduced back.  The Prometheus extension can be enabled by adding the following configuration in the Config.toml file.   [ballerina.observe] metricsEnabled=true metricsReporter=\"prometheus\"  [ballerinax.prometheus] host=\"127.0.0.1\" # Optional Configuration. Default value is localhost port=9797 # Optional Configuration. Default value is 9797  The Jaeger extension can be enabled by adding the following config.   [ballerina.observe] tracingEnabled=true tracingProvider=\"jaeger\"  [ballerinax.jaeger] agentHostname=\"127.0.0.1\" # Optional Configuration. Default value is localhost agentPort=6831 # Optional Configuration. Default value is 6831  By default, the Jaeger extension now publishes traces to the Jaeger Agent using the jaeger.thrift over the compact Thrift protocol.  Code to Cloud    The Kubernetes artifacts can be generated using the --cloud=k8s build option. The import ballerina/cloud as _ import is no longer required.  VS code plugin support for the Kubernetes.toml  Code Completion based on the c2c specification.  Code Actions add/modify the probes and environments based on the source code.  Breaking Changes    Resource method declarations are no longer allowed in object-type descriptors.  Resource methods are not considered to be part of the type.  Non-isolated service variables defined outside an isolated function can be accessed within the function only if the variable is a final variable and the type is a subtype of readonly.  The @icon annotation has been replaced with the @display annotation.  The value type of XML iteration, which was previously xml|string is now xml. Moreover, the value type of xml<T> iteration is now T.   Taint Analyzer Update  With this release, the taint analyzer does not produce taint errors unless explicitly enabled. However, the taint analyzer still performs the taint flow analysis without producing errors if error logging is not enabled.  This is enabled via the build option below in the Ballerina.toml file  [build-options] taintCheck = true   or else, by using the --taint-check option in the Ballerina CLI tools as follows.  bal run --taint-check [file.bal | project] bal build --taint-check [file.bal | project]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-alpha4/","name":"Swan Lake Alpha4","summary":"Table of contents      This is the fourth Alpha release in a series of planned Alpha and Beta releases leading up to the Ballerina Swan Lake GA release.It introduces the new language features planned for the Swan Lake GA release and includes improvements and bug fixes done to ...","content":"/  /  / Swan Lake Alpha4  Swan Lake Alpha4  Table of contents Overview of Ballerina Swan Lake Alpha4  This is the fourth Alpha release in a series of planned Alpha and Beta releases leading up to the Ballerina Swan Lake GA release.  It introduces the new language features planned for the Swan Lake GA release and includes improvements and bug fixes done to the compiler, runtime, standard library, and developer tooling after the Swan Lake Alpha3 release.    Updating Ballerina  If you are already using Ballerina, you can use the to directly update to Ballerina Swan Lake Alpha4 as follows.  To do this, first, execute the command below to get the update tool updated to its latest version.    bal update   If you are using an Update Tool version below 0.8.14, execute the ballerina update command to update it. Next, execute the command below to update to Swan Lake Alpha4.    bal dist pull slalpha4   Installing Ballerina  If you have not installed Ballerina, then download the to install.  Language Updates  New Features  Relational Expressions With All Ordered Types  Relational expressions (<, >, <=, and >=) are supported with all . The static type of both operands must belong to the same ordered type.  Inferring the Argument of a Dependently-Typed Function from the Contextually-Expected Type  When the default value of a typedesc parameter of a dependently-typed function is <> and an argument is not provided for the parameter when calling the function, the argument will be inferred from the contextually-expected type of the function call.  function func(typedesc<anydata> td = <>) returns td = external;  public function main() {  // The argument for `td` is inferred to be `int`.  int value = func(); }   Improvements  Improvements to Dependently-Typed Lang Library Functions to Infer the Argument from the Contextually-Expected Type    The lang:value:ensureType lang library function is now dependently-typed.  The typedesc argument of the lang.value:cloneWithType, lang.value:fromJsonWithType, lang.value:fromJsonStringWithType, and lang.value:ensureType dependently-typed lang library functions will be inferred from the contextually-expected type if it is not passed as an argument.   import ballerina/io;   type Person record {|  string name;  int age;  |};   public function main() {  map<anydata> anydataMap = {name: \"Amy\", age: 30};   // The `typedesc` argument is inferred to be `Person`  // based on the contextually expected type.  Person|error result = anydataMap.cloneWithType();  io:println(result is Person); // Prints `true`.  }   Improvements to the Return Type of lang.value:cloneReadOnly  Changed the return type of the lang.value:cloneReadOnly lang library function from the type of the value (T) to the intersection of the type and readonly (T & readonly).  type Person record {|  string name;  int age; |};  public function main() {  Person mutablePerson = {name: \"Amy\", age: 30};   // The result of `cloneReadOnly()` can be directly assigned  // to a variable of type `Person & readonly`.  Person & readonly immutablePerson = mutablePerson.cloneReadOnly(); }   Changes to the Return Types of lang.value:fromJsonFloatString and lang.value:fromJsonDecimalString  Changed the return types of the lang.value:fromJsonFloatString and lang.value:fromJsonDecimalString lang library functions from json to lang.value:JsonFloat and lang.value:JsonDecimal respectively.  Breaking Changes    A compilation error occurs if the inferred type of an unused variable that is declared with var includes a subtype of the error type.  Removed the error<*> syntax.  Removed support for relational expressions with numeric values when the static types of the operands belong to different ordered types.  The lang.array:indexOf and lang.array:lastIndexOf lang library functions cannot be used with values that do not belong to anydata.  An object used as the iterable value in a foreach statement, from clause, or join clause must be a subtype of object:Iterable.  The RawTemplate type is distinct now.  The filler value of the decimal type is now +0d.  Changed the completion type C in stream<T, C> from error|never to error?. stream<T> is equivalent to stream<T, ()>. stream<T> and stream<T, error> are assignable to stream<T, error?>.  Annotations with the service attach point cannot be used with service classes.  Checking keywords (check and checkpanic) are allowed in a statement only if the statement is a call statement (i.e., when the expression is a function or method call).  Lowered the precedence of the trap expression.   Bug Fixes  To view bug fixes, see the .  Runtime Updates  New Features  Providing Values for Configurable Variables via Command Line Arguments  Configurable values can be provided with the built-in command-line option -C.  -Ckey=value   Key Syntax:  key:= [[org-name .] module-name .] variable   Command-line arguments are supported for configurable variables with boolean, int, float, decimal, string, and xml types.  configurable int port = ?;   Example Usages:    If the configurable variable is defined in the default module or if a single Ballerina file is being used:   bal run -- -Cport=9090  bal run program.bal -- -Cport=9090  java -jar executable.jar -Cport=9090 If the configurable variable is defined in a different module of the same organization:   bal run -- -Cmodule-name.port=9090  java -jar executable.jar -Cmodule-name.port=9090 If the configurable variable is defined in a module of a different organization.   bal run -- -Corg-name.module-name.port=9090 java -jar executable.jar -Corg-name.module-name.port=9090 Locating Multiple TOML Files  Configurable values can be provided in multiple TOML files using the BAL_CONFIG_FILES environment variable.  The file locations can be specified in the environment variable using an OS-specific separator. The precedence order will be determined by the order in which the files are specified in the environment variable. If such an environment variable is not specified, the file located in the current directory with the file name Config.toml will be used.  Providing TOML Content via Environment Variables  The configurable values can be provided using the BAL_CONFIG_DATA environment variable in which the content is expected to be in the TOML (v0.4) format.  Bug Fixes  To view bug fixes, see the .  Standard Library Updates  Improvements  time Package  Introduced the following APIs to support email-typed string conversions:    Converts a given UTC to an email string.   import ballerina/time; string emailFormattedString = time:utcToEmailString(time:utcNow());     Converts a given time:Civil to an email string.   import ballerina/time; time:Civil civil = check time:civilFromString(\"2021-04-12T23:20:50.520+05:30[Asia/Colombo]\"); string|time:Error emailDateTime = time:civilToEmailString(civil, \"GMT\");     Converts a given email string to time:Civil.   import ballerina/time; time:Civil|time:Error emailDateTime = time:civilFromEmailString(\"Wed, 10 Mar 2021 19:51:55 -0820\");   io Package    Improved the print APIs to support string templates.   import ballerina/io; string val = \"John\"; io:println(`Hello ${val}!!!`); io:print(`Hello ${val}!!!`);     Changed streaming APIs to be completed from nil return.   mysql Package    Changed the previous SSLConfig Record to SecureSocket Record.   public type SecureSocket record {|  SSLMode mode = SSL_PREFERRED;  crypto:KeyStore key?;  crypto:TrustStore cert?; |};     Changed the SSLMode value from SSL_VERIFY_CERT to SSL_VERIFY_CA.   xmldata Package  Updated the API to convert a JSON to an XML to be supported by the nil return value.  import ballerina/xmldata; json data = {  name: \"John\" }; xml?|Error x = xmldata:fromJson(data);   java.arrays Package  Renamed the java.arrays package’s org and package names as ballerina and jballerina.java.arrays.  import ballerina/jballerina.java.arrays; handle secondWord = arrays:get(input, 1);   websub Package  Added pre-built constants for WebSub common-responses.   @websub:SubscriberServiceConfig {  target: [\"https://sample.hub\", \"https://sample.topic.one\"], leaseSeconds: 36000,  secret: \"secretKey\"  } service /subscriber on new websub:Listener(9090) {  remote function onSubscriptionValidationDenied(websub:SubscriptionDeniedError msg) returns websub:Acknowledgement? {  // implement subscription validation denied logic here  return websub:ACKNOWLEDGEMENT;  }   remote function onSubscriptionVerification(websub:SubscriptionVerification msg)  returns websub:SubscriptionVerificationSuccess|websub:SubscriptionVerificationError {  // implement subscription intent verification logic here  return websub:SUBSCRIPTION_VERIFICATION_SUCCESS;  }   remote function onEventNotification(websub:ContentDistributionMessage event) returns websub:Acknowledgement|websub:SubscriptionDeletedError? {  // implement on event notification logic here  return websub:ACKNOWLEDGEMENT;  }  }    kafka Package    Updated the SecureSocket record.  Updated the init methods of the kafka:Producer, kafka:Consumer, and kafka:Listener classes.  kafka:Producer kafkaProducer = check new(kafka:DEFAULT_URL, config); kafka:Producer kafkaProducer = check new (bootstrapServers=”localhost:9092”); kafka:Producer kafkaProducer = check new(”localhost:9092”); // Same for listener and consumer initialization   nats Package  Updated the init methods of the client and listener.  nats:Client client = check new(url=”http://google.com:9090”, ssl=config); nats:Client client = check new(nats:DEFAULT_URL); nats:Client client = check new(”http://google.com:9090”); // Same for listener initialization   stan Package  Updated the init methods of the client and listener.  stan:Client client = check new(url=”http://localhost:9090”); nats:Client client = check new(nats:DEFAULT_URL); // Same for listener initialization   rabbitmq Package  Updated the init methods of the client and listener.  rabbitmq:Client client = check new(host=”localhost”, port=9090); rabbitmq:Client client = check new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT); rabbitmq:Client client = check new(”localhost”, 9090); // Same for listener initialization   Security Updates  Removed encrypted passwords and hashed passwords support for Basic Auth file user store authentication.  Bug Fixes  To view bug fixes, see the .  Developer Tools Updates  Bug Fixes  To view bug fixes, see the GitHub milestone for Swan Lake Alpha4 of the repositories below.    Language Server  To view bug fixes, see the .  Observability Updates    Introduced the open-telemetry standard for Ballerina tracing instead of open-tracing  Updated the Jaeger extension to support open-telemetry     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-alpha5/","name":"Swan Lake Alpha5","summary":"Table of contents      This is the fifth Alpha release in a series of planned Alpha and Beta releases leading up to the Ballerina Swan Lake GA release.It introduces the new language features planned for the Swan Lake GA release and includes improvements and bug fixes done to ...","content":"/  /  / Swan Lake Alpha5  Swan Lake Alpha5  Table of contents Overview of Ballerina Swan Lake Alpha5  This is the fifth Alpha release in a series of planned Alpha and Beta releases leading up to the Ballerina Swan Lake GA release.  It introduces the new language features planned for the Swan Lake GA release and includes improvements and bug fixes done to the compiler, runtime, standard library, and developer tooling after the Swan Lake Alpha4 release.    Updating Ballerina  If you are already using Ballerina, you can use the to directly update to Ballerina Swan Lake Alpha5 as follows.  To do this, first, execute the command below to get the update tool updated to its latest version.    bal update   If you are using an Update Tool version below 0.8.14, execute the ballerina update command to update it. Next, execute the command below to update to Swan Lake Alpha5.    bal dist pull slalpha5   Installing Ballerina  If you have not installed Ballerina, then download the to install.  Language Updates  New Features  The lang.xml:data() Lang Library Function  The lang.xml:data() lang library function has been introduced to get the character data from an xml value. This function returns the character data of an xml:Text value as a string. For an xml:Element value, this returns the concatenation of the result of invoking this function over the children of the element. Calling lang.xml:data() on comments, processing instructions, and empty sequences returns an empty string.  The lang.xml:getDescendants() Lang Library Function  The lang.xml:getDescendants() lang library function has been introduced to retrieve a sequence of the descendant elements for a given element in document order.  Bitwise Operations as Constant Expressions  Bitwise binary operations <<, >>, >>>, ^, &, | are now allowed as constant expressions.  const BASE = 0x10; const int SHIFTED = (BASE << 2) | 0xa;   Improvements  Improvements to the XML Literal  XML template literals now support the inclusion of multiple XML items of the same xml subtype as well as different xml subtypes.  xml x1 = xml `<ele>item</ele><!--comment-->text<?foo?>`; xml<xml:Element> x2 = xml `<ele>item1</ele><ele>item2</ele>`; xml<xml:Comment> x3 = xml `<!--comment1--><!--comment2-->`; xml<xml:ProcessingInstruction> x4 = xml `<?foo?><?bar?>`; string interpolation = \"Interpolation\"; xml<xml:Text> x5 = xml `text ${interpolation}`;   Normalization of XML Attribute Values  In XML template literals, character references within XML attribute values are now normalized to the referring character. For example, the value of the e.attr attribute in the following example is now a&b.  xml:Element e = xml `<elem attr=\"a&amp;b\" />`;   Breaking Changes    The lang.array:lastIndexOf and lang.array:indexOf lang library functions can only be used with arrays of which the element types are subtypes of the anydata type.  A compilation error occurs if the field visibility qualifiers in the including type and the included type with object type inclusion are not the same.  Remote method call action cannot be used to call non-remote methods.  The xml and readonly type-descriptors can no longer be used as expressions. A reference to a type definition defined with such type-descriptors needs to be used instead.  The argument passed to the second parameter of the attach method of the listener for service declarations has been fixed as follows. If there is no attach-point in the service, () (nil) is passed as the argument. If the attach-point is the root resource path (“/”), an empty array is passed.  The lang.xml:getContent() function no longer accepts xml:Text as an argument. The new lang.xml:data() function can be used instead.  lang.value functions cannot be called on expressions of type object. Function call syntax (value:func(obj)) can be used instead.  The lang.stream:reduce() lang library function will only return the reduced value or an error (if the completion type includes a subtype of error). It no longer returns a nil () value. The return type of lang.stream:reduce() has been updated accordingly.  An issue causing the complement of numeric literals to return incorrect values has been fixed.  Negation has been disallowed with numeric literals.  Subtyping rules have been fixed to consider the never type, which denotes an empty set of values as a subtype of any type T.  Relational expressions with lists have been fixed to consider the relative order of lists with different sizes.  Any non-error value will match the wildcard match pattern at runtime even when the matched expression’s static type includes a subtype of error.  An invalid attempt to transfer out a value via a return statement that uses self in an isolated object method results in a compilation error.  In a readonly and class intersection, the method qualifiers are now preserved from the class.   Bug Fixes  To view bug fixes, see the .  Runtime Updates  New Features  Support for Configurable Variables with Records Having Fields of Record Types  public type Person readonly & record {  string name;  int id;  Address address; };  public type Address record {  string city;  County country; };  public type County record {  string name; };   configurable Person person = ?;    The Config.toml would be as follows.  [person] name = \"waruna\" id = 10 address.city=\"Colombo\" address.country.name=\"Sri Lanka\"    Support for Configurable Variables with Arrays Having Fields of Record Types  configurable Person[] & readonly personArray = ?;   The Config.toml would be as follows.  [[personArray]] name = \"manu\" id = 11 address.city=\"New York\" address.country.name=\"USA\"  [[personArray]] name = \"hinduja\" id = 12 address.city=\"London\" address.country.name=\"UK\"   Support for Configurable Variables with Multidimensional Arrays  configurable int[][] & readonly int2DArr = ?;   The Config.toml would be as follows.  int2DArr = [[1,2],[3,4]]   Support for Optional Module Name in TOML Syntax of Configurable Variables  When providing values for configurable variables, the module information should be provided in the Config.toml file according to the following specifications.    The org-name and module-name are optional for configurable variables defined in the root module of the program.  The org-name is optional only for configurable variables defined in the root package of the program.   For example, consider a package with the organization name as myOrg and root module name as main.  The main.bal would be as follows.  import main.foo; import importedOrg/mod; configurable string mainVar = ?; public function main() { // use imported modules }   The foo.bal file of the main.foo module will be as follows.  configurable string fooVar = ?;   In the mod.bal, which is from another package with the organization name importedOrg and module name mod,  configurable string modVar = ?;   the values can be provided in Config.toml as follows.  mainVar = \"variable from root module\" [main.foo] fooVar = \"variable from non-root module of the root package\" [importedOrg.mod] modVar = \"variable from non-root package\"   Improvements  Improved Command-Line Argument Parsing  The command-line arguments are now parsed into the following.   options and option arguments  operands   Options and Option Arguments  The record parameter is included as the last of the parameter specify options.  In the example below, name and score are options. Alice and 99.9 are arguments of the option. Both the operand and option parameters can be of types int, float, decimal, string, array of any of these types, and union of any of these types with nil.  public type Person record { \tstring name; \tfloat? score = 0; };  public function main(*Person person) { \t// Process data here }   bal run file.bal -- --name Alice --score=99.9   An array value is specified by repeatedly specifying the option parameter. In the example below, suppose scores is an int array.  bal run file.bal -- --scores=10 --scores=20 --scores=30   This produces the following int array.  [10, 20, 30]     Note: Additionally, option parameters can be of types boolean, boolean[], or boolean?. When there’s an option of one of these types, it does not take an option argument. The presence of the option is considered to be true and the absence of it is considered to be false.   In the example below, suppose results is a boolean array.  bal run file.bal -- --results --results --results   This produces the following boolean array.  [true, true, true]   Operands  Other parameters that are not included records specify operands. For these parameters, the position is significant and the name is not.  In the example below, it includes the two operands 100 and Good, which get mapped to efficiency and character respectively.  public type Person record { \tstring name; \tfloat? score = 0; }; public function main(int efficiency, string character, *Person person) { \t// Process data here }   bal run file.bal -- --name alice 100 --score=99.9 Good     Note: If there is an operand parameter of type O[], then it cannot be followed by parameters of type O[], O?, and O x = d. Here, O stands for a type that is a subtype of one of string, float, or decimal.   Bug Fixes  To view bug fixes, see the .  Standard Library Updates  New Features  Added compiler plugin validation for services in the following packages: email, file, graphql, grpc, http, kafka, nats, rabbitmq, stan, tcp, udp, websocket, websub, and websubhub`.  graphql Package    Added named fragment support in GraphQL queries.  Added enum support for GraphQL services.  Added map support for GraphQL fields.   Improvements  jballerina.java Package  The java:cast function is now a dependently-typed function. If the typedesc argument is not provided, it is inferred from the contextually-expected type.  FileInputStream|error obj1 = java:cast(inputStream, FileInputStream); FileInputStream|error obj2 = java:cast(inputStream); // The second argument is inferred to be `FileInputStream`.   file Package    Changed the path field in the ListenerConfig from optional to mandatory.  Improved the compiler plugin validation for the service.   log Package    Changed the time format in the log output to RFC3339.  Added validation to check log levels in the Config.toml file.   sql Package  If return types of the SQL time-related data types are expected as records, then the type of those records will be validated now and should be as follows.    DATE -> time:Date  TIME -> time:TimeOfDay  TIME WITH TIME ZONE -> time:TimeOfDay  TIMESTAMP -> time:Civil  TIMESTAMP WITH TIME ZONE -> time:Civil   websubhub Package  Added the websubhub:ServiceConfig annotation.  Bug Fixes  To view bug fixes, see the .  Developer Tools Updates  Bug Fixes  To view bug fixes, see the GitHub milestone for Swan Lake Alpha5 of the repositories below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview1/","name":"Swan Lake Preview 1","summary":"Table of contents      Ballerina Swan Lake will be a major new version of Ballerina that we plan to release in January 2021. We will be doing major releases every 6 months from then on. We also plan to use popular ballet names as the codename for each ...","content":"/  /  / Swan Lake Preview 1  Swan Lake Preview 1  Table of contents - - - {:.}  Overview of Ballerina Swan Lake - Preview 1 Ballerina Swan Lake will be a major new version of Ballerina that we plan to release in January 2021. We will be doing major releases every 6 months from then on. We also plan to use popular ballet names as the codename for each release - so the 2021-07 release will be the Nutcracker release. We will announce details on maintenance of released versions and will also have an LTS release model similar to Ubuntu or Java.  This release is the first preview version of Ballerina Swan Lake. This release includes a new set of language features and significant improvements to the compiler, runtime, standard libraries, and developer tooling.  You can use the update tool to update to Ballerina Swan Lake Preview 1 as follows.  For existing users:  If you are already using jBallerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the Update Tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 1.    ballerina dist pull slp1   However, if you are using a jBallerina version below 1.1.0, install via the .  For new users:  If you have not installed jBallerina, then download the to install.  Highlights    Immutability in the type system: Ballerina compiler guarantees that when you state a value as immutable, it stays unchanged  distinct types bring native support for nominal typing into the structural type system in Ballerina  Improved the error type design eliminates pain-points in the previous version. The distinct error type allows programmers to define more refined error types that support common error handling use cases  Improved transaction support in the language: A set of language features that are designed to make it easier and more convenient to write robust applications in Ballerina  Enhanced Query expressions that bring the power of SQL-like query capabilities directly into the language as comprehensions for data processing  Introducing the table type: A new built-in collection type that works like a general-purpose hash table, where the keys are part of the values being stored  Improved Ballerina SQL module API that leverages the latest languages features such as stream type, query expressions, and raw templates  The new mocking API in Ballerina test framework helps you to mock an entire object or a function allowing you to test your code independent of external dependencies   What’s new in Ballerina Swan Lake - Preview 1  Language  The Language implementation is based on . This Specification introduces a set of new features and improvements in the following main areas.    Type system enhancements  Improved immutability support  New transactions support  Improved query support   Some of these new language features are revamped versions of the existing language features. Therefore, the source code will not be backward compatible with the stable Ballerina 1.2 releases.  In addition to the new Language features, this release introduces a new parser implementation aiming to improve the performance and usability of the compiler. Now, the compiler has more control over syntax errors and it can provide better diagnostics for syntax errors. Additionally, the new parser has tightened up the language parser rules with respect to the Ballerina language specification. However, it still does not cover the full set of the language features. This will be fixed in the upcoming preview versions.  Type system enhancements Enum  An Enum provides a convenient syntax for declaring a union of string constants.  public enum Color {  RED,  GREEN,  BLUE }  is exactly equivalent to:  public const RED = \"RED\"; public const GREEN = \"GREEN\"; public const BLUE = \"BLUE\"; public type Color RED|GREEN|BLUE;   New readonly type  A value belongs to the readonly type if its read-only flag is set. A value belonging to one of the following inherently-immutable basic types will always have it’s read-only bit set and will always belong to the readonly type.    all simple basic types - nil, boolean, int, float, decimal  string  error  function  service  typedesc   A value belonging to one of the following selectively-immutable types will belong to readonly (i.e., will be immutable) only if its read-only bit is set.    xml  list  mapping  table  object   An immutable value is deeply immutable and thus an immutable structure is guaranteed to have only immutable values at any level. As with previous versions of Ballerina, an immutable value can be created by calling .cloneReadOnly() on the value. Additionally, it is now possible to create an immutable value by providing a read-only type as the contextually expected type.  readonly immutableValue = “hello world“;  Intersection type  Intersection types have been introduced with this release. A value belongs to an intersection type T1 & T2 if the value belongs to both T1 and T2. The implementation currently supports intersection types only if one of the constituent types of the intersection is readonly.  Intersection types are especially useful when defining immutable values of selectively immutable types. Providing a readonly intersection type as the contextually expected type for a constructor expression results in the value being created as an immutable value. By definition, such a value belongs to the readonly type too.  map<int> & readonly immutableMap = {  a: 1,  b: 2,  c: 3 };  readonly immutableValue = immutableMap;   Here, immutableMap belongs to both map<int> and readonly.  Introduction of distinct types  Distinct types provide functionalities similar to that provided by nominal types but they work within Ballerina’s structural type system. Distinct types are similar to the branded types found in some other structurally typed languages, such as Modula-3.  Withdistinct types, it is possible to define unique types that are structurally similar. Distinct types can be used only with the object or error basic types. This release adds distinct error support and distinct object support will be added later. Revamped error type  The error type has been revised to take advantage of distinct types. The previous error value had a reason string for categorizing errors and a detail record for additional data about the error such as message and cause.  Old Syntax type Error error<reasonType, detailType>;  Here the reasonType is a subtype of string and detailType is a subtype of record {| string message?; error cause; (anydata|error)... |}.  Now error value has a message string, an optional cause, and mapping value for additional details about the error value and distinct error types are used for categorizing. .  New Syntax type Error error<typeParameter>;   Here the error typeParameter has to be a subtype of map<anydata|readonly>. The error type parameter is optional and if absent, it defaults to map<anydata|readonly>. If present, it must be a subtype of map<anydata|readonly>.  type Error0 error; type Error1 error<map<string>>; type Error2 error<record {| int code; |}>;  Revised error constructor  Error values of user-defined types are created using the error constructor of that type. The first mandatory positional augment of the error constructor is the error message and it must be a subtype of string. The second optional positional argument can be provided to pass an error cause. Error details are provided as named arguments in the error constructor.  type AppError error<record {| string buildNo; string userId; |};  AppError appError = AppError(\"Failed to delete the order line\", buildNo=getBuildNo(), userId=userId);  Inferring the type of the error  A type of error<*> means that the type is a subtype of error, where the precise subtype is to be inferred from the context.  type TrxErrorData record {|  string message = \"\";  error cause?;  string data = \"\"; |};  type TrxError error<TrxErrorData>;  TrxError e = TrxError(\"IAmAnInferredErr\"); error<*> err = e;  The distinct error type  The error types can be defined as distinct types so that Ballerina programmers can have more fine-grained control over error handling.  // Define a distinct error type `ApplicationError` to be a subtype of `error`. type ApplicationError distinct error;  // `FileUploadError` is a subtype of `ApplicationError`. type FileUploadError distinct ApplicationError;  // `UserPermissionError` is a subtype of `ApplicationError`. type UserPermissionError distinct ApplicationError;  // Creating Error values FileUploadError fileErr = FileUploadError(\"File upload failed\");  ApplicationError err = fileErr; UserPermissionError userErr = fileErr; // Compile Time Error.   The type test expression can be used to identify values of each distinct error type at runtime.  The never type  The never type describes the type that does not contain any shapes. No value ever belongs to never.  This can be useful to describe the return type of a function, if the function never returns. It can also be useful as a type parameter. For example, xml<never> describes an xml type that has no constituents, i.e. the empty xml value.  function aNeverReturningFunction() returns never {  panic error(\"Invalid function call\"); }  Revamped table type  The table type has been redesigned to be more consistent with other structural types and no longer has preview status.  A table is a structural value whose members are mapping values that represent rows of the table. A table provides access to its members using a key, which comes from the read-only fields of the member. It keeps its members in order but does not provide random access to a member using its position in this order. The built-in functions enable inserting, accessing, deleting data, and applying functions on members of a table.  type Employee record {  readonly int id;  string name;  float salary; };  table<Employee> tbEmployee = table {  {key id, name, salary},  [  {1, \"Mary\", 300.5},  {2, \"John\", 200.5},  {3, \"Jim\", 330.5}  ] };  type EmployeeTable table<Employee> key(id);  public function main() {  EmployeeTable employeeTab = table [  {id: 1, name: \"John\", salary: 300.50},  {id: 2, name: \"Bella\", salary: 500.50},  {id: 3, name: \"Peter\", salary: 750.0}  ];  Employee emp = {id: 5, name: \"Gimantha\", salary: 100.50};  employeeTab.add(emp);  Employee peekEmp = employeeTab.get(1); }  Type inclusion  The type (including type) that includes another object (included type) can override fields and functions of the included type. The types of the fields and functions in the including type should be subtypes of the types of the corresponding fields and functions in the included type. Object type inclusion can now include non-abstract objects.  type GridMessage object {  int|string address = \"\";  string body = \"\";   public function init(string body, int|string address) {  self.body = body;  self.address = address;  }   function getAddress() returns int|string {  return self.address;  } };  type EfficientGridMessage object {  *GridMessage;   int address = 0;   public function init(string body, int address) {  self.body = body;  self.address = address;  }   function getAddress() returns int {  return self.address;  } };   type GridPacket record {  int|string address;  string body = \"\";  (int|byte|string)[] header?; };  type EfficientGridPacket record {  *GridPacket;   int address = 0;  byte[] header?; };  Raw templates Similar to string template literals, a raw template literal allows interpolating expressions into a string literal. However, for a raw template, the resulting value is an object whose type is a subtype of lang.object:RawTemplate.  import ballerina/io; import ballerina/lang.'object;  public function main() {  string name = \"Ballerina\";  'object:RawTemplate greeting = `Hello ${name}!!!`;   io:println(greeting.strings);  io:println(greeting.insertions[0]); }  Dependently-typed function signatures A function’s return type descriptor can now refer to a name of a parameter of the function if the type of the parameter is a subtype of typedesc. The actual return type of such a function then depends on the value the user specifies for the referenced typedesc parameter when calling the function.  Note that currently this is only supported for external functions.  import ballerina/java;  function query(typedesc<anydata> rowType) returns map<rowType> = @java:Method {  class: \"org.ballerinalang.test.DependentlyTypedFunctions\",  name: \"query\",  paramTypes: [\"org.ballerinalang.jvm.values.api.BTypedesc\"] } external;  public function main() {  map<int> m1 = query(int);  map<string> m2 = query(string); }   Improved support for immutability  This release introduces improved support for immutability. With the introduction of the readonly type, values that are known to be immutable can now be defined at compile-time.  An intersection type T & readonly where T is a selectively-immutable type results in a read-only type. When such a type is used as the contextually expected type for a constructor expression, the value created will be an immutable value.  import ballerina/io;  type Details record {|  int id;  string country; |};  type Employee record {|  Details details;  string department; |};  public function main() {  Employee & readonly emp = {  details: {  id: 112233,  country: \"Sri Lanka\"  },  department: \"IT\"  };  io:println(emp.isReadOnly()); // true  io:println(emp.details.isReadOnly()); // true }   Attempting to create an immutable value with incompatible mutable values as members will result in compilation errors.Read-only intersections for objects are only allowed with abstract objects. In order to represent a non-abstract object type as a read-only type, the object would have to be defined as a readonly object. For more information, see .  Read-only fields A record or an object can now have readonly fields. A readonly field cannot be updated once the record or the object value is created and the value provided for the particular field should be an immutable value. If the field is of type T, the contextually-expected type for a value provided for a field would be T & readonly.  Thus, a readonly field guarantees that the field will not change and also that the value set for the field itself will not be updated.  type Details record {|  int id;  string country; |};  type Employee record {|  readonly Details details;  string department; |};  public function main() {  Details & readonly immutableDetails = {  id: 112233,  country: \"Sri Lanka\"  };  Employee emp = {  details: immutableDetails,  department: \"IT\"  };  emp.details = { // error - cannot update 'readonly' record field 'details' in 'Employee'  id: 2222,  country: \"UK\"  }; }   If all the fields of a closed record or an object are readonly, the record or the object itself is considered immutable and a value of the particular type can be used where an immutable value is expected.  type Identifier record {|  readonly int id;  readonly string code; |};  type Controller object {  readonly int id;  function init(int id) {  self.id = id;  }  function getId() returns int {  return self.id;  } };  public function main() {  Identifier details = {  id: 112233,  code: \"SLC\"  };  Controller controller = new (1234);  readonly[] arr = [details, controller]; }   Read-only objects An object type can also be defined as a readonly object type and any value belonging to this type will be immutable. Similar to readonly fields, each value provided for a field of a readonly object is expected to be immutable and the field itself cannot be updated once set.  type Details record {  int id;  string country; };  type Controller readonly object {  Details details;  boolean allow = true;  function init(Details & readonly details) {  self.details = details;  }  function getDetails() returns Details {  return self.details;  } };  public function main() {  Controller controller = new ({id: 1234, country: \"SL\"});  controller.allow = false; // error - cannot update 'readonly' value of type 'Controller' }  Transactions Transaction support has been revisited based on a A Ballerina transaction is a series of data manipulation statements that must either fully complete or fully fail, thereby, leaving the system in a consistent state. A transaction is performed using a transaction statement. The semantics of the transaction statement guarantees that every Begin() operation will be paired with a corresponding Rollback() or Commit() operation. It is also possible to perform retry operations over the transactions as well. Other than that, the transaction module provides some util functions to set commit/rollback handlers, retrieve transaction information, etc. This release only supports local transactions.  public function main() returns error? {  // JDBC Client for H2 database.  jdbc:Client dbClient = check new (url = \"jdbc:h2:file:./local-transactions/testdb\",  user = \"test\", password = \"test\");   // Create the tables that are required for the transaction.  var ret = dbClient->execute(\"CREATE TABLE IF NOT EXISTS CUSTOMER \" +  \"(ID INTEGER, NAME VARCHAR(30))\");  handleExecute(ret, \"Create CUSTOMER table\");   ret = dbClient->execute(\"CREATE TABLE IF NOT EXISTS SALARY \" +  \"(ID INTEGER, MON_SALARY FLOAT)\");  handleExecute(ret, \"Create SALARY table\");   transaction {  var customerResult = dbClient->execute(\"INSERT INTO CUSTOMER(ID,NAME) \" +  \"VALUES (1, 'Anne')\");  var salaryResult = dbClient->execute(\"INSERT INTO SALARY (ID, MON_SALARY) \" +  \"VALUES (1, 2500)\");   transactions:Info transInfo = transactions:info();  io:println(transInfo);   var commitResult = commit;   if (commitResult is ()) {  io:println(\"Transaction committed\");  handleExecute(customerResult, \"Insert data into CUSTOMER table\");  handleExecute(salaryResult, \"Insert data into SALARY table\");  } else {  io:println(\"Transaction failed\");  }  }   // Drop the tables.  ret = dbClient->execute(\"DROP TABLE CUSTOMER\");  handleExecute(ret, \"Drop table CUSTOMER\");  ret = dbClient->execute(\"DROP TABLE SALARY\");  handleExecute(ret, \"Drop table SALARY\");   check dbClient.close(); }  Query improvements  Ballerina query action/expression provides a language-integrated query feature using SQL-like syntax. A Ballerina query is a comprehension, which can be used with a value that is iterable with any error type. A query consists of a sequence of clauses (i.e., from, join, let, on, where, select, do, and limit). The first clause must be a from clause and must consist of either a select or a do clause as well. When a query is evaluated, its clauses are executed in a pipeline by making the sequence of frames emitted by one clause being the input to the next clause. Each clause in the pipeline is executed lazily pulling input from its preceding clause. The result of such a query can either be a list, stream, table, string, XML, or termination value of the iterator which is ().  import ballerina/io;  type Student record {  string fName;  string lName;  int intakeYear;  float score; };  type Report record {  string name;  string degree;  int expectedGradYear; };  public function main() {   Student s1 = {fName: \"Alex\", lName: \"George\", intakeYear: 2020, score: 1.5};  Student s2 = {fName: \"Ranjan\", lName: \"Fonseka\", intakeYear: 2020, score: 0.9};  Student s3 = {fName: \"John\", lName: \"David\", intakeYear: 2022, score: 1.2};  Student s4 = {fName: \"Gorge\", lName: \"Fernando\", intakeYear: 2021, score: 1.1};  Student[] studentList = [s1, s2, s3, s4];   Report[] reportList = from var student in studentList  where student.score >= 1  let string degreeName = \"Bachelor of Medicine\",  int graduationYear = student.intakeYear + 5  select {  name: student.fName,  degree: degreeName,  expectedGradYear: graduationYear  }  limit 2;   foreach var report in reportList {  io:println(report);  } }  Other backward-incompatible/significant improvements    Parameter defaults are not added if a rest argument is provided when calling a function.  The __init method of object and the __init function of modules have been renamed to init.  Module variables can now be initialized in the module’s init function.  Hex literals have been disallowed as decimal values  Record values compatible with json can now be assigned to json variables.  Record values compatible with a map type can now be assigned to variables of that map type.  Type descriptors cannot be used in expression contexts. Only type references are now allowed to be used in expression contexts.  List binding patterns can now be used with arrays.  Error binding patterns and structured match patterns are not yet supported with the new parser.   Standard Library  Introduced new SQL module  The newly-introduced sql module provides a common interface and functionality to interact with a database. The corresponding database clients can be created by using specific database modules such as MySQL or using the Java Database Connectivity module JDBC.  The revamped SQL implementation has the support for sql:ParameterizedQuery through which parameterized queries can be passed easily.  A sample connector for a MySQL database is as follows. import ballerina/mysql; import ballerina/sql;  public function main() returns sql:Error? {   mysql:Client mysqlClient = check new (\"localhost\", \"root\", \"root\", \"testdb\");   int id = 10;  string name = \"Alice\";  sql:ParameterizedQuery sqlQuery = `INSERT INTO Persons (id, name) values (${id}, ${name})`;   sql:ExecutionResult result = check mysqlClient->execute(sqlQuery);  check mysqlClient.close(); }   Enhanced log API module  Revamped log API to support anydata and improved performance.  import ballerina/log;  public function main() {  log:printDebug(\"Debug log\");  log:printDebug(12345);  log:printDebug(3.146);  log:printDebug(true);   Fruit apple = new (\"Apple\", 20);  log:printDebug(function() returns int {  return apple.getCount();  }); }  public type Fruit object {  string name;  int count;  public function init(string name, int count) {  self.name = name;  self.count = count;  }  function getCount() returns int {  return self.count;  } };   Enhanced gRPC module  The client/bidirectional streaming service implementation is revamped to support multiple service resources.  The previous gRPC client/bidirectional streaming had a shortcoming where a service can only contain a single streaming resource. In order to overcome this, the implementation of the client/bidi streaming has been changed to accept a stream type like below.  E.g.,   service HelloWorld on new grpc:Listener(9090) {  resource function lotsOfGreetings(grpc:Caller caller, stream<string,error> clientStream) {   //Read and process each message in the client stream  error? e = clientStream.forEach(function(string name) {  });  //Once the client sends a notification to indicate the end of the stream, 'grpc:EOS' is returned by the stream  if (e is grpc:EOS) {  grpc:Error? err = caller->send(\"Ack\");   //If the client sends an error to the server, the stream closes and returns the error  } else if (e is error) {   }  } }    Enhanced Auth module  The capability to validate the JWT signature with JWKs is extended now. With that, the JWT signature can be validated either from the TrustStore configuration or JWKs configuration.  jwt:JwtValidatorConfig validatorConfig = {  issuer: \"ballerina\",  audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  clockSkewInSeconds: 60,  jwksConfig: {  url: \"https://example.com/oauth2/jwks\",  clientConfig: {  secureSocket: {  trustStore: trustStore  }  }  } };   Enhanced Email module  The Email Connector clients are given the capability to add custom SMTP properties, custom POP properties, and custom IMAP properties via the configuration of each of the clients.  The SMTP client is made capable of sending custom email headers (SMTP header) via the SMTP client and retrieving all the email headers to the user via POP and IMAP clients.  A listener is introduced to asynchronously listen to email servers with polling and receive if any email is received. This listener supports both POP3 and IMAP4 protocols. A sample code is given below.   import ballerina/email; import ballerina/io;  email:PopConfig popConfig = {  port: 995,  enableSsl: true };  listener email:Listener emailListener = new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  protocol: \"POP\",  protocolConfig: popConfig,  pollingInterval: 2000 });  service emailObserver on emailListener {   resource function onMessage(email:Email emailMessage) {  }   resource function onError(email:Error emailError) {  }  }   Adding the Socket module to Ballerina Central  Previously, the Socket module was available only in the Ballerina distribution. From this release onwards, it is available in both the  released Ballerina distribution and Ballerina Central. This will allow us to release the module independently.  Developer tools  Maven dependency management  Now, you can specify your native jar dependencies with maven artifact id in the Ballerina.toml. When you build the program build tool will fetch those dependencies from the Maven Central automatically. If you specify the maven artifact id and the jar path both the jar path will get precedence.  E.g.,  [[platform.libraries]] modules = [ \"module1\", \"module2\"] artifactId = \"json\" groupId = \"json.org\" version = \"0.7.2\"   Scoping support for native dependencies  Now you can specify the scope for platform libraries. Based on the scope, dependencies will be included to different phases. The values of this will be as follows    default - will be available to compile, run tests, execute, and also distributed with the BALO.  provided - will be available to compile, run tests, execute but not distributed with the BALO.  testOnly - will be only available to run tests.   E.g.,  [platform] target = \"java8\"  [[platform.libraries]] modules = [\"sap-client\"] path = \"path/to/sap_client_1.2.3.jar\" scope = \"provided\" The Bindgen tool    Java Subtyping support is added to the generated bindings.  Maven dependency resolving is integrated into the tool and a new -mvn|--maven command option is introduced to facilitate this.  Error mappings are improved by generating Ballerina error types for Java exceptions.  Introduces a function in the java module of the Ballerina standard library to support Java Casting.  Introduces the generation of API documentation comments in the generated bindings.  Introduces a --public flag to change the visibility modifier (which is module private by default) to public.  Moves the array util functions into the java.arrays module in the Ballerina standard library instead of generating it each time when the tool is executed.  Bug fixes and improvements to usability and generated bindings.   The bindgen tool command after the newly-introduced options is as follows.  ballerina bindgen [(-cp|--classpath) <classpath>...]  [(-mvn|--maven) <groupId>:<artifactId>:<version>]  [(-o|--output) <output>]  [--public]  (<class-name>...)   API documentation    The search capability is added into the API Documentation  You can now combine documentation from multiple projects using the doc tool   Debugger  This provides variable evaluation support. This will allow you to evaluate a variable using the expression evaluation option to retrieve the value of the variable at a debug hit.  Test framework  Introduction of the Mocking API in the Test module  The new mocking API simplifies function and object mocking in unit tests via the when-then convention.  The mocking features can be used to control the behavior of functions and objects by defining return values or  replacing the entire object or function with a user-defined equivalent. This feature will help you to test your Ballerina code independently from other modules and external endpoints. For the complete list of available mocking features, see .  Function mocking  The MockFunction object is added to handle function mocking. The MockFunction objects are defined by attaching the @test:MockFn annotation to the MockFunction to specify the function to mock.  @test:MockFn {  functionName : \"<function_to_mock>\" } test:MockFunction mockObj = new();   Function mocking is done by using the following functions:   The test:when(mockObj) is used to initialize the mocking capability within a particular test case  This allows you to use the associated mocking functions like call(), thenReturn() and withArguments()   Object mocking  Object mocking enables controlling the values of member variables and the behavior of the member functions of an object    Introduced the ability to create a test double, which provides an equivalent mock in place of the real object  Introduced the capability of stubbing the member function or member variable   Object mocking is done by using the following functions:   The test:mock() and test:prepare() are used to initialize the mocking capability  The test:prepare() function allows you to use the associated mocking functions like thenReturn(), thenReturnSequence(), doNothing() , and withArguments()     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview3/","name":"Swan Lake Preview 3","summary":"Table of contents      This release is the third preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.You can use the update tool to update to Ballerina ...","content":"/  /  / Swan Lake Preview 3  Swan Lake Preview 3  Table of contents Overview of Ballerina Swan Lake Preview 3  This release is the third preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.  You can use the update tool to update to Ballerina Swan Lake Preview 3 as follows.  For existing users:  If you are already using jBallerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the Update Tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 3.    ballerina dist pull slp3   However, if you are using a jBallerina version below 1.1.0, install via the .  For new users:  If you have not installed jBallerina, then download the to install.  Highlights    Support for defining external object method bodies  Order by clause for sorting  Inner/Nested query expressions  Support for executing stored procedures in the SQL connector  Azure Functions support   What’s new in Ballerina Swan Lake Preview 3  Language  The language implementation is based on .  External object method bodies  This release introduces support for defining object methods with external function bodies.  type Person object {  string fname;  string lname;   function init(string fname, string lname) {  self.lname = lname;  self.fname = fname;  }   function getFullName() returns string = @java:Method {  class: \"abc.Hello\"  } external; };   The Java method to which the getFullName() method is bound:  public static BString getFullName(ObjectValue objectValue) {  return objectValue.getStringValue(new BmpStringValue(\"fname\")).concat(new BmpStringValue(\" \")).concat(  objectValue.getStringValue(new BmpStringValue(\"lname\"))); }   Order by clause for sorting  This release introduces the order by clause support for sorting in query expression/action. An order-by clause is executed by constructing a list of entries.  Student s1 = {id: 1, fname: \"John\", fee: 2000.56, age: 20}; Student s2 = {id: 2, fname: \"John\", fee: 2000.56, age: 22}; Student s3 = {id: 3, fname: \"Roger\", fee: 4000.56, age: 21}; Student s4 = {id: 4, fname: \"Kate\", fee: 2000.56, age: 24};  Student[] studentList = [s1, s2, s3, s4];  Student[] sortedList = from var student in studentList  order by student.age ascending, student.fname  select student;   Inner/Nested query expressions  This release introduces the support to write inner/nested query expression/action.  Person[] personList = [  {id: 1, fname: \"Alex\", lname: \"George\"},  {id: 2, fname: \"Ranjan\", lname: \"Fonseka\"},  {id: 3, fname: \"Idris\", lname: \"Elba\"},  {id: 4, fname: \"Dermot\", lname: \"Crowley\"} ];  Department[] deptList = [  {id: 1, name:\"HR\"},  {id: 2, name:\"Operations\"},  {id: 3, name:\"Engineering\"} ];  Employee[] empList = [  {personId: 1, deptId: 2},  {personId: 2, deptId: 1},  {personId: 3, deptId: 3},  {personId: 4, deptId: 3} ];   DeptPerson[] deptPersonList =  from var emp in (from var e in empList select e)  join Person psn in (from var p in personList select p)  on emp.personId equals psn.id  join Department dept in (from var d in deptList select d)  on emp.deptId equals dept.id  select {  fname : psn.fname,  lname : psn.lname,  dept : dept.name  };   Standard Library  SQL Connectors  Stored procedures can now be executed through SQL connectors (JDBC & MySQL).  int uid = 10; sql:OutParameter insertId = new;  var ret = dbClient->call(`call InsertPerson(${uid}, ${insertId})`); if (ret is error) {  io:println(\"Error occurred:\", err.message()); } else {  io:println(\"Out Parameter insert id: \", insertId.get(int));  stream<record{}, sql:Error>? resultStr = ret.queryResult;  if (!(resultStr is ())) {  sql:Error? e = resultStr.forEach(function(record{} result) {  io:println(\"Full Customer details: \", result);  });  } else {  io:println(\"Stored procedure does not return anything.\");  } }   Module Organization  The ballerina/nats library was moved to Ballerina Central. Previously, this module was packed in the Ballerina distribution. With this change, this library can now be released independently.  Developer Tools  Language Server  Introducing AI-based Data Mapping Code Action  Two record types can now be mapped automatically using the Data Mapping code action. Once a possible record mapping instance is identified, it suggests a mapping based on an AI algorithm. A mapping function will be generated automatically and added to the workspace to perform the record mapping.  The following is a sample in which the code action to generate a mapping function will appear when attempting to assign a mapping value to a variable of a type that is not directly assignable.  type Grade record {|  int maths;  int physics;  int chemistry; |};  type NameAndGrade record {|  string name;  string surname;  int maths;  int physics;  int chemistry; |};  public function main() {  NameAndGrade student = { \tname: \"Kamal\", \tsurname: “Perera”, \tmaths: 90, physics: 99, chemistry: 95  };  Grade grades = student; }  By choosing the Generate mapping functioncode action, the following function will be added to the workspace.  function mapNameAndGradeToGrade(NameAndGrade nameAndGrade) returns Grade { // Some record fields might be missing in the AI-based mapping.  Grade grade = { maths: nameAndGrade.maths, physics: nameAndGrade.physics, chemistry: nameAndGrade.chemistry};  return grade; }   Furthermore, the line with the error would be replaced with a function call as shown below.  Grade grades = mapNameAndGradeToGrade(student);   For more information, see .  Test Framework  Support single test execution  A single test function or a set of functions can now be executed using the --tests flag as follows.  $ ballerina test --tests <test_function> --all   API change in assertEquals and assertNotEquals functions  Deep value equality is supported only for anydata-typed values according to the language specification. The assertEquals function has been changed to accept only anydata-typed values to reflect this behavior.  Introduction of the assertExactEquals and assertNotExactEquals functions  The assertExactEquals function compares two values to assert whether they refer to the same entity (i.e., they are exactly equal).  import ballerina/test;  type Person object {  public string name = \"\";  public int age = 0;  public Person? parent = ();  private string email = \"default@abc.com\";  string address = \"No 20, Palm grove\"; };  @test:Config {} function testAssertObjectEquals() {  Person p1 = new;  Person p2 = p1;  test:assertExactEquals(p1, p2); }  @test:Config {} function testAssertObjectNotEquals() {  Person p1 = new;  Person p2 = new ();  test:assertNotExactEquals(p1, p2); }    Introduction of the @test:BeforeGroups and @test:AfterGroups functions  These two new annotations can now be used when writing tests with the Ballerina test framework.  import ballerina/io; import ballerina/test;  @test:BeforeGroups { value : [\"group1\"] } function beforeGroupsFunc() { \tio:println(“I’m a before groups function!”) }  @test:Config {} function testFunction() { \tio:println(“I’m a test function!”)  }  @test:AfterGroups { value : [\"group1\"] } function afterGroupsFunc() { \tio:println(“I’m a after groups function!”)  }   Introduction of the alwaysRun field to the @test:AfterSuite annotation  You can now specify alwaysRun : true|false in the @AfterSuite annotation, which enables running the @AfterSuite even if the @BeforeSuite function fails during the test execution. The default value is false.  import ballerina/io; import ballerina/test;   @test:BeforeSuite function beforeSuiteFunc() { \tio:println(\"I’m the before suite function\"); \tint a = 2/0; }  @test:AfterSuite {} function afterSuiteFunc1() { \tio:println(\"I will be run only if before suite function executes successfully.\"); }  @test:AfterSuite { alwaysRun:true } function afterSuiteFunc2() { \tio:println(\"I will be run even if the before suite function fails.\"); }   Code to Cloud  Azure Functions Support  Ballerina now supports writing serverless functions using the Azure Functions framework.  import ballerina/http; import ballerinax/azure.functions as af;  @af:Function public function fromHttpToQueue(af:Context ctx,  @af:HTTPTrigger {} af:HTTPRequest req,  @af:QueueOutput { queueName: \"queue1\" } af:StringOutputBinding msg)  returns @af:HTTPOutput af:HTTPBinding { \tmsg.value = req.body; \treturn { statusCode: 200, payload: \"Request: \" + req.toString() }; }   For more information, see and the .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview2/","name":"Swan Lake Preview 2","summary":"Table of contents      This release is the second preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.You can use the update tool to update to Ballerina ...","content":"/  /  / Swan Lake Preview 2  Swan Lake Preview 2  Table of contents Overview of Ballerina Swan Lake Preview 2 This release is the second preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.  You can use the update tool to update to Ballerina Swan Lake Preview 2 as follows.  For existing users:  If you are already using jBallerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the Update Tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 2.    ballerina dist pull slp2   However, if you are using a jBallerina version below 1.1.0, install via the .  For new users:  If you have not installed jBallerina, then download the to install.  Highlights   Support for resilient parsing  Improved support for immutability  Improved support to convert compatible values to and from JSON  Improved log API to support changing module log levels at runtime  Improved mocking API in the test framework  Improved Docker images using thin JAR   What’s new in Ballerina Swan Lake Preview 2  Language The language implementation is based on the .  Resilient parsing support Resilient parsing support has been added to the compiler. It is now capable of performing semantic validation for source code even when there are syntax errors.  Improvements related to immutability  readonly fields in the mapping constructor expression  A specific field (key-value pair or variable name) in a mapping constructor expression can now be marked as readonly. Such a field expects an immutable value and the field cannot be updated once the mapping value is constructed.  type Employee record {|  Details details;  string department;  float salary; |};  type Details record {|  string name;  int id; |};  public function main() {  string department = \"legal\";  Employee employee = {  readonly details: {  name: \"Amy\",  id: 112244  },  readonly department,  salary: 100.0  }; }   Attempting to update a field that was specified as a readonly field will result in an error.  employee.department = \"finance\"; // panics   If a constructor expression is used as a value with a readonly field, the constructed value will be an immutable value. The following evaluates to true.  employee.details.isReadOnly()   readonly as the contextually expected type for mapping and list constructor expressions  The readonly type can now be used as the contextually-expected type for mapping and list constructor expressions. This results in the creation of a record or an array value, which is immutable.  import ballerina/io;  type Details record {|  string name;  string author; |};  public function main() {  Details & readonly greatExpectations = {  name: \"Great Expectations\",  author: \"Charles Dickens\"  };  readonly item = {  details: greatExpectations,  categories: [\"Charles Dickens\", \"novel\"]  };  // Prints true. io:println(item is readonly & record {|  Details details;  [string, string] categories; |}); }   <readonly> casts to construct immutable values  A value can now be constructed with its read-only bit set (i.e., as an immutable value) by using a cast to <readonly> with the constructor expression. By definition, all the values used within the constructor expression should be immutable.  type Details record {|  string name;  string author; |};  public function main() {  Details details = <readonly> {  name: \"Great Expectations\",  author: \"Charles Dickens\"  }; }   Since details is created as an immutable value, the following check evaluates to true.  details.isReadOnly()  Passing arguments for required/defaultable parameters via the rest argument  Previously, the rest argument in a function/method call expression could only provide arguments for the rest parameter. A rest argument can now be used to provide arguments for required and/or defaultable parameters too.  public function main() {  // Arguments for `name`, `department`, and `id` parameters.  [string, string, int] details = [\"Amy\", \"legal\", 212124];  Employee e1 = createEmployee(...details);  // Arguments for `department`, `id`, and `access` parameters.  [string, int, string, string] detailsAndAccess = [\"HR\", 112233, \"L2\", \"L3\"];  Employee e2 = createEmployee(\"Jo\", ...detailsAndAccess); }  function createEmployee(string name, string department, int id = 1000,  string... access) returns Employee => {  name, id, department, access };  type Employee record {|  string name;  string department;  int id;  string[] access; |};   Improvements related to JSON compatibility  Three new methods have been introduced to the ballerina/lang.value module to facilitate converting to and from JSON. Additionally, the toJsonString method can now be called on anydata values.  The toJson method toJson converts a value of type anydata to json. This does a deep copy of the value and converts values that do not belong to json into values that do.  public function main() {  string[] arrString = [\"hello\", \"world\"];  json|error arrStringJson = arrString.toJson(); }   The toJsonString method  toJsonString converts a value of type anydata to a string that represents the value in the JSON format. It first converts the value to a JSON using toJson and then converts it to a string.  public function main() {  map<string> address = {  line1: \"Line1\",  line2: \"Line2\"  };  string adrString = address.toJsonString(); }   The fromJsonWithType method  fromJsonWithType converts a value of type json to a user-specified type. The implementation is similar to cloneWithType except that it also does the inverse of the conversions done by toJson.  type Student record {  int id;  string name; };  public function main() {  json studentJson = {\"id\": 3, \"name\": \"Pubudu\"};  Student|error student = studentJson.fromJsonWithType(Student); }   The fromJsonStringWithType method  fromJsonStringWithType converts a string in JSON format to a user-specified type. This method can be described as a combination of fromJsonString followed by fromJsonWithType.  type StringMap map<string>;  public function main() {  string str = \"{\\\"first_name\\\":\\\"Fname\\\", \\\"last_name\\\":\\\"Lname\\\"}\";  map<string>|error m = str.fromJsonStringWithType(StringMap); }   Standard Library  HTTP  The redirect client has been improved to support temporary and permanent redirects with the original request’s HTTP method. A new allowAuthHeaders field was introduced in the redirect configuration to get user consent before repeating sensitive data on subsequent requests.  Log  The new log:setModuleLogLevel function allows users to set the module log level through the Log API.  Config  The config:getAsArray and config:getAsMap functions now return immutable values. This way, the user can simply cast the returned value to the desired list type or mapping type without having to use cloneWithType().  Security    JWT signature validation with JWK has been improved by introducing a cache. This cache preloads the JWKs, and thereby, reduces the runtime latency added due to the HTTP call to the JWK endpoint when validating the signature.  An auth:InvocationContext record, which can be used as a data holder has been introduced. It can hold auth-related information such as authentication scheme, auth token, and authenticated user’s ID, claims, and scopes preserved for a single request-response flow.   WebSocket  The WebSocket client now supports cookies. A new field cookies has been introduced in the http:WebSocketClientConfiguration and http:WebSocketFailoverClientConfiguration records to specify the cookies.  Runtime API    The runtime:timeout function has been removed. The runtime:sleep function can be used as the alternative.   E.g., consider the following example, which uses the runtime:timeout function.  future<()> f1 = runtime:timeout(50);   This can now be done as follows:  future<()> f1 = start runtime:sleep(50);     The runtime:getProperty function has been removed. Java interoperability can be used as the alternative to access Java system properties.  The auth-related configurations have been moved out from the runtime:InvocationContext to the newly-introduced auth:InvocationContext.   Module organization  The following standard libraries were moved to Ballerina Central. Previously, these modules were packed in the Ballerina distribution. With this change, these libraries can now be released independently.   ballerina/encoding  ballerina/jwt  ballerina/websub  ballerinax/rabbitmq   Developer Tools  Test Framework  Improved Mocking API  Object Mocking  The syntax for initializing a mock object was improved to remove the cast.  Previous syntax:  http:Client mockHttpClient = <http:Client>test:mock(http:Client);   New syntax:  http:Client mockHttpClient = test:mock(http:Client);   Function Mocking  The mocking API now supports scoping and stubbing of mock functions that are declared for functions in imported modules. With the above support, the @MockFn {} and @Mock {} annotations have been unified and now all function mocks can be declared with the @Mock {} annotation.  With the improved mocking API, a function can be mocked as follows:  import ballerina/math; import ballerina/test;  @test:Mock {  moduleName : \"ballerina/math\",  functionName : \"absInt\" } test:MockFunction mock_absInt = new();  @test:Config {} public function testFunction() {  test:when(mock_absInt).thenReturn(100);  test:assertEquals(math:absInt(-5), 100); }   Deployment  By default, Docker images are now created using the thin JAR. Using the thin JAR improves the push and pull times significantly. Since layers are reused, disk space required to store thin JAR based images is less.  This can be changed to use the uber JAR by setting the uberJar field in the Docker or Kubernetes annotation to true.  Kubernetes annotations: @kubernetes:Deployment {  uberJar: true }   Docker annotations: @docker:Config {  uberJar: true }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview4/","name":"Swan Lake Preview 4","summary":"Table of contents      This release is the fourth preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.You can use the update tool to update to Ballerina ...","content":"/  /  / Swan Lake Preview 4  Swan Lake Preview 4  Table of contents Overview of Ballerina Swan Lake Preview 4  This release is the fourth preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.    Updating Ballerina  You can use the update tool to update to Ballerina Swan Lake Preview 4 as follows.  For existing users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 4.    ballerina dist pull slp4   However, if you are using a Ballerina version below 1.1.0, install via the .  For new users  If you have not installed Ballerina, then download the to install.  Highlights    Revised Ballerina object syntax, which differentiates the object type from the class, from which you can create object values.  Introducing isolated functions to achieve concurrency safety together with readonly values.  Introducing distinct object types offering the functionality similar to what is provided in nominal type systems.  Improvements to quoted identifiers to support arbitrary, non-empty strings as Ballerina identifiers.   What is new in Ballerina Swan Lake Preview 4  Language  The language implementation is based on the and the new .  Class definitions  Module-class definitions  With the introduction of module-class definitions, the type of the object and the implementation of the behavior of the object are separated. Module-class definitions describe both the type of the object and the behavior of that object whereas object-type definitions describe only the type of the object.  The abstract objects are now plain object-type definitions and the previous object-type definitions with implementations are now module-class definitions.  To migrate existing code easily, you can abstract this change by simply replacing type Obj object {...}; with class Obj {...}.  Previous syntax:  public type Obj object {  int i;  function init(int i) {  self.i = i;  } };   New syntax:  public class Obj {  int i;  function init(int i) {  self.i = i;  } }   Object-type descriptor  Object-type descriptors can be used to describe an object type.    Note: They cannot be used to create object values.   Similar to the previous abstract object, object-type definitions no longer support specifying the default values for fields.  To migrate existing abstract object-type definitions, you can simply remove the abstract keyword from the type definition.  Previous syntax:  type Obj abstract object {  function foo(int i); };   New syntax:  type Obj object {  function foo(int i); };   Object-constructor expressions  Object-constructor expressions can be used to define an object inline as opposed to referring to a pre-defined class with a new expression. The parameter list of an init method within an object constructor expression must be empty.  public function main() {  var ob = object { function foo() { // do something }  }; }   Object-constructor expressions also support a type reference in which the referenced type is included in the object type in the same way as in an object-type inclusion.  class RefClass {  int x;  function init(int y) {  self.x = y;  } }  var objectValue = object RefClass { function init() {  self.x = 4;  } };   Distinct objects  This release adds support for defining distinct object types. This provides a way to achieve an effect similar to nominal typing for objects within the Ballerina structural type system.  distinct class Student {  function getKind() returns string {  return \"Student\";  } }  distinct class Employee {  function getKind() returns string {  return \"Employee\";  } }  Student p = new (); Employee q = p; // error: incompatible types: expected 'Employee', found 'Student' // Sub-typing relationship is indicated by type inclusion of `Employee`. distinct class Manager {  *Employee;  function getKind() returns string {  return \"Manager\";  } }  Manager r = new (); Employee s = r; // This is allowed since ‘Manager’ is a distinct subtype of ‘Employee’    Final fields in objects  Classes and object-constructor expressions can define fields as final fields. A value can only be assigned to such a field during the object construction (i.e., via an initializer expression or in the init method). A final field of an object cannot be assigned a new value once the object is created.  class Controller {  final string id = \"default\";  final map<decimal> config;  int priority;   function init(map<decimal> config, int priority) {  self.config = config;  self.priority = priority;  } }     Note: Objects no longer allow read-only fields.   Isolated functions  A function that accesses mutable values only via its parameters can now be marked as an isolated function. Concurrency safety can be guaranteed when isolated functions are used with immutable values or by controlling the arguments passed to the isolated function.  isolated function addSum(int[] arr, int i, int j) {  arr.push(i + j); }   A function can be marked as isolated if it   accesses the global state only if it is immutable (i.e., variables that are implicitly or explicitly final and the type is a subtype of readonly (immutable values))  calls a function or a method only if that function or method is isolated  does not start new workers   Improved support for quoted identifiers  The quoted identifier feature has been improved by adding the support for extending the types of the characters that are allowed. This adds the possibility of using arbitrary, non-empty strings as identifiers. The quoted identifiers can be used with a ’ prefix and the following supported character sets.    Alphanumeric characters  Underscore  ASCII special characters with a preceding \\ escape character  The JVM-reserved character set is now supported by Ballerina through an encoding scheme  Unicode characters  Characters specified with hexadecimal Unicode code points (e.g., ` \\u{1234}`)   // Quoted identifiers in type names and field names. type 'Person_\\{name\\&ĀǤȆ\\} record {|  string 'first\\ name;  int 'ĀǤȆ; |};  // Quoted identifiers in function names. function 'get_ɱȅșșȧǧȅ_with\\#(int value) returns string {  return value.toString() + \" is numeric value\"; }  public function main() {  'Person_\\{name\\&ĀǤȆ\\} person = {'first\\ name: \"John\", 'ĀǤȆ: 25};   string message = 'get_ɱȅșșȧǧȅ_with\\#(5);   // Quoted identifiers with hexadecimal code points.  string 'unicode_\\u{2324} = \"John Doe\"; }   Subsequent initialization support for local final variables  Local final variables can now be defined without an initializer expression as long as they are initialized before they are referenced, similar to ordinary local variables. However, a value cannot be assigned to a final variable more than once.  map<int> lengths = {};  function addLength(string key, string|string[] value) {  final int length;   if value is string {  length = value.length();  } else if value.length() == 0 {  length = 0;  } else {  length = value[0].length();  }   lengths[key] = length; }   Handle errors at a single point Ballerina supports handling errors at a single place using the on fail clause. The on fail clause can be used optionally with statements such as while, foreach, do, transaction, retry, lock, and match.   do {  int parsedNum = check parse(\"12\");   // Parsing a random string will return an error. // Thereafter, the control is transferred to the `on fail` clause.  int parsedStr = check parse(\"invalid\");   var res = commit;  } on fail error e {  io:println(\"Error occurred during parsing: \", e.message());  }    The fail statement  Executing a fail Statement will cause the control flow to transfer to the on fail clause of the nearest lexically-enclosing statement that has an on fail clause. If there is no on fail clause, then it breaks the current execution and returns an error.   do {  if (accountID < 0) {  InvalidAccountIDError invalidAccountIdError = InvalidAccountIDError(INVALID_ACCOUNT_ID, accountID = accountID);  fail invalidAccountIdError;  } else if (accountID > 100) { AccountNotFoundError accountNotFoundError = AccountNotFoundError(ACCOUNT_NOT_FOUND, accountID = accountID);  fail accountNotFoundError;  }  // The type of `e` should be the union of the error types that could  // result in transferring control from the `do` statement.  } on fail InvalidAccountIDError|AccountNotFoundError e {  io:println(\"Error occurred: \", e.message(),\", Account ID: \", e.detail()[\"accountID\"]);  }   Predeclared module prefixes  The module prefix t (which could be boolean, decimal, error, float, future, int, map, object, stream, string, table, typedesc, or xml) has been predeclared as referring to the lang.t lang library module now.  Such modules can now be used without explicitly importing them.  public function main() {  int max = 'int:max(311, 22, 41234); }   Improved lang library functions  Several changes and improvements have been introduced to the ballerina/lang.value and ballerina/lang.array lang library modules.  Improved lang library support for JSON  Two new functions (i.e., fromJsonDecimalString() and fromJsonFloatString()) have been introduced to support different numeric types when converting (parsing) a string as json. The fromJsonDecimalString() function converts numeric values to decimal whereas the fromJsonFloatString() function converts them to float.  The fromJsonString() function now converts numeric values as follows.  If the numeric value starts with the negative sign (-) and is numerically equal to zero (0), it is converted to float -0.0. If the numeric value is syntactically an integer, it is converted to an int value. All other numeric values are converted to decimal values.  Changes to toString()  The toString() function now performs a direct conversion of the value to a string rather than producing a string that describes the value. The details of the conversion are specified by the ToString abstract operation defined in the Ballerina Language Specification using the direct style.  If a student is a record value defined as follows,  Student student = {  name : \"Anne\",  address : (),  age : 23,  grades : [\"A\", \"A+\", \"B\"] };   evaluating student.toString() results in a different output as follows.  Previous result:  name=Anne address= age=23 grades=A A+ B   New result:  {\"name\":\"Anne\",\"address\":null,\"age\":23,\"grades\":[\"A\",\"A+\",\"B\"]}   Improved lang.array:sort() function  This release supports an improved ballerina/lang.array:sort() function. Now, you can specify the direction in which the sorting should be done and a key function, which returns a value that is used to order the members when sorting.  The sort() function returns an array consisting of the members of the original array in the sorted order. If the member type of the array is not ordered, then the key function must be specified.  string[] cars = [\"Ford\", \"Toyota\", \"Mitsubishi\", \"BMW\", \"Tesla\"]; string[] sortedCars = cars.sort(array:DESCENDING, car => car.length());   Runtime  jBallerina Runtime APIs  The jBallerina runtime APIs were moved to the org.ballerinalang.jvm.api package and new APIs were introduced. The following APIs can be used to manage various runtime constructs.    Class  Usage  BValueCreator  Create ballerina value instances.  BErrorCreator  Create ballerina error instances.  BExecutor  The entry point from the server connector side to the Ballerina side. After finding the resource, server connector implementations can use this API to invoke the Ballerina engine.  BRuntime  The external API to be used by the interop users to control the Ballerina runtime behavior.  BStringUtils  Common utility methods used for string manipulation.  Asynchronous Java interoperability  Calling async Java methods from Ballerina has been formalized using a new API. Previously, this was achieved by setting internal values to the Ballerina Strand object. With this change, any Java extern method accepting BalEnv as the first parameter, will be given an instance of the execution context.  The BalEnv execution context instance provides a markAsync method, which will mark the current Java method as asynchronous making the Ballerina runtime wait on it in a non-blocking way.  Ballerina Intermediate Representation (BIR) optimizations and improvements  The BIR has been optimized to reuse temporary variables inside Ballerina functions. This reduces the number of instructions in the byte-code representation contributing to reductions in method sizes and slightly-better runtime performance.  Also, The BIR binary format is now represented in a structured form using the . Kaitai Struct Language is a commonly-used approach to define binary formats. With the structured format, the BIR now can be easily understood and validated, which will help any user who wants to understand and work on generating different target executable code (e.g., generating LLVM-based executable code by reading the BIR).  The BIR binary structure is represented as the .  The BIR is now improved by including local variable scope information. With this support, the debugging view of local variables within functions has been improved to show correct-scoped variables during the debugging sessions.  Along with the scoping, BIR now contains a new variable kind named SYNTHETIC, which identifies the variables generated at the de-sugar phase. These are skipped when adding meta-data so that generated variables do not appear in the scope with a debug hit.  Standard Library  Re-align organization names of the connectors.    Modules  Old Organisation  New Organisation  mysql  ballerina/mysql  ballerinax/mysql  kafka  ballerina/kafka  ballerinax/kafka  rabbitmq  ballerina/rabbitmq  ballerinax/rabbitmq  nats  ballerina/nats  ballerinax/nats  Developer Tools  The OpenAPI Tool  OpenAPI CLI  The behavior of the OpenAPI CLI command was changed to make it easier to use. Now, you can generate Ballerina code from an OpenAPI contract and vice versa.  OpenAPI to Ballerina  $ ballerina openapi -i <contract> -o <output path>     You can give the contract file in the YAML or JSON format.  The above command generates both the service and client stubs.  The command will give an output of three files containing the service, client and schema.   Command output example:  $ ballerina openapi -i petstore.yaml The service generation process is complete. The following files were created. -- petstore-service.bal -- petstore-client.bal -- schema.bal     If you are interested in creating only a service, you can use the mode option to give the required mode. The mode can be a service or a client.   $ ballerina openapi -i <contract> --mode (service | client ) -o <output Path>     You can specify the output path with the -o option.   $ ballerina openapi -i <contract> --service-name <service name> -o <output Path>     If you are interested in creating a service with resources having a specific tag or an operationId, you can do the following.   $ ballerina openapi -i <contract> --tags <tags> -o <output Path> $ ballerina openapi -i <contract> --operations <operationIds> -o <output Path>   Ballerina to OpenAPI  $ ballerina openapi -i <ballerina service file> -o <output path> The service name is not mandatory and you can give the service name if you want to document a specific service. Otherwise, it will generate all the services that are included in the Ballerina source file.  $ ballerina openapi -i <ballerina service file> --service <service Name> -o <output path>   Improvements related to code actions  Azure Functions  Fix for .  AWS Lambda  Added domain-specific event types support.  Code formatting  A new formatter is introduced with a limited support for language features.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview5/","name":"Swan Lake Preview 5","summary":"Table of contents      This release is the fifth preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.You can use the update tool to update to Ballerina ...","content":"/  /  / Swan Lake Preview 5  Swan Lake Preview 5  Table of contents Overview of Ballerina Swan Lake Preview 5  This release is the fifth preview version of Ballerina Swan Lake. This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard libraries, and developer tooling.    Updating Ballerina  You can use the update tool to update to Ballerina Swan Lake Preview 5 as follows.  For existing users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 5.    ballerina dist pull slp5   However, if you are using a Ballerina version below 1.1.0, install via the .  For new users  If you have not installed Ballerina, then download the to install.  Highlights    Migration from JDK 8 to JDK 11  Introduction of isolated objects for class definitions or object-type descriptors  Replacement of XML functional constructors by lang lib functions  Unification of the object field scope and object method scope into a single scope  Ability to assign a simple JSON value to a variable of the same type without casting  Improvements to the lang library functions  Improved HTTP client remote method API with data-binding support  Improved SQL procedure call API  Misfire policy support for tasks  Improved code formatting support for all the language features   What is new in Ballerina Swan Lake Preview 5  Language  Isolated objects  A class definition or an object-type descriptor can now be marked as isolated. All fields of an isolated object that are not final or are not a subtype of readonly or isolated object {} have to be private fields.  The methods of an isolated object that access such fields can only refer to self within a lock statement, which ensures that there is no data race in accessing mutable state. If a method accesses such a field, additional rules apply to how values are transferred in and out in order to ensure that there are no references into the object’s mutable storage except via isolated objects. The initial value expressions of the fields also need to ensure the same.  type Coordinates record {|  int latitude;  int longitude; |};  isolated class Hotels {   private map<Coordinates> hotels = {};   isolated function add(string name, Coordinates coordinates) {  lock {  self.hotels[name] = coordinates.clone();  }  }   isolated function getCoordinates() returns map<Coordinates> {  lock {  return self.hotels.clone();  }  } }   An isolated function can also access a final variable if the type of the variable is a subtype of isolated object {}.  final Hotels hotels = new;  isolated function getCoordinates() returns Coordinates[] => hotels.getCoordinates().toArray();   Lang lib functions to replace XML functional constructors  XML functional constructor syntax has been removed. In place of XML functional constructors, 'xml:createXXX functions should be used.  Disallowed syntax 'xml:Element element = 'xml:Element(\"elem\"); 'xml:Comment comment = 'xml:Comment(\"comment content\"); 'xml:ProcessingInstruction proceInstruc = 'xml:ProcessingInstruction(\"DONOT\", \"print this\"); 'xml:Text text = 'xml:Text(\"this is a character sequence\");   Valid syntax 'xml:Element element = 'xml:createElement(\"elem\"); 'xml:Comment comment = 'xml:createComment(\"comment content\"); 'xml:ProcessingInstruction proceInstruc = 'xml:createProcessingInstruction(\"DONOT\", \"print this\"); 'xml:Text text = 'xml:createText(\"this is a character sequence\");   Unified object method scope and object field scope  Object field scope and object method scope have been unified into a single scope. This means that it is no longer possible to have fields and methods with the same name.  With this change, object methods can be accessed similar to object fields and the reference to self is captured in the resulting function pointer.  class Accumulator {  int i;   function init(int i) {  self.i = i;  }   function accumulate(int acc) {  self.i = self.i + acc;  }   function get() returns int {  return self.i;  } }  public function main() {  Accumulator accumulator = new(0);  var acc = accumulator.accumulate; // access a method as a field  var getVal = accumulator.get;  acc(1); // similar to calling accumulator.accumulate(1);  acc(2);  int val = getVal(); }   Improvement in accessing simple values in a JSON  A non-structural value (i.e., simple value) in a JSON object can now be directly assigned to a variable of the same type without casting.  For this, the field access expression should be used with the check expression. The simple value should belong to one of the types: (), int, float, decimal, string, or boolean.  public function main() returns error? {  json j1 = {name: \"Anne\", age: 20, marks: {math: 90, language: 95}};  string name = check j1.name;  int age = check j1.age; }   Improved lang library functions  Several changes and improvements have been introduced to the ballerina/lang.value lang library module.  New ensureType function  This method can be used to check if a value belongs to the given type similar to the type cast expression. However, instead of panicking, this method returns an error if the type test fails.  New toBalString() and fromBalstring() functions  Two new functions namely toBalString() and fromBalstring() have been introduced to roundtrip between anydata and Ballerina expression-like string. The toBalString() function converts a Ballerina value to a string that looks like a Ballerina expression (expression style).  The fromBalstring() function parses and evaluates a string produced by toBalString() when applied to an anydata value. The details of the conversion performed in toBalString() are specified by the ToString abstract operation defined in the Ballerina Language Specification using the expression style.  More isolated lang library functions  These include lang library functions that accept an argument of a function type. With these functions, a parameter, which is of a function type may be annotated with the @isolatedParam annotation.  public isolated function forEach(Type[] arr, @isolatedParam function(Type val) returns () func) returns () = external;   When such a function is called in a context where an isolated call is expected, the argument passed for a parameter that is annotated with @isolatedParam should also be an isolated function.  int total = 0;  function sum(int i) {  total += i; }  isolated function validate(int i) {  if i > 100 {  panic error(string `Invalid Value: ${i}`);  } }  function arraySum() {  int[] x = [1, 2, 3];   // Since `arraySum` is not `isolated`, non-isolated // function `sum` can be passed as the argument.  x.forEach(sum); }  isolated function validateArray() {  int[] x = [1, 2, 3];   // Since `validateArray` is `isolated`, the argument // should also be an `isolated` function.  x.forEach(validate); }   Runtime  The Ballerina runtime Java API package name has been changed from org.ballerinalang.jvm to io.ballerina.runtime. A new io.ballerina.api.TypeCreator API is introduced to create Ballerina types at runtime.  Standard Library  HTTP client remote method API improvement with data-binding support  Response payload binding functionality is provided for an HTTP client by returning the payload according to the targetType defaultable parameter that is mentioned in the remote method.  Previous syntax: http:Response|error res = clientEP->post(\"/path\", req);   New syntax: http:Response|http:Payload|error res = clientEP->post(\"/path\", req, json); // or json payload = <json> check clientEP->post(\"/path\", req, json);   SQL procedure call API improvement  The SQL data type of the Out Parameter can now be defined in the SQL procedure call API, thus, eliminating the use of metadata to configure Out Parameter types.  Previous syntax: sql:OutParameter filterId = new;   New Syntax sql:IntegerOutParameter filterId = new;   Misfire policy support for tasks  The task module now supports the misfire policy. A new misfirePolicy field has been introduced in the task:TimerConfiguration and task:AppointmentConfiguration to specify the policy.  Developer Tools  Code formatting  Improved formatting support for all the language features. The new formatter also supports:    Range formatting  Line wrapping   Known Issues    The standard library module (ballerina/websub) is not working with Swan Lake Preview 5.  The standard library module (ballerina/socket) can only be built offline (i.e., with the --offline parameter) with Swan Lake Preview 5.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview6/","name":"Swan Lake Preview 6","summary":"Table of contents      This is an internal-only release.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your browser.  ...","content":"/  /  / Swan Lake Preview 6  Swan Lake Preview 6  Table of contents Overview of Ballerina Swan Lake Preview 6  This is an internal-only release.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview7/","name":"Swan Lake Preview 7","summary":"Table of contents      This release is the seventh preview version of Ballerina Swan Lake. It is the successor of the fifth preview version (SLP5) and SLP6 is an internal-only release.This release includes a new set of language features along with improvements and bug fixes to the compiler, ...","content":"/  /  / Swan Lake Preview 7  Swan Lake Preview 7  Table of contents Overview of Ballerina Swan Lake Preview 7  This release is the seventh preview version of Ballerina Swan Lake. It is the successor of the fifth preview version (SLP5) and SLP6 is an internal-only release.  This release includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard library, and developer tooling.    Updating Ballerina  You can use the update tool to update to Ballerina Swan Lake Preview 7 as follows.  For Existing Users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 7.    ballerina dist pull slp7   However, if you are using a Ballerina version below 1.1.0, install via the .  For New Users  If you have not installed Ballerina, then download the to install.  Highlights    Introducing Ballerina Packages  Support for configuring module-level, basic variables at the program execution  Ability to mark module-variable declarations with an initial value expression as isolated  Ability to use the isolated qualifier with an object-constructor expression to construct an isolated object  Support to mark an object-type definition as a distinct object type  Allow using the object constructor to create distinct objects  Support to register and deregister a dynamic listener at the runtime  Introduction of the new runtime APIs  Revamp of the File/Filepath modules  Introduction of new high-level APIs to provide I/O operations  Introduction of a new code-action Add Type Cast  Revamp of the code-action extension APIs  Introduction of code to cloud (c2c) to simplify deploying Ballerina code in the cloud   What is new in Ballerina Swan Lake Preview 7  Ballerina Packages  With this release we will be introducing Ballerina Packages. Ballerina Package is a bundle that consist of one or more Ballerina modules. Going forward, the Ballerina Package will be used to share Ballerina libraries.  With the introduction of Ballerina packages Ballerina project structure and build tools has also been changed. Please refer to the page for more details.  For Swan Lake releases Ballerina Central will support users to push and pull Ballerina Packages. Going forward It will not be possible to push individual modules with swan lake releases. With the preview releases you have the ability to push and pull Ballerina Packages to/from Central. However the Packages pushed using preview releases will be cleared when we release the swan lake GA release.You can use the existing Ballerina Central key to push Packages.  Language  Support for Configurability  Now, Ballerina supports configuring module-level, basic variables at the program execution. The value provided in the program will be overridden by the value specified in the configuration file. These variables can be initialized using the configurable keyword in the following ways.  A configurable variable that is defined with ? as the initializer expression requires a value to be specified for such a variable in the configuration file.  configurable string hostName = ?;   A configurable variable that is defined with any other initializer expression can be overridden by a value specified in the configuration file. If a value is not provided in the configuration file, the initializer expression is used.  configurable string hostName = “0.0.0.0”;   Currently, configuration is supported via a TOML (v0.4.0) file named configuration.toml. This file should be located in the current directory. The format of the configuration.toml file is as follows.  [orgName.pkgName.submoduleName] # The above toml table specification is not needed for single file execution intVar = 24 floatVar = 4.8 stringVar = \"hello world\" booleanVar = false   Currently, Ballerina supports configurable variables of the types int, float, boolean, and string. Future versions will add support for configurable variables of any type that is a subtype of readonly&anydata.  Isolated Variables  Module variable declarations with an initial value expression can now be marked as isolated. An isolated variable can be accessed only within a lock statement.  Similar to isolated objects, isolated variables are also considered as isolated roots, which guarantee that their mutable state is only reachable via the isolated root. As with isolated objects, when an isolated variable is accessed within a lock statement, additional rules apply to how values are transferred in and out of the lock statement.  An isolated variable can also be accessed in an isolated function.  type Coordinates record {|  decimal latitude;  decimal longitude; |};  isolated map<Coordinates> cities = {};  isolated function getLocation(string city) returns Coordinates? {  lock {  return cities[city].clone();  } }  isolated function resetCities() {  lock {  cities = {};  } }   Isolated Object Constructor Expressions  Several changes have been introduced to how an object constructor expression can construct an isolated object. Now, the isolated qualifier can be used with an object constructor expression to construct an isolated object.  class Identifier {  int id = 1; }  public function main() {  Identifier nonIsolatedIdentifier = new;   Identifier isolatedIdentifier = isolated object {  final int id = 1;  private string name = \"default\";   function updateName(string name) {  lock {  self.name = name;  }  }  };   boolean b1 = <any> nonIsolatedIdentifier is isolated object {}; // false  boolean b2 = <any> isolatedIdentifier is isolated object {}; // true }   An object-constructor expression also constructs an isolated object if all of the fields of the object constructor expression are final and the types of the fields are subtypes of readonly or isolated object {}.  isolated class Identifier {  final int i;  private int j;   isolated function init(int i, int j) {  self.i = i;  self.j = j;  } }  public function main() {  var ob = object { // Constructs an `isolated` object.  final int a = 1000;  final Identifier b = new (1, 2);  };   isolated object {} isolatedOb = ob; // Now valid. }   Support for Distinct Objects  Distinct Object Type  An object type definition can now define a distinct object type.  type Circle distinct object {  int x;  int y;  int r; };  type Color [int, int, int];  class ColoredCircle {  *Circle;  Color color;   function init(int x, int y, int r, Color color) {  self.x = x;  self.y = y;  self.r = r;  self.color = color;  } }  class ColoredCircleLookAlike {  int x;  int y;  int r;  Color color;   function init(int x, int y, int r, Color color) {  self.x = x;  self.y = y;  self.r = r;  self.color = color;  } }  Circle c = new ColoredCircle(0, 0, 0, [123, 100, 100]); Circle d = new ColoredCircleLookAlike(0, 0, 0, [123, 100, 100]); // Not allowed.   The ColoredCircle type is a distinct type that is a subtype of the Circle distinct object type even though ColoredCircle is not marked as a distinct class.  Although ColoredCircleLookAlike is structurally a subtype of the Circle type, since Circle is a distinct type and ColoredCircleLookAlike does not include it via object type inclusion,ColoredCircleLookAlike is not a subtype of Circle.  Distinct Object Constructor  If no type reference is provided in the object constructor, the contextually-expected type must be definite and the type-ids of the constructed object will be the type-ids of the contextually-expected type. This allows using the object constructor to create distinct objects.  Runtime  Support for DynamicListener  A dynamic listener can be registered and deregistered at runtime as follows.  ModListener listenerVar = new(); // Where ModListener is a DynamicListener runtime:registerListener(listenerVar); runtime:deregisterListener(listenerVar);   These methods and the definition of DynamicListener have been added to the new lang.runtime module.  public type DynamicListener object {  public function __start() returns error?;  public function __gracefulStop() returns error?;  public function __immediateStop() returns error?; };   New Runtime APIs  The io.ballerina.runtime.api. package will only be exposed to the outside. The runtime API package and its sub packages will contain the required APIs to handle the runtime constructs as follows.    Package  Description  io.ballerina.runtime.api.creators  Provides APIs to create runtime types, values, and errors.  io.ballerina.runtime.api.utils  Provides APIs to manage XML, JSON, string, and type-related operations.  io.ballerina.runtime.api.types and io.ballerina.runtime.api.values  Holds the Ballerina runtime API types and values.  io.ballerina.runtime.api.Environment  Interop functions can have an Environment parameter as the first parameter. This provides APIs to get the current module, strand ID, strand name, and strand metadata. Also, with the Environment instance, you can set and get the strand local properties.  io.ballerina.runtime.api.Runtime  The Environment also provides an instance of the current runtime class, which will contain APIs to invoke Ballerina object functions.  io.ballerina.runtime.api.*  Contains Future, Module, PredefinedTypes, and TypeTags classes to handle the other runtime constructs.  None of the Ballerina runtime internal exceptions will be exposed. The BError class should be used to handle Ballerina runtime errors. The io.ballerina.runtime.api.creators.ErrorCreator class provides the required APIs to create runtime errors.  Standard Library  Revamp File and Filepath Modules  The file and filepath APIs have been revamped in this release. A summarized list of the changes done is as follows.    The file and filepath modules have been merged together. There will be no filepath module anymore.  Some APIs have been removed.   From filepath - extension, getPathSeparator, getPathListSeparator, isReserved, and matches  From file - exists, tempDir  The implementation of some APIs has been modified.   From filepath - normalize  From file - createDir, remove, copy, readDir, getMetaData (earlier getFileInfo)  Some new APIs have been introduced.   createTemp - to create a temporary file in either the default temp directory of the OS or in a specific directory.  createTempDir - to create a temporary directory as above.  test - checks if a file/directory exists, readable, writable, etc.  Improved IO Module  The new high-level APIs below were introduced to provide I/O operations.    Added a new set of APIs to read from files supporting different data types.   E.g., io:fileReadBytes, io:fileReadJson, io:fileReadCsv, and io:fileReadXml  Added a new set of APIs to read files as streams.   E.g., io:fileReadBlocksAsStream, io:fileReadLinesAsStream, and io:fileReadCsvAsStream  Language Server    Introduced a new code-action Add Type Cast to add a typecast when variable assignment fails due to incompatible types.   Before execution:  int myInt = 1.1;  int myInt = getFloat();    After execution:  int myInt = <int>1.1;  int myInt = <int>getFloat();   The code-action extension APIs have been revamped in this release. A summarized list of changes is as follows.   The MatchedNode, matchedSymbol, and matchedExprType for the cursor position are available now through the PositionDetails construct in the CodeActionContext.  Listing the priorities can be set for the code-actions now (lower the number, greater the priority).  Code to Cloud    Introduced code to cloud (c2c) to simplify the experience of developing and deploying Ballerina code in the cloud. Code to cloud builds the containers and required artifacts by deriving the required values from the code without using any annotations.   import ballerina/http;  import ballerina/c2c as _;   service hello on new http:Listener(9090) {  resource function sayHello(http:Caller caller, http:Request req) returns error? {  check caller->respond(\"Hello, World!\");  }  }   Removed the Kubernetes module and replaced it by the c2c module.  Breaking Changes    It is no longer possible to specify the version in an import declaration. A specific version can be imported by specifying the package dependency along with the version in the Ballerina.toml file.   [[dependency]]  org = \"ballerina\"  name = \"stringutils\"  version = \"0.5.2\"  As the initial step of upcoming changes for the error detail, the detail type descriptor of an error type descriptor can no longer be a closed record.  The Kubernetes module is removed and replaced by the c2c module.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/downloads/swan-lake-release-notes/swan-lake-preview8/","name":"Swan Lake Preview 8","summary":"Table of contents      This release is the eighth preview version of Ballerina Swan Lake. It includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard library, and developer tooling.You can use the update tool to update to Ballerina Swan ...","content":"/  /  / Swan Lake Preview 8  Swan Lake Preview 8  Table of contents Overview of Ballerina Swan Lake Preview 8  This release is the eighth preview version of Ballerina Swan Lake. It includes a new set of language features along with improvements and bug fixes to the compiler, runtime, standard library, and developer tooling.    Updating Ballerina  You can use the update tool to update to Ballerina Swan Lake Preview 8 as follows.  For Existing Users  If you are already using Ballerina, you can directly update your distribution to the Swan Lake channel using the . To do this, first, execute the command below to get the update tool updated to its latest version.    ballerina update   Next, execute the command below to update to Swan Lake Preview 8.    ballerina dist pull slp8   However, if you are using a Ballerina version below 1.1.0, install via the .  For New Users  If you have not installed Ballerina, then download the to install.  Highlights    Ability to use \\ to escape the special characters in an identifier without specifying the initial quote  Introduction of included record parameters  Introduction of service typing changes basing services on objects  Extension of Ballerina transaction capabilities to define transactional resource functions and transactional remote functions  Improvements to the HTTP, Log, Email, and WebSub Standard Library modules  Introduction of the new GraphQL, NATS Streaming (STAN), UUID, and WebSocket Standard Library modules   What is new in Ballerina Swan Lake Preview 8  Language  Support Identifier Escapes Without an Initial Quote  Now, \\ can simply be used to escape the special characters in an identifier without specifying the initial quote. For example, both the formats below are supported now.  int a\\-b; int 'a\\-b;   Included Record Parameters  Included record parameters can be specified as *T P in which T denotes a record type descriptor and P denotes the name of the parameter.  An included record parameter is similar to a required parameter, but it also allows the caller of the function to specify the value for a field of the record type as a named argument using the field’s name, as if it had been declared as a parameter.  The names of the fields in the record type of an included record parameter must be distinct from each other and also from the names of the other parameters, unless it is an optional field of type never.  A named argument in a function call can correspond to the fields of an included record parameter in two different ways.    Being relevant to a field of the included recorded parameter, which is not of the never type.   import ballerina/io;  type Student record {  string firstName;  string lastName?; };  function printStudentDetails(int admissionNo, *Student student) {  string name = student.firstName;  string? lastName = student?.lastName;  if lastName is string {  name += string ` ${lastName}`;  }  io:println(\"Admission No: \", admissionNo, \", Student Name: \", name); } public function main() {  printStudentDetails(1001, firstName = \"Peter\");  printStudentDetails(1002, firstName = \"Anne\", lastName = \"Doe\"); } Being relevant to a record rest descriptor of an included record parameter that is of an open record type. The following conditions should be satisfied for this.   In the parameter list, there should be only one included record parameter that is of an open record type.  The open record type must disallow fields of the same names as the other parameters and individual field descriptors of the other included record parameters, by including optional individual field descriptors of the type never. In addition to these optional individual field descriptors, there should not be any other field descriptors in this record type.  import ballerina/io;  type Grades record {|  never math?;  never physics?;  int...; |};  function printAverage(int math, int physics, *Grades grades) {  int totalMarks = math + physics;  int count = grades.length() + 2;  foreach int grade in grades {  totalMarks += grade;  }  io:println(\"Average: \", totalMarks/count); }  public function main() {  printAverage(90, 85);  printAverage(85, 85, chemistry = 75);  printAverage(75, 85, chemistry = 90, zoology = 80); }   Service Typing Changes  Services are now based on objects. The service declaration syntax below is mere syntactic sugar for creating a new instance of a service class and then attaching it to a listener. With this change, the path that the service should serve on can be provided in the service-declaration syntax. This was previously provided using an annotation.  Previous Syntax  import ballerina/http;  service hello on new http:Listener(9090) {   resource function sayHello() returns error? {   } }   New Syntax  import ballerina/http;  service [/optional_base_path] on new http:Listener(9090) {   resource function get sayHello() returns string {   } }     Note: There is no longer a service variable name as hello in the first example. Since services are objects, they can contain fields and regular methods. In addition to that, services can contain remote methods and resource methods.   Resource methods are defined as follows:  resource function resource-method-name resource-path () { }    Resource methods do not have a method name similar to a regular method.  The resource-method-name informs the listener of the operations this resource allows. For example, in the HTTP listener, the resource-method-name maps to the HTTP methods such as GET or PUT.  The resource-path is the path in which this resource resides within the service. You can use . as the resource-path to indicate the path /.   A service declared using the service-declaration syntax cannot be referred to using an identifier anymore. Instead, you need to use an object constructor prepended by the service keyword to declare a service object or create a new instance of a service class.  service object { } hello = service object {  string message = \"Hello\";   resource function get sayHello() returns string {   } }  listener http:Listener l = new (7000); string[] basePath = [\"/\"]; // service base path: / l.attach(hello, basePath);   service class HelloService {  string message;  resource function get sayHello() returns string {   }   function init(string message) {  self.message = message;  } }  var hello = new HelloService(\"Hello\"); listener http:Listener l = new(7000); string[] basePath = [\"hello\", \"path\"]; // service on \"/hello/path\" l.attach(hello, basePath);   Listener Object  Listener is no longer defined in ballerina/lang.object lang-library, now it is a compiler known internal type. A type is a listener object type if it is a subtype of the object type Listener<T,A>, for some type T that is a subtype of service object {} and some type A that is a subtype of string[]|string|().  The object type Listener<T,A>, is described by the following object type descriptor:  object {  public function attach(T svc, A attachPoint) returns error?;  public function detach(T svc) returns error?;  public function start() returns error?;  public function gracefulStop() returns error?;  public function immediateStop() returns error?; }   Transactional Services  Ballerina transaction capabilities have been extended to services. Now, you can define transactional resource methods and transactional remote methods. These methods will be participants of global distributed transactions. Infection and agreement protocols are implemented based on the Ballerina distributed transaction protocol.  By defining services as participants, all services work as a single unit of work. If any of the services fail, the whole transaction will be reverted and if all the services are successfully called, the transaction will be completed and committed successfully.  Defining Transactional Resource Methods in a Service  transactional resource function get message(http:Caller caller, http:Request req) {  http:Response res = new;  callSomeService(res); callAnotherService(res);  checkpanic caller->respond(res); }   Defining Transactional Remote Methods in a Client Object  transactional remote function callMyFirstService() returns @tainted any|error {  return self.httpClient1->get(\"/echo/message\"); }  transactional remote function callMySecondService() returns @tainted any|error {  return self.httpClient2->get(\"/user/history\"); }   Calling the Service  transaction {  var res1 = client->callMyFirstService();  var res2 = client ->callMySecondService();  var x = commit;  if (x is error) {  // error code  } else {  // success code  } }   Standard Library  HTTP Module Changes  Service Declaration    Basepath field has been removed from the ServiceConfig annotation. Use the absolute resource path that begins with / as the basePath which is optional and defaults to / when not specified.  The service type can be added as http:Service, which is optional after the service keyword.   Previous Syntax  @http:ServiceConfig {  basePath: “hello” } service myService on new http:Listener(9090) {  }   New Syntax  service http:Service /hello on new http:Listener(9090) {  }   Resource Method Declaration    Use the resource method name to specify the HTTP method to support instead of the methods field of the ResourceConfig annotation (e.g., get).  Use default as the resource method name when the resource has to support all methods including standard HTTP methods and custom methods (e.g., the passthrough/proxy use case).  The resource path segment represents the path as the path field of the ResourceConfig has been removed.  Use . to specify the resource path segment if the path needs to be set as /.  Path params are specified in the resource path segment within square brackets along with the type. The supported types are string, int, float, boolean (e.g., path/[string foo]).  Resource signature parameters are optional. Even the Caller and Request are optional and not ordered.  Query param binding support is added. The supported types are string, int, float, boolean, decimal, and the array types of the aforementioned types. The Query param type can be nilable (e.g., (string? bar)).  Rest param support is added. It can be used as a wildcard path segment to accept requests to multiple different paths. Earlier it was used as /* and now it can be specified as [string… s] in which s is accessible within the resource.  Use the @http:Payload {} annotation to denote the data binding param in the resource signature as the body field of the ResourceConfig has been removed.   service http:Service /mytest on new http:Listener(9090) {  resource function post foo/[int id]/bar/[string... extra](string? bar, http:Caller caller, @http:Payload {} json p) {  // [int id] is a path param  // [string... extra] is a rest param  // string? bar is a query param  // json p is the request payload  } }   Log Module Changes    Log levels are reduced to INFO and ERROR. There will be no user configuration to control the log level. All the logs will be printed to the standard error stream.  There are only two APIs to log messages as follows.   Log INFO messages  log:print(\"something went wrong\", id = 845315);   Output:  time = 2019-08-09 11:47:07,342 module = \"myorg/hello\" message = \"something went wrong\" id = 845315    Log ERROR messages  log:printError(\"something went wrong\", err = e, id = 845315);   Output:  time = 2019-08-09 11:47:07,342 module = \"myorg/hello\" message = \"something went wrong\" error = \"invaild operation\" id = 845315   The API supports passing any number of key/value pairs along with the message.  Log messages are printed following the LogFMT standards.   Email Module Changes  The methods related to sending and receiving emails were renamed. The Listener API was divided into the POP and IMAP protocols.  Client Changes    The email:Email definition is changed to email:Message.  The read method of the email:ImapClient, email:PopClient, and email:Listener (i.e., the new email:PopListener and email:ImapListener) are changed to receiveEmailMessage.   Service Declaration    The email:Listener is split into the email:PopListener and email:ImapListener. Therefore, the protocol field is removed from the new protocol-specific listeners. The email:PopConfig or email:ImapConfig that was used as a field for the email:Listener is not required for new the API implementation. The protocol configuration-related fields are made parts of the new listeners.  The resource methods are changed to remote methods in the new listener APIs.  The service name is given as a string with the new Ballerina language changes.  The onMessage method of the email:Listener (i.e., the new email:PopListener and email:ImapListener) is changed to onEmailMessage.  The pollingInterval field of the email:Listener is changed to pollingIntervalInMillis in new listener APIs. That makes it consistent with other Ballerina modules, which have time durations configured in milliseconds.   A sample POP3 listener is given below.  Previous Syntax  email:PopConfig popConfig = {  port: 995,  enableSsl: true };  listener email:Listener emailListener = new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  protocol: \"POP\",  protocolConfig: popConfig,  pollingInterval: 2000 });  service emailObserver on emailListener {   resource function onMessage(email:Email emailMessage) {   }   resource function onError(email:Error emailError) {   }  }   New Syntax  listener email:PopListener emailListener = new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  pollingIntervalInMillis: 2000,  port: 995,  enableSsl: true });  service \"emailObserver\" on emailListener {   remote function onEmailMessage(email:Message emailMessage) {   }   remote function onError(email:Error emailError) {   }  }   WebSub Module Changes    The base path is removed from the SubscriberServiceConfig annotation.  The onNotification and onIntentVerification resources are converted to remote methods.   Previous Syntax  @websub:SubscriberServiceConfig {  path: \"/websub\",  target: [\"http://localhost:9191/websub/hub\", \"http://websubpubtopic.com\"] } service websubSubscriber on new websub:Listener(8181) {  resource function onIntentVerification(websub:Caller caller, websub:IntentVerificationRequest request) {}  resource function onNotification(websub:Notification notification) {} }   New Syntax  @websub:SubscriberServiceConfig {  target: [\"http://localhost:23191/websub/hub\", \"http://one.websub.topic.com\"] } service websub:SubscriberService /websub on new websub:Listener(8181) {  remote function onIntentVerification(websub:Caller caller, websub:IntentVerificationRequest request) {}  remote function onNotification (websub:Notification notification) {} }   Introduced New Modules  GraphQL  The Ballerina GraphQL module is introduced with this release. This module provides the support to define GraphQL services and handle simple GraphQL queries. Currently, this supports GraphQL service endpoints with the resource methods, which return graphql:Scalar values (int, string, boolean, and float) and record types only.  NATS Streaming (STAN)  With this release, a new module is introduced for NATS Streaming. Previously, the Ballerina NATS module included the support for streaming as well. Now, NATS and NATS Streaming are separated into Ballerina NATS and Ballerina STAN modules.  UUID  The Ballerina UUID module is introduced with this release. This module provides functions related to UUID (Universally Unique Identifier) such as generating different types of UUIDs and validating and checking the versions of UUID strings.  WebSocket    The WebSocket module has been moved out of the HTTP module. Therefore, you will have to change the import from ballerina/http to ballerina/websocket.  Introduced a new listener for the WebSocket module.   Previous Syntax  listener http:Listener wsListener = new (9090);   New Syntax  listener websocket:Listener wsListener = new (9090);     The base path is removed from the WebSocketServiceConfig.  Has 2 types of services. In order to work with WebSockets, the two services below are mandatory.   websocket:UpgradeService - This is to handle the WebSocket upgrade. This takes the http:Request and http:Caller parameters in. This service has a predefined onUpgrade remote method that returns a websocket:Service or an error. Earlier, this was handled by an HTTP upgrade resource.  websocket:Service - This is to handle events after the WebSocket upgrade. This service is still similar to the earlier WebSocket service, which had predefined resources like onText, onBinary, onError, onPing, and onPong. With the new syntax, all those resources are converted into remote methods.  Previous Syntax  import ballerina/http;  listener http:Listener socketListener = new (9000);  @http:WebSocketServiceConfig {  path: \"/basic\" } service echo on socketListener {  resource function onText(http:WebSocketCaller caller, json text) {}  resource function onBinary(http:WebSocketCaller caller, byte[] b) {} }   New Syntax  import ballerina/http; import ballerina/websocket;  service websocket:UpgradeService / basic on new websocket:Listener(9000) {   remote isolated function onUpgrade(http:Caller caller, http:Request req) returns websocket:Service|websocket:WebSocketError {  return new WsService();  } }  service class WsService {  *websocket:Service;   remote isolated function onText(websocket:Caller caller, string data) {  }   remote isolated function onBinary(websocket:Caller caller, byte[] data) {  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/home.html","name":"Ballerina is an open source programming language and platform for cloud-era application programmers to easily write software that just works.","summary":"\"A programming language that doesn't change the way you think about programming is not worth knowing.\" For decades, programming languages have treated networks simply as I/O sources. Ballerina introduces fundamental, new abstractions of client objects, services, resource functions, and listeners to bring networking into the language so that programmers can ...","content":"\"A programming language that doesn't change the way you think about programming is not worth knowing.\" Ballerina is an open source programming language and platform for cloud-era application programmers to easily write software that just works.  Try Ballerina  Why Ballerina  The Network in the Language  For decades, programming languages have treated networks simply as I/O sources. Ballerina introduces fundamental, new abstractions of client objects, services, resource functions, and listeners to bring networking into the language so that programmers can directly address the as part of their application logic. This facilitates resilient, secure, performant network applications to be within every programmer’s reach.  Sequence Diagrams for Programming  Sequence diagrams have been everyone’s favorite tool to describe how distributed & concurrent programs work. Yet, no current programming language lets you write your logic as a sequence diagram. In Ballerina, every program is a sequence diagram that illustrates distributed and concurrent interactions automatically. The diagram is the code. The code is the diagram.  Structural, Open-by-Default Typing  Static typing is the network application programmer’s development headache and dynamic typing is the reliability engineer’s nightmare. Ballerina’s statically-typed, structural type system that is designed to be network data schema friendly allows application programmers to write code that adheres to the : Be conservative in what you send, be liberal in what you accept.  From Code to Cloud  In the cloud-era, running a program is no longer just a matter of compiling and executing but rather it is about compiling, building the image, pushing the image, configuring container orchestration, and .. eventually running. Ballerina brings the entire program execution process to the hands of the developer with extensible metadata that gets compiled to runnable programs for all major cloud platforms. You code, we cloud!  Batteries Included  Today’s network is democratized! HTTPS to HTTP/2 to WebSockets to WebSub to AMQP to JSON to XML to ProtoBuf to gRPC to OpenAPI to plain old bytes - Ballerina has it all in the standard library and toolchain to help developers rapidly build applications. At development time, Ballerina covers documentation, testing, sharing, versioning, and more. We plumb, you build!  Developer First  Programs in the real world are written once and read tens to hundreds of times. Whenever possible, Ballerina prioritizes programmer convenience & productivity with familiarity, clearer abstractions, and easier concepts over uber system performance. Today, hardware is cheap, we programmers are not and time to market is everything.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/","name":"Why Ballerina Try Ballerina Featured Videos","summary":"Ballerina is an open-source programming language for the cloud that makes it easier to use, combine, and create network services.\n   Network primitives in the language make it simpler to write services and run them in the cloud.\n            ...","content":"Ballerina is an open-source programming language for the cloud that makes it easier to use, combine, and create network services.  Why Ballerina  Cloud Native  Network primitives in the language make it simpler to write services and run them in the cloud.  Flexibly Typed  Structural types with support for openness are used both for static typing within a program and for  describing service interfaces.  Data Oriented Type-safe, declarative processing of JSON, XML, and tabular data with language-integrated queries.  Graphical Programs have both a textual syntax and an equivalent graphical form based on sequence diagrams.  Concurrent Easy and efficient concurrency with sequence diagrams and language-managed threads without the complexity of asynchronous functions.  Reliable, Maintainable  Explicit error handling, static types, and concurrency safety, combined with a familiar, readable syntax make programs reliable and maintainable.  Try Ballerina  Featured Videos  Why Ballerina and Where We are Now  Tutorial: Start Programming with Ballerina  ×  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/404.html","name":"Ballerina","summary":"Sorry, we couldn't find that! Check out the ?\n        by  |  |  | \n       ...","content":"Sorry, we couldn't find that! Check out the ?  by | | |"},{"page":"/learn/by-example/alternate-wait.html","name":"Alternate Wait","summary":"The wait action can be used to wait for one of several workers.Fetch from A or B.The wait action can be used to wait for one of several workers.\n This function will return as soon as the return value of either\n A or B is available.This website uses cookies so ...","content":"/  /  / Alternate Wait  import ballerina/http; import ballerina/io;  // Fetch from A or B. function altFetch(string urlA, string urlB) returns string|error {  worker A returns string|error {  return fetch(urlA);  }   worker B returns string|error {  return fetch(urlB);  }   // The `wait` action can be used to wait for one of several workers.  // This function will return as soon as the return value of either  // `A` or `B` is available.  return wait A | B; }  public function main() returns error? {  string res = check altFetch(\"https://postman-echo.com/get?lang=ballerina\",  \"https://postman-echo.com/get?greeting=hello\");  io:println(res); }  function fetch(string url) returns string|error {  http:Client cl = check new (url);  map<json> payload = check cl->get(\"\");  return payload[\"args\"].toString(); }    Alternate Wait  The wait action can be used to wait for one of several workers.    import ballerina/http; import ballerina/io;    function altFetch(string urlA, string urlB) returns string|error {  worker A returns string|error {  return fetch(urlA);  }    Fetch from A or B.   worker B returns string|error {  return fetch(urlB);  }    return wait A | B; }    The wait action can be used to wait for one of several workers.  This function will return as soon as the return value of either  A or B is available.   public function main() returns error? {  string res = check altFetch(\"https://postman-echo.com/get?lang=ballerina\",  \"https://postman-echo.com/get?greeting=hello\");  io:println(res); }    function fetch(string url) returns string|error {  http:Client cl = check new (url);  map<json> payload = check cl->get(\"\");  return payload[\"args\"].toString(); }    bal run alternate_wait.bal {\"lang\":\"ballerina\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/annotations.html","name":"Annotations","summary":"Annotations start with @tag and they come before what they apply to.\n Unprefixed tags refer to standard platform-defined annotations and\n Prefixed tags refer to annotations declared in modules.\n @tag can be followed by record constructor expression.The @display annotation applies to the transform functionThe strand annotation applies to the start action.This ...","content":"/  /  / Annotations  import ballerina/io; // The `@display` annotation applies to the transform function @display {  label: \"Transform\",  iconPath: \"transform.png\" } public function transform(string s) returns string {  return s.toUpperAscii(); }  public function main() {  // The strand annotation applies to the start action.  future<int> fut = @strand { thread: \"any\" } start foo();  int x = check wait fut;  io:println(x); }  public function foo() returns int {  return 10; }    Annotations  Annotations start with @tag and they come before what they apply to.  Unprefixed tags refer to standard platform-defined annotations and  Prefixed tags refer to annotations declared in modules.  @tag can be followed by record constructor expression.    import ballerina/io;    @display {  label: \"Transform\",  iconPath: \"transform.png\" } public function transform(string s) returns string {  return s.toUpperAscii(); }    The @display annotation applies to the transform function   public function main() {    future<int> fut = @strand { thread: \"any\" } start foo();  int x = check wait fut;  io:println(x); }    The strand annotation applies to the start action.   public function foo() returns int {  return 10; }    bal run annotations.bal 10    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/anydata-type.html","name":"Anydata Type","summary":"The type for plain data is anydata. The subtype of any. == and != operators tests for deep equality.\n x.clone() returns a deep copy, with the same mutability. x.cloneReadOnly() returns a deep copy that is\n immutable. Ballerina syntax uses ReadOnly to mean immutable. Both x.clone and cloneReadOnly() do\n not copy ...","content":"/  /  / Anydata Type  import ballerina/io;  anydata x1 = [1, \"string\", true]; // `x1.clone()` returns a deep copy with the same mutability. anydata x2 = x1.clone();  // Checks deep equality. boolean eq = (x1 == x2);  public function main() {  io:println(x2);  io:println(eq); }    Anydata Type  The type for plain data is anydata. The subtype of any. == and != operators tests for deep equality.  x.clone() returns a deep copy, with the same mutability. x.cloneReadOnly() returns a deep copy that is  immutable. Ballerina syntax uses ReadOnly to mean immutable. Both x.clone and cloneReadOnly() do  not copy immutable parts of x. const structures are allowed. Equality and cloning handle cycles.    import ballerina/io;    anydata x1 = [1, \"string\", true];    anydata x2 = x1.clone();    x1.clone() returns a deep copy with the same mutability.   boolean eq = (x1 == x2);    Checks deep equality.   public function main() {  io:println(x2);  io:println(eq); }    bal run anydata_type.bal [1,\"string\",true] true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/any-type.html","name":"Any Type","summary":"any means any value except an error.\n Equivalent to a union of all non-error basic types.\n Use any|error for absolutely any value.\n Langlib lang.value module contains functions that apply to multiple basic types.A variable of type any can hold any value except an error.Can cast any to specific type.Langlib lang.value ...","content":"/  /  / Any Type  import ballerina/io;  // A variable of type `any` can hold any value except an error. any x = 1;  public function main() {  // Can cast `any` to specific type.  int n = <int>x;  io:println(n);   // Langlib lang.value module contains functions that apply to multiple basic types.  // Can convert to string.  string s = x.toString();   io:println(s == \"1\");   // Can test its type with the `is` operator.  float f = x is int|float ? <float>x : 0.0;   io:println(f); }    Any Type  any means any value except an error.  Equivalent to a union of all non-error basic types.  Use any|error for absolutely any value.  Langlib lang.value module contains functions that apply to multiple basic types.    import ballerina/io;    any x = 1;    A variable of type any can hold any value except an error.   public function main() {    int n = <int>x;  io:println(n);    Can cast any to specific type.   string s = x.toString();    Langlib lang.value module contains functions that apply to multiple basic types.  Can convert to string.   io:println(s == \"1\");    float f = x is int|float ? <float>x : 0.0;    Can test its type with the is operator.   io:println(f); }    bal run any_type.bal 1 true 1.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/arrays.html","name":"Arrays","summary":"T[] is an array of T. Arrays are mutable. == and != on arrays is deep: two arrays are\n equal if they have the same members in the same order. Ordering is lexicographical based on the\n ordering of the members. Langlib arr.length() function gets the length; arr.setLength(n) sets the length.v[i] ...","content":"/  /  / Arrays  import ballerina/io;  public function main() {  int[] v = [1, 2, 3];   // `v[i]` does indexed access.  int n = v[0];  io:println(n);   // `v[i]` is an `lvalue`.  v[3] = 4;   // len will be 3.  int len = v.length(); }    Arrays  T[] is an array of T. Arrays are mutable. == and != on arrays is deep: two arrays are  equal if they have the same members in the same order. Ordering is lexicographical based on the  ordering of the members. Langlib arr.length() function gets the length; arr.setLength(n) sets the length.    import ballerina/io;    public function main() {  int[] v = [1, 2, 3];    int n = v[0];  io:println(n);    v[i] does indexed access.   v[3] = 4;    v[i] is an lvalue.   int len = v.length(); }    len will be 3.   bal run arrays.bal 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/asynchronous-function-calls.html","name":"Asynchronous Function Calls","summary":"start calls a function asynchronously and the function runs on a separate logical thread (“strand”): cooperatively multitasked by default\n Result will be of type future and future is a separate basic type\n Waiting for the same future more than once gives an error.\n Use f.cancel() to terminate a futurestart calls ...","content":"/  /  / Asynchronous Function Calls  import ballerina/io;  public function main() {  // start calls a function asynchronously future<int> fut = start foo();   // wait for future<T> gives T|error int x = check wait fut;  io:println(x); }  function foo() returns int {  return 10; }    Asynchronous Function Calls  start calls a function asynchronously and the function runs on a separate logical thread (“strand”): cooperatively multitasked by default  Result will be of type future and future is a separate basic type  Waiting for the same future more than once gives an error.  Use f.cancel() to terminate a future    import ballerina/io;    public function main() {    future<int> fut = start foo();    start calls a function asynchronously   int x = check wait fut;  io:println(x); }    wait for future gives T|error   function foo() returns int {  return 10; }    bal run asynchronous_function_calls.bal 10    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/backtick-templates.html","name":"Backtick Templates","summary":"The backtick templates consist of a tag followed by characters surrounded by backticks. They can contain\n expressions in ${...} to be interpolated. If no escapes are recognized: use an expression to escape.\n They can contain newlines. \n Processed in two phases. \n - Phase 1 does tag-independent parse: result is ...","content":"/  /  / Backtick Templates  import ballerina/io;  public function main() {  string name = \"James\";   // Concatenates `Hello, ` strings with the `name` value.  string s1 = string`Hello, ${name}`;  io:println(s1);   // Concatenates `Backtick:` strings with ```.  string s2 = string`Backtick:${\"`\"}`;  io:println(s2); }    Backtick Templates  The backtick templates consist of a tag followed by characters surrounded by backticks. They can contain  expressions in ${...} to be interpolated. If no escapes are recognized: use an expression to escape.  They can contain newlines. Processed in two phases. - Phase 1 does tag-independent parse: result is a list of strings and expressions. - Phase 2 is tag-dependent. Phase 2 for string... converts expressions to strings and concatenates. base16 and base64  tags do not allow expressions.    import ballerina/io;    public function main() {  string name = \"James\";    string s1 = string`Hello, ${name}`;  io:println(s1);    Concatenates Hello, strings with the name value.   string s2 = string`Backtick:${\"`\"}`;  io:println(s2); }    Concatenates Backtick: strings with ```.   bal run backtick_templates.bal Hello, James Backtick:`    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/ballerina-basic-types.html","name":"Ballerina Basic Types","summary":"Simple types: /\n Always plain data. Includes nil, boolean, int, float, decimal. /\n Sequence: /\n Always plain data. Includes string, xml. /\n Structural: /\n Plain data if members are array/tuple, map/record, table. /\n Behavioural: /\n Not plain data. Includes function, object, error, stream, typedesc, handle.This website uses cookies so that ...","content":"/  /  / Ballerina Basic Types  Ballerina Basic Types  Simple types: /  Always plain data. Includes nil, boolean, int, float, decimal. /  Sequence: /  Always plain data. Includes string, xml. /  Structural: /  Plain data if members are array/tuple, map/record, table. /  Behavioural: /  Not plain data. Includes function, object, error, stream, typedesc, handle.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/binary-data.html","name":"Binary Data","summary":"Binary data is represented by arrays of byte values. It is a special syntax for byte arrays\n in base 64 and base 16. The relationship between byte and int is not the same as\n what you are used to. A byte is an int in the range 0 to 0xFF. ...","content":"/  /  / Binary Data  public function main() {  // Creates a `byte` array using the `base64` byte array literal.  byte[] data = base64`yPHaytRgJPg+QjjylUHakEwz1fWPx/wXCW41JSmqYW8=`;   // Creates an `int` using a hexadecimal numeral.  int x = 0xDEADBEEF;   // `byte & int` will be `byte`.  byte b = x & 0xFF; }    Binary Data  Binary data is represented by arrays of byte values. It is a special syntax for byte arrays  in base 64 and base 16. The relationship between byte and int is not the same as  what you are used to. A byte is an int in the range 0 to 0xFF. byte is a subtype of int.  int type supports normal bitwise operators: & | ^ ~ << >> >>>.  Ballerina knows the obvious rules about when bitwise operations produce a byte.    public function main() {    byte[] data = base64`yPHaytRgJPg+QjjylUHakEwz1fWPx/wXCW41JSmqYW8=`;    Creates a byte array using the base64 byte array literal.   int x = 0xDEADBEEF;    Creates an int using a hexadecimal numeral.   byte b = x & 0xFF; }    byte & int will be byte.   bal run binary_data.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/booleans.html","name":"Booleans and Conditionals","summary":"boolean type has two values: true, false.\n The ! operator works on booleans only.  && and || operators short-curcit as in C.\n Usual comparison operators produce boolean values: == != < > <= >=.Here’s a conditional expression. Uses C syntax.Parentheses are options in conditions, but curly braces are required ...","content":"/  /  / Booleans and Conditionals  import ballerina/io;  boolean flag = true;  // Here's a conditional expression. Uses C syntax. int n = flag ? 1 : 2;  public function main() {  // Parentheses are options in conditions, but curly braces are required in `if/else` and other compound statements. if flag {  io:println(1);  } else {  io:println(2);  } }    Booleans and Conditionals  boolean type has two values: true, false.  The ! operator works on booleans only. && and || operators short-curcit as in C.  Usual comparison operators produce boolean values: == != < > <= >=.    import ballerina/io;    boolean flag = true;    int n = flag ? 1 : 2;    Here’s a conditional expression. Uses C syntax.   public function main() {    if flag {  io:println(1);  } else {  io:println(2);  } }    Parentheses are options in conditions, but curly braces are required in if/else and other compound statements.   bal run booleans.bal 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/cache-basics.html","name":"Cache Basics","summary":"The Ballerina Cache API provides an in-memory cache implementation by default with a\n Least Recently Used algorithm-based eviction policy.\n For more information on the underlying module,\n see the .This creates a new cache instance with the default configurations.Adds new entries to the cache.Checks for the cached key availability.Fetches the cached ...","content":"/  /  / Cache Basics  import ballerina/cache; import ballerina/io;  public function main() returns error? {  // This creates a new cache instance with the default configurations.  cache:Cache cache = new();   // Adds new entries to the cache.  check cache.put(\"key1\", \"value1\");  check cache.put(\"key2\", \"value2\");   // Checks for the cached key availability.  if (cache.hasKey(\"key1\")) {  // Fetches the cached value.  string value = <string> check cache.get(\"key1\");  io:println(\"The value of the key1: \" + value);  }  // Gets the keys of the cache entries.  string[] keys = cache.keys();  io:println(\"The existing keys in the cache: \" + keys.toString());   // Gets the size of the cache.  int size = cache.size();  io:println(\"The cache size: \", size); }    Cache Basics  The Ballerina Cache API provides an in-memory cache implementation by default with a  Least Recently Used algorithm-based eviction policy.  For more information on the underlying module,  see the .    import ballerina/cache; import ballerina/io;    public function main() returns error? {    cache:Cache cache = new();    This creates a new cache instance with the default configurations.   check cache.put(\"key1\", \"value1\");  check cache.put(\"key2\", \"value2\");    Adds new entries to the cache.   if (cache.hasKey(\"key1\")) {    Checks for the cached key availability.   string value = <string> check cache.get(\"key1\");  io:println(\"The value of the key1: \" + value);  }    Fetches the cached value.   string[] keys = cache.keys();  io:println(\"The existing keys in the cache: \" + keys.toString());    Gets the keys of the cache entries.   int size = cache.size();  io:println(\"The cache size: \", size); }    Gets the size of the cache.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run cache_basic.bal The value of the key1: value1 The existing keys in the cache: [\"key1\",\"key2\"] The cache size: 2    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/check-expression.html","name":"Check Expression","summary":"check E is used with expression E that might result in an error.\n If E does result in an error, then check makes the function return that error\n immediately.\n Type of check E does not include error.\n The control flow remains explicit.Convert bytes to a string and then to an ...","content":"/  /  / Check Expression  import ballerina/io;  // Convert bytes to a string and then to an int. function intFromBytes(byte[] bytes) returns int|error {   // Use `check` with an expression that may return `error`.  // If `string:fromBytes(bytes)` returns an error, `check`  // makes the function return the error here.  // If not, the returned string value is used as the // value of the `str` variable.  string str = check string:fromBytes(bytes);  return int:fromString(str); }  public function main() {  int|error res = intFromBytes([104, 101, 108, 108, 111]);  io:println(res); }    Check Expression  check E is used with expression E that might result in an error.  If E does result in an error, then check makes the function return that error  immediately.  Type of check E does not include error.  The control flow remains explicit.    import ballerina/io;    function intFromBytes(byte[] bytes) returns int|error {    Convert bytes to a string and then to an int.   string str = check string:fromBytes(bytes);  return int:fromString(str); }    Use check with an expression that may return error.  If string:fromBytes(bytes) returns an error, check  makes the function return the error here.  If not, the returned string value is used as the  value of the str variable.   public function main() {  int|error res = intFromBytes([104, 101, 108, 108, 111]);  io:println(res); }    bal run check_expression.bal error(\"{ballerina/lang.int}NumberParsingError\",message=\"'string' value 'hello' cannot be converted to 'int'\")    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/const-and-final.html","name":"Const and Final","summary":"const means immutable and known at compile-time. Its type is singleton: set containing single value.\n A variable or a class field can be declared as final, meaning it cannot be assigned to, after\n it has been initialized.Constants can be defined without the type.\n Then the type is inferred from the ...","content":"/  /  / Const and Final  import ballerina/io;  // Constants can be defined without the type. // Then the type is inferred from the right hand side. const MAX_VALUE = 1000; const URL = \"https://ballerina.io\";  // The value for variable `msg` can only be assigned once. final string msg = loadMessage();  public function main() {  io:println(MAX_VALUE);  io:println(URL);  io:println(msg); }  function loadMessage() returns string {  return \"Hello World\"; }    Const and Final const means immutable and known at compile-time. Its type is singleton: set containing single value.  A variable or a class field can be declared as final, meaning it cannot be assigned to, after  it has been initialized.    import ballerina/io;    const MAX_VALUE = 1000; const URL = \"https://ballerina.io\";    Constants can be defined without the type.  Then the type is inferred from the right hand side.   final string msg = loadMessage();    The value for variable msg can only be assigned once.   public function main() {  io:println(MAX_VALUE);  io:println(URL);  io:println(msg); }    function loadMessage() returns string {  return \"Hello World\"; }    bal run const_and_final 1000 https://ballerina.io Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/configurable-variables.html","name":"Configurable Variables","summary":"A module-level variable can be declared as configurable. The initializer of a configurable variable\n can be overridden at runtime (e.g., by a TOML file). A variable where configuration is required\n can use an initializer of ?. The type of a configurable variable must be subtype of anydata.Port on which to ...","content":"/  /  / Configurable Variables  // Port on which to run the service. configurable int port = 8080;  // Password must be supplied in configuration file. // configurable string password = ?;    Configurable Variables  A module-level variable can be declared as configurable. The initializer of a configurable variable  can be overridden at runtime (e.g., by a TOML file). A variable where configuration is required  can use an initializer of ?. The type of a configurable variable must be subtype of anydata.    configurable int port = 8080;    Port on which to run the service.   Password must be supplied in configuration file.  configurable string password = ?;   bal run configurable_variables.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/cache-invalidation.html","name":"Cache Invalidation","summary":"The Ballerina Cache API provides an in-memory cache implementation by default with the\n Least Recently Used algorithm-based eviction policy.\n For more information on the underlying module,\n see the .This is the mock function, which will replace the real function.Invoking the main function.This creates a new cache with the advanced configuration.The ...","content":"/  /  / Cache Invalidation  import ballerina/test;  string[] outputs = [];  // This is the mock function, which will replace the real function. @test:Mock {  moduleName: \"ballerina/io\",  functionName: \"println\" } test:MockFunction mock_printLn = new();  public function mockPrint(any|error... val) {  any|error value = val.reduce(getStringValue, \"\");  if (value is error) {  outputs.push(value.message());  } else {  outputs.push(value.toString());  } }  @test:Config{} function testFunc() returns error? {  test:when(mock_printLn).call(\"mockPrint\");   // Invoking the main function.  error? output = main();  if (output is error) {  test:assertFail(\"Test failed\");  } else {  test:assertEquals(outputs[0].toString(), \"The value of the key1: value1\");  test:assertEquals(outputs[1].toString(), \"The existing keys in the cache: [\\\"key1\\\",\\\"key2\\\"]\");  test:assertEquals(outputs[2].toString(), \"The cache size: 2\");  } }  function getStringValue(any|error a, any|error b) returns string {  string aValue = a is error ? a.toString() : a.toString();  string bValue = b is error ? b.toString() : b.toString();  return (aValue + bValue); }  41 new-examples/cache-invalidation/cache_invalidation.bal Viewed @@ -0,0 +1,41 @@ import ballerina/cache; import ballerina/io;  public function main() returns error? {   // This creates a new cache with the advanced configuration.  cache:Cache cache = new ({  // The maximum size of the cache is 10.  capacity: 10,  // The eviction factor is set to 0.2, which means at the  // time of eviction 10*0.2=2 entries get removed from the cache.  evictionFactor: 0.2,  // The default max age of the cache entry is set to 2 seconds.  defaultMaxAge: 2,  // The cache cleanup task runs every 3 seconds and clears all  // the expired entries.  cleanupInterval: 3  });   // Adds the new entries to the cache.  check cache.put(\"key1\", \"value1\");  check cache.put(\"key2\", \"value2\");  // Adds a new entry to the cache by overriding the default max age.  check cache.put(\"key3\", \"value3\", 3600);   // Gets the keys of the cache entries.  string[] keys = cache.keys();  io:println(\"The existing keys in the cache: \", keys);   // Discards the given cache entry.  _ = check cache.invalidate(\"key2\");   // Gets the keys of the cache entries.  io:println(\"The existing keys in after invalidating a given key: \", cache.keys());   // Discards all the cache entries of the cache.  _ = check cache.invalidateAll();   // Gets the keys of the cache entries after all the keys are invalidated.  io:println(\"The keys after invalidating all the keys: \", cache.keys()); }    Cache Invalidation  The Ballerina Cache API provides an in-memory cache implementation by default with the  Least Recently Used algorithm-based eviction policy.  For more information on the underlying module,  see the .    import ballerina/test;    string[] outputs = [];    @test:Mock {  moduleName: \"ballerina/io\",  functionName: \"println\" } test:MockFunction mock_printLn = new();    This is the mock function, which will replace the real function.   public function mockPrint(any|error... val) {  any|error value = val.reduce(getStringValue, \"\");  if (value is error) {  outputs.push(value.message());  } else {  outputs.push(value.toString());  } }    @test:Config{} function testFunc() returns error? {  test:when(mock_printLn).call(\"mockPrint\");    error? output = main();  if (output is error) {  test:assertFail(\"Test failed\");  } else {  test:assertEquals(outputs[0].toString(), \"The value of the key1: value1\");  test:assertEquals(outputs[1].toString(), \"The existing keys in the cache: [\\\"key1\\\",\\\"key2\\\"]\");  test:assertEquals(outputs[2].toString(), \"The cache size: 2\");  } }    Invoking the main function.   function getStringValue(any|error a, any|error b) returns string {  string aValue = a is error ? a.toString() : a.toString();  string bValue = b is error ? b.toString() : b.toString();  return (aValue + bValue); }  41 new-examples/cache-invalidation/cache_invalidation.bal Viewed @@ -0,0 +1,41 @@ import ballerina/cache; import ballerina/io;    public function main() returns error? {    cache:Cache cache = new ({    This creates a new cache with the advanced configuration.   capacity: 10,    The maximum size of the cache is 10.   evictionFactor: 0.2,    The eviction factor is set to 0.2, which means at the  time of eviction 10*0.2=2 entries get removed from the cache.   defaultMaxAge: 2,    The default max age of the cache entry is set to 2 seconds.   cleanupInterval: 3  });    The cache cleanup task runs every 3 seconds and clears all  the expired entries.   check cache.put(\"key1\", \"value1\");  check cache.put(\"key2\", \"value2\");    Adds the new entries to the cache.   check cache.put(\"key3\", \"value3\", 3600);    Adds a new entry to the cache by overriding the default max age.   string[] keys = cache.keys();  io:println(\"The existing keys in the cache: \", keys);    Gets the keys of the cache entries.   _ = check cache.invalidate(\"key2\");    Discards the given cache entry.   io:println(\"The existing keys in after invalidating a given key: \", cache.keys());    Gets the keys of the cache entries.   _ = check cache.invalidateAll();    Discards all the cache entries of the cache.   io:println(\"The keys after invalidating all the keys: \", cache.keys()); }    Gets the keys of the cache entries after all the keys are invalidated.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run cache_invalidation.bal The existing keys in the cache: [\"key1\",\"key2\",\"key3\"] The existing keys in after invalidating a given key: [\"key1\",\"key3\"] The keys in after invalidating all the keys: []    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/consuming-services.html","name":"Consuming Services: Client Objects","summary":"Ballerina has a language construct called client objects.\n They are a special kind of objects that contain remote methods in addition to regular methods.\n remote methods are used to interact with a remote service.\n Applications typically do not need to write client classes, which are either provided by library modules ...","content":"/  /  / Consuming Services: Client Objects  import ballerina/io; import ballerina/http;  public function main() returns error? {  // A client object is created by applying `new` to a client clss.  http:Client httpClient = check new (\"https://api.github.com/\");   // Remote method calls use `->` syntax. This enables sequence diagram veiw. http:Response resp = check httpClient->get(\"/orgs/ballerina-platform/repos\");  io:println(resp.statusCode); }    Consuming Services: Client Objects  Ballerina has a language construct called client objects.  They are a special kind of objects that contain remote methods in addition to regular methods.  remote methods are used to interact with a remote service.  Applications typically do not need to write client classes, which are either provided by library modules or generated from some flavor of IDL.    import ballerina/io; import ballerina/http;    public function main() returns error? {    http:Client httpClient = check new (\"https://api.github.com/\");    A client object is created by applying new to a client clss.   http:Response resp = check httpClient->get(\"/orgs/ballerina-platform/repos\");  io:println(resp.statusCode); }    Remote method calls use -> syntax. This enables sequence diagram veiw.   bal run consuming_services.bal 200    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/converting-from-json-to-user-defined-type.html","name":"Converting From JSON to User-Defined Type","summary":"With mutable values, would not be type-safe to allow a cast.\n Mutable structures have inherent type that limits mutation.\n Cast to T will work on mutable structure s only if inherent type\n of s is subtype of T.\n Casting of immutable value will work, but does not do numeric conversions.With ...","content":"/  /  / Converting From JSON to User-Defined Type  import ballerina/io;  type Coord record {  float x;  float y; };  public function main() {  json j = {x: 1.0, y: 2.0};   // With mutable values, would not be type-safe to allow a cast.  // Cast to T will work on mutable structure s only if inherent type // of s is subtype of T.  // Casting of immutable value will work.  json k = j.cloneReadOnly();  Coord c = <Coord> k;   io:println(c.x);  io:println(c.y); }    Converting From JSON to User-Defined Type  With mutable values, would not be type-safe to allow a cast.  Mutable structures have inherent type that limits mutation.  Cast to T will work on mutable structure s only if inherent type  of s is subtype of T.  Casting of immutable value will work, but does not do numeric conversions.    import ballerina/io;    type Coord record {  float x;  float y; };    public function main() {  json j = {x: 1.0, y: 2.0};    json k = j.cloneReadOnly();  Coord c = <Coord> k;    With mutable values, would not be type-safe to allow a cast.  Cast to T will work on mutable structure s only if inherent type  of s is subtype of T.  Casting of immutable value will work.   io:println(c.x);  io:println(c.y); }    bal run converting_from_json_to_user_defined_type.bal 1.0 2.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/controlling-openness.html","name":"Controlling Openness","summary":"Use record {| ... |} to describe a record type that allows exclusively what is specified in the body.\n Use T... to allow other fields of type T. map<T> is same as record {| T...; |}.x is a map with float values.h is a map with string values.This website uses ...","content":"/  /  / Controlling Openness  import ballerina/io;  type Coord record {|  float x;  float y; |};  Coord x = { x: 1.0, y: 2.0 };  // `x` is a `map` with `float` values. map<float> m1 = x;  type Headers record {|  string 'from;  string to;  string...; |};  Headers h = {  'from: \"Jane\", to: \"John\" };  // `h` is a `map` with `string` values. map<string> m2 = h;  public function main() {  io:println(m1);  io:println(m2); }    Controlling Openness  Use record {| ... |} to describe a record type that allows exclusively what is specified in the body.  Use T... to allow other fields of type T. map<T> is same as record {| T...; |}.    import ballerina/io;    type Coord record {|  float x;  float y; |};    Coord x = { x: 1.0, y: 2.0 };    map<float> m1 = x;    x is a map with float values.   type Headers record {|  string 'from;  string to;  string...; |};    Headers h = {  'from: \"Jane\", to: \"John\" };    map<string> m2 = h;    h is a map with string values.   public function main() {  io:println(m1);  io:println(m2); }    bal run controlling_openness.bal {\"x\":1.0,\"y\":2.0} {\"from\":\"Jane\",\"to\":\"John\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/converting-from-user-defined-type-to-json.html","name":"Converting From User-Defined Type to JSON","summary":"Conversion from json value to JSON format is straightforward.\n Converting from application-specific, user-defined subtype of anydata\n to json is also possible.\n In many cases, this is a no-op: user-defined type will be a subtype of\n json as well as of anydata.\n With tables, XML or records open to anydata, use ...","content":"/  /  / Converting From User-Defined Type to JSON  import ballerina/io;  // Closed type. type ClosedCoord record {|  float x;  float y; |};  // Open type, can have additional `anydata` fields. type OpenCoord record {  float x;  float y; };  public function main() {  ClosedCoord a = {x: 1.0, y: 2.0};  // Nothing to do.  json j = a;   io:println(j);   OpenCoord b = {x: 1.0, y: 2.0, \"z\": \"city\"};  // Use `toJson` to convert `anydata` to `json`.  // Usually happens automatically.  json k = b.toJson();   io:println(k); }    Converting From User-Defined Type to JSON  Conversion from json value to JSON format is straightforward.  Converting from application-specific, user-defined subtype of anydata  to json is also possible.  In many cases, this is a no-op: user-defined type will be a subtype of  json as well as of anydata.  With tables, XML or records open to anydata, use toJson to convert  anydata to json.  APIs that generate JSON typically accept anydata and automatically  apply toJson.    import ballerina/io;    type ClosedCoord record {|  float x;  float y; |};    Closed type.   type OpenCoord record {  float x;  float y; };    Open type, can have additional anydata fields.   public function main() {  ClosedCoord a = {x: 1.0, y: 2.0};    json j = a;    Nothing to do.   io:println(j);    OpenCoord b = {x: 1.0, y: 2.0, \"z\": \"city\"};    json k = b.toJson();    Use toJson to convert anydata to json.  Usually happens automatically.   io:println(k); }    bal run converting_from_user_defined_type_to_json.bal {\"x\":1.0,\"y\":2.0} {\"x\":1.0,\"y\":2.0,\"z\":\"city\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/converting-to-user-defined-type.html","name":"Converting to User-Defined Type","summary":"The cloneWithType langlib function in the lang.value\n module can be used to convert a value to a user-defined type.\n Result recursively uses specified type as inherent type of new value.\n Automatically performs numeric conversions as necessary.\n Every part of value is cloned, including immutable structural values.\n Graph structure is not ...","content":"/  /  / Converting to User-Defined Type  import ballerina/io;  type Coord record {  float x;  float y; };  public function main() returns error? {  json j = {x: 1.0, y: 2.0};   // Argument is a typedesc value.  // Static return type depends on argument.  Coord c = check j.cloneWithType(Coord);  io:println(c.x);   // Argument defaulted from context.  Coord d = check j.cloneWithType();  io:println(d.x); }    Converting to User-Defined Type  The cloneWithType langlib function in the lang.value  module can be used to convert a value to a user-defined type.  Result recursively uses specified type as inherent type of new value.  Automatically performs numeric conversions as necessary.  Every part of value is cloned, including immutable structural values.  Graph structure is not preserved.  Variant fromJsonWithType also does reverse of conversions done by  toJson.    import ballerina/io;    type Coord record {  float x;  float y; };    public function main() returns error? {  json j = {x: 1.0, y: 2.0};    Coord c = check j.cloneWithType(Coord);  io:println(c.x);    Argument is a typedesc value.  Static return type depends on argument.   Coord d = check j.cloneWithType();  io:println(d.x); }    Argument defaulted from context.   bal run converting_to_user_defined_type.bal 1.0 1.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/covariance.html","name":"Covariance","summary":"Arrays and maps are covariant.\n Static type-checking guarantees that result of a read from a mutable\n structure will be consistent with the static type.\n Covariance means that a write to a mutable structure may result in a\n runtime error.\n Arrays, maps, and records have an “inherent” type that constrains mutation.Assigning ...","content":"/  /  / Covariance  int[] iv = [1, 2, 3];  // Assigning `int[]` to `any[]` is allowed. // - set of values allowed by `int` is subset of set of values allowed by `any` // - set of values allowed by `int[]`` is subset of set of values allowed by `any[]`` any[] av = iv;  public function main() {  // Runtime error; otherwise `iv[0]` would have wrong type.  av[0] = \"str\"; }    Covariance  Arrays and maps are covariant.  Static type-checking guarantees that result of a read from a mutable  structure will be consistent with the static type.  Covariance means that a write to a mutable structure may result in a  runtime error.  Arrays, maps, and records have an “inherent” type that constrains mutation.    int[] iv = [1, 2, 3];    any[] av = iv;    Assigning int[] to any[] is allowed.  - set of values allowed by int is subset of set of values allowed by any  - set of values allowed by int[]is subset of set of values allowed byany[]``   public function main() {    av[0] = \"str\"; }    Runtime error; otherwise iv[0] would have wrong type.   bal run covariance.bal error: {ballerina/lang.array}InherentTypeViolation {\"message\":\"incompatible types: expected 'int', found 'string'\"}  at covariance:main(covariance.bal:10)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/decimal-type.html","name":"Decimal Type","summary":"It is the third numeric type. \n Works like int and float. \n No implicit conversion. \n Represents decimal fractions exactly. Avoids surprises that you get with float. Preserves precision.\n Separate basic type; counts as anydata. Literal uses the suffix d(f suffix is for float). \n Floating point, not infinite ...","content":"/  /  / Decimal Type  import ballerina/io;  // The `decimal` type represents the set of 128-bits IEEE 754R decimal floating point numbers. decimal nanos = 1d/1000000000d;  function floatSurprise() {  float f = 100.10 - 0.01;  io:println(f); }  public function main() {  floatSurprise();  io:println(nanos); }    Decimal Type  It is the third numeric type. Works like int and float. No implicit conversion. Represents decimal fractions exactly. Avoids surprises that you get with float. Preserves precision.  Separate basic type; counts as anydata. Literal uses the suffix d(f suffix is for float). Floating point, not infinite precision. - 34 decimal digits. - 22 digits are enough for US national debt in ¢. - 27 digits are enough for an age of universe in ns. - No infinity, NaN or negative zero.    import ballerina/io;    decimal nanos = 1d/1000000000d;    The decimal type represents the set of 128-bits IEEE 754R decimal floating point numbers.   function floatSurprise() {  float f = 100.10 - 0.01;  io:println(f); }    public function main() {  floatSurprise();  io:println(nanos); }    bal run decimal_type.bal 100.08999999999999 1E-9    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/creating-tables-with-query.html","name":"Creating Tables With Query","summary":"Query expressions can create tables. Key of created table can be specified explicitly.The query expression starts with table.\n The key specifier key(id) specifies the key sequence of the constructed table.\n The result of the query expression is a table.This website uses cookies so that we can provide you with the ...","content":"/  /  / Creating Tables With Query  import ballerina/io;  type Employee record {|  readonly int id;  string firstName;  string lastName;  int salary; |};  public function main() {  table<Employee> key(id) employees = table [  {id: 1, firstName: \"John\", lastName: \"Smith\", salary: 100},  {id: 2, firstName: \"Fred\", lastName: \"Bloggs\", salary: 2000}  ];   // The `query expression` starts with `table`.  // The key specifier `key(id)` specifies the key sequence of the constructed `table`.  // The result of the `query expression` is a `table`.  var highPaidEmployees = table key(id) from var e in employees  where e.salary >= 1000  select e;  io:println(highPaidEmployees); }    Creating Tables With Query  Query expressions can create tables. Key of created table can be specified explicitly.    import ballerina/io;    type Employee record {|  readonly int id;  string firstName;  string lastName;  int salary; |};    public function main() {  table<Employee> key(id) employees = table [  {id: 1, firstName: \"John\", lastName: \"Smith\", salary: 100},  {id: 2, firstName: \"Fred\", lastName: \"Bloggs\", salary: 2000}  ];    var highPaidEmployees = table key(id) from var e in employees  where e.salary >= 1000  select e;  io:println(highPaidEmployees); }    The query expression starts with table.  The key specifier key(id) specifies the key sequence of the constructed table.  The result of the query expression is a table.   bal run creating_tables_with_query.bal [{\"id\":2,\"firstName\":\"Fred\",\"lastName\":\"Bloggs\",\"salary\":2000}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/defining-classes.html","name":"Defining Classes","summary":"Module can contain class definitions.\n init method initializes the object.\n Arguments to new are passed as arguments to init.\n Methods use self to access their object.\n private means accessible only by code within the class definition.private means accessible only by code within the class definition.init method initializes the object.Methods use ...","content":"/  /  / Defining Classes  import ballerina/io;  public class Counter {  // `private` means accessible only by code within the class definition.  private int n;   // `init` method initializes the object.  public function init(int n = 0) {  self.n = n;  }   public function get() returns int {  // Methods use `self` to access their object.  return self.n;  }   public function inc() {  self.n += 1;  } }  public function main() {  // Arguments to `new` are passed as arguments to `init`.  Counter counter = new (12);   io:println(counter.get()); }    Defining Classes  Module can contain class definitions.  init method initializes the object.  Arguments to new are passed as arguments to init.  Methods use self to access their object.  private means accessible only by code within the class definition.    import ballerina/io;    public class Counter {    private int n;    private means accessible only by code within the class definition.   public function init(int n = 0) {  self.n = n;  }    init method initializes the object.   public function get() returns int {    return self.n;  }    Methods use self to access their object.   public function inc() {  self.n += 1;  } }    public function main() {    Counter counter = new (12);    Arguments to new are passed as arguments to init.   io:println(counter.get()); }    bal run defining_classes.bal 12    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/destructuring-records.html","name":"Destructuring Records","summary":"Destructuring records is particularly useful with query expressions, but works anywhere you can have var.\n var is followed by a binding pattern. The semantics of binding pattern is open. {x} is short for\n {x: x} in both binding patterns and record constructors.A Person record is destructured here, as a\n projection ...","content":"/  /  / Destructuring Records  import ballerina/io;  type Person record {  string first;  string last;  int yearOfBirth; };  public function main() {  Person[] persons = [  {first: \"Melina\", last: \"Kodel\", yearOfBirth: 1994},  {first: \"Tom\", last: \"Riddle\", yearOfBirth: 1926}  ];   // A `Person` record is destructured here, as a  // projection with `first` and `last` fields.  // `{first: f, last: l}` is the `binding pattern`.  var names1 = from var {first: f, last: l} in persons  select {first: f, last: l};  io:println(names1);   // The same can be simplified as this.  var names2 = from var {first, last} in persons  select {first, last};  io:println(names2); }    Destructuring Records  Destructuring records is particularly useful with query expressions, but works anywhere you can have var.  var is followed by a binding pattern. The semantics of binding pattern is open. {x} is short for  {x: x} in both binding patterns and record constructors.    import ballerina/io;    type Person record {  string first;  string last;  int yearOfBirth; };    public function main() {  Person[] persons = [  {first: \"Melina\", last: \"Kodel\", yearOfBirth: 1994},  {first: \"Tom\", last: \"Riddle\", yearOfBirth: 1926}  ];    var names1 = from var {first: f, last: l} in persons  select {first: f, last: l};  io:println(names1);    A Person record is destructured here, as a  projection with first and last fields.  {first: f, last: l} is the binding pattern.   var names2 = from var {first, last} in persons  select {first, last};  io:println(names2); }    The same can be simplified as this.   bal run destructuring_records.bal [{\"first\":\"Melina\",\"last\":\"Kodel\"},{\"first\":\"Tom\",\"last\":\"Riddle\"}] [{\"first\":\"Melina\",\"last\":\"Kodel\"},{\"first\":\"Tom\",\"last\":\"Riddle\"}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/documentation.html","name":"Documentation","summary":"Annotations would be inconvenient for specifying structured document\n Ballerina-flavored Markdown (BFM) is additional conventions on top of Markdown,\n which make it more convenient for documenting Ballerina codeLines starting with # contain structured documentation in Markdown format.Documenting parameters of the functionDocumenting return parameter of the functionThis website uses cookies so that ...","content":"/  /  / Documentation  // Lines starting with `#` contain structured documentation in Markdown format. # Adds two integers. // Documenting parameters of the function # + x - an integer # + y - another integer // Documenting return parameter of the function # + return - the sum of `x` and `y` public function add(int x, int y)  returns int {  return x + y; }    Documentation  Annotations would be inconvenient for specifying structured document  Ballerina-flavored Markdown (BFM) is additional conventions on top of Markdown,  which make it more convenient for documenting Ballerina code    # Adds two integers.    Lines starting with # contain structured documentation in Markdown format.   # + x - an integer # + y - another integer    Documenting parameters of the function   # + return - the sum of `x` and `y` public function add(int x, int y)  returns int {  return x + y; }    Documenting return parameter of the function   bal run documentation.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/directories.html","name":"Directories","summary":"The Ballerina File API contains functions to perform directory operations.\n For more information on the underlying module,\n see the .Creates a new directory with any non-existent parents.Checks whether the directory of the provided path exists.Copies the directory with another name.Renames the directory to another new name.Gets the list of files/directories ...","content":"/  /  / Directories  import ballerina/file; import ballerina/io;  public function main() returns error? {   // Creates a new directory with any non-existent parents.  string dirPath = check file:joinPath(\"foo\", \"bar\");  check file:createDir(dirPath, file:RECURSIVE);  io:println(\"The \" + dirPath + \" directory created successfully.\");   // Checks whether the directory of the provided path exists.  boolean dirExists = check file:test(\"foo\", file:EXISTS);  io:println(\"Is foo directory exist: \", dirExists.toString());   // Copies the directory with another name.  check file:copy(dirPath, \"test\", file:REPLACE_EXISTING);  io:println(\"The \" + dirPath + \" directory copied successfully.\");   // Renames the directory to another new name.  check file:rename(\"foo\", \"test1\");  io:println(\"The foo directory renamed successfully.\");   // Gets the list of files/directories in the given directory.  file:MetaData[] readDirResults = check file:readDir(\"test1\");  io:println(\"Directory path: \", readDirResults[0].absPath);  io:println(\"Directory size: \", readDirResults[0].size.toString());  io:println(\"Is directory: \", readDirResults[0].dir.toString());  io:println(\"Modified at \", readDirResults[0].modifiedTime.toString());   // Removes the directory in the specified file path.  check file:remove(\"test\");   // Removes the directory in the specified file path with all its children.  check file:remove(\"test1\", file:RECURSIVE);  io:println(\"Directories removed successfully.\"); }    Directories  The Ballerina File API contains functions to perform directory operations.  For more information on the underlying module,  see the .    import ballerina/file; import ballerina/io;    public function main() returns error? {    string dirPath = check file:joinPath(\"foo\", \"bar\");  check file:createDir(dirPath, file:RECURSIVE);  io:println(\"The \" + dirPath + \" directory created successfully.\");    Creates a new directory with any non-existent parents.   boolean dirExists = check file:test(\"foo\", file:EXISTS);  io:println(\"Is foo directory exist: \", dirExists.toString());    Checks whether the directory of the provided path exists.   check file:copy(dirPath, \"test\", file:REPLACE_EXISTING);  io:println(\"The \" + dirPath + \" directory copied successfully.\");    Copies the directory with another name.   check file:rename(\"foo\", \"test1\");  io:println(\"The foo directory renamed successfully.\");    Renames the directory to another new name.   file:MetaData[] readDirResults = check file:readDir(\"test1\");  io:println(\"Directory path: \", readDirResults[0].absPath);  io:println(\"Directory size: \", readDirResults[0].size.toString());  io:println(\"Is directory: \", readDirResults[0].dir.toString());  io:println(\"Modified at \", readDirResults[0].modifiedTime.toString());    Gets the list of files/directories in the given directory.   check file:remove(\"test\");    Removes the directory in the specified file path.   check file:remove(\"test1\", file:RECURSIVE);  io:println(\"Directories removed successfully.\"); }    Removes the directory in the specified file path with all its children.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run directories.bal The foo/bar directory created successfully. Is foo directory exist: true The foo/bar directory copied successfully. The foo directory renamed successfully. Directory path: /A/B/C/test1/bar Directory size: 64 Is directory: true Modified at 1621859440 0.871000000 Directories removed successfully.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/directory-listener.html","name":"Directory Listener","summary":"The Directory Listener is used to listen to a directory in the local file system.\n It notifies when new files are created in the directory or when the existing files are deleted or modified.\n For more information on the underlying module,\n see the .In this example, the listener monitors any ...","content":"/  /  / Directory Listener  import ballerina/file; import ballerina/log;  // In this example, the listener monitors any modifications done to a specific directory. // Before running the example, change the value of the 'path' field // to indicate the path of the directory that you want the listener to monitor. // As the recursive property is set to false, // the listener does not monitor the child directories of the main directory // that it listens to. listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false });  // The directory listener should have at least one of these predefined resources. service \"localObserver\" on inFolder {   // This function is invoked once a new file is created in the listening directory.  remote function onCreate(file:FileEvent m) {  log:printInfo(\"Create: \" + m.name);  }   // This function is invoked once an existing file is deleted from the listening directory.  remote function onDelete(file:FileEvent m) {  log:printInfo(\"Delete: \" + m.name);  }   // This function is invoked once an existing file is modified in the listening directory.  remote function onModify(file:FileEvent m) {  log:printInfo(\"Modify: \" + m.name);  } }    Directory Listener  The Directory Listener is used to listen to a directory in the local file system.  It notifies when new files are created in the directory or when the existing files are deleted or modified.  For more information on the underlying module,  see the .    import ballerina/file; import ballerina/log;    listener file:Listener inFolder = new ({  path: \"/home/ballerina/fs-server-connector/observed-dir\",  recursive: false });    In this example, the listener monitors any modifications done to a specific directory.  Before running the example, change the value of the ‘path’ field  to indicate the path of the directory that you want the listener to monitor.  As the recursive property is set to false,  the listener does not monitor the child directories of the main directory  that it listens to.   service \"localObserver\" on inFolder {    The directory listener should have at least one of these predefined resources.   remote function onCreate(file:FileEvent m) {  log:printInfo(\"Create: \" + m.name);  }    This function is invoked once a new file is created in the listening directory.   remote function onDelete(file:FileEvent m) {  log:printInfo(\"Delete: \" + m.name);  }    This function is invoked once an existing file is deleted from the listening directory.   remote function onModify(file:FileEvent m) {  log:printInfo(\"Modify: \" + m.name);  } }    This function is invoked once an existing file is modified in the listening directory.   # After running the sample, create a new file called `test1.txt` in the directory called `observed-dir`, modify it, and delete it. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run directory_listener.bal time = 2020-12-12 13:49:08,497 level = INFO module = \"\" message = \"Create: /home/ballerina/fs-server-connector/observed-dir/test1.txt\" time = 2020-12-12 13:49:41,709 level = INFO module = \"\" message = \"Modify: /home/ballerina/fs-server-connector/observed-dir/test1.txt\" time = 2020-12-12 13:50:04,997 level = INFO module = \"\" message = \"Delete: /home/ballerina/fs-server-connector/observed-dir/test1.txt\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/enumerations.html","name":"Enumerations","summary":"Enumerations are shorthand for unions of string constants. A const can be used as a singleton type.\n An enum is not a distinct type. You can specify the string constants explicitly.This is shorthand for \n const RED = \"RED\"; \n const GREEN = \"GREEN\"; \n const BLUE = \"BLUE\": \n ...","content":"/  /  / Enumerations  import ballerina/io;  // This is shorthand for <br></br> // `const RED = \"RED\";` <br></br> // `const GREEN = \"GREEN\";` <br></br> // `const BLUE = \"BLUE\":` <br></br> // `type Color RED|GREEN|BLUE;` enum Color {  RED, GREEN, BLUE }  // An `enum` member can explicitly specify an associated expression. enum Language {  ENG = \"English\",  TL = \"Tamil\",  SI = \"Sinhala\" }  public function main() {  io:println(RED);  io:println(ENG); }    Enumerations  Enumerations are shorthand for unions of string constants. A const can be used as a singleton type.  An enum is not a distinct type. You can specify the string constants explicitly.    import ballerina/io;    enum Color {  RED, GREEN, BLUE }    This is shorthand for const RED = \"RED\"; const GREEN = \"GREEN\"; const BLUE = \"BLUE\": type Color RED|GREEN|BLUE;   enum Language {  ENG = \"English\",  TL = \"Tamil\",  SI = \"Sinhala\" }    An enum member can explicitly specify an associated expression.   public function main() {  io:println(RED);  io:println(ENG); }    bal run enumerations.bal RED English    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/environment-variables.html","name":"Environment Variables","summary":"The os library provides functions to retrieve information about the OS and the current users of the OS.\n For more information on the underlying module,\n see the .Returns the environment variable value associated with the HTTP_PORT.Returns the username of the current user.Returns the current user’s home directory path.This website uses ...","content":"/  /  / Environment Variables  import ballerina/io; import ballerina/os;  public function main() {  // Returns the environment variable value associated with the `HTTP_PORT`.  string port = os:getEnv(\"HTTP_PORT\");  io:println(\"HTTP_PORT: \", port);   // Returns the username of the current user.  string username = os:getUsername();  io:println(\"Username: \", username);   // Returns the current user's home directory path.  string userHome = os:getUserHome();  io:println(\"Userhome: \", userHome); }    Environment Variables  The os library provides functions to retrieve information about the OS and the current users of the OS.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/os;    public function main() {    string port = os:getEnv(\"HTTP_PORT\");  io:println(\"HTTP_PORT: \", port);    Returns the environment variable value associated with the HTTP_PORT.   string username = os:getUsername();  io:println(\"Username: \", username);    Returns the username of the current user.   string userHome = os:getUserHome();  io:println(\"Userhome: \", userHome); }    Returns the current user’s home directory path.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run environment_variables.bal HTTP_PORT: 5005 Username: Alex Userhome: /Users/Alex    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/error-handling.html","name":"Error Handling","summary":"Usually a function handles errors by passing them up to its caller.\n The main function can also return an error.Convert bytes to a string and then to an int.The is operator can be used to distinguish errors\n from others value.The main function can return an error.The check expression is shorthand ...","content":"/  /  / Error Handling  import ballerina/io;  // Convert bytes to a string and then to an int. function intFromBytes(byte[] bytes) returns int|error {  string|error ret = string:fromBytes(bytes);   // The `is` operator can be used to distinguish errors  // from others value.  if ret is error {  return ret;  } else {  return int:fromString(ret);  } }  // The `main` function can return an error. public function main() returns error? {  int|error res = intFromBytes([104, 101, 108, 108, 111]); if res is error {  // The `check` expression is shorthand for this pattern of  // checking if a value is an error and returning that value.  return res;   } else {  io:println(\"result: \", res);  } }    Error Handling  Usually a function handles errors by passing them up to its caller.  The main function can also return an error.    import ballerina/io;    function intFromBytes(byte[] bytes) returns int|error {  string|error ret = string:fromBytes(bytes);    Convert bytes to a string and then to an int.   if ret is error {  return ret;  } else {  return int:fromString(ret);  } }    The is operator can be used to distinguish errors  from others value.   public function main() returns error? {  int|error res = intFromBytes([104, 101, 108, 108, 111]); if res is error {    The main function can return an error.   return res;    The check expression is shorthand for this pattern of  checking if a value is an error and returning that value.   } else {  io:println(\"result: \", res);  } }    bal run error_handling.bal error: {ballerina/lang.int}NumberParsingError {\"message\":\"'string' value 'hello' cannot be converted to 'int'\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/error-reporting.html","name":"Error Reporting","summary":"Ballerina does not have exceptions. Errors are reported by functions returning\n error values.\n error is its own basic type.\n The return type of a function that may return an error value will be a union with error.\n An error value includes a string message.\n An error value includes stack trace ...","content":"/  /  / Error Reporting  import ballerina/io;  // Parses a string to convert to an integer value. // This function may return error values. // The return type is a union with error. function parse(string s) returns int|error {  int n = 0;  int[] cps = s.toCodePointInts();  foreach int cp in cps {  cp -= 0x30;  if cp < 0 || cp > 9 {  // If `cp` is not a digit construct and return // an error value with \"not a digit\" as the error message.  return error(\"not a digit\");  }  n = n * 10 + cp;  }  return n; }  public function main() {  // An `int` value is returned when the argument is a string  // that can be successfully parsed as an integer.  int|error x = parse(\"123\");  io:println(x);   // An `error` value is returned when the argument is a string  // that has a character that is not a digit.  int|error y = parse(\"1h\");  io:println(y); }    Error Reporting  Ballerina does not have exceptions. Errors are reported by functions returning  error values.  error is its own basic type.  The return type of a function that may return an error value will be a union with error.  An error value includes a string message.  An error value includes stack trace from the point where error(msg) is called.  Error values are immutable.    import ballerina/io;    function parse(string s) returns int|error {  int n = 0;  int[] cps = s.toCodePointInts();  foreach int cp in cps {  cp -= 0x30;  if cp < 0 || cp > 9 {    Parses a string to convert to an integer value.  This function may return error values.  The return type is a union with error.   return error(\"not a digit\");  }  n = n * 10 + cp;  }  return n; }    If cp is not a digit construct and return  an error value with “not a digit” as the error message.   public function main() {    int|error x = parse(\"123\");  io:println(x);    An int value is returned when the argument is a string  that can be successfully parsed as an integer.   int|error y = parse(\"1h\");  io:println(y); }    An error value is returned when the argument is a string  that has a character that is not a digit.   bal run error_reporting.bal 123 error(\"not a digit\")    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/error-subtyping.html","name":"Error Subtyping","summary":"distinct creates a new subtype and can be used to define\n subtypes of error.\n The name of the distinct error type can be used with the error\n constructor to create an error value of that type.\n Works like a nominal type: is operator can be used to\n distinguish distinct subtypes\n ...","content":"/  /  / Error Subtyping  import ballerina/io;  // `distinct` creates a new subtype. type XErr distinct error; type YErr distinct error;  type Err XErr|YErr;  // The name of the distinct type can be used with the error // constructor to create an error value of that type. // `err` holds an error value of type `XErr`. Err err = error XErr(\"Whoops!\");  function desc(Err err) returns string {  // `is` operator can be used to distinguish distinct subtypes.  return err is XErr ? \"X\" : \"Y\"; }  public function main() {  io:println(desc(err)); }    Error Subtyping  distinct creates a new subtype and can be used to define  subtypes of error.  The name of the distinct error type can be used with the error  constructor to create an error value of that type.  Works like a nominal type: is operator can be used to  distinguish distinct subtypes  Each occurrence of distinct has a unique identifier that is  used to tag instances of the type.    import ballerina/io;    type XErr distinct error; type YErr distinct error;    distinct creates a new subtype.   type Err XErr|YErr;    Err err = error XErr(\"Whoops!\");    The name of the distinct type can be used with the error  constructor to create an error value of that type.  err holds an error value of type XErr.   function desc(Err err) returns string {    return err is XErr ? \"X\" : \"Y\"; }    is operator can be used to distinguish distinct subtypes.   public function main() {  io:println(desc(err)); }    bal run error_subtyping.bal X    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/floating-point-numbers.html","name":"Floating Point Numbers","summary":"The float type is IEEE 64-bit binary floating point (same as double in Java) and supports same arithmetic operators as int.No implicit coversion between integers and floating point values are allowed.\n You can <T> for explicit conversions.This website uses cookies so that we can provide you with the best user ...","content":"/  /  / Floating Point Numbers  import ballerina/io;  public function main() {  float x = 1.0;   int n = 5;   // No implicit coversion between integers and floating point values are allowed. // You can `<T>` for explicit conversions.  float y = x + <float>n;  io:println(y); }    Floating Point Numbers  The float type is IEEE 64-bit binary floating point (same as double in Java) and supports same arithmetic operators as int.    import ballerina/io;    public function main() {  float x = 1.0;    int n = 5;    float y = x + <float>n;  io:println(y); }    No implicit coversion between integers and floating point values are allowed.  You can <T> for explicit conversions.   bal run floating_point_numbers.bal 6.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/filepaths.html","name":"File Paths","summary":"The Ballerina File API also contains utility functions to manipulate file paths in a way that is compatible with the\n target operating system.\n For more information on the underlying module,\n see the .Gets the absolute representation of the path.Checks whether the path is absolute.Gets the base name of the path.Gets ...","content":"/  /  / File Paths  import ballerina/file; import ballerina/io;  public function main() returns error? {  // Gets the absolute representation of the path.  string absValue = check file:getAbsolutePath(\"test.txt\");  io:println(\"Absolute path: \", absValue);   // Checks whether the path is absolute.  boolean isAbs = check file:isAbsolutePath(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);   // Gets the base name of the path.  string name = check file:basename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name);   // Gets the enclosing parent directory.  string parentPath = check file:parentPath(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath);   // Gets the shortest path name equivalent to the path by purely lexical processing.  string normalizedPath = check file:normalizePath(\"foo/../bar\", file:CLEAN);  io:println(\"Normalized path of foo/../bar: \", normalizedPath);   // Gets the list of path elements joined by the OS-specific path separator.  string[] parts = check file:splitPath(\"/A/B/C\");  io:println(string `Path elements of /A/B/C: ${parts.toString()}`);   // Joins any number of path elements into a single path.  string path = check file:joinPath(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path);   // Returns a relative path that is logically equivalent to the target path when joined to the base path.  string relPath = check file:relativePath(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); }    File Paths  The Ballerina File API also contains utility functions to manipulate file paths in a way that is compatible with the  target operating system.  For more information on the underlying module,  see the .    import ballerina/file; import ballerina/io;    public function main() returns error? {    string absValue = check file:getAbsolutePath(\"test.txt\");  io:println(\"Absolute path: \", absValue);    Gets the absolute representation of the path.   boolean isAbs = check file:isAbsolutePath(\"/A/B/C\");  io:println(\"/A/B/C is absolute: \", isAbs);    Checks whether the path is absolute.   string name = check file:basename(\"/A/B/C\");  io:println(\"Filename of /A/B/C: \", name);    Gets the base name of the path.   string parentPath = check file:parentPath(\"/A/B/C\");  io:println(\"Parent of /A/B/C: \", parentPath);    Gets the enclosing parent directory.   string normalizedPath = check file:normalizePath(\"foo/../bar\", file:CLEAN);  io:println(\"Normalized path of foo/../bar: \", normalizedPath);    Gets the shortest path name equivalent to the path by purely lexical processing.   string[] parts = check file:splitPath(\"/A/B/C\");  io:println(string `Path elements of /A/B/C: ${parts.toString()}`);    Gets the list of path elements joined by the OS-specific path separator.   string path = check file:joinPath(\"/\", \"foo\", \"bar\");  io:println(\"Built path of '/', 'foo', 'bar': \", path);    Joins any number of path elements into a single path.   string relPath = check file:relativePath(\"a/b/c\", \"a/c/d\");  io:println(\"Relative path between 'a/b/c' and 'a/c/d': \", relPath); }    Returns a relative path that is logically equivalent to the target path when joined to the base path.   # To run this sample, navigate to the directory that contains the # `.bal` file and issue the `bal run` command below. bal run filepaths.bal On Unix: Absolute path of test.txt: /A/test.txt /A/B/C is absolute: true Filename of /A/B/C: C Parent of /A/B/C: /A/B Normalized path of foo/../bar: bar Path elements of /A/B/C: [\"A\",\"B\",\"C\"] Built path of '/', 'foo', 'bar': /foo/bar Relative path between 'a/b/c' and 'a/c/d': ../../c/d    On Windows: Absolute path of test.txt: \\A\\test.txt /A/B/C is absolute: false Filename of /A/B/C: C Parent of /A/B/C: \\A\\B Normalized path of foo/../bar: bar Path elements of /A/B/C: [\"A\",\"B\",\"C\"] Built path of '/', 'foo', 'bar': \\foo\\bar Relative path between 'a/b/c' and 'a/c/d': ..\\..\\c\\d    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/foreach-statement.html","name":"Foreach Statement","summary":"The foreach statement iterates over an iterable value, by binding a variable to each member of the\n iterable value in order. foreach also works for strings, and will iterate over each character of the string.foreach statement can be used to iterate an array.\n Each iteration returns an element in the ...","content":"/  /  / Foreach Statement  import ballerina/io;  public function main() {  float v1 = sum([10.5, 20.5, 30.5]);  float v2 = sum2([10.5, 20.5, 30.5]);  io:println(\"v1:\", v1, \" v2:\", v2); }  function sum(float[] v) returns float {  float r = 0.0;  // `foreach` statement can be used to iterate an `array`.  // Each iteration returns an element in the `array`.  foreach float x in v {  r += x;  }  return r; }  function sum2(float[] v) returns float {  float r = 0.0;  // `m ..< n` creates a value that when iterated over will give the  // integers starting from `m` that are `< n`.  foreach int i in 0 ..< v.length() {  r += v[i];  }  return r; }    Foreach Statement  The foreach statement iterates over an iterable value, by binding a variable to each member of the  iterable value in order. foreach also works for strings, and will iterate over each character of the string.    import ballerina/io;    public function main() {  float v1 = sum([10.5, 20.5, 30.5]);  float v2 = sum2([10.5, 20.5, 30.5]);  io:println(\"v1:\", v1, \" v2:\", v2); }    function sum(float[] v) returns float {  float r = 0.0;    foreach float x in v {  r += x;  }  return r; }    foreach statement can be used to iterate an array.  Each iteration returns an element in the array.   function sum2(float[] v) returns float {  float r = 0.0;    foreach int i in 0 ..< v.length() {  r += v[i];  }  return r; }    m ..< n creates a value that when iterated over will give the  integers starting from m that are < n.   bal run foreach_statement.bal v1:61.5 v2:61.5    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/functions.html","name":"Functions","summary":"A function accpets zero or more arguments and returns a single value.\n Function parameters are declared as in C. You are not allowed to assign to parameters in Ballerina.This function definition has two parameters of type int.\n returns clause specifies type of return value.return statement returns a value.This website uses ...","content":"/  /  / Functions  import ballerina/io;  // This function definition has two parameters of type `int`. // `returns` clause specifies type of return value. function add(int x, int y) returns int {  int sum = x + y;  // `return` statement returns a value.  return sum; }  public function main() {  io:println(add(5, 11)); }    Functions  A function accpets zero or more arguments and returns a single value.  Function parameters are declared as in C. You are not allowed to assign to parameters in Ballerina.    import ballerina/io;    function add(int x, int y) returns int {  int sum = x + y;    This function definition has two parameters of type int.  returns clause specifies type of return value.   return sum; }    return statement returns a value.   public function main() {  io:println(add(5, 11)); }    bal run functions.bal 16    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/function-values.html","name":"Function Values","summary":"Functions are values and work as closures\n Function type is a Separate basic type\n Anonymous function and type syntax look like function definition without the nameAnonymous function syntaxFunction type syntaxModule level function defintionFunction isEven refered as a valueArrays provide the usual functional methods:\n filter, map, forEach, reduceShorthand syntax for when ...","content":"/  /  / Function Values  import ballerina/io;  // Anonymous function syntax var isOdd = function(int n) returns boolean {  return n % 2 != 0; };  // Function type syntax type IntFilter function (int n) returns boolean;  // Module level function defintion function isEven(int n) returns boolean {  return n % 2 == 0; }  public function main() {  // Function `isEven` refered as a value  IntFilter f = isEven;   int[] nums = [1, 2, 3];   // Arrays provide the usual functional methods: // filter, map, forEach, reduce  int[] evenNums = nums.filter(f);  io:println(evenNums);   // Shorthand syntax for when type is inferred and body is an expression  int[] oddNums = nums.filter(n => n % 2 != 0);  io:println(oddNums); }    Function Values  Functions are values and work as closures  Function type is a Separate basic type  Anonymous function and type syntax look like function definition without the name    import ballerina/io;    var isOdd = function(int n) returns boolean {  return n % 2 != 0; };    Anonymous function syntax   type IntFilter function (int n) returns boolean;    Function type syntax   function isEven(int n) returns boolean {  return n % 2 == 0; }    Module level function defintion   public function main() {    IntFilter f = isEven;    Function isEven refered as a value   int[] nums = [1, 2, 3];    int[] evenNums = nums.filter(f);  io:println(evenNums);    Arrays provide the usual functional methods:  filter, map, forEach, reduce   int[] oddNums = nums.filter(n => n % 2 != 0);  io:println(oddNums); }    Shorthand syntax for when type is inferred and body is an expression   bal run function_values.bal [2] [1,3]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/graphql-hello-world.html","name":"Hello World","summary":"A GraphQL service in Ballerina represents a GraphQL schema. Each resource function of the graphql:Service\n represents a resolver function in the root Query type. The return type of each resource function will be the\n type of each field represented by the resource function.\n For more information on the underlying package, ...","content":"/  /  / Hello World  import ballerina/graphql;  // The `graphql:Service` exposes a GraphQL service on the provided port. service graphql:Service /graphql on new graphql:Listener(4000) {   // A resource function inside a `graphql:Service` represents a resolver.  // This resource can be queried using the `{ greeting }`.  resource function get greeting() returns string {   return \"Hello, World\";  } }    Hello World  A GraphQL service in Ballerina represents a GraphQL schema. Each resource function of the graphql:Service  represents a resolver function in the root Query type. The return type of each resource function will be the  type of each field represented by the resource function.  For more information on the underlying package, see the  .  This example shows a simple GraphQL endpoint that has a single field in the root Query type, which returns a string.    import ballerina/graphql;    service graphql:Service /graphql on new graphql:Listener(4000) {    The graphql:Service exposes a GraphQL service on the provided port.   resource function get greeting() returns string {    A resource function inside a graphql:Service represents a resolver.  This resource can be queried using the { greeting }.   return \"Hello, World\";  } }    # To start the service, navigate to the directory that contains the # `.bal` file, and issue the `bal run` command below. # Since Ballerina GraphQL runs on a Ballerina HTTP listener, an `http:Listener` # log will be printed. bal run graphql_hello_world.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:4000    # Send a query to the GraphQL endpoint using a cURL command. # The query used: { greeting } curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ greeting }\" }' 'http://localhost:4000/graphql' {\"data\":{\"greeting\":\"Hello, World\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/graphql-input-types.html","name":"Input Types","summary":"GraphQL resources can have input parameters, which will be mapped to input\n values in the generated GraphQL schema. Currently, the supported input types\n are: string, int, boolean, float, and enum. Any of these types can\n be an optional and/or defaultable types.\n For more information on the underlying package, see the\n ...","content":"/  /  / Input Types  import ballerina/graphql;  service /graphql on new graphql:Listener(4000) {   // The input parameters in a resource function becomes input values of the  // corresponding GraphQL field. In this GraphQL schema, the // `greeting` field of `Query` type has a `name` input value, which accepts  // `string` values.  isolated resource function get greeting(string name) returns string {   return string`Hello, ${name}`;  } }    Input Types  GraphQL resources can have input parameters, which will be mapped to input  values in the generated GraphQL schema. Currently, the supported input types  are: string, int, boolean, float, and enum. Any of these types can  be an optional and/or defaultable types.  For more information on the underlying package, see the  .    import ballerina/graphql;    service /graphql on new graphql:Listener(4000) {    isolated resource function get greeting(string name) returns string {    The input parameters in a resource function becomes input values of the  corresponding GraphQL field. In this GraphQL schema, the  greeting field of Query type has a name input value, which accepts  string values.   return string`Hello, ${name}`;  } }    # To start the service, navigate to the directory that contains the # `.bal` file, and issue the `bal run` command below. # Since Ballerina GraphQL runs on a Ballerina HTTP listener, an `http:Listener` # log will be printed. bal run graphql_input_types.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:4000    # Send a query to the GraphQL endpoint using a cURL command. # The query used: { greeting(name: \"Walter\") } curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ greeting(name: \\\"Walter\\\") }\" }' 'http://localhost:4000/graphql' {\"data\":{\"greeting\":\"Hello, Walter\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/graphql-hierarchical-resource-paths.html","name":"Hierarchical Resource Paths","summary":"The resources in Ballerina GraphQL services can have hierarchical resource\n paths. When a hierarchical path is present, an OBJECT type is created for\n each intermediate path segment with the same name. Every sub path under a\n path segment will be added as a field of the created type.\n For more ...","content":"/  /  / Hierarchical Resource Paths  import ballerina/graphql;  // This service has multiple resources with hierarchical resource paths. // The root operation has a field named `profile` and it is the first segment // of the hierarchical path in this service. The type of this field will also // be `profile`. (For hierarchical paths, the field name and the type name will // be the same). The `profile` type has two fields: `quote` and `name`. The // type of the `quote` field is `String` and the type of the `name` field is // `name`. The `name` type has two fields:`first` and the `last`. Both of the // fields are of type `String`. service graphql:Service /graphql on new graphql:Listener(4000) {   // This resource represents the `quote` field under the `profile` object.  resource function get profile/quote() returns string {  return \"I am the one who knocks!\";  }   // This resource represents the `first` field under the `name` object type.  // The `name` field in the `profile` object is of type `name`.  resource function get profile/name/first() returns string {  return \"Walter\";  }   // This resource represents the `last` field under the `name` object type.  // The `name` field in the `profile` object is of type `name`.  resource function get profile/name/last() returns string {  return \"White\";  } }    Hierarchical Resource Paths  The resources in Ballerina GraphQL services can have hierarchical resource  paths. When a hierarchical path is present, an OBJECT type is created for  each intermediate path segment with the same name. Every sub path under a  path segment will be added as a field of the created type.  For more information on the underlying package, see the  .  This example shows a GraphQL endpoint, which has a profile field of type Person.  A GraphQL client can query this service to retrieve specific fields or subfields of the Person object.    import ballerina/graphql;    service graphql:Service /graphql on new graphql:Listener(4000) {    This service has multiple resources with hierarchical resource paths.  The root operation has a field named profile and it is the first segment  of the hierarchical path in this service. The type of this field will also  be profile. (For hierarchical paths, the field name and the type name will  be the same). The profile type has two fields: quote and name. The  type of the quote field is String and the type of the name field is  name. The name type has two fields:first and the last. Both of the  fields are of type String.   resource function get profile/quote() returns string {  return \"I am the one who knocks!\";  }    This resource represents the quote field under the profile object.   resource function get profile/name/first() returns string {  return \"Walter\";  }    This resource represents the first field under the name object type.  The name field in the profile object is of type name.   resource function get profile/name/last() returns string {  return \"White\";  } }    This resource represents the last field under the name object type.  The name field in the profile object is of type name.   # To start the service, navigate to the directory that contains the # `.bal` file, and issue the `bal run` command below. # Since Ballerina GraphQL runs on a Ballerina HTTP listener, an `http:Listener` # log will be printed. bal run graphql_hierarchical_resource_paths.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:4000    # Send a query to the GraphQL endpoint using a cURL command. # The query used: { profile { quote name { first } } } curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ profile { quote name { first } } }\" }' 'http://localhost:4000/graphql' {\"data\":{\"profile\":{\"quote\":\"I am the one who knocks!\", \"name\":{\"first\":\"Walter\"}}}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/graphql-returning-record-values.html","name":"Returning Record Values","summary":"In Ballerina GraphQL, a service represents the GraphQL endpoint.\n Each resource function inside the service represents a resolver function for a field in the root Query type.\n For more information on the underlying package, see the\n .\n This example shows a GraphQL endpoint, which has a field profile of type ...","content":"/  /  / Returning Record Values  import ballerina/graphql;  service graphql:Service /graphql on new graphql:Listener(4000) {   // Ballerina GraphQL resolvers can return `record` values. The record will be mapped to an `OBJECT` type.  resource function get profile() returns Person {   return {  name: \"Walter White\",  age: 51,  address: {  number: \"308\",  street: \"Negra Arroyo Lane\",  city: \"Albuquerque\"  }  };  } }  // Define the custom record types for the returning data. public type Person record {  string name;  int age;  Address address; }; public type Address record {  string number;  string street;  string city; };    Returning Record Values  In Ballerina GraphQL, a service represents the GraphQL endpoint.  Each resource function inside the service represents a resolver function for a field in the root Query type.  For more information on the underlying package, see the  .  This example shows a GraphQL endpoint, which has a field profile of type Person.  A GraphQL client can query on this service to retrieve specific fields or subfields of the Person object.    import ballerina/graphql;    service graphql:Service /graphql on new graphql:Listener(4000) {    resource function get profile() returns Person {    Ballerina GraphQL resolvers can return record values. The record will be mapped to an OBJECT type.   return {  name: \"Walter White\",  age: 51,  address: {  number: \"308\",  street: \"Negra Arroyo Lane\",  city: \"Albuquerque\"  }  };  } }    public type Person record {  string name;  int age;  Address address; }; public type Address record {  string number;  string street;  string city; };    Define the custom record types for the returning data.   # To start the service, navigate to the directory that contains the # `.bal` file, and issue the `bal run` command below. # Since Ballerina GraphQL runs on a Ballerina HTTP listener, an `http:Listener` # log will be printed. bal run graphql_returning_record_values.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:4000    # Send a query to the GraphQL endpoint using a cURL command. # The query used: { profile { name, address { city } } } curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ profile { name, address { city } } }\" }' 'http://localhost:4000/graphql' {\"data\":{\"profile\":{\"name\":\"Walter White\", \"address\":{\"city\":\"Albuquerque\"}}}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/graphql-returning-service-objects.html","name":"Returning Service Objects","summary":"A GraphQL resource function can return service objects. The returning\n service objects are mapped to the OBJECT type in the GraphQL schema. Each\n resource function in the returned service object becomes a field in the\n created OBJECT type.\n For more information on the underlying package, see the\n .Resource functions can ...","content":"/  /  / Returning Service Objects  import ballerina/graphql;  service graphql:Service /graphql on new graphql:Listener(4000) {   // Resource functions can return service objects. The returning service  // object is mapped to an `OBJECT` type in GraphQL. Each resource  // function is mapped to a field in the `OBJECT`.  isolated resource function get profile() returns Person {   return new(\"Walter White\", 51);  } }  // Define a service class to use in GraphQL service. service class Person {  private string name;  private int age;   isolated function init(string name, int age) {  self.name = name;  self.age = age;  }   // Each resource function becomes a field of the `Person` type.  isolated resource function get name() returns string {  return self.name;  }  isolated resource function get age() returns int {  return self.age;  }  isolated resource function get isAdult() returns boolean {  return self.age > 21;  } }    Returning Service Objects  A GraphQL resource function can return service objects. The returning  service objects are mapped to the OBJECT type in the GraphQL schema. Each  resource function in the returned service object becomes a field in the  created OBJECT type.  For more information on the underlying package, see the  .    import ballerina/graphql;    service graphql:Service /graphql on new graphql:Listener(4000) {    isolated resource function get profile() returns Person {    Resource functions can return service objects. The returning service  object is mapped to an OBJECT type in GraphQL. Each resource  function is mapped to a field in the OBJECT.   return new(\"Walter White\", 51);  } }    service class Person {  private string name;  private int age;    Define a service class to use in GraphQL service.   isolated function init(string name, int age) {  self.name = name;  self.age = age;  }    isolated resource function get name() returns string {  return self.name;  }  isolated resource function get age() returns int {  return self.age;  }  isolated resource function get isAdult() returns boolean {  return self.age > 21;  } }    Each resource function becomes a field of the Person type.   # To start the service, navigate to the directory that contains the # `.bal` file, and issue the `bal run` command below. # Since Ballerina GraphQL runs on a Ballerina HTTP listener, an `http:Listener` # log will be printed. bal run graphql_returning_service_objects.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:4000    # Send a query to the GraphQL endpoint using a cURL command. # The query used: { profile { name isAdult } } curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ profile { name isAdult } }\" }' 'http://localhost:4000/graphql' {\"data\":{\"profile\":{\"name\":\"Walter White\", \"isAdult\":true}}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-bidirectional-streaming.html","name":"Bidirectional Streaming RPC","summary":"The gRPC Server Connector exposes the gRPC service over HTTP2.\n This example demonstrates how a gRPC bidirectional streaming service and a client\n operate when each of them sends a sequence of messages using a read-write stream.\n In such scenarios, the two streams operate independently. Therefore, clients and servers can read ...","content":"/  /  / Bidirectional Streaming RPC  // This is the server implementation of the bidirectional streaming scenario. import ballerina/grpc;  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"Chat\" on new grpc:Listener(9090) {  remote function chat(ChatStringCaller caller,  stream<ChatMessage, error?> clientStream) returns error? {  // Reads and processes each message in the client stream.  check clientStream.forEach(function(ChatMessage chatMsg) {  checkpanic caller->sendString(  string `${chatMsg.name}: ${chatMsg.message}`);  });  // Once the client sends a notification to indicate the end of the stream, '()' is returned by the stream.  check caller->complete();  } } // This is the client implementation of the bidirectional streaming scenario. import ballerina/io;  // Creates a gRPC client to interact with the remote server. ChatClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  // Executes the RPC call and receives the customized streaming client.  ChatStreamingClient streamingClient = check ep->chat();   // Reads server responses in another strand.  future<error?> f1 = start readResponse(streamingClient);   // Sends multiple messages to the server.  ChatMessage[] messages = [  {name: \"Sam\", message: \"Hi\"},  {name: \"Ann\", message: \"Hey\"},  {name: \"John\", message: \"Hello\"}  ];  foreach ChatMessage msg in messages {  check streamingClient->sendChatMessage(msg);  }  // Once all the messages are sent, the client sends the message to notify the server about the completion.  check streamingClient->complete();   // Waits until all server messages are received.  check wait f1; }  function readResponse(ChatStreamingClient streamingClient) returns error? {  // Receives the server stream response iteratively.  string? result = check streamingClient->receiveString();  while !(result is ()) {  io:println(result);  result = check streamingClient->receiveString();  } }    Bidirectional Streaming RPC  The gRPC Server Connector exposes the gRPC service over HTTP2.  This example demonstrates how a gRPC bidirectional streaming service and a client  operate when each of them sends a sequence of messages using a read-write stream.  In such scenarios, the two streams operate independently. Therefore, clients and servers can read and write in any order.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service Chat { \trpc chat (stream ChatMessage)  returns (stream google.protobuf.StringValue); } message ChatMessage { \tstring name = 1; \tstring message = 2; }    This is the service definition for the bidirectional streaming scenario.   # Create new Protocol Buffers definition file `grpc_bidirectional_streaming.proto` and add service definition. # Run the command below in the Ballerina tools distribution for stub generation. bal grpc --input grpc_bidirectional_streaming.proto --output stubs    # Once you run the command, `grpc_bidirectional_streaming_pb.bal` file is generated inside stubs directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc;    This is the server implementation of the bidirectional streaming scenario.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"Chat\" on new grpc:Listener(9090) {  remote function chat(ChatStringCaller caller,  stream<ChatMessage, error?> clientStream) returns error? {    check clientStream.forEach(function(ChatMessage chatMsg) {  checkpanic caller->sendString(  string `${chatMsg.name}: ${chatMsg.message}`);  });    Reads and processes each message in the client stream.   check caller->complete();  } }    Once the client sends a notification to indicate the end of the stream, ‘()’ is returned by the stream.   # Create a Ballerina package. # Copy the generated `grpc_bidirectional_streaming_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_bidirectional_streaming.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. bal build service    # Run the service using the command below. bal run service/target/bin/service.jar    import ballerina/io;    This is the client implementation of the bidirectional streaming scenario.   ChatClient ep = check new(\"http://localhost:9090\");    Creates a gRPC client to interact with the remote server.   public function main () returns error? {    ChatStreamingClient streamingClient = check ep->chat();    Executes the RPC call and receives the customized streaming client.   future<error?> f1 = start readResponse(streamingClient);    Reads server responses in another strand.   ChatMessage[] messages = [  {name: \"Sam\", message: \"Hi\"},  {name: \"Ann\", message: \"Hey\"},  {name: \"John\", message: \"Hello\"}  ];  foreach ChatMessage msg in messages {  check streamingClient->sendChatMessage(msg);  }    Sends multiple messages to the server.   check streamingClient->complete();    Once all the messages are sent, the client sends the message to notify the server about the completion.   check wait f1; }    Waits until all server messages are received.   function readResponse(ChatStreamingClient streamingClient) returns error? {    string? result = check streamingClient->receiveString();  while !(result is ()) {  io:println(result);  result = check streamingClient->receiveString();  } }    Receives the server stream response iteratively.   # Create a Ballerina package. # Copy the generated `grpc_bidirectional_streaming_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_bidirectional_streaming_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. bal build client    # Run the client using the command below. bal run client/target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-client-streaming.html","name":"Client Streaming RPC","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This example includes a gRPC client streaming service and a client. The client writes a sequence of messages and sends them to the server.\n Once the client has finished writing the messages, it waits for the server to ...","content":"/  /  / Client Streaming RPC  // This is the server implementation of the client streaming scenario. import ballerina/grpc; import ballerina/log;  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {  remote function lotsOfGreetings(stream<string, grpc:Error?> clientStream)  returns string|error {  log:printInfo(\"Client connected successfully.\");  // Reads and processes each message in the client stream.  check clientStream.forEach(isolated function(string name) {  log:printInfo(\"Greet received: \" + name);  });  // Once the client sends a notification to indicate the end of the stream, '()' is returned by the stream.  return \"Ack\";  } } // This is the client implementation of the client streaming scenario. import ballerina/io;  // Creates a gRPC client to interact with the remote server. HelloWorldClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  // Executes the client-streaming RPC call and receives the streaming client.  LotsOfGreetingsStreamingClient streamingClient = check  ep->lotsOfGreetings();   // Sends multiple messages to the server.  string[] requests = [\"Hi Sam\", \"Hey Sam\", \"GM Sam\"];  foreach var greet in requests {  check streamingClient->sendString(greet);  }   // Once all the messages are sent, the server notifies the caller with a `complete` message.  check streamingClient->complete();   // Receives the server response.  string? response = check streamingClient->receiveString();  io:println(response);  }    Client Streaming RPC  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This example includes a gRPC client streaming service and a client. The client writes a sequence of messages and sends them to the server.  Once the client has finished writing the messages, it waits for the server to read them and return a response.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfGreetings (stream google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the client streaming scenario.   # Create new Protocol Buffers definition file `grpc_client_streaming.proto` and add service definition. # Run the command below in the Ballerina tools distribution for stub generation. bal grpc --input grpc_client_streaming.proto --output stubs    # Once you run the command, `grpc_client_streaming_pb.bal` file is generated inside stubs directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc; import ballerina/log;    This is the server implementation of the client streaming scenario.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {  remote function lotsOfGreetings(stream<string, grpc:Error?> clientStream)  returns string|error {  log:printInfo(\"Client connected successfully.\");    check clientStream.forEach(isolated function(string name) {  log:printInfo(\"Greet received: \" + name);  });    Reads and processes each message in the client stream.   return \"Ack\";  } }    Once the client sends a notification to indicate the end of the stream, ‘()’ is returned by the stream.   # Create a Ballerina package. # Copy the generated `grpc_client_streaming_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_client_streaming.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. bal build service    # Run the service using the command below. bal run service/target/bin/service.jar    import ballerina/io;    This is the client implementation of the client streaming scenario.   HelloWorldClient ep = check new(\"http://localhost:9090\");    Creates a gRPC client to interact with the remote server.   public function main () returns error? {    LotsOfGreetingsStreamingClient streamingClient = check  ep->lotsOfGreetings();    Executes the client-streaming RPC call and receives the streaming client.   string[] requests = [\"Hi Sam\", \"Hey Sam\", \"GM Sam\"];  foreach var greet in requests {  check streamingClient->sendString(greet);  }    Sends multiple messages to the server.   check streamingClient->complete();    Once all the messages are sent, the server notifies the caller with a complete message.   string? response = check streamingClient->receiveString();  io:println(response);    Receives the server response.   }    # Create a Ballerina package. # Copy the generated `grpc_client_streaming_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_client_streaming_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. bal build client    # Run the client using the command below. bal run client/target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-server-streaming.html","name":"Server Streaming RPC","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This example includes a gRPC server streaming service and a client. The\n client sends a request to the server and gets a stream to read the messages until all the messages are read.\n For more information on the ...","content":"/  /  / Server Streaming RPC  // This is the server implementation of the server streaming scenario. import ballerina/grpc; import ballerina/log;  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {  remote function lotsOfReplies(string name)  returns stream<string, error?>|error {  log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];  // Creates the array of responses by appending the received name.  int i = 0;  foreach string greet in greets {  greets[i] = greet + \" \" + name;  i += 1;  }  // Returns the stream of messages back to the client.  return greets.toStream();  } } // This is the client implementation for the server streaming scenario. import ballerina/grpc; import ballerina/io;  // Creates a gRPC client to interact with the remote server. HelloWorldClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  // Executes the streaming RPC call and gets the response as a stream.  stream<string, grpc:Error?> result = check ep->lotsOfReplies(\"WSO2\");  // Iterates through the stream and prints the content.  check result.forEach(function(string str) {  io:println(str);  }); }    Server Streaming RPC  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This example includes a gRPC server streaming service and a client. The  client sends a request to the server and gets a stream to read the messages until all the messages are read.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc lotsOfReplies (google.protobuf.StringValue)  returns (stream google.protobuf.StringValue); }    This is the service definition for the server streaming scenario.   # Create new Protocol Buffers definition file `grpc_server_streaming.proto` and add service definition. # Run the command below in the Ballerina tools distribution for stub generation. bal grpc --input grpc_server_streaming.proto --output stubs    # Once you run the command, `grpc_server_streaming_pb.bal` file is generated inside stubs directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc; import ballerina/log;    This is the server implementation of the server streaming scenario.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {  remote function lotsOfReplies(string name)  returns stream<string, error?>|error {  log:printInfo(\"Server received hello from \" + name);  string[] greets = [\"Hi\", \"Hey\", \"GM\"];    int i = 0;  foreach string greet in greets {  greets[i] = greet + \" \" + name;  i += 1;  }    Creates the array of responses by appending the received name.   return greets.toStream();  } }    Returns the stream of messages back to the client.   # Create a Ballerina package. # Copy the generated `grpc_server_streaming_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_server_streaming.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. bal build service    # Run the service using the command below. bal run service/target/bin/service.jar    import ballerina/grpc; import ballerina/io;    This is the client implementation for the server streaming scenario.   HelloWorldClient ep = check new(\"http://localhost:9090\");    Creates a gRPC client to interact with the remote server.   public function main () returns error? {    stream<string, grpc:Error?> result = check ep->lotsOfReplies(\"WSO2\");    Executes the streaming RPC call and gets the response as a stream.   check result.forEach(function(string str) {  io:println(str);  }); }    Iterates through the stream and prints the content.   # Create a Ballerina package. # Copy the generated `grpc_server_streaming_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_server_streaming_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. bal build client    # Run the client using the command below. bal run client/target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-secured-simple.html","name":"Secured Simple RPC","summary":"The gRPC Server Connector is used to expose gRPC services over HTTP/2.\n This example demonstrates how a gRPC secured simple service interacts with a gRPC simple client.\n For more information on the underlying module,\n see the .This is the service definition for the secured connection (HTTPS) scenario.This is the server ...","content":"/  /  / Secured Simple RPC  // This is the server implementation of the secured connection (HTTPS) scenario. import ballerina/grpc;  // Creates a gRPC Listener endpoint with TLS enabled. listener grpc:Listener securedEp = new (9090, {  host: \"localhost\",  secureSocket: {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } });  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on securedEp {  remote function hello(string request) returns string|error {  // Reads the request message and sends a response.  return \"Hello \" + request;  } } // This is the client implementation of the secured connection (HTTPS) scenario. import ballerina/io;  // Creates a gRPC client to interact securely with the remote server. HelloWorldClient ep = check new (\"https://localhost:9090\", {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  } });  public function main () returns error? {  // Executes a simple remote call.  string result = check ep->hello(\"WSO2\");  // Prints the received result.  io:println(result); }    Secured Simple RPC  The gRPC Server Connector is used to expose gRPC services over HTTP/2.  This example demonstrates how a gRPC secured simple service interacts with a gRPC simple client.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition for the secured connection (HTTPS) scenario.   # Create a new Protocol Buffers definition file named `grpc_secured_simple.proto` and add the service definition to it. # Run the command below in the Ballerina tools distribution for stub generation. bal grpc --input grpc_secured_simple.proto --output stubs    # Once you run the command, `grpc_secured_simple_pb.bal` file is generated inside stubs directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc;    This is the server implementation of the secured connection (HTTPS) scenario.   listener grpc:Listener securedEp = new (9090, {  host: \"localhost\",  secureSocket: {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } });    Creates a gRPC Listener endpoint with TLS enabled.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on securedEp {  remote function hello(string request) returns string|error {    return \"Hello \" + request;  } }    Reads the request message and sends a response.   # Create a Ballerina package. # Copy the generated `grpc_secured_simple_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_secured_simple.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. `bal build service`    # Run the service using the command below. bal run service/target/bin/service.jar    import ballerina/io;    This is the client implementation of the secured connection (HTTPS) scenario.   HelloWorldClient ep = check new (\"https://localhost:9090\", {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  } });    Creates a gRPC client to interact securely with the remote server.   public function main () returns error? {    string result = check ep->hello(\"WSO2\");    Executes a simple remote call.   io:println(result); }    Prints the received result.   # Create a Ballerina package. # Copy the generated `grpc_secured_simple_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_secured_simple_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. `bal build client`    # Run the client using the command below. bal run client/target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/hello-world-service.html","name":"Hello World Service","summary":"Let’s write a simple HTTP service in Ballerina.\n This example demonstrates the network primitives in the language that make it simpler to develop services.This function responds with string value Hello, World! to HTTP GET requests.Invoke the service using the “cURL” command below.This website uses cookies so that we can provide ...","content":"/  /  / Hello World Service  import ballerina/http;  service / on new http:Listener(9090) {   // This function responds with `string` value `Hello, World!` to HTTP GET requests.  resource function get greeting() returns string {  return \"Hello, World!\";  } }    Hello World Service  Let’s write a simple HTTP service in Ballerina.  This example demonstrates the network primitives in the language that make it simpler to develop services.    import ballerina/http;    service / on new http:Listener(9090) {    resource function get greeting() returns string {  return \"Hello, World!\";  } }    This function responds with string value Hello, World! to HTTP GET requests.   bal run hello_world_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/greeting Hello, World!    Invoke the service using the “cURL” command below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/hello-world.html","name":"Hello World Main","summary":"Let’s write the Hello World program in Ballerina.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your browser.  ...","content":"/  /  / Hello World Main  import ballerina/io;  public function main() {  io:println(\"Hello, World!\"); }    Hello World Main  Let’s write the Hello World program in Ballerina.    import ballerina/io;    public function main() {  io:println(\"Hello, World!\"); }    # To run this sample, place the source code in # `hello_world.bal` file and use `bal run` command. bal run hello_world.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/hierarchical-resources.html","name":"Hierarchical Resources","summary":"Resource name is relative path, which can have multiple path seqments.\n Base path is absolute path. Single listener can have multple services each with different base paths.Base path of this service is /demo.You can combine base path and relative path to get the path of the resource, that is /demo/greeting/hello.This ...","content":"/  /  / Hierarchical Resources  import ballerina/http;  // Base path of this service is `/demo`. service /demo on new http:Listener(8080) {  // You can combine base path and relative path to get the path of the resource, that is `/demo/greeting/hello`.  resource function get greeting/hello(string name) returns string {  return \"Hello, \" + name;  } }    Hierarchical Resources  Resource name is relative path, which can have multiple path seqments.  Base path is absolute path. Single listener can have multple services each with different base paths.    import ballerina/http;    service /demo on new http:Listener(8080) {    Base path of this service is /demo.   resource function get greeting/hello(string name) returns string {  return \"Hello, \" + name;  } }    You can combine base path and relative path to get the path of the resource, that is /demo/greeting/hello.   bal run hierarchical_resources.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    # Run this cURL command to invoke the resource. curl \"localhost:8080/demo/greeting/hello?name=Ballerina\" Hello, Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-simple-with-headers.html","name":"Simple RPC With Headers","summary":"The gRPC Server Connector exposes the gRPC service over HTTP2.\n This example demonstrates how the gRPC simple service interacts with the gRPC client, and how\n header values are handled.\n For more information on the underlying module,\n see the .This is the service definition of the simple scenario.This is the server ...","content":"/  /  / Simple RPC With Headers  // This is the server implementation of the simple RPC scenario. import ballerina/grpc; import ballerina/log;  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {   remote function hello(ContextString request) returns ContextString|error {  // Reads the request message and creates a response.  string message = \"Hello \" + request.content;   // Reads the header value in the request message by passing the request header map and header key.  string reqHeader = check grpc:getHeader(request.headers,  \"client_header_key\");  log:printInfo(\"Server received header value: \" + reqHeader);   // Sends the response with the header.  return {content: message, headers: {server_header_key:  \"Response Header value\"}};  } } // This is the client implementation of the simple RPC scenario. import ballerina/grpc; import ballerina/io;  // Creates a gRPC client to interact with the remote server. HelloWorldClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  // Creates the request message with the header value.  ContextString requestMessage =  {content: \"WSO2\", headers: {client_header_key: \"0987654321\"}};   // Executes a simple remote call.  ContextString result = check ep->helloContext(requestMessage);   // Prints the received result.  io:println(result.content);   // Reads the header value in the response message and prints it.  io:println(check grpc:getHeader(result.headers, \"server_header_key\")); }    Simple RPC With Headers  The gRPC Server Connector exposes the gRPC service over HTTP2.  This example demonstrates how the gRPC simple service interacts with the gRPC client, and how  header values are handled.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition of the simple scenario.   # Create a new Protocol Buffers definition file named `grpc_simple_with_headers.proto` and add the service definition. # Run the command below in the Ballerina tools distribution for stub generation. `bal grpc --input grpc_simple_with_headers.proto --output stubs`    # Once you run the command, the `grpc_simple_with_headers_pb.bal` file is generated inside the `stubs` directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc; import ballerina/log;    This is the server implementation of the simple RPC scenario.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {    remote function hello(ContextString request) returns ContextString|error {    string message = \"Hello \" + request.content;    Reads the request message and creates a response.   string reqHeader = check grpc:getHeader(request.headers,  \"client_header_key\");  log:printInfo(\"Server received header value: \" + reqHeader);    Reads the header value in the request message by passing the request header map and header key.   return {content: message, headers: {server_header_key:  \"Response Header value\"}};  } }    Sends the response with the header.   # Create a Ballerina package. # Copy the generated `grpc_simple_with_headers_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_simple_with_headers.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. `bal build service`    # Run the service using the command below. `bal run service/target/bin/service.jar`    import ballerina/grpc; import ballerina/io;    This is the client implementation of the simple RPC scenario.   HelloWorldClient ep = check new(\"http://localhost:9090\");    Creates a gRPC client to interact with the remote server.   public function main () returns error? {    ContextString requestMessage =  {content: \"WSO2\", headers: {client_header_key: \"0987654321\"}};    Creates the request message with the header value.   ContextString result = check ep->helloContext(requestMessage);    Executes a simple remote call.   io:println(result.content);    Prints the received result.   io:println(check grpc:getHeader(result.headers, \"server_header_key\")); }    Reads the header value in the response message and prints it.   # Create a Ballerina package. # Copy the generated `grpc_simple_with_headers_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_simple_with_headers_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. `bal build client`    # Run the client using the command below. `bal run client/target/bin/client.jar`    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/grpc-simple.html","name":"Simple RPC","summary":"The gRPC Server Connector exposes the gRPC service over HTTP2.\n This example demonstrates how the gRPC simple service interacts with the gRPC client.\n For more information on the underlying module,\n see the .This is the service definition of the simple scenario.This is the server implementation of the simple RPC scenario.Reads ...","content":"/  /  / Simple RPC  // This is the server implementation of the simple RPC scenario. import ballerina/grpc;  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {   remote function hello(string request) returns string|error {  // Reads the request message and sends a response.  return \"Hello \" + request;  } } // This is the client implementation of the simple RPC scenario. import ballerina/io;  // Creates a gRPC client to interact with the remote server. HelloWorldClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  // Executes a simple remote call.  string result = check ep->hello(\"WSO2\");  // Prints the received result.  io:println(result); }    Simple RPC  The gRPC Server Connector exposes the gRPC service over HTTP2.  This example demonstrates how the gRPC simple service interacts with the gRPC client.  For more information on the underlying module,  see the .    syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\"; service HelloWorld { \trpc hello (google.protobuf.StringValue)  returns (google.protobuf.StringValue); }    This is the service definition of the simple scenario.   # Create a new Protocol Buffers definition file named `grpc_simple.proto` and add the service definition. # Run the command below from the Ballerina tools distribution for stub generation. `bal grpc --input grpc_simple.proto --output stubs`    # Once you run the command, the `grpc_simple_pb.bal` file is generated inside the `stubs` directory.    # For more information on how to use the Ballerina Protocol Buffers tool, see the [Proto To Ballerina](https://ballerina.io/learn/by-example/proto-to-ballerina.html) example.    import ballerina/grpc;    This is the server implementation of the simple RPC scenario.   @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"HelloWorld\" on new grpc:Listener(9090) {    remote function hello(string request) returns string|error {    return \"Hello \" + request;  } }    Reads the request message and sends a response.   # Create a Ballerina package. # Copy the generated `grpc_simple_pb.bal` stub file to the package. # For example, if you create a package named `service`, copy the stub file to the `service` package.    # Create a new `grpc_simple.bal` Ballerina file inside the `service` package and add the service implementation.    # Execute the command below to build the 'service' package. `bal build service`    # Run the service using the command below. bal run service/target/bin/service.jar    import ballerina/io;    This is the client implementation of the simple RPC scenario.   HelloWorldClient ep = check new(\"http://localhost:9090\");    Creates a gRPC client to interact with the remote server.   public function main () returns error? {    string result = check ep->hello(\"WSO2\");    Executes a simple remote call.   io:println(result); }    Prints the received result.   # Create a Ballerina package. # Copy the generated `grpc_unary_blocking_pb.bal` stub file to the package. # For example, if you create a package named `client`, copy the stub file to the `client` package.    # Create a new `grpc_unary_blocking_client.bal` Ballerina file inside the `client` package and add the client implementation.    # Execute the command below to build the 'client' package. bal build client    # Run the client using the command below. bal run client/target/bin/client.jar    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-1-1-to-2-0-protocol-switch.html","name":"HTTP 1.1 to 2.0 Protocol Switch","summary":"In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it\n to another service over the HTTP/2.0 protocol.\n For more information on the underlying module,\n see the .HTTP version is set to 2.0.Forward the  to the http2 service.Handle the errors that are returned ...","content":"/  /  / HTTP 1.1 to 2.0 Protocol Switch  import ballerina/http;  // HTTP version is set to 2.0. http:Client http2serviceClientEP =  checkpanic new (\"http://localhost:7090\", {httpVersion: \"2.0\"});  service /http11Service on new http:Listener(9090) {   resource function 'default .(http:Request clientRequest)  returns http:Response {  // Forward the [clientRequest](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request) to the `http2` service.  http:Response|error clientResponse =  http2serviceClientEP->forward(\"/http2service\", clientRequest);   http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {  // Handle the errors that are returned when invoking the  // [forward](https://docs.central.ballerina.io/ballerina/http/latest/clients/HttpClient#forward) function.  response.statusCode = 500;  response.setPayload(<@untainted>clientResponse.message());   }  // Send the response back to the caller.  return response;   } }  // HTTP version is set to 2.0. listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});  service /http2service on http2serviceEP {   resource function 'default .() returns json {  // Construct the response payload.  json response = {\"response\":{\"message\":\"response from http2 service\"}};   // Send the response back to the caller (http11Service).  return response;  } }    HTTP 1.1 to 2.0 Protocol Switch  In this example, the Ballerina HTTP service receives a message over the HTTP/1.1 protocol and forwards it  to another service over the HTTP/2.0 protocol.  For more information on the underlying module,  see the .    import ballerina/http;    http:Client http2serviceClientEP =  checkpanic new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   service /http11Service on new http:Listener(9090) {    resource function 'default .(http:Request clientRequest)  returns http:Response {    http:Response|error clientResponse =  http2serviceClientEP->forward(\"/http2service\", clientRequest);    Forward the to the http2 service.   http:Response response = new;  if (clientResponse is http:Response) {  response = clientResponse;  } else {    response.statusCode = 500;  response.setPayload(<@untainted>clientResponse.message());    Handle the errors that are returned when invoking the  function.   }    return response;    Send the response back to the caller.   } }    listener http:Listener http2serviceEP = new (7090,  config = {httpVersion: \"2.0\"});    HTTP version is set to 2.0.   service /http2service on http2serviceEP {    resource function 'default .() returns json {    json response = {\"response\":{\"message\":\"response from http2 service\"}};    Construct the response payload.   return response;  } }    Send the response back to the caller (http11Service).   # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_1_1_to_2_0_protocol_switch.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/http11Service {\"response\":{\"message\":\"response from http2 service\"}}    Invoke the HTTP/1.1 service using “cURL”.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-100-continue.html","name":"100 Continue","summary":"Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.\n 100-continue indicates that the server has received the request headers and the client can proceed with sending the request.\n For more information on the underlying module,\n see the ..Send a 100-continue response to the ...","content":"/  /  / 100 Continue  import ballerina/http; import ballerina/log;  service /hello on new http:Listener(9090) {   resource function 'default .(http:Caller caller, http:Request request)  returns string|http:InternalServerError|http:ExpectationFailed {  // [Check if the client expects a 100-continue response](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#expects100Continue).  if (request.expects100Continue()) {   string mediaType = request.getContentType();  if (mediaType.toLowerAscii() == \"text/plain\") {  // Send a 100-continue response to the client.  var result = caller->continue();   if (result is error) {  log:printError(\"Error sending response\", 'error = result);  }  } else {  // Send a 417 response to ignore the payload since content type is mismatched  // with the expected content type.  http:ExpectationFailed resp = {body:\"Unprocessable Entity\"};  return resp;   }  }   // The client starts sending the payload once it receives the  // 100-continue response. Retrieve the payload that is sent by the client.  http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  return \"Hello World!\\n\";  } else {  http:InternalServerError resp = {body:payload.message()};  return resp;  }  } }    100 Continue  Convenience functions are provided in the HTTP library for ease of use when handling 100-continue scenarios.  100-continue indicates that the server has received the request headers and the client can proceed with sending the request.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    service /hello on new http:Listener(9090) {    resource function 'default .(http:Caller caller, http:Request request)  returns string|http:InternalServerError|http:ExpectationFailed {    if (request.expects100Continue()) {    .   string mediaType = request.getContentType();  if (mediaType.toLowerAscii() == \"text/plain\") {    var result = caller->continue();    Send a 100-continue response to the client.   if (result is error) {  log:printError(\"Error sending response\", 'error = result);  }  } else {    http:ExpectationFailed resp = {body:\"Unprocessable Entity\"};  return resp;    Send a 417 response to ignore the payload since content type is mismatched  with the expected content type.   }  }    http:Response res = new;  var payload = request.getTextPayload();  if (payload is string) {  log:printInfo(payload);  return \"Hello World!\\n\";  } else {  http:InternalServerError resp = {body:payload.message()};  return resp;  }  } }    The client starts sending the payload once it receives the  100-continue response. Retrieve the payload that is sent by the client.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_expect_header.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 time = 2021-01-21 20:31:28,347 level = INFO module = \"\" message = \"TEST 100 CONTINUE\"    #Run the cURL command below to run the client. curl -v -d \"TEST 100 CONTINUE\" http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: text/plain' * Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Length: 17 > Content-Type: text/plain > < HTTP/1.1 100 Continue < server: ballerina < date: Tue, 22 Sep 2020 09:16:18 +0530 * We are completely uploaded and fine < HTTP/1.1 200 OK < content-type: text/plain < content-length: 13 < server: ballerina < date: Tue, 22 Sep 2020 09:16:18 +0530 < Hello World! * Connection #0 to host localhost left intact    # Use the following client to invoke the service using an unsupported media type. Service is supposed to ignore # the payload if the content type does not matched. curl -v -d '{\"TEST\":\"100 CONTINUE\"}' http://localhost:9090/hello -H 'Expect:100-continue' -H 'Content-Type: application/json' * Connected to localhost (127.0.0.1) port 9090 (#0) > POST /hello HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Expect:100-continue > Content-Type: application/json > Content-Length: 25 > < HTTP/1.1 417 Expectation Failed < content-type: text/plain < content-length: 20 < server: ballerina < date: Tue, 22 Sep 2020 09:19:53 +0530 * HTTP error before end of send, stop sending < * Closing connection 0 Unprocessable Entity    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-absolute-path-and-path.html","name":"Absolute Path and Resource Path","summary":"Ballerina supports writing RESTful services according to the JAX-RS specification.\n You can use the absolute-resource-path and resource-name to access a resource function while the accessor-name,\n which is an HTTP verb as post and get to constrain your resource function in a RESTful manner.\n For more information on the underlying module,\n ...","content":"/  /  / Absolute Path and Resource Path  import ballerina/http;  // The `absolute resource path` identifier represents the absolute path to the service. When bound to a listener // endpoint, the service will be accessible at the specified path. If the path is omitted, then it defaults to `/`. // A string literal also can represent the absolute path. E.g., `\"/foo\"`. // The `type descriptor` represents the respective type of the service. E.g., `http:Service`. service http:Service /foo on new http:Listener(9090) {   // The `resource method name` identifier (`post`) confines the resource to the specified HTTP methods. In this  // instance, only `POST` requests are allowed. The `default` accessor name can be used to match with all methods  // including standard HTTP methods and custom methods.  // The `resource path` identifier associates the relative path to the service object's path. E.g., `bar`.  resource function post bar(http:Request req) returns http:Response {  // This method retrieves the request payload as a JSON.  var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {  // Since the JSON is known to be valid, `untaint` the data denoting that the data is trusted and set the JSON to the response.  res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted>payload.message());  }  // Reply to the client with the response.  return res;  } }    Absolute Path and Resource Path  Ballerina supports writing RESTful services according to the JAX-RS specification.  You can use the absolute-resource-path and resource-name to access a resource function while the accessor-name,  which is an HTTP verb as post and get to constrain your resource function in a RESTful manner.  For more information on the underlying module,  see the .    import ballerina/http;    service http:Service /foo on new http:Listener(9090) {    The absolute resource path identifier represents the absolute path to the service. When bound to a listener  endpoint, the service will be accessible at the specified path. If the path is omitted, then it defaults to /.  A string literal also can represent the absolute path. E.g., \"/foo\".  The type descriptor represents the respective type of the service. E.g., http:Service.   resource function post bar(http:Request req) returns http:Response {    The resource method name identifier (post) confines the resource to the specified HTTP methods. In this  instance, only POST requests are allowed. The default accessor name can be used to match with all methods  including standard HTTP methods and custom methods.  The resource path identifier associates the relative path to the service object’s path. E.g., bar.   var payload = req.getJsonPayload();  http:Response res = new;  if (payload is json) {    This method retrieves the request payload as a JSON.   res.setJsonPayload(<@untainted>payload);  } else {  res.statusCode = 500;  res.setPayload(<@untainted>payload.message());  }    Since the JSON is known to be valid, untaint the data denoting that the data is trusted and set the JSON to the response.   return res;  } }    Reply to the client with the response.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run absolute_path_and_path.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run the cURL command below to invoke the resource. curl http://localhost:9090/foo/bar -d \"{\\\"hello\\\": \\\"world\\\"}\" -H \"Content-Type: application/json\" {\"hello\": \"world\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-basic-auth.html","name":"Client - Basic Auth","summary":"A client, which is secured with Basic auth can be used to connect to\n a secured service.\n The client is enriched with the Authorization: Basic <token> header by\n passing the http:CredentialsConfig for the auth configuration of the\n client.\n For more information on the underlying module,\n see the .Defines the HTTP ...","content":"/  /  / Client - Basic Auth  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the Basic auth secured APIs. // The client is enriched with the `Authorization: Basic <token>` header by // passing the `http:CredentialsConfig` for the `auth` configuration of the // client. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"ldclakmal\",  password: \"ldclakmal@123\"  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - Basic Auth  A client, which is secured with Basic auth can be used to connect to  a secured service.  The client is enriched with the Authorization: Basic <token> header by  passing the http:CredentialsConfig for the auth configuration of the  client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"ldclakmal\",  password: \"ldclakmal@123\"  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the Basic auth secured APIs.  The client is enriched with the Authorization: Basic <token> header by  passing the http:CredentialsConfig for the auth configuration of the  client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before testing this sample, first start a sample service secured with Basic Auth. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_basic_auth.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-bearer-token-auth.html","name":"Client - Bearer Token Auth","summary":"A client, which is secured with Bearer token auth can be used to connect to\n a secured service.\n The client is enriched with the Authorization: Bearer <token> header by\n passing the http:BearerTokenConfig for the auth configuration of the\n client.Defines the HTTP client to call the secured APIs.\n The client is ...","content":"/  /  / Client - Bearer Token Auth  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the secured APIs. // The client is enriched with the `Authorization: Bearer <token>` header by // passing the `http:BearerTokenConfig` for the `auth` configuration of the // client. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  token: \"56ede317-4511-44b4-8579-a08f094ee8c5\"  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - Bearer Token Auth  A client, which is secured with Bearer token auth can be used to connect to  a secured service.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:BearerTokenConfig for the auth configuration of the  client.    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  token: \"56ede317-4511-44b4-8579-a08f094ee8c5\"  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the secured APIs.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:BearerTokenConfig for the auth configuration of the  client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before testing this sample, first start a secured sample service. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_bearer_token_auth.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-mutual-ssl.html","name":"Client - Mutual SSL","summary":"Ballerina supports mutual SSL, which is a certificate-based authentication\n process in which two parties (the client and server) authenticate each other by\n verifying the digital certificates. It ensures that both parties are assured\n of each other’s identity.\n For more information on the underlying module,\n see the .An HTTP client can ...","content":"/  /  / Client - Mutual SSL  import ballerina/http; import ballerina/io;  // An HTTP client can be configured to initiate new connections that are // secured via mutual SSL. // The [http:ClientSecureSocket](https://docs.central.ballerina.io/ballerina/http/latest/records/ClientSecureSocket) record provides the SSL-related configurations. http:Client securedEP = check new(\"https://localhost:9090\",  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  },  cert: \"../resource/path/to/public.crt\",  protocol: {  name: http:TLS  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - Mutual SSL  Ballerina supports mutual SSL, which is a certificate-based authentication  process in which two parties (the client and server) authenticate each other by  verifying the digital certificates. It ensures that both parties are assured  of each other’s identity.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  },  cert: \"../resource/path/to/public.crt\",  protocol: {  name: http:TLS  },  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } );    An HTTP client can be configured to initiate new connections that are  secured via mutual SSL.  The record provides the SSL-related configurations.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # As a prerequisite, navigate to the directory that contains the # `http_service_mutual_ssl.bal` file and execute the `bal run` command below. # (You may need to change the certificate file path and private key file path.) bal run http_service_mutual_ssl.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, private key file path and # trusted certificate file path.) bal run http_client_mutual_ssl.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-circuit-breaker.html","name":"Circuit Breaker","summary":"The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.\n For more information on the underlying module,\n see the .The circuit breaker looks for errors across a rolling time window.\n After the circuit is broken, it does not send requests to\n the ...","content":"/  /  / Circuit Breaker  import ballerina/http; import ballerina/lang.runtime;  // The circuit breaker looks for errors across a rolling time window. // After the circuit is broken, it does not send requests to // the backend until the `resetTime`. http:Client backendClientEP = check new (\"http://localhost:8080\", {  // Configuration options that control the behavior of the circuit  // breaker.  circuitBreaker: {  // Failure calculation window. This is how long the circuit  // breaker keeps the statistics for the operations.  rollingWindow: {   // Time period in seconds for which the failure  // threshold is calculated.  timeWindow: 10,   // The granularity (in seconds) at which the time  // window slides. The `RollingWindow` is divided into  // buckets and slides by these increments.  bucketSize: 2,   // Minimum number of requests in the `RollingWindow` that  // will trip the circuit.  requestVolumeThreshold: 0   },  // The threshold for request failures.  // When this threshold exceeds, the circuit trips. This is the  // ratio between failures and total requests. The ratio is  // calculated using the requests received within the given  // rolling window.  failureThreshold: 0.2,   // The time period (in seconds) to wait before attempting to  // make another request to the upstream service.  resetTime: 10,   // HTTP response status codes that are considered as failures  statusCodes: [400, 404, 500]   },  timeout: 2  }  );  // Create an HTTP service bound to the endpoint (circuitBreakerEP). service /cb on new http:Listener(9090) {   resource function get .(http:Request request)  returns http:Response|http:InternalServerError {  http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);  // If the `backendResponse` is an `http:Response`, it is sent back to  // the client. If `backendResponse` is an `http:ClientError`, an  // internal server error is returned to the client.  if (backendResponse is http:Response) {  return backendResponse;  } else {  return {body:backendResponse.message()};  }   } }  int counter = 1;  // This sample service is used to mock connection timeouts and service outages. // This should run separately from the `circuitBreakerDemo` service. service /hello on new http:Listener(8080) {   resource function get .() returns string|http:InternalServerError {  if (counter % 5 == 0) {  counter += 1;  // Delay the response by 5 seconds to  // mimic the network level delays.  runtime:sleep(5);   return \"Hello World!!!\";  } else if (counter % 5 == 3) {  counter += 1;  return {body:\"Error occurred while processing the request.\"};  } else {  counter += 1;  return \"Hello World!!!\";  }  } }    Circuit Breaker  The Circuit Breaker is used to gracefully handle network related errors, which occur when using the HTTP Client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/lang.runtime;    http:Client backendClientEP = check new (\"http://localhost:8080\", {    The circuit breaker looks for errors across a rolling time window.  After the circuit is broken, it does not send requests to  the backend until the resetTime.   circuitBreaker: {    Configuration options that control the behavior of the circuit  breaker.   rollingWindow: {    Failure calculation window. This is how long the circuit  breaker keeps the statistics for the operations.   timeWindow: 10,    Time period in seconds for which the failure  threshold is calculated.   bucketSize: 2,    The granularity (in seconds) at which the time  window slides. The RollingWindow is divided into  buckets and slides by these increments.   requestVolumeThreshold: 0    Minimum number of requests in the RollingWindow that  will trip the circuit.   },    failureThreshold: 0.2,    The threshold for request failures.  When this threshold exceeds, the circuit trips. This is the  ratio between failures and total requests. The ratio is  calculated using the requests received within the given  rolling window.   resetTime: 10,    The time period (in seconds) to wait before attempting to  make another request to the upstream service.   statusCodes: [400, 404, 500]    HTTP response status codes that are considered as failures   },  timeout: 2  }  );    service /cb on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (circuitBreakerEP).   resource function get .(http:Request request)  returns http:Response|http:InternalServerError {  http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);    if (backendResponse is http:Response) {  return backendResponse;  } else {  return {body:backendResponse.message()};  }    If the backendResponse is an http:Response, it is sent back to  the client. If backendResponse is an http:ClientError, an  internal server error is returned to the client.   } }    int counter = 1;    service /hello on new http:Listener(8080) {    This sample service is used to mock connection timeouts and service outages.  This should run separately from the circuitBreakerDemo service.   resource function get .() returns string|http:InternalServerError {  if (counter % 5 == 0) {  counter += 1;    runtime:sleep(5);    Delay the response by 5 seconds to  mimic the network level delays.   return \"Hello World!!!\";  } else if (counter % 5 == 3) {  counter += 1;  return {body:\"Error occurred while processing the request.\"};  } else {  counter += 1;  return \"Hello World!!!\";  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_circuit_breaker.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 time = 2021-01-21 19:20:04,028 level = INFO module = ballerina/http message = \"CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state.\" time = 2021-01-21 19:20:14,306 level = INFO module = ballerina/http message = \"CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state.\" time = 2021-01-21 19:20:17,810 level = INFO module = ballerina/http message = \"CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state.\" time = 2021-01-21 19:20:36,295 level = ERROR module = \"\" message = \"Error sending response from mock service\" error = \"Connection between remote client and host is closed\" time = 2021-01-21 19:22:38,052 = INFO module = ballerina/http message = \"CircuitBreaker failure threshold exceeded. Circuit tripped from CLOSE to OPEN state.\" time = 2021-01-21 19:23:23,628 level = INFO module = ballerina/http message = \"CircuitBreaker reset timeout reached. Circuit switched from OPEN to HALF_OPEN state.\" time = 2021-01-21 19:23:57,633 level = INFO module = ballerina/http message = \"CircuitBreaker trial run was successful. Circuit switched from HALF_OPEN to CLOSE state.\"    # The first two requests complete without any errors. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 17:07:58 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 17:08:00 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The third request responds with a `500 Internal Server Error` because the # mock service sends a `500` http status code when responding to every third # request. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < date: Mon, 21 Sep 2020 17:08:00 +0530 < server: ballerina < content-length: 53 < * Connection #0 to host localhost left intact Internal error occurred while processing the request.    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina < date: Mon, 21 Sep 2020 17:08:02 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 8.340 seconds.    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina < date: Mon, 21 Sep 2020 17:08:04 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 6.079 seconds.    curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina < date: Mon, 21 Sep 2020 17:08:07 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 3.475 seconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 17:08:12 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # The fifth request times out because the mock service times out when # responding to every fifth request. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 57 < server: ballerina < date: Mon, 21 Sep 2020 17:08:17 +0530 < * Connection #0 to host localhost left intact Idle timeout triggered before initiating inbound response    # Subsequent requests fail immediately since the reset timeout period has not # elapsed. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 99 < server: ballerina < date: Mon, 21 Sep 2020 17:08:22 +0530 < * Connection #0 to host localhost left intact Upstream service unavailable. Requests to upstream service will be suspended for 4.917 seconds.    # The request sent immediately after the timeout period expires, is the trial # request. It is sent to see if the backend service is back to normal. # If this request is successful, the circuit is set to `close` and normal # functionality resumes. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 17:08:32 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    # Since the immediate request after the timeout expired was successful, the # requests sent after that complete normally. curl -v http://localhost:9090/cb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /cb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 17:08:35 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-2-0-server-push.html","name":"HTTP 2.0 Server Push","summary":"This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.\n HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.\n For more information on the underlying module,\n see the .Create an endpoint with port 7090 to accept ...","content":"/  /  / HTTP 2.0 Server Push  import ballerina/http; import ballerina/log;  // Create an endpoint with port 7090 to accept HTTP requests. // HTTP version is set to 2.0. listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});  service /http2Service on http2ServiceEP {   resource function 'default .(http:Caller caller) {   // [Send a Push Promise](https://docs.central.ballerina.io/ballerina/http/latest/clients/Caller#promise).  http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  'error = promiseResponse1);  }   // Send another Push Promise.  http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  'error = promiseResponse2);  }   // Send one more Push Promise.  http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  'error = promiseResponse3);  }   // Construct the requested resource.  http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);   // Send the requested resource.  var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  'error = response);  }   // Construct promised resource1.  http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);   // [Push promised resource1](https://docs.central.ballerina.io/ballerina/http/latest/clients/Caller#pushPromisedResponse).  var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response1\", 'error = pushResponse1);  }   // Construct promised resource2.  http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);   // Push promised resource2.  var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response2\", 'error = pushResponse2);  }   // Construct promised resource3.  http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);   // Push promised resource3.  var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response3\", 'error = pushResponse3);  }  } } import ballerina/http; import ballerina/log;  // Create an [HTTP client](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client) that can send HTTP/2 messages. // HTTP version is set to 2.0. http:Client clientEP =  checkpanic new (\"http://localhost:7090\", {httpVersion: \"2.0\"});  public function main() {   http:Request serviceReq = new;  http:HttpFuture httpFuture = new;  // [Submit a request](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#submit).  var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq);   if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  'error = submissionResult);  return;  }   http:PushPromise?[] promises = [];  int promiseCount = 0;  // [Check if promises exists](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#hasPromise).  boolean hasPromise = clientEP->hasPromise(httpFuture);   while (hasPromise) {  http:PushPromise pushPromise = new;  // [Get the next promise](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#getNextPromise).  var nextPromiseResult = clientEP->getNextPromise(httpFuture);   if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  'error = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path);   if (pushPromise.path == \"/resource2\") {  // The client is not interested in receiving `/resource2`.  // Therefore, [reject the promise](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#rejectPromise).  clientEP->rejectPromise(pushPromise);   log:printInfo(\"Push promise for resource2 rejected\");  } else {  // Store the required promises.  promises[promiseCount] = pushPromise;   promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  }   http:Response response = new;  // [Get the requested resource](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#getResponse).  var result = clientEP->getResponse(httpFuture);   if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  'error = <error>result);  return;  }   var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  'error = responsePayload);  }   // Fetch required promise responses.  foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  'error = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" +  promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  'error = promisedPayload);  }  } }    HTTP 2.0 Server Push  This example demonstrates sending and receiving HTTP/2 Server Push messages in Ballerina HTTP Library.  HTTP/2 Server Push messages allow the server to send resources to the client before the client requests for it.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    listener http:Listener http2ServiceEP = new (7090,  config = {httpVersion: \"2.0\"});    Create an endpoint with port 7090 to accept HTTP requests.  HTTP version is set to 2.0.   service /http2Service on http2ServiceEP {    resource function 'default .(http:Caller caller) {    http:PushPromise promise1 = new (path = \"/resource1\", method = \"GET\");  var promiseResponse1 = caller->promise(promise1);  if (promiseResponse1 is error) {  log:printError(\"Error occurred while sending the promise1\",  'error = promiseResponse1);  }    .   http:PushPromise promise2 = new (path = \"/resource2\", method = \"GET\");  var promiseResponse2 = caller->promise(promise2);  if (promiseResponse2 is error) {  log:printError(\"Error occurred while sending the promise2\",  'error = promiseResponse2);  }    Send another Push Promise.   http:PushPromise promise3 = new (path = \"/resource3\", method = \"GET\");  var promiseResponse3 = caller->promise(promise3);  if (promiseResponse3 is error) {  log:printError(\"Error occurred while sending the promise3\",  'error = promiseResponse3);  }    Send one more Push Promise.   http:Response res = new;  json msg = {\"response\": {\"name\": \"main resource\"}};  res.setPayload(msg);    Construct the requested resource.   var response = caller->respond(res);  if (response is error) {  log:printError(\"Error occurred while sending the response\",  'error = response);  }    Send the requested resource.   http:Response push1 = new;  msg = {\"push\": {\"name\": \"resource1\"}};  push1.setPayload(msg);    Construct promised resource1.   var pushResponse1 = caller->pushPromisedResponse(promise1, push1);  if (pushResponse1 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response1\", 'error = pushResponse1);  }    .   http:Response push2 = new;  msg = {\"push\": {\"name\": \"resource2\"}};  push2.setPayload(msg);    Construct promised resource2.   var pushResponse2 = caller->pushPromisedResponse(promise2, push2);  if (pushResponse2 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response2\", 'error = pushResponse2);  }    Push promised resource2.   http:Response push3 = new;  msg = {\"push\": {\"name\": \"resource3\"}};  push3.setPayload(msg);    Construct promised resource3.   var pushResponse3 = caller->pushPromisedResponse(promise3, push3);  if (pushResponse3 is error) {  log:printError(\"Error occurred while sending the promised \" +  \"response3\", 'error = pushResponse3);  }  } }    Push promised resource3.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_2.0_service.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:7090    import ballerina/http; import ballerina/log;    http:Client clientEP =  checkpanic new (\"http://localhost:7090\", {httpVersion: \"2.0\"});    Create an that can send HTTP/2 messages.  HTTP version is set to 2.0.   public function main() {    http:Request serviceReq = new;  http:HttpFuture httpFuture = new;    var submissionResult = clientEP->submit(\"GET\", \"/http2Service\", serviceReq);    .   if (submissionResult is http:HttpFuture) {  httpFuture = submissionResult;  } else {  log:printError(\"Error occurred while submitting a request\",  'error = submissionResult);  return;  }    http:PushPromise?[] promises = [];  int promiseCount = 0;    boolean hasPromise = clientEP->hasPromise(httpFuture);    .   while (hasPromise) {  http:PushPromise pushPromise = new;    var nextPromiseResult = clientEP->getNextPromise(httpFuture);    .   if (nextPromiseResult is http:PushPromise) {  pushPromise = nextPromiseResult;  } else {  log:printError(\"Error occurred while fetching a push promise\",  'error = nextPromiseResult);  return;  }  log:printInfo(\"Received a promise for \" + pushPromise.path);    if (pushPromise.path == \"/resource2\") {    clientEP->rejectPromise(pushPromise);    The client is not interested in receiving /resource2.  Therefore, .   log:printInfo(\"Push promise for resource2 rejected\");  } else {    promises[promiseCount] = pushPromise;    Store the required promises.   promiseCount = promiseCount + 1;  }  hasPromise = clientEP->hasPromise(httpFuture);  }    http:Response response = new;    var result = clientEP->getResponse(httpFuture);    .   if (result is http:Response) {  response = result;  } else {  log:printError(\"Error occurred while fetching response\",  'error = <error>result);  return;  }    var responsePayload = response.getJsonPayload();  if (responsePayload is json) {  log:printInfo(\"Response : \" + responsePayload.toJsonString());  } else {  log:printError(\"Expected response payload not received\",  'error = responsePayload);  }    foreach var p in promises {  http:PushPromise promise = <http:PushPromise>p;  http:Response promisedResponse = new;  var promisedResponseResult = clientEP->getPromisedResponse(promise);  if (promisedResponseResult is http:Response) {  promisedResponse = promisedResponseResult;  } else {  log:printError(\"Error occurred while fetching promised response\",  'error = promisedResponseResult);  return;  }  var promisedPayload = promisedResponse.getJsonPayload();  if (promisedPayload is json) {  log:printInfo(\"Promised resource : \" +  promisedPayload.toJsonString());  } else {  log:printError(\"Expected promised response payload not received\",  'error = promisedPayload);  }  } }    Fetch required promise responses.   #Run the `http_client.bal` that contains ballerina client. bal run http_client.bal time = 2021-01-21 18:54:45,237 level = INFO module = \"\" message = \"Received a promise for /resource1\" time = 2021-01-21 18:54:45,278 level = INFO module = \"\" message = \"Received a promise for /resource2\" time = 2021-01-21 18:54:45,281 level = INFO module = \"\" message = \"Push promise for resource2 rejected\" time = 2021-01-21 18:54:45,283 level = INFO module = \"\" message = \"Received a promise for /resource3\" time = 2021-01-21 18:54:45,306 level = INFO module = \"\" message = \"Response : {\"response\":{\"name\":\"main resource\"}}\" time = 2021-01-21 18:54:45,314 level = INFO module = \"\" message = \"Promised resource : {\"push\":{\"name\":\"resource1\"}}\" time = 2021-01-21 18:54:45,468 level = INFO module = \"\" message = \"Promised resource : {\"push\":{\"name\":\"resource3\"}}\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-data-binding.html","name":"Client Data Binding","summary":"Client data binding helps to access the response payload directly as a return value. The contextually expected\n return type is inferred from the LHS variable type. A possible payload type out of string|xml|json|\n map<json>|byte[]|record|record[] and http:Response is expected as return value type or as the targetType\n parameter in the client ...","content":"/  /  / Client Data Binding  import ballerina/http; import ballerina/log;  type MapJson map<json>; type Person record {|  string name;  int age; |};  http:Client backendClient = check new(\"http://localhost:9092\");  service /call on new http:Listener(9090) {   resource function get all() returns http:Response|error {  // Binding the payload to a string type. The `targetType` is inferred from the LHS variable type.  string|error result = backendClient->get(\"/backend/String\");   // In this instance, The return type of the client remote action is `string` or `http:ClientError`.  if (result is error) {  log:printError(\"Error: \" + result.message());  return result;  } else {  // It implies that the [payload type](https://docs.central.ballerina.io/ballerina/http/latest/types#Payload)  // is string.  log:printInfo(\"String payload: \" + result);  }   // Binding the payload to a JSON type. If an error returned, it will be responded back to the caller.  json jsonPayload = check backendClient->post(\"/backend/Json\", \"foo\");   log:printInfo(\"Json payload: \" + jsonPayload.toJsonString());   // Since only the `named types` or `built-in types` can be passed as function parameters, `Map` or `Array`  // types have to be defined beforehand. Here, the type `MapJson` is passed instead of `map<json>`.  // Same can be done for `byte[]` or `Person[]` as well.  map<json> value = check backendClient->post(\"/backend/Json\", \"foo\");  log:printInfo(check value.id);   // A `record` and `record[]` are also possible types for data binding.  Person person = check backendClient->get(\"/backend/person\");  log:printInfo(\"Person name: \" + person.name);   // Still the `targetType` can be specified and use `var`.  var res = check backendClient->get(\"/backend/Response\",  targetType = http:Response);  return res;  }   resource function get '5xx() returns http:Response|json {  json|error res = backendClient->post(\"/backend/5XX\", \"want 500\");  // When the data binding is expected to happen and if the `post` remote function gets a 5XX response from the  // backend, the response will be returned as an [http:RemoteServerError](https://docs.central.ballerina.io/ballerina/http/latest/errors#RemoteServerError)  // including the error message and status code.  if (res is error) {  http:Response resp = new;  if (res is http:RemoteServerError) {  resp.statusCode = res.detail()?.statusCode ?: 500;  } else {  resp.statusCode = 500;  }  resp.setPayload(<@untainted>res.message());  return resp;  } else {  return res;  }  }   resource function get '4xx() returns http:Response|json {  // When the data binding is expected to happen and if the client remote function gets a 4XX response from the  // backend, the response will be returned as an [http:ClientRequestError](https://docs.central.ballerina.io/ballerina/http/latest/errors#ClientRequestError)  // including the error message and status code.  json|error res = backendClient->post(\"/backend/err\", \"want 400\");  if (res is error) {  http:Response resp = new;  if (res is http:ClientRequestError) {  resp.statusCode = res.detail()?.statusCode ?: 400;  } else {  resp.statusCode = 500;  }  resp.setPayload(<@untainted>res.message());  return resp;  } else {  return res;  }  } }  service /backend on new http:Listener(9092) {   resource function get 'String() returns string {  return \"Hello ballerina!!!!\";  }   resource function post 'Json() returns json {  return {id: \"Ballerina\", values: {a: {x: \"b\"}}};  }   resource function get person() returns record {|*http:Ok; Person body;|} {  return {body: {name: \"Smith\", age: 15}};  }   resource function get 'Response() returns http:Ok {  return {  body: {id: \"data-binding-done\"},  headers: {\"x-fact\":\"backend-payload\"}  };  }   resource function post '5XX() returns http:NotImplemented {  return {body:\"data-binding-failed-with-501\"};  } }    Client Data Binding  Client data binding helps to access the response payload directly as a return value. The contextually expected  return type is inferred from the LHS variable type. A possible payload type out of string|xml|json|  map<json>|byte[]|record|record[] and http:Response is expected as return value type or as the targetType  parameter in the client remote function signature.  A successful data binding process will return the payload in the given targetType. When the user expects client  data binding to happen, the HTTP error responses (4XX, 5XX) will be categorized as an http:ClientError of the  client remote operation. Since the default targetType is http:Response, the user still has the option to access  the complete response to explore more.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    type MapJson map<json>; type Person record {|  string name;  int age; |};    http:Client backendClient = check new(\"http://localhost:9092\");    service /call on new http:Listener(9090) {    resource function get all() returns http:Response|error {    string|error result = backendClient->get(\"/backend/String\");    Binding the payload to a string type. The targetType is inferred from the LHS variable type.   if (result is error) {  log:printError(\"Error: \" + result.message());  return result;  } else {    In this instance, The return type of the client remote action is string or http:ClientError.   log:printInfo(\"String payload: \" + result);  }    It implies that the is string.   json jsonPayload = check backendClient->post(\"/backend/Json\", \"foo\");    Binding the payload to a JSON type. If an error returned, it will be responded back to the caller.   log:printInfo(\"Json payload: \" + jsonPayload.toJsonString());    map<json> value = check backendClient->post(\"/backend/Json\", \"foo\");  log:printInfo(check value.id);    Since only the named types or built-in types can be passed as function parameters, Map or Array  types have to be defined beforehand. Here, the type MapJson is passed instead of map<json>.  Same can be done for byte[] or Person[] as well.   Person person = check backendClient->get(\"/backend/person\");  log:printInfo(\"Person name: \" + person.name);    A record and record[] are also possible types for data binding.   var res = check backendClient->get(\"/backend/Response\",  targetType = http:Response);  return res;  }    Still the targetType can be specified and use var.   resource function get '5xx() returns http:Response|json {  json|error res = backendClient->post(\"/backend/5XX\", \"want 500\");    if (res is error) {  http:Response resp = new;  if (res is http:RemoteServerError) {  resp.statusCode = res.detail()?.statusCode ?: 500;  } else {  resp.statusCode = 500;  }  resp.setPayload(<@untainted>res.message());  return resp;  } else {  return res;  }  }    When the data binding is expected to happen and if the post remote function gets a 5XX response from the  backend, the response will be returned as an including the error message and status code.   resource function get '4xx() returns http:Response|json {    json|error res = backendClient->post(\"/backend/err\", \"want 400\");  if (res is error) {  http:Response resp = new;  if (res is http:ClientRequestError) {  resp.statusCode = res.detail()?.statusCode ?: 400;  } else {  resp.statusCode = 500;  }  resp.setPayload(<@untainted>res.message());  return resp;  } else {  return res;  }  } }    When the data binding is expected to happen and if the client remote function gets a 4XX response from the  backend, the response will be returned as an including the error message and status code.   service /backend on new http:Listener(9092) {    resource function get 'String() returns string {  return \"Hello ballerina!!!!\";  }    resource function post 'Json() returns json {  return {id: \"Ballerina\", values: {a: {x: \"b\"}}};  }    resource function get person() returns record {|*http:Ok; Person body;|} {  return {body: {name: \"Smith\", age: 15}};  }    resource function get 'Response() returns http:Ok {  return {  body: {id: \"data-binding-done\"},  headers: {\"x-fact\":\"backend-payload\"}  };  }    resource function post '5XX() returns http:NotImplemented {  return {body:\"data-binding-failed-with-501\"};  } }    # To start the service, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run http_client_data_binding.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 time = 2021-01-21 19:29:10,007 level = INFO module = \"\" message = \"String payload: Hello ballerina!!!!\" time = 2021-01-21 19:29:10,057 level = INFO module = \"\" message = \"Json payload: {\"id\":\"Ballerina\", \"values\":{\"a\":{\"x\":\"b\"}}}\" time = 2021-01-21 19:29:10,078 level = INFO module = \"\" message = \"Ballerina\" time = 2021-01-21 19:29:10,092 level = INFO module = \"\" message = \"Person name: Smith\"    # To invoke the `bindCheck` resource, use the cURL command below. curl -v \"http://localhost:9090/call/all\" > GET /call/all HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < x-fact: backend-payload < date: Wed, 21 Oct 2020 19:45:28 +0530 < server: ballerina < content-length: 26 < * Connection #0 to host localhost left intact {\"id\":\"data-binding-done\"}* Closing connection 0    # To invoke the `handle500` resource, use the cURL command below. curl -v \"http://localhost:9090/call/5xx\" > GET /call/5xx HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 501 Not Implemented < content-type: text/plain < content-length: 28 < server: ballerina < date: Wed, 21 Oct 2020 19:46:42 +0530 < * Connection #0 to host localhost left intact data-binding-failed-with-501* Closing connection 0    # To invoke the `handle404` resource, use the cURL command below. curl -v \"http://localhost:9090/call/4xx\" > GET /call/4xx HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 404 Not Found < content-type: text/plain < content-length: 66 < server: ballerina < date: Wed, 21 Oct 2020 19:48:37 +0530 < * Connection #0 to host localhost left intact no matching resource found for path : /backend/err , method : POST* Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-oauth2-client-credentials-grant-type.html","name":"Client - OAuth2 Client Credentials Grant Type","summary":"A client, which is secured with OAuth2 client credentials grant type\n can be used to connect to a secured service.\n The client is enriched with the Authorization: Bearer <token> header by\n passing the http:OAuth2ClientCredentialsGrantConfig for the auth\n configuration of the client.\n For more information on the underlying module,\n see the ...","content":"/  /  / Client - OAuth2 Client Credentials Grant Type  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the OAuth2 secured APIs. // The client is enriched with the `Authorization: Bearer <token>` header by // passing the `http:ClientCredentialsGrantConfig` for the `auth` configuration // of the client. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9445/oauth2/token\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - OAuth2 Client Credentials Grant Type  A client, which is secured with OAuth2 client credentials grant type  can be used to connect to a secured service.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:OAuth2ClientCredentialsGrantConfig for the auth  configuration of the client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9445/oauth2/token\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the OAuth2 secured APIs.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:ClientCredentialsGrantConfig for the auth configuration  of the client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before testing this sample, first start a sample service secured with OAuth2. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_oauth2_client_credentials_grant_type.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-endpoint.html","name":"Client","summary":"The HTTP Client Connector can be used to connect to and interact with an HTTP server.\n For more information on the underlying module,\n see the .Creates a new client with the backend URL.Sends a GET request to the specified endpoint.Handles the response.Sends a POST request to the specified endpoint.Handles the ...","content":"/  /  / Client  import ballerina/http; import ballerina/io;  // Creates a new client with the backend URL. http:Client clientEndpoint = check new (\"http://postman-echo.com\");  public function main() {  io:println(\"GET request:\");  // Sends a `GET` request to the specified endpoint.  http:Response|error response = clientEndpoint->get(\"/get?test=123\");  // Handles the response.  handleResponse(response);   io:println(\"\\nPOST request:\");  // Sends a `POST` request to the specified endpoint.  response = clientEndpoint->post(\"/post\", \"POST: Hello World\");  // Handles the response.  handleResponse(response);   io:println(\"\\nUse custom HTTP verbs:\");  // Uses the `execute()` remote function for custom HTTP verbs.  response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");   // The `get()`, `head()`, and `options()` have the optional headers parameter to send out headers,  response = clientEndpoint->get(\"/get\",  {\"Sample-Name\": \"http-client-connector\"});   if (response is http:Response) {  // [Get the content type](https://docs.central.ballerina.io/ballerina/http/latest/classes/Response#getContentType) from the response.  string contentType = response.getContentType();  io:println(\"Content-Type: \" + contentType);   int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString());   } else {  io:println(\"Error when calling the backend: \",  response.message());  } }  //The below function handles the response received from the remote HTTP endpoint. function handleResponse(http:Response|error response) {  if (response is http:Response) {  // [Get the JSON payload](https://docs.central.ballerina.io/ballerina/http/latest/classes/Response#getJsonPayload) from the response.  var msg = response.getJsonPayload();  if (msg is json) {  // Prints the received `JSON` response.  io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.message());  }  } else {  io:println(\"Error when calling the backend: \",  response.message());  } }    Client  The HTTP Client Connector can be used to connect to and interact with an HTTP server.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client clientEndpoint = check new (\"http://postman-echo.com\");    Creates a new client with the backend URL.   public function main() {  io:println(\"GET request:\");    http:Response|error response = clientEndpoint->get(\"/get?test=123\");    Sends a GET request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nPOST request:\");    response = clientEndpoint->post(\"/post\", \"POST: Hello World\");    Sends a POST request to the specified endpoint.   handleResponse(response);    Handles the response.   io:println(\"\\nUse custom HTTP verbs:\");    response = clientEndpoint->execute(\"COPY\", \"/get\", \"CUSTOM: Hello World\");    Uses the execute() remote function for custom HTTP verbs.   response = clientEndpoint->get(\"/get\",  {\"Sample-Name\": \"http-client-connector\"});    The get(), head(), and options() have the optional headers parameter to send out headers,   if (response is http:Response) {    string contentType = response.getContentType();  io:println(\"Content-Type: \" + contentType);    from the response.   int statusCode = response.statusCode;  io:println(\"Status code: \" + statusCode.toString());    } else {  io:println(\"Error when calling the backend: \",  response.message());  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {    The below function handles the response received from the remote HTTP endpoint.   var msg = response.getJsonPayload();  if (msg is json) {    from the response.   io:println(msg.toJsonString());  } else {  io:println(\"Invalid payload received:\", msg.message());  }  } else {  io:println(\"Error when calling the backend: \",  response.message());  } }    Prints the received JSON response.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run http_client_endpoint.bal GET request: {\"args\":{\"test\":\"123\"}, \"headers\":{\"x-forwarded-proto\":\"http\", \"x-forwarded-port\":\"80\", \"host\":\"postman-echo.com\", \"x-amzn-trace-id\":\"Root=1-5f6acc0b-5f17f7991ebad5eb7f01c723\", \"user-agent\":\"ballerina\"}, \"url\":\"http://postman-echo.com/get?test=123\"}    POST request: {\"args\":{}, \"data\":\"POST: Hello World\", \"files\":{}, \"form\":{}, \"headers\":{\"x-forwarded-proto\":\"http\", \"x-forwarded-port\":\"80\", \"host\":\"postman-echo.com\", \"x-amzn-trace-id\":\"Root=1-5f6acc0b-f81ed9556fbed9f17ee221b9\", \"content-length\":\"17\", \"content-type\":\"text/plain\", \"user-agent\":\"ballerina\"}, \"json\":null, \"url\":\"http://postman-echo.com/post\"}    Use custom HTTP verbs: Content-Type: application/json; charset=utf-8 Status code: 200    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-oauth2-refresh-token-grant-type.html","name":"Client - OAuth2 Refresh Token Grant Type","summary":"A client, which is secured with an OAuth2 refresh token grant type can be\n used to connect to a secured service.\n The client is enriched with the Authorization: Bearer <token> header by\n passing the http:OAuth2RefreshTokenGrantConfig to the auth\n configuration of the client.\n For more information on the underlying module,\n see ...","content":"/  /  / Client - OAuth2 Refresh Token Grant Type  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the OAuth2 secured APIs. // The client is enriched with the `Authorization: Bearer <token>` header by // passing the `http:RefreshTokenGrantConfig` for the `auth` configuration of the // client. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  refreshUrl: \"https://localhost:9445/oauth2/token\",  refreshToken: \"24f19603-8565-4b5f-a036-88a945e1f272\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - OAuth2 Refresh Token Grant Type  A client, which is secured with an OAuth2 refresh token grant type can be  used to connect to a secured service.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:OAuth2RefreshTokenGrantConfig to the auth  configuration of the client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  refreshUrl: \"https://localhost:9445/oauth2/token\",  refreshToken: \"24f19603-8565-4b5f-a036-88a945e1f272\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the OAuth2 secured APIs.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:RefreshTokenGrantConfig for the auth configuration of the  client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before test this sample, first start a sample service secured with OAuth2. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_oauth2_refresh_token_grant_type.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-oauth2-password-grant-type.html","name":"Client - OAuth2 Password Grant Type","summary":"A client, which is secured with OAuth2 password grant type can be used to\n connect to a secured service.\n The client is enriched with the Authorization: Bearer <token> header by\n passing the http:OAuth2PasswordGrantConfig to the auth configuration of\n the client.\n For more information on the underlying module,\n see the .Defines ...","content":"/  /  / Client - OAuth2 Password Grant Type  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the OAuth2 secured APIs. // The client is enriched with the `Authorization: Bearer <token>` header by // passing the `http:PasswordGrantConfig` to the `auth` configuration of the // client. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9445/oauth2/token\",  username: \"admin\",  password: \"admin\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  refreshConfig: {  refreshUrl: \"https://localhost:9445/oauth2/token\",  scopes: [\"hello\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - OAuth2 Password Grant Type  A client, which is secured with OAuth2 password grant type can be used to  connect to a secured service.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:OAuth2PasswordGrantConfig to the auth configuration of  the client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9445/oauth2/token\",  username: \"admin\",  password: \"admin\",  clientId: \"FlfJYKBD2c925h4lkycqNZlC2l4a\",  clientSecret: \"PJz0UhTJMrHOo68QQNpvnqAY_3Aa\",  scopes: [\"admin\"],  refreshConfig: {  refreshUrl: \"https://localhost:9445/oauth2/token\",  scopes: [\"hello\"],  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  clientConfig: {  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the OAuth2 secured APIs.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:PasswordGrantConfig to the auth configuration of the  client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before testing this sample, first start a sample service secured with OAuth2. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_oauth2_password_grant_type.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-self-signed-jwt-auth.html","name":"Client - Self Signed JWT Auth","summary":"A client, which is secured with self-signed JWT can be used to connect to\n a secured service.\n The client is enriched with the Authorization: Bearer <token> header by\n passing the http:JwtIssuerConfig to the auth configuration of the\n client. A self-signed JWT is issued before the request is sent.\n For more ...","content":"/  /  / Client - Self Signed JWT Auth  import ballerina/http; import ballerina/io;  // Defines the HTTP client to call the JWT auth secured APIs. // The client is enriched with the `Authorization: Bearer <token>` header by // passing the `http:JwtIssuerConfig` for the `auth` configuration of the // client. A self-signed JWT is issued before the request is sent. http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"ballerina\",  issuer: \"wso2\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  keyId: \"5a0b754-895f-4279-8843-b745e11a57e9\",  jwtId: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",  customClaims: { \"scp\": \"admin\" },  expTime: 3600,  signatureConfig: {  config: {  keyFile: \"../resource/path/to/private.key\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - Self Signed JWT Auth  A client, which is secured with self-signed JWT can be used to connect to  a secured service.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:JwtIssuerConfig to the auth configuration of the  client. A self-signed JWT is issued before the request is sent.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"ballerina\",  issuer: \"wso2\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  keyId: \"5a0b754-895f-4279-8843-b745e11a57e9\",  jwtId: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",  customClaims: { \"scp\": \"admin\" },  expTime: 3600,  signatureConfig: {  config: {  keyFile: \"../resource/path/to/private.key\"  }  }  },  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    Defines the HTTP client to call the JWT auth secured APIs.  The client is enriched with the Authorization: Bearer <token> header by  passing the http:JwtIssuerConfig for the auth configuration of the  client. A self-signed JWT is issued before the request is sent.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # Before testing this sample, first start a sample service secured with JWT Auth. # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path and private key file path.) bal run http_client_self_signed_jwt_auth.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-client-ssl-tls.html","name":"Client - SSL/TLS","summary":"You can use the HTTPS client to connect or interact with an HTTPS listener.\n Provide the http:ClientSecureSocket configurations to the client to\n initiate an HTTPS connection.\n For more information on the underlying module,\n see the .An HTTP client can be configured to communicate through HTTPS as well.\n To secure a ...","content":"/  /  / Client - SSL/TLS  import ballerina/http; import ballerina/io;  // An HTTP client can be configured to communicate through HTTPS as well. // To secure a client using HTTPS, the client needs to be configured with // a certificate file of the listener. // The [http:ClientSecureSocket](https://docs.central.ballerina.io/ballerina/http/latest/records/ClientSecureSocket) record // provides the SSL-related configurations of the client. http:Client securedEP = check new(\"https://localhost:9090\",  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );  public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    Client - SSL/TLS  You can use the HTTPS client to connect or interact with an HTTPS listener.  Provide the http:ClientSecureSocket configurations to the client to  initiate an HTTPS connection.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io;    http:Client securedEP = check new(\"https://localhost:9090\",  secureSocket = {  cert: \"../resource/path/to/public.crt\"  } );    An HTTP client can be configured to communicate through HTTPS as well.  To secure a client using HTTPS, the client needs to be configured with  a certificate file of the listener.  The record  provides the SSL-related configurations of the client.   public function main() returns error? {  http:Response response = check securedEP->get(\"/foo/bar\");  io:println(check response.getTextPayload()); }    # As a prerequisite, navigate to the directory that contains the # `http_service_ssl_tls.bal` file and execute the `bal run` command below. # (You may need to change the certificate file path and private key file path.) bal run http_service_ssl_tls.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the trusted certificate file path.) bal run http_client_ssl_tls.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-cors.html","name":"CORS","summary":"This sample demonstrates the Ballerina server connector CORS configuration.\n CORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources\n unless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.\n For more information on the ...","content":"/  /  / CORS  import ballerina/http;  // Service-level [CORS config](https://docs.central.ballerina.io/ballerina/http/latest/records/CorsConfig) applies // globally to each `resource`. @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service /crossOriginService on new http:Listener(9092) {   // Resource-level [CORS config](https://docs.central.ballerina.io/ballerina/http/latest/records/CorsConfig)  // overrides the service-level CORS headers.  @http:ResourceConfig {  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function get company() returns json {  return {\"type\": \"middleware\"};  }   // Since there are no resource-level CORS configs defined here, the global  // service-level CORS configs will be applied to this resource.  resource function post lang() returns json {  return {\"lang\": \"Ballerina\"};  } }    CORS  This sample demonstrates the Ballerina server connector CORS configuration.  CORS headers can be applied in both the service-level and the resource-level. Service-level CORS headers apply to all the resources  unless there are headers configured at the resource-level. Ballerina CORS supports both simple and pre-flight requests.  For more information on the underlying module,  see the .    import ballerina/http;    @http:ServiceConfig {  cors: {  allowOrigins: [\"http://www.m3.com\", \"http://www.hello.com\"],  allowCredentials: false,  allowHeaders: [\"CORELATION_ID\"],  exposeHeaders: [\"X-CUSTOM-HEADER\"],  maxAge: 84900  } } service /crossOriginService on new http:Listener(9092) {    Service-level applies  globally to each resource.   @http:ResourceConfig {  cors: {  allowOrigins: [\"http://www.bbc.com\"],  allowCredentials: true,  allowHeaders: [\"X-Content-Type-Options\", \"X-PINGOTHER\"]  }  }  resource function get company() returns json {  return {\"type\": \"middleware\"};  }    Resource-level overrides the service-level CORS headers.   resource function post lang() returns json {  return {\"lang\": \"Ballerina\"};  } }    Since there are no resource-level CORS configs defined here, the global  service-level CORS configs will be applied to this resource.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_cors.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # Run the cURL command below to send a CORS simple request. curl -v \"http://localhost:9092/crossOriginService/company\" -H \"Origin:http://www.bbc.com\" > GET /crossOriginService/company HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.64.1 > Accept: */* > Origin:http://www.bbc.com > < HTTP/1.1 200 OK < content-type: application/json < access-control-allow-origin: http://www.bbc.com < access-control-allow-credentials: true < content-length: 21 < server: ballerina < * Connection #0 to host localhost left intact {\"type\":\"middleware\"}* Closing connection 0    # Run the cURL command below to send a CORS preflight request. curl -v \"http://localhost:9092/crossOriginService/lang\" -X OPTIONS -H \"Origin:http://www.m3.com\" -H \"Access-Control-Request-Method:POST\" > OPTIONS /crossOriginService/lang HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.64.1 > Accept: */* > Origin:http://www.m3.com > Access-Control-Request-Method:POST > < HTTP/1.1 200 OK < access-control-allow-origin: http://www.m3.com < access-control-max-age: 84900 < access-control-allow-methods: POST < content-length: 0 < server: ballerina < * Connection #0 to host localhost left intact * Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-compression.html","name":"Compression","summary":"This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server\n compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When\n the particular header is not present or the header value is “identity”, the ...","content":"/  /  / Compression  import ballerina/http;  listener http:Listener listenerEndpoint = new (9090);  // Since compression behavior of the service is set as [COMPRESSION_AUTO](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_AUTO), // entity body compression is done according to the scheme indicated in the `Accept-Encoding` request header. // Compression is not performed when the header is not present or when the header value is \"identity\". // [compression](https://docs.central.ballerina.io/ballerina/http/latest/records/CompressionConfig) annotation // provides the related configurations. @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service /autoCompress on listenerEndpoint {   resource function 'default .() returns json {  return {\"Type\": \"Auto compression\"};  } }  // [COMPRESSION_ALWAYS](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_ALWAYS) // guarantees a compressed response entity body. Compression scheme is set to the // value indicated in Accept-Encoding request header. When a particular header is not present or the header // value is \"identity\", encoding is done using the \"gzip\" scheme. // By default, Ballerina compresses any MIME type unless they are mentioned under `contentTypes`. // Compression can be constrained to certain MIME types by specifying them as an array of MIME types. // In this example encoding is applied to \"text/plain\" responses only. @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service /alwaysCompress on listenerEndpoint {   // Since compression is only constrained to \"text/plain\" MIME type,  // `getJson` resource does not compress the response entity body.  resource function 'default getJson() returns json {  return {\"Type\": \"Always but constrained by content-type\"};  }  // The response entity body is always compressed since MIME type has matched.  resource function 'default getString() returns string {  return \"Type : This is a string\";  } }  // The HTTP client can indicate the [compression](https://docs.central.ballerina.io/ballerina/http/latest/types#Compression) // behavior (\"AUTO\", \"ALWAYS\", \"NEVER\") for content negotiation. // Depending on the compression option values, the `Accept-Encoding` header is sent along with the request. // In this example, the client compression behavior is set as [COMPRESSION_ALWAYS](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_ALWAYS). If you have not specified // an `Accept-Encoding` header, the client specifies it with \"deflate, gzip\". Alternatively, the existing header is sent. // When compression is specified as [COMPRESSION_AUTO](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_AUTO), only the user-specified `Accept-Encoding` header is sent. // If the behavior is set as [COMPRESSION_NEVER](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_NEVER), the client makes sure not to send the `Accept-Encoding` header. http:Client clientEndpoint = checkpanic new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );  service /passthrough on new http:Listener(9092) {   resource function 'default .(http:Request req) returns http:Response|json {  http:Response|error response =  clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  return response;  } else {  return {\"error\": \"error occurred while invoking service\"};  }  } }  // The compression behavior of the service is inferred by [COMPRESSION_AUTO](https://docs.central.ballerina.io/ballerina/http/latest/constants#COMPRESSION_AUTO), which is the default value // of the compression config. service /backend on listenerEndpoint {  resource function 'default echo(@http:Header{name:\"accept-encoding\"}  string? accept) returns string {  if (accept is string) {  return \"Backend response was encoded : \" + accept;  } else {  return \"Accept-Encoding header is not present\";  }  } }    Compression  This sample demonstrates how the Ballerina HTTP service is configured to change the compression behaviour. By default, the server  compresses the response entity body with the scheme(gzip, deflate) that is specified in the Accept-Encoding request header. When  the particular header is not present or the header value is “identity”, the server does not perform any compression. Compression  is disabled when the option is set to COMPRESSION_NEVER.”  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener listenerEndpoint = new (9090);    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_AUTO  } } service /autoCompress on listenerEndpoint {    Since compression behavior of the service is set as ,  entity body compression is done according to the scheme indicated in the Accept-Encoding request header.  Compression is not performed when the header is not present or when the header value is “identity”.  annotation  provides the related configurations.   resource function 'default .() returns json {  return {\"Type\": \"Auto compression\"};  } }    @http:ServiceConfig {  compression: {  enable: http:COMPRESSION_ALWAYS,  contentTypes: [\"text/plain\"]  } } service /alwaysCompress on listenerEndpoint {    guarantees a compressed response entity body. Compression scheme is set to the  value indicated in Accept-Encoding request header. When a particular header is not present or the header  value is “identity”, encoding is done using the “gzip” scheme.  By default, Ballerina compresses any MIME type unless they are mentioned under contentTypes.  Compression can be constrained to certain MIME types by specifying them as an array of MIME types.  In this example encoding is applied to “text/plain” responses only.   resource function 'default getJson() returns json {  return {\"Type\": \"Always but constrained by content-type\"};  }    Since compression is only constrained to “text/plain” MIME type,  getJson resource does not compress the response entity body.   resource function 'default getString() returns string {  return \"Type : This is a string\";  } }    The response entity body is always compressed since MIME type has matched.   http:Client clientEndpoint = checkpanic new (\"http://localhost:9090\", {  compression: http:COMPRESSION_ALWAYS  } );    The HTTP client can indicate the behavior (“AUTO”, “ALWAYS”, “NEVER”) for content negotiation.  Depending on the compression option values, the Accept-Encoding header is sent along with the request.  In this example, the client compression behavior is set as . If you have not specified  an Accept-Encoding header, the client specifies it with “deflate, gzip”. Alternatively, the existing header is sent.  When compression is specified as , only the user-specified Accept-Encoding header is sent.  If the behavior is set as , the client makes sure not to send the Accept-Encoding header.   service /passthrough on new http:Listener(9092) {    resource function 'default .(http:Request req) returns http:Response|json {  http:Response|error response =  clientEndpoint->post(\"/backend/echo\", <@untainted>req);  if (response is http:Response) {  return response;  } else {  return {\"error\": \"error occurred while invoking service\"};  }  } }    service /backend on listenerEndpoint {  resource function 'default echo(@http:Header{name:\"accept-encoding\"}  string? accept) returns string {  if (accept is string) {  return \"Backend response was encoded : \" + accept;  } else {  return \"Accept-Encoding header is not present\";  }  } }    The compression behavior of the service is inferred by , which is the default value  of the compression config.   # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_compression.bal # Service deployment ballerina: started HTTP/WS listener 0.0.0.0:9092 ballerina: started HTTP/WS listener 0.0.0.0:9090    # To invoke the autoCompress Service, use the cURL command below. # Here the `Accept-Encoding` header is specified as `deflate`. curl -v --output - http://localhost:9090/autoCompress -H \"Accept-Encoding:deflate\" > GET /autoCompress HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > Accept-Encoding:deflate > < HTTP/1.1 200 OK < content-type: application/json < server: ballerina < content-encoding: deflate < content-length: 41 < x��V * Connection #0 to host localhost left intact �,HU�Rr,-�WH��-(J-.���S���\u0003��\t�    # To invoke the alwaysCompress Service to get the JSON payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. curl -v --output - http://localhost:9090/alwaysCompress/getJson > GET /alwaysCompress/getJson HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json < server: ballerina < content-length: 49 < * Connection #0 to host localhost left intact {\"Type\":\"Always but constrained by content-type\"}    # To invoke the alwaysCompress Service to get the String payload, use the following curl command. # Here the `Accept-Encoding` header is not specified. curl -v --output - http://localhost:9090/alwaysCompress/getString > GET /alwaysCompress/getString HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < server: ballerina < content-encoding: gzip < content-length: 48 < \u001f� * Connection #0 to host localhost left intact �,HU���,V�D�⒢̼t��\u0003ʴ��\u0017    # To invoke the passthrough Service, use the following curl command. curl -v --output - http://localhost:9092/passthrough/ > GET /passthrough/ HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.58.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < server: ballerina < transfer-encoding: chunked < * Connection #0 to host localhost left intact Backend response was encoded : deflate, gzip    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-default-resource.html","name":"Default Resource","summary":"Ballerina provides rest params in the resource path and the default resource method to help designing proxy services\n and default resources. It can be used to handle unmatched requests.\n For more information on the underlying module,\n see the .The absolute resource path can be omitted. Then, it defaults to /.The ...","content":"/  /  / Default Resource  import ballerina/http;  // The `absolute resource path` can be omitted. Then, it defaults to `/`. service on new http:Listener(9090) {   // The `default` accessor name can be used to match with all methods including standard HTTP methods  // and custom methods. The rest param is used to represent the wildcard of the `resource path` in which any path  // segment will get dispatched to the resource in the absence of an exact path match.  resource function 'default [string... paths](http:Request req)  returns json {  return {method: req.method, path: paths};  }   // The resource is confined to `GET` requests with the path `/greeting`.  resource function get greeting() returns string {  return \"Specific resource is invoked\";  } }    Default Resource  Ballerina provides rest params in the resource path and the default resource method to help designing proxy services  and default resources. It can be used to handle unmatched requests.  For more information on the underlying module,  see the .    import ballerina/http;    service on new http:Listener(9090) {    The absolute resource path can be omitted. Then, it defaults to /.   resource function 'default [string... paths](http:Request req)  returns json {  return {method: req.method, path: paths};  }    The default accessor name can be used to match with all methods including standard HTTP methods  and custom methods. The rest param is used to represent the wildcard of the resource path in which any path  segment will get dispatched to the resource in the absence of an exact path match.   resource function get greeting() returns string {  return \"Specific resource is invoked\";  } }    The resource is confined to GET requests with the path /greeting.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_default_resource.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run the cURL command below with the unmatched path and method. curl \"http://localhost:9090/foo/bar\" -X POST {\"method\":\"POST\", \"path\":[\"foo\", \"bar\"]}    Run the cURL command below to invoke the `greeting` resource. curl \"http://localhost:9090/greeting\" Specific resource is invoked    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-data-binding.html","name":"Service Data Binding","summary":"HTTP service data binding helps to access the request payload through the last resource signature parameter. The\n parameter name should be declared in the resource config under the body annotation. string, json, xml,\n byte[], record, and record[] are supported as parameter types.\n For more information on the underlying module,\n see ...","content":"/  /  / Service Data Binding  import ballerina/http;  type Student record {  string Name;  int Grade;  map<any> Marks; };  service /hello on new http:Listener(9090) {   // The `orderDetails` parameter in [Payload annotation](https://docs.central.ballerina.io/ballerina/http/latest/records/Payload)  // represents the entity body of the inbound request.  resource function post bindJson(@http:Payload json orderDetails)  returns json|http:BadRequest {  //Accesses the JSON field values.  var details = orderDetails.Details;  if (details is json) {  return details;  } else {  http:BadRequest response = {body: \"Order Details unavailable\"};  return response;  }  }   //Binds the XML payload of the inbound request to the `store` variable.  @http:ResourceConfig {  consumes: [\"application/xml\"]  }  resource function post bindXML(@http:Payload xml store) returns xml {  //Accesses the XML content.  xml city = store.selectDescendants(\"{http://www.test.com}city\");  return city;  }   //Binds the JSON payload to a custom record. The payload's content should  //match the record.  @http:ResourceConfig {  consumes: [\"application/json\"]  }  resource function post bindStruct(@http:Payload Student student)  returns json {  //Accesses the fields of the `Student` record.  string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untainted string>student.Marks[\"English\"];  return {Name: name, Grade: grade, English: english};  } }    Service Data Binding  HTTP service data binding helps to access the request payload through the last resource signature parameter. The  parameter name should be declared in the resource config under the body annotation. string, json, xml,  byte[], record, and record[] are supported as parameter types.  For more information on the underlying module,  see the .    import ballerina/http;    type Student record {  string Name;  int Grade;  map<any> Marks; };    service /hello on new http:Listener(9090) {    resource function post bindJson(@http:Payload json orderDetails)  returns json|http:BadRequest {    The orderDetails parameter in represents the entity body of the inbound request.   var details = orderDetails.Details;  if (details is json) {  return details;  } else {  http:BadRequest response = {body: \"Order Details unavailable\"};  return response;  }  }    Accesses the JSON field values.   @http:ResourceConfig {  consumes: [\"application/xml\"]  }  resource function post bindXML(@http:Payload xml store) returns xml {    Binds the XML payload of the inbound request to the store variable.   xml city = store.selectDescendants(\"{http://www.test.com}city\");  return city;  }    Accesses the XML content.   @http:ResourceConfig {  consumes: [\"application/json\"]  }  resource function post bindStruct(@http:Payload Student student)  returns json {    Binds the JSON payload to a custom record. The payload’s content should match the record.   string name = <@untainted>student.Name;  int grade = <@untainted>student.Grade;  string english = <@untainted string>student.Marks[\"English\"];  return {Name: name, Grade: grade, English: english};  } }    Accesses the fields of the Student record.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_data_binding.bal #Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the `bindJson` resource, execute the below HTTP request. curl -v http://localhost:9090/hello/bindJson -d '{ \"Details\": { \"ID\": \"77999\", \"Name\": \"XYZ\"} , \"Location\": { \"No\": \"01\", \"City\": \"Colombo\"}}' -H \"Content-Type:application/json\" > POST /hello/bindJson HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > Content-Type:application/json > Content-Length: 92 > * upload completely sent off: 92 out of 92 bytes < HTTP/1.1 200 OK < content-type: application/json < content-length: 28 < server: ballerina < * Connection #0 to host localhost left intact {\"ID\":\"77999\", \"Name\":\"XYZ\"}* Closing connection 0    # To invoke the `bindXML` resource, execute the below HTTP request. curl -v http://localhost:9090/hello/bindXML -d \"<h:Store id = \\\"AST\\\" xmlns:h=\\\"http://www.test.com\\\"><h:street>Main</h:street><h:city>94</h:city></h:Store>\" -H \"Content-Type:application/xml\" > POST /hello/bindXML HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > Content-Type:application/xml > Content-Length: 104 > * upload completely sent off: 104 out of 104 bytes < HTTP/1.1 200 OK < content-type: application/xml < content-length: 49 < server: ballerina < * Connection #0 to host localhost left intact <h:city xmlns:h=\"http://www.test.com\">94</h:city>* Closing connection 0    # To invoke the `bindStruct` resource, execute the below HTTP request. curl -v http://localhost:9090/hello/bindStruct -d '{ \"Name\": \"John\", \"Grade\": 12, \"Marks\": {\"English\" : \"85\", \"IT\" : \"100\"}}' -H \"Content-Type:application/json\" > POST /hello/bindStruct HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > Content-Type:application/json > Content-Length: 73 > * upload completely sent off: 73 out of 73 bytes < HTTP/1.1 200 OK < content-type: application/json < content-length: 43 < server: ballerina < * Connection #0 to host localhost left intact {\"Name\":\"John\", \"Grade\":12, \"English\":\"85\"}* Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-cookies.html","name":"Cookies","summary":"This example demonstrates how to handle HTTP cookies in a Ballerina service and client.\n For more information on the underlying module,\n see the .Retrieve the JSON payload from the request as it\n contains the login details of a user.Retrieve the username and password.Check the password value. by setting name as ...","content":"/  /  / Cookies  import ballerina/http;  listener http:Listener serverEP = new (9095);  service /cookieDemo on serverEP {   resource function post login(http:Request req)  returns http:Response|http:BadRequest {  // Retrieve the JSON payload from the request as it  // contains the login details of a user.  json|error details = req.getJsonPayload();   if (details is json) {  // Retrieve the username and password.  json|error name = details.name;  json|error password = details.password;   if (name is json && password is json) {  // Check the password value.  if (password == \"p@ssw0rd\") {   // [Create a new cookie](https://docs.central.ballerina.io/ballerina/http/latest/classes/Cookie) by setting `name` as the `username`  // and `value` as the logged-in user's name.  http:Cookie cookie = new(\"username\", name.toString());   // Set the cookies path as `/` to apply it to all the  // resources in the service.  cookie.path = \"/\";   http:Response response = new;   // [Add the created cookie to the response](https://docs.central.ballerina.io/ballerina/http/latest/classes/Response#addCookie).  response.addCookie(cookie);   // Set a message payload to inform that the login has  // been succeeded.  response.setTextPayload(\"Login succeeded\");  return response;  }  }  }  return {body: \"Invalid request payload\"};  }   resource function get welcome(http:Request req) returns string {  // [Retrieve cookies from the request](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getCookies).  http:Cookie[] cookies = req.getCookies();   // Get the cookie value of the `username`.  http:Cookie[] usernameCookie = cookies.filter(function  (http:Cookie cookie) returns boolean {  return cookie.name == \"username\";  });   if (usernameCookie.length() > 0) {  string? user = usernameCookie[0].value;  if (user is string) {  // Respond with the username added to the welcome message.  return \"Welcome back \" + <@untainted> user;   } else {  // If the user is `nil`, send a login message.  return \"Please login\";  }  } else {  // If the `username` cookie is not presented, send a login message.  return \"Please login\";  }  } } import ballerina/http; import ballerina/log;  // HTTP client configurations associated with [enabling cookies](https://docs.central.ballerina.io/ballerina/http/latest/records/CookieConfig). http:ClientConfiguration clientEPConfig = {  cookieConfig: {  enabled: true  } };  public function main() returns error? {  // Create a new HTTP client by giving the URL and the client configuration.  http:Client httpClient = check new(\"http://localhost:9095/cookieDemo\",  clientEPConfig);   // Initialize an HTTP request.  http:Request request = new;   // Send a username and a password as a JSON payload to the backend.  json jsonPart = {  name: \"John\",  password: \"p@ssw0rd\"  };  request.setJsonPayload(jsonPart);   // Send an outbound request to the `login` backend resource.  http:Response|error loginResp = httpClient->post(\"/login\", request);   if (loginResp is error) {  log:printError(\"Login failed\", 'error = loginResp);  } else {  // When the login is successful, make another request to the  // `/welcome` resource of the backend service.  // As cookies are enabled in the HTTP client, it automatically handles cookies  // received with the login response and sends the relevant cookies  // to the `welcome` service resource.  var welcomeResp = httpClient->get(\"/welcome\", targetType = string);   if (welcomeResp is string) {  // A welcome message with the sent username  // will get printed.  log:printInfo(welcomeResp);  }  } }    Cookies  This example demonstrates how to handle HTTP cookies in a Ballerina service and client.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener serverEP = new (9095);    service /cookieDemo on serverEP {    resource function post login(http:Request req)  returns http:Response|http:BadRequest {    json|error details = req.getJsonPayload();    Retrieve the JSON payload from the request as it  contains the login details of a user.   if (details is json) {    json|error name = details.name;  json|error password = details.password;    Retrieve the username and password.   if (name is json && password is json) {    if (password == \"p@ssw0rd\") {    Check the password value.   http:Cookie cookie = new(\"username\", name.toString());    by setting name as the username  and value as the logged-in user’s name.   cookie.path = \"/\";    Set the cookies path as / to apply it to all the  resources in the service.   http:Response response = new;    response.addCookie(cookie);    .   response.setTextPayload(\"Login succeeded\");  return response;  }  }  }  return {body: \"Invalid request payload\"};  }    Set a message payload to inform that the login has  been succeeded.   resource function get welcome(http:Request req) returns string {    http:Cookie[] cookies = req.getCookies();    .   http:Cookie[] usernameCookie = cookies.filter(function  (http:Cookie cookie) returns boolean {  return cookie.name == \"username\";  });    Get the cookie value of the username.   if (usernameCookie.length() > 0) {  string? user = usernameCookie[0].value;  if (user is string) {    return \"Welcome back \" + <@untainted> user;    Respond with the username added to the welcome message.   } else {    return \"Please login\";  }  } else {    If the user is nil, send a login message.   return \"Please login\";  }  } }    If the username cookie is not presented, send a login message.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run cookie_server.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9095    import ballerina/http; import ballerina/log;    http:ClientConfiguration clientEPConfig = {  cookieConfig: {  enabled: true  } };    HTTP client configurations associated with .   public function main() returns error? {    http:Client httpClient = check new(\"http://localhost:9095/cookieDemo\",  clientEPConfig);    Create a new HTTP client by giving the URL and the client configuration.   http:Request request = new;    Initialize an HTTP request.   json jsonPart = {  name: \"John\",  password: \"p@ssw0rd\"  };  request.setJsonPayload(jsonPart);    Send a username and a password as a JSON payload to the backend.   http:Response|error loginResp = httpClient->post(\"/login\", request);    Send an outbound request to the login backend resource.   if (loginResp is error) {  log:printError(\"Login failed\", 'error = loginResp);  } else {    var welcomeResp = httpClient->get(\"/welcome\", targetType = string);    When the login is successful, make another request to the  /welcome resource of the backend service.  As cookies are enabled in the HTTP client, it automatically handles cookies  received with the login response and sends the relevant cookies  to the welcome service resource.   if (welcomeResp is string) {    log:printInfo(welcomeResp);  }  } }    A welcome message with the sent username  will get printed.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run http_client.bal time = 2020-12-15 16:14:08,691 level = INFO module = \"\" message = \"Welcome back John\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-disable-chunking.html","name":"Disable Chanking","summary":"This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header.\nIf the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.\n For more information on ...","content":"/  /  / Disable Chanking  import ballerina/http;  // The HTTP client's chunking behavior can be configured as [CHUNKING_AUTO](https://docs.central.ballerina.io/ballerina/http/latest/constants#CHUNKING_AUTO), // [CHUNKING_ALWAYS](https://docs.central.ballerina.io/ballerina/http/latest/constants#CHUNKING_ALWAYS), // or [CHUNKING_NEVER](https://docs.central.ballerina.io/ballerina/http/latest/constants#CHUNKING_NEVER). // In this example, it is set to `CHUNKING_NEVER`, which means that chunking never happens irrespective of how it is // specified in the request. When chunking is set to `CHUNKING_AUTO`, chunking is done as specified in the request. // [http1Settings](https://docs.central.ballerina.io/ballerina/http/latest/records/ClientHttp1Settings) annotation // provides the chunking-related configurations. http:Client clientEndpoint = check new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});  service /chunkingSample on new http:Listener(9092) {   resource function get .() returns http:Response|http:InternalServerError {  //Invoke endpoint with along with a JSON payload.  http:Response|error clientResponse =  clientEndpoint->post(\"/echo/\", {\"name\": \"Ballerina\"});  if (clientResponse is http:Response) {  return clientResponse;  } else {  json msg =  {\"error\": \"An error occurred while invoking the service.\"};  return {body: msg};  }  } }  // A sample backend, which responds according to the chunking behavior. service /echo on new http:Listener(9090) {   resource function post .(@http:Header{name:\"Content-length\"} string? cLen,  @http:Header{name:\"Transfer-Encoding\"} string? traEncoding)  returns json|http:BadRequest {   string value;  //Set the response according to the request headers.  if (cLen is string) {  value = \"Length-\" + cLen;  //Mark the `value` as trusted data and send out the JSON.  return {\"Outbound request content\": <@untainted>value};  }  if (traEncoding is string) {  value = traEncoding;  //Perform data validation for transfer-encoding.  if (value != \"chunked\" && value != \"compress\"  && value != \"deflate\" && value != \"gzip\"  && value != \"identity\") {  value = \"Transfer-Encoding contains invalid data\";  http:BadRequest badRequest = {body: value};  return badRequest;  } else {  //Mark the `value` as trusted data and send out the JSON.  return {\"Outbound request content\": <@untainted>value};  }  }  value = \"Neither Transfer-Encoding nor content-length header found\";  http:BadRequest badRequest = {body: value};  return badRequest;  } }    Disable Chanking  This sample demonstrates how to configure the chunking behavior of an HTTP client endpoint. By default, the HTTP client sends messages with the content-length header. If the message size is larger than the buffer size (8K), messages are chunked. Chunking can be disabled using the connector options.  For more information on the underlying module,  see the .    import ballerina/http;    http:Client clientEndpoint = check new (\"http://localhost:9090\",  {http1Settings: {chunking: http:CHUNKING_NEVER}});    The HTTP client’s chunking behavior can be configured as ,  ,  or .  In this example, it is set to CHUNKING_NEVER, which means that chunking never happens irrespective of how it is  specified in the request. When chunking is set to CHUNKING_AUTO, chunking is done as specified in the request.  annotation  provides the chunking-related configurations.   service /chunkingSample on new http:Listener(9092) {    resource function get .() returns http:Response|http:InternalServerError {    http:Response|error clientResponse =  clientEndpoint->post(\"/echo/\", {\"name\": \"Ballerina\"});  if (clientResponse is http:Response) {  return clientResponse;  } else {  json msg =  {\"error\": \"An error occurred while invoking the service.\"};  return {body: msg};  }  } }    Invoke endpoint with along with a JSON payload.   service /echo on new http:Listener(9090) {    A sample backend, which responds according to the chunking behavior.   resource function post .(@http:Header{name:\"Content-length\"} string? cLen,  @http:Header{name:\"Transfer-Encoding\"} string? traEncoding)  returns json|http:BadRequest {    string value;    if (cLen is string) {  value = \"Length-\" + cLen;    Set the response according to the request headers.   return {\"Outbound request content\": <@untainted>value};  }  if (traEncoding is string) {  value = traEncoding;    Mark the value as trusted data and send out the JSON.   if (value != \"chunked\" && value != \"compress\"  && value != \"deflate\" && value != \"gzip\"  && value != \"identity\") {  value = \"Transfer-Encoding contains invalid data\";  http:BadRequest badRequest = {body: value};  return badRequest;  } else {    Perform data validation for transfer-encoding.   return {\"Outbound request content\": <@untainted>value};  }  }  value = \"Neither Transfer-Encoding nor content-length header found\";  http:BadRequest badRequest = {body: value};  return badRequest;  } }    Mark the value as trusted data and send out the JSON.   # To start the services, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run http_disable_chunking.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    To use the client, execute the cURL command below. curl http://localhost:9092/chunkingSample {\"Outbound request content\":\"Length-20\"}    To enable chunking, change the chunking option of the `clientEndpoint` in the `.bal` file to `http:CHUNKING_ALWAYS`. {\"Outbound request content\":\"chunked\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-failover.html","name":"Failover","summary":"Ballerina users can configure multiple HTTP clients in a given failover group.\n If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.\n For more information on the underlying module,\n see the .Create an endpoint with port 8080 for the mock backend services.Define the failover client ...","content":"/  /  / Failover  import ballerina/http; import ballerina/lang.runtime;  // Create an endpoint with port 8080 for the mock backend services. listener http:Listener backendEP = new (8080);  // Define the failover client endpoint to call the backend services. http:FailoverClient foBackendEP = check new ({   timeout: 5,  failoverCodes: [501, 502, 503],  interval: 5,  // Define a set of HTTP Clients that are targeted for failover.  targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });  service /fo on new http:Listener(9090) {   resource function 'default .()  returns http:Response|http:InternalServerError {  http:Response|error backendResponse = foBackendEP->get(\"/\");   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  return backendResponse;  } else {  return {body: backendResponse.message()};  }   } }  // Define the sample service to mock connection timeouts and service outages. service /echo on backendEP {   resource function 'default .() returns string {  // Delay the response for 30 seconds to mimic network level delays.  runtime:sleep(30);   return \"echo Resource is invoked\";  } }  // Define the sample service to mock a healthy service. service /mock on backendEP {   resource function 'default .() returns string {  return \"Mock Resource is Invoked.\";  } }    Failover  Ballerina users can configure multiple HTTP clients in a given failover group.  If one of the HTTP clients (dependencies) fails, Ballerina automatically fails over to another endpoint.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/lang.runtime;    listener http:Listener backendEP = new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:FailoverClient foBackendEP = check new ({    Define the failover client endpoint to call the backend services.   timeout: 5,  failoverCodes: [501, 502, 503],  interval: 5,    targets: [  {url: \"http://nonexistentEP/mock1\"},  {url: \"http://localhost:8080/echo\"},  {url: \"http://localhost:8080/mock\"}  ] });    Define a set of HTTP Clients that are targeted for failover.   service /fo on new http:Listener(9090) {    resource function 'default .()  returns http:Response|http:InternalServerError {  http:Response|error backendResponse = foBackendEP->get(\"/\");    if (backendResponse is http:Response) {  return backendResponse;  } else {  return {body: backendResponse.message()};  }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   } }    service /echo on backendEP {    Define the sample service to mock connection timeouts and service outages.   resource function 'default .() returns string {    runtime:sleep(30);    Delay the response for 30 seconds to mimic network level delays.   return \"echo Resource is invoked\";  } }    service /mock on backendEP {    Define the sample service to mock a healthy service.   resource function 'default .() returns string {  return \"Mock Resource is Invoked.\";  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_failover.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Failover Service, use the cURL command below. curl -v http://localhost:9090/fo # The `FailoverClient` endpoint is configured with three target services.The first two targets are configured to mimic # failure backends. If one target service goes down, the failover client automatically calls the other targets. # Once you invoke the Failover demo service, the Failover client fails over the request to the configured # target endpoints. In this example, the third target is configured to give a successful response and the following # response is given when the failover demo service is invoked. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:37 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked. # Invoke the Failover Service again using the cURL command below. curl -v http://localhost:9090/fo # At this point, Ballerina failover client already knows that leading endpoints (in this case the first two targets) # failed in the last invocation and it got the successful response from the third target. So the failover client # resumes the failover from the last successful target. In this case it is the third target and the client will get # the immediate response for subsequent calls. # Server response: * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /fo HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 4 Sep 2019 15:29:41 +0530 < server: ballerina/1.0.0-beta < content-length: 25 < * Connection #0 to host localhost left intact Mock Resource is Invoked.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-passthrough.html","name":"Passthrough","summary":"The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.\n For more information on the underlying module,\n see the .The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify\n which HTTP methods are allowed.When  ...","content":"/  /  / Passthrough  import ballerina/http; import ballerina/log;  http:Client clientEP = check new (\"http://localhost:9092/hello\");  service /passthrough on new http:Listener(9090) {   // The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify  // which HTTP methods are allowed.  resource function 'default .(http:Request req)  returns http:Response|http:InternalServerError {  // When [forward()](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#forward) is called on the backend client endpoint, it forwards the request that the passthrough  // resource received to the backend. When forwarding, the request is made using the same HTTP method that was  // used to invoke the passthrough resource. The `forward()` function returns the response from the backend if  // there are no errors.  http:Response|error clientResponse = clientEP->forward(\"/\", req);   // `forward()` can return an HTTP response or an error.  if (clientResponse is http:Response) {  // If the request was successful, an HTTP response is returned.  return clientResponse;   } else {  // If there was an error, the 500 error response is sent back to the client.  return {body: clientResponse.message()};   }  } }  // Sample hello world service. service /hello on new http:Listener(9092) {   // The `helloResource` accepts any HTTP methods as the accessor is defined as `'default`.  resource function 'default .(http:Caller caller) {  // [Send the response](https://docs.central.ballerina.io/ballerina/http/latest/clients/Caller#respond) back to the caller.  var result = caller->respond(\"Hello World!\");   if (result is error) {  log:printError(\"Error sending response\", 'error = result);  }  } }    Passthrough  The passthrough sample exhibits the process of an HTTP client connector. The ‘Echo Service’ is used as a sample backend.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    http:Client clientEP = check new (\"http://localhost:9092/hello\");    service /passthrough on new http:Listener(9090) {    resource function 'default .(http:Request req)  returns http:Response|http:InternalServerError {    The passthrough resource allows all HTTP methods since the resource configuration does not explicitly specify  which HTTP methods are allowed.   http:Response|error clientResponse = clientEP->forward(\"/\", req);    When is called on the backend client endpoint, it forwards the request that the passthrough  resource received to the backend. When forwarding, the request is made using the same HTTP method that was  used to invoke the passthrough resource. The forward() function returns the response from the backend if  there are no errors.   if (clientResponse is http:Response) {    forward() can return an HTTP response or an error.   return clientResponse;    If the request was successful, an HTTP response is returned.   } else {    return {body: clientResponse.message()};    If there was an error, the 500 error response is sent back to the client.   }  } }    service /hello on new http:Listener(9092) {    Sample hello world service.   resource function 'default .(http:Caller caller) {    The helloResource accepts any HTTP methods as the accessor is defined as 'default.   var result = caller->respond(\"Hello World!\");    back to the caller.   if (result is error) {  log:printError(\"Error sending response\", 'error = result);  }  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run passthrough.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the service, use the cURL commands below. curl http://localhost:9090/passthrough -X POST Hello World! curl http://localhost:9090/passthrough -X GET Hello World! curl http://localhost:9090/passthrough -X PUT Hello World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-load-balancer.html","name":"Load Balancer","summary":"An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given\n set of target endpoints.\n For more information on the underlying module,\n see the .Create an endpoint with port 8080 for the mock backend services.Define the load balance client endpoint to call ...","content":"/  /  / Load Balancer  import ballerina/http;  // Create an endpoint with port 8080 for the mock backend services. listener http:Listener backendEP = check new (8080);  // Define the load balance client endpoint to call the backend services. http:LoadBalanceClient lbBackendEP = check new ({  // Define the set of HTTP clients that need to be load balanced.  targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],   timeout: 5 });  // Create an HTTP service bound to the endpoint (`loadBalancerEP`). service /lb on new http:Listener(9090) {   resource function 'default .()  returns http:Response|http:InternalServerError {  json requestPayload = {\"name\": \"Ballerina\"};  http:Response|error response = lbBackendEP->post(\"/\", requestPayload);  // If a response is returned, the normal process runs. If the service  // does not get the expected response, the error-handling logic is  // executed.  if (response is http:Response) {  return response;  } else {  return {body: response.message()};  }   } }  // Define the mock backend services, which are called by the load balancer. service /mock1 on backendEP {   resource function 'default .() returns string {  return \"Mock1 resource was invoked.\";  } }  service /mock2 on backendEP {   resource function 'default .() returns string {  return \"Mock2 resource was invoked.\";  } }  service /mock3 on backendEP {   resource function 'default .() returns string {  return \"Mock3 resource was invoked.\";  } }    Load Balancer  An HTTP load balancing endpoint is used when the request load needs to be load balanced across a given  set of target endpoints.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener backendEP = check new (8080);    Create an endpoint with port 8080 for the mock backend services.   http:LoadBalanceClient lbBackendEP = check new ({    Define the load balance client endpoint to call the backend services.   targets: [  {url: \"http://localhost:8080/mock1\"},  {url: \"http://localhost:8080/mock2\"},  {url: \"http://localhost:8080/mock3\"}  ],    Define the set of HTTP clients that need to be load balanced.   timeout: 5 });    service /lb on new http:Listener(9090) {    Create an HTTP service bound to the endpoint (loadBalancerEP).   resource function 'default .()  returns http:Response|http:InternalServerError {  json requestPayload = {\"name\": \"Ballerina\"};  http:Response|error response = lbBackendEP->post(\"/\", requestPayload);    if (response is http:Response) {  return response;  } else {  return {body: response.message()};  }    If a response is returned, the normal process runs. If the service  does not get the expected response, the error-handling logic is  executed.   } }    service /mock1 on backendEP {    Define the mock backend services, which are called by the load balancer.   resource function 'default .() returns string {  return \"Mock1 resource was invoked.\";  } }    service /mock2 on backendEP {    resource function 'default .() returns string {  return \"Mock2 resource was invoked.\";  } }    service /mock3 on backendEP {    resource function 'default .() returns string {  return \"Mock3 resource was invoked.\";  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_load_balancer.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # To invoke the Load Balancer Demo Service, use the cURL command below. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 23 Sep 2020 09:59:31 +0530 < server: ballerina < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked.    # Repeat the same cURL command to invoke the Load Balance Demo Service again. # The request will be load balanced to the second mock service. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 23 Sep 2020 10:00:20 +0530 < server: ballerina < content-length: 27 < * Connection #0 to host localhost left intact Mock2 resource was invoked.    # Invoke the Load Balancer Demo Service one more time using the same cURL command. # The request will be load balanced to the third mock service. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 23 Sep 2020 10:00:22 +0530 < server: ballerina < content-length: 27 < * Connection #0 to host localhost left intact Mock3 resource was invoked.    # Invoke the Load Balancer Demo Service using the same cURL command for the last time. # The request will be load balanced to the first mock service again. curl -v http://localhost:9090/lb * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 9090 (#0) > GET /lb HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.54.0 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < date: Wed, 23 Sep 2020 10:00:25 +0530 < server: ballerina < content-length: 27 < * Connection #0 to host localhost left intact Mock1 resource was invoked.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-path-matrix-param.html","name":"Path Matrix Param","summary":"HTTP module provides first class support for specifying Path parameters in the resource path along with the type.\n The supported types are string, int, float, boolean, and decimal (e.g., path/[string foo]).\n Ballerina supports extracting MatrixParam values using an http:Request method.\n For more information on the underlying module,\n see the .The ...","content":"/  /  / Path Matrix Param  import ballerina/http;  service /sample on new http:Listener(9090) {   // The path param is defined as a part of the resource path along with the type and it is extracted from the  // request URI.  resource function get path/[string foo](http:Request req) returns json {   // Gets the [MatrixParams](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getMatrixParams).  map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};   // Create a JSON payload with the extracted values.  json responseJson = {  \"pathParam\": foo,  \"matrix\": matrixJson  };  // Send a response with the JSON payload to the client.  return responseJson;  } }    Path Matrix Param  HTTP module provides first class support for specifying Path parameters in the resource path along with the type.  The supported types are string, int, float, boolean, and decimal (e.g., path/[string foo]).  Ballerina supports extracting MatrixParam values using an http:Request method.  For more information on the underlying module,  see the .    import ballerina/http;    service /sample on new http:Listener(9090) {    resource function get path/[string foo](http:Request req) returns json {    The path param is defined as a part of the resource path along with the type and it is extracted from the  request URI.   map<any> pathMParams = req.getMatrixParams(\"/sample/path\");  var a = <string>pathMParams[\"a\"];  var b = <string>pathMParams[\"b\"];  string pathMatrixStr = string `a=${a}, b=${b}`;  map<any> fooMParams = req.getMatrixParams(\"/sample/path/\" + foo);  var x = <string>fooMParams[\"x\"];  var y = <string>fooMParams[\"y\"];  string fooMatrixStr = string `x=${x}, y=${y}`;  json matrixJson = {\"path\": pathMatrixStr, \"foo\": fooMatrixStr};    Gets the .   json responseJson = {  \"pathParam\": foo,  \"matrix\": matrixJson  };    Create a JSON payload with the extracted values.   return responseJson;  } }    Send a response with the JSON payload to the client.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_path_matrix_param.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    # Run the cURL command below to invoke the service. curl \"http://localhost:9090/sample/path;a=4;b=5/value1;x=10;y=15\" {\"pathParam\":\"value1\", \"matrix\":{\"path\":\"a=4, b=5\", \"foo\":\"x=10, y=15\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-query-parameter.html","name":"Query Parameter","summary":"HTTP module provides first class support for reading URL query parameters as resource method argument.\n The supported types are string, int, float, boolean, decimal, and the array types of the aforementioned types. The\n query param type can be nilable (e.g., (string? bar)). The request also provide certain method to retrieve ...","content":"/  /  / Query Parameter  import ballerina/http;  service /product on new http:Listener(9090) {   // The `a`, `b` method arguments are considered as query parameters.  resource function get count(int a, int b) returns json {  return { count : a + b};  }   // The query param type is nilable which means the URI may contain the param.  // In the absence of the query param `id` the type is nil.  resource function get name(string? id) returns string {  if (id is string) {  return \"product_\" + id;  }  return \"product_0000\";  }   // The multiple query param values also can be accommodate to an array.  resource function get detail(string[]? colour) returns json {  return { product_colour : colour};  }   // In addition to resource method argument, query params can be retrieved from the inbound request  resource function get part(http:Request req) returns json {  // Gets the [first queryParam](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getQueryParamValue)  // value for a given parameter key.  string? foo = req.getQueryParamValue(\"foo\");   // Gets [multiple queryParam](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getQueryParamValues)  // values for a given parameter key.  string[]? bar = req.getQueryParamValues(\"bar\");   // Gets [all the queryParam](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getQueryParams)  // key value pairs of the inbound request.  map<string[]> all = req.getQueryParams();   return { foo: foo, bar: bar, all: all};  } }    Query Parameter  HTTP module provides first class support for reading URL query parameters as resource method argument.  The supported types are string, int, float, boolean, decimal, and the array types of the aforementioned types. The  query param type can be nilable (e.g., (string? bar)). The request also provide certain method to retrieve query  param at their convenience For more information on the underlying module,  see the .    import ballerina/http;    service /product on new http:Listener(9090) {    resource function get count(int a, int b) returns json {  return { count : a + b};  }    The a, b method arguments are considered as query parameters.   resource function get name(string? id) returns string {  if (id is string) {  return \"product_\" + id;  }  return \"product_0000\";  }    The query param type is nilable which means the URI may contain the param.  In the absence of the query param id the type is nil.   resource function get detail(string[]? colour) returns json {  return { product_colour : colour};  }    The multiple query param values also can be accommodate to an array.   resource function get part(http:Request req) returns json {    In addition to resource method argument, query params can be retrieved from the inbound request   string? foo = req.getQueryParamValue(\"foo\");    Gets the value for a given parameter key.   string[]? bar = req.getQueryParamValues(\"bar\");    Gets values for a given parameter key.   map<string[]> all = req.getQueryParams();    Gets key value pairs of the inbound request.   return { foo: foo, bar: bar, all: all};  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_query_parameter.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run the cURL command below to invoke product/count resource. curl \"http://localhost:9090/product/count?a=315&b=585\" {\"count\":900}    Run the cURL command below to invoke product/name resource. curl \"http://localhost:9090/product/name?id=432423\" product_432423    Run the cURL command below to invoke product/detail resource. curl \"http://localhost:9090/product/detail?colour=red&colour=green\" {\"product_colour\":[\"red\", \"green\"]}    Run the cURL command below to invoke product/part resource. curl \"http://localhost:9090/product/part?bar=a&bar=b&foo=1&baz=bal\" {\"foo\":\"1\", \"bar\":[\"a\", \"b\"], \"all\":{\"bar\":[\"a\", \"b\"], \"foo\":[\"1\"], \"baz\":[\"bal\"]}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-redirects.html","name":"Redirects","summary":"This example demonstrates an HTTP redirect.\n To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect\n to true.\n For more information on the underlying module,\n see the .Creates an HTTP client to interact with a remote endpoint.\n  record provides configurations associated with ...","content":"/  /  / Redirects  import ballerina/http; import ballerina/log;  // Creates an HTTP client to interact with a remote endpoint. // [followRedirects](https://docs.central.ballerina.io/ballerina/http/latest/records/FollowRedirects) record provides configurations associated with HTTP redirects. http:Client clientEndpoint = check new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );  service /hello on new http:Listener(9090) {   resource function get .() returns string {  // Sends a `GET` request to the specified endpoint.  http:Response|error returnResult = clientEndpoint->get(\"/redirect1\");   if (returnResult is http:Response) {  // Retrieves the text payload from the response.  var payload = returnResult.getTextPayload();   if (payload is string) {  return \"Response received : \" + <@untainted>payload;  } else {  return \"Error in payload: \" + <@untainted>payload.message();  }  } else {  return \"Connection error: \" + <@untainted>returnResult.message();  }  } }  service /redirect1 on new http:Listener(9092) {   resource function get .(http:Caller caller) {  http:Response res = new;  // Sends a redirect response with a location.  error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);   if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  'error = result);  }  } }  service /redirect2 on new http:Listener(9093) {   resource function get .() returns string {  // Sends a response to the caller.  return \"Hello World!\";   } }    Redirects  This example demonstrates an HTTP redirect.  To follow redirects when calling an external HTTP server using the Ballerina HTTP client connector, set followRedirect  to true.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log;    http:Client clientEndpoint = check new (\"http://localhost:9092\", {  followRedirects: {enabled: true, maxCount: 5}  } );    Creates an HTTP client to interact with a remote endpoint.  record provides configurations associated with HTTP redirects.   service /hello on new http:Listener(9090) {    resource function get .() returns string {    http:Response|error returnResult = clientEndpoint->get(\"/redirect1\");    Sends a GET request to the specified endpoint.   if (returnResult is http:Response) {    var payload = returnResult.getTextPayload();    Retrieves the text payload from the response.   if (payload is string) {  return \"Response received : \" + <@untainted>payload;  } else {  return \"Error in payload: \" + <@untainted>payload.message();  }  } else {  return \"Connection error: \" + <@untainted>returnResult.message();  }  } }    service /redirect1 on new http:Listener(9092) {    resource function get .(http:Caller caller) {  http:Response res = new;    error? result = caller->redirect(res,  http:REDIRECT_TEMPORARY_REDIRECT_307,  [\"http://localhost:9093/redirect2\"]);    Sends a redirect response with a location.   if (result is error) {  log:printError(\"Error in sending redirect response to caller\",  'error = result);  }  } }    service /redirect2 on new http:Listener(9093) {    resource function get .() returns string {    return \"Hello World!\";    Sends a response to the caller.   } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run http_redirects.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 [ballerina/http] started HTTP/WS listener 0.0.0.0:9093    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-different-payload-types.html","name":"Handling Different Payload Types","summary":"Ballerina supports different payload types to be used directly with HTTP client actions\n(eg: POST, PUT, DELETE etc..) and service respond calls.\n For more information on the underlying module,\n see the . endpoint.Service to test HTTP client remote functions with different payload types. remote function without any payload. remote function with\nthe ...","content":"/  /  / Handling Different Payload Types  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  //[Client](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client) endpoint. http:Client clientEP = check new (\"http://localhost:9091/backEndService\");  //Service to test HTTP client remote functions with different payload types. service /actionService on new http:Listener(9090) {   resource function 'default messageUsage()  returns string|http:InternalServerError {  //[GET](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#get) remote function without any payload.  http:Response|error response = clientEP->get(\"/greeting\");  handleResponse(response);   //[GET](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#get) remote function with  //the request given as a message.  http:Request request = new;  response = clientEP->execute(\"GET\", \"/greeting\", request);  handleResponse(response);   //[POST](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#post) remote function without any payload.  response = clientEP->post(\"/echo\", ());  handleResponse(response);   //[POST](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#post) remote function with  //text as the payload.  response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);   //[POST](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#post) remote function with  //`xml` as the payload.  response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);   //POST remote function with `json` as the payload.  response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);   //[POST](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client#post) remote function with  //`byte[]` as the payload.  string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);   //Get a byte stream to a given file.  var bStream = io:fileReadBlocksAsStream(\"./files/logo.png\");   if (bStream is stream<byte[], io:Error?>) {  //Make a POST request with a byte stream as the payload. Since the file path is static `<@untainted>` is used to denote that the byte stream is trusted.  response = clientEP->post(\"/image\", <@untainted>bStream);  handleResponse(response);   //[Create a JSON body part](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#setJson).  mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});   //[Create a text body part](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#setText).  mime:Entity part2 = new;  part2.setText(\"Hello\");   //Make a POST request with body parts as the payload.  mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response);   return \"Client actions successfully executed!\";  } else {  return {body:bStream.message()};  }  } }  //Back end service that send out different payload types as response. service /backEndService on new http:Listener(9091) {   resource function get greeting() returns string {  return \"Hello\";  }   resource function post echo(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = returnValue.message();  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  }   resource function post image(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } }  //Handle response data received from HTTP client remote functions. function handleResponse(http:Response|error response) {  if (response is http:Response) {  //Print the content type of the received data.  if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\",  'error = payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  log:printInfo(\"Xml data: \" + payload.toString());  } else {  log:printError(\"Error in parsing xml data\",  'error = payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\",  'error = payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\",  'error = payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\",  'error = payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.message(), 'error = response);  } }  function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted>err.message());  var result = caller->respond(res);  handleError(result); }  function handleError(error? result) {  if (result is error) {  log:printError(result.message(), 'error = result);  } }  //Get the base type from a given content type. function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }  //Loop through body parts and print its content. function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.message(), 'error = payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.message(), 'error = payload);  }  }  } }    Handling Different Payload Types  Ballerina supports different payload types to be used directly with HTTP client actions (eg: POST, PUT, DELETE etc..) and service respond calls.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = check new (\"http://localhost:9091/backEndService\");    endpoint.   service /actionService on new http:Listener(9090) {    Service to test HTTP client remote functions with different payload types.   resource function 'default messageUsage()  returns string|http:InternalServerError {    http:Response|error response = clientEP->get(\"/greeting\");  handleResponse(response);    remote function without any payload.   http:Request request = new;  response = clientEP->execute(\"GET\", \"/greeting\", request);  handleResponse(response);    remote function with the request given as a message.   response = clientEP->post(\"/echo\", ());  handleResponse(response);    remote function without any payload.   response = clientEP->post(\"/echo\", \"Sample Text\");  handleResponse(response);    remote function with text as the payload.   response = clientEP->post(\"/echo\", xml `<yy>Sample Xml</yy>`);  handleResponse(response);    remote function with xml as the payload.   response = clientEP->post(\"/echo\", {name: \"apple\", color: \"red\"});  handleResponse(response);    POST remote function with json as the payload.   string textVal = \"Sample Text\";  byte[] binaryValue = textVal.toBytes();  response = clientEP->post(\"/echo\", binaryValue);  handleResponse(response);    remote function with byte[] as the payload.   var bStream = io:fileReadBlocksAsStream(\"./files/logo.png\");    Get a byte stream to a given file.   if (bStream is stream<byte[], io:Error?>) {    response = clientEP->post(\"/image\", <@untainted>bStream);  handleResponse(response);    Make a POST request with a byte stream as the payload. Since the file path is static <@untainted> is used to denote that the byte stream is trusted.   mime:Entity part1 = new;  part1.setJson({\"name\": \"Jane\"});    .   mime:Entity part2 = new;  part2.setText(\"Hello\");    .   mime:Entity[] bodyParts = [part1, part2];  response = clientEP->post(\"/echo\", bodyParts);  handleResponse(response);    Make a POST request with body parts as the payload.   return \"Client actions successfully executed!\";  } else {  return {body:bStream.message()};  }  } }    service /backEndService on new http:Listener(9091) {    Back end service that send out different payload types as response.   resource function get greeting() returns string {  return \"Hello\";  }    resource function post echo(http:Caller caller, http:Request req) {  if (req.hasHeader(\"content-type\")) {  string baseType = getBaseType(req.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var returnValue = req.getTextPayload();  string textValue = \"\";  if (returnValue is string) {  textValue = returnValue;  } else {  textValue = returnValue.message();  }  var result = caller->respond(<@untainted>textValue);  handleError(result);  } else if (mime:APPLICATION_XML == baseType) {  var xmlValue = req.getXmlPayload();  if (xmlValue is xml) {  var result = caller->respond(<@untainted>xmlValue);  handleError(result);  } else {  sendErrorMsg(caller, xmlValue);  }  } else if (mime:APPLICATION_JSON == baseType) {  var jsonValue = req.getJsonPayload();  if (jsonValue is json) {  var result = caller->respond(<@untainted>jsonValue);  handleError(result);  } else {  sendErrorMsg(caller, jsonValue);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var blobValue = req.getBinaryPayload();  if (blobValue is byte[]) {  var result = caller->respond(<@untainted>blobValue);  handleError(result);  } else {  sendErrorMsg(caller, blobValue);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  var bodyParts = req.getBodyParts();  if (bodyParts is mime:Entity[]) {  var result = caller->respond(<@untainted>bodyParts);  handleError(result);  } else {  sendErrorMsg(caller, bodyParts);  }  }  } else {  var result = caller->respond(());  handleError(result);  }  }    resource function post image(http:Caller caller, http:Request req) {  var bytes = req.getBinaryPayload();  if (bytes is byte[]) {  http:Response response = new;  response.setBinaryPayload(<@untainted>bytes,  contentType = mime:IMAGE_PNG);  var result = caller->respond(response);  handleError(result);  } else {  sendErrorMsg(caller, bytes);  }  } }    function handleResponse(http:Response|error response) {  if (response is http:Response) {    Handle response data received from HTTP client remote functions.   if (response.hasHeader(\"content-type\")) {  string baseType = getBaseType(response.getContentType());  if (mime:TEXT_PLAIN == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\",  'error = payload);  }  } else if (mime:APPLICATION_XML == baseType) {  var payload = response.getXmlPayload();  if (payload is xml) {  log:printInfo(\"Xml data: \" + payload.toString());  } else {  log:printError(\"Error in parsing xml data\",  'error = payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  var payload = response.getJsonPayload();  if (payload is json) {  log:printInfo(\"Json data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing json data\",  'error = payload);  }  } else if (mime:APPLICATION_OCTET_STREAM == baseType) {  var payload = response.getTextPayload();  if (payload is string) {  log:printInfo(\"Response contains binary data: \" + payload);  } else {  log:printError(\"Error in parsing binary data\",  'error = payload);  }  } else if (mime:MULTIPART_FORM_DATA == baseType) {  log:printInfo(\"Response contains body parts: \");  var payload = response.getBodyParts();  if (payload is mime:Entity[]) {  handleBodyParts(payload);  } else {  log:printError(\"Error in parsing multipart data\",  'error = payload);  }  } else if (mime:IMAGE_PNG == baseType) {  log:printInfo(\"Response contains an image\");  }  } else {  log:printInfo(\"Entity body is not available\");  }  } else {  log:printError(response.message(), 'error = response);  } }    Print the content type of the received data.   function sendErrorMsg(http:Caller caller, error err) {  http:Response res = new;  res.statusCode = 500;  res.setPayload(<@untainted>err.message());  var result = caller->respond(res);  handleError(result); }    function handleError(error? result) {  if (result is error) {  log:printError(result.message(), 'error = result);  } }    function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Get the base type from a given content type.   function handleBodyParts(mime:Entity[] bodyParts) {  foreach var bodyPart in bodyParts {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_JSON == baseType) {  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"Json Part: \" + payload.toJsonString());  } else {  log:printError(payload.message(), 'error = payload);  }  }  if (mime:TEXT_PLAIN == baseType) {  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text Part: \" + payload);  } else {  log:printError(payload.message(), 'error = payload);  }  }  } }    Loop through body parts and print its content.   # In the directory, which contains the `.bal` file, create a directory named `files`, # and add an image file named `logo.png` in it. # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run different_payload_types.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9091 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 time = 2020-12-15 17:41:04,032 level = INFO module = \"\" message = \"Text data: Hello\" time = 2020-12-15 17:41:04,050 level = INFO module = \"\" message = \"Text data: Hello\" time = 2020-12-15 17:41:04,055 level = INFO module = \"\" message = \"Entity body is not available\" time = 2020-12-15 17:41:04,062 level = INFO module = \"\" message = \"Text data: Sample Text\" time = 2020-12-15 17:41:04,206 level = INFO module = \"\" message = \"Xml data: <yy>Sample Xml</yy>\" time = 2020-12-15 17:41:04,224 level = INFO module = \"\" message = \"Json data: {\"name\":\"apple\", \"color\":\"red\"}\" time = 2020-12-15 17:41:04,232 level = INFO module = \"\" message = \"Response contains binary data: Sample Text\" time = 2020-12-15 17:41:04,256 level = INFO module = \"\" message = \"Response contains an image\" time = 2020-12-15 17:41:04,275 level = INFO module = \"\" message = \"Response contains body parts: \" time = 2020-12-15 17:41:04,280 level = INFO module = \"\" message = \"Json Part: {\"name\":\"Jane\"}\" time = 2020-12-15 17:41:04,281 level = INFO module = \"\" message = \"Text Part: Hello\"    #Send a request to the action service curl -X GET http://localhost:9090/actionService/messageUsage Client actions successfully executed!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-resource-returns.html","name":"Resource Return Types","summary":"The resource method can return anydata type, an http:Response object, StatusCodeResponse records along with\n error?. Instead of using an http:Caller, the response can be sent similarly by returning from the method.\n When returning anydata, the @http:Payload annotation can be used to specify the Content-type of the response\n additionally. Otherwise, the ...","content":"/  /  / Resource Return Types  import ballerina/http;  type PersonAccount record {  string name;  int accountNo; };  service /bank on new http:Listener(9090) {   // The resource returns the json type values and the `Content-type` header is set according to the `mediaType`  // field of [@http:Payload](https://docs.central.ballerina.io/ballerina/http/latest/records/HttpPayload)  // annotation.  resource function get branch() returns  @http:Payload {mediaType:\"application/json+id\"} json {   return { branch : [\"Colombo, Srilanka\"]};  }   // The [StatusCodeResponse](https://docs.central.ballerina.io/ballerina/http/latest/types#StatusCodeResponse)  // can be state as return type to send responses with specific HTTP status codes.  resource function get [string 'type]()  returns http:Ok|http:InternalServerError {   if 'type == \"open\" {  // Creates response with 200 status code and set body as response payload.  http:Ok ok = {body: \"Bank is open\"};   return ok;  } else {  // Creates response with 500 status code and set body as response payload.  http:InternalServerError err = {body: \"Bank is closed\"};   return err;  }  }   // Inline response records are useful to return headers and body along with status code. In this instance the  // return type is a subtype of [http:Created](https://docs.central.ballerina.io/ballerina/http/latest/records/Created)  // record, hence 201 response will be sent.  resource function get createAccount(string name)  returns record {|*http:Created; PersonAccount body;|} {   PersonAccount account = {accountNo: 84230, name: name};  return {  mediaType: \"application/account+json\",  headers: {  \"Location\": \"/myServer/084230\"  },  body: account  };  } }    Resource Return Types  The resource method can return anydata type, an http:Response object, StatusCodeResponse records along with  error?. Instead of using an http:Caller, the response can be sent similarly by returning from the method.  When returning anydata, the @http:Payload annotation can be used to specify the Content-type of the response  additionally. Otherwise, the default content type of the respective return value type will be added.  For more information on the underlying module,  see the .    import ballerina/http;    type PersonAccount record {  string name;  int accountNo; };    service /bank on new http:Listener(9090) {    resource function get branch() returns  @http:Payload {mediaType:\"application/json+id\"} json {    The resource returns the json type values and the Content-type header is set according to the mediaType  field of annotation.   return { branch : [\"Colombo, Srilanka\"]};  }    resource function get [string 'type]()  returns http:Ok|http:InternalServerError {    The can be state as return type to send responses with specific HTTP status codes.   if 'type == \"open\" {    http:Ok ok = {body: \"Bank is open\"};    Creates response with 200 status code and set body as response payload.   return ok;  } else {    http:InternalServerError err = {body: \"Bank is closed\"};    Creates response with 500 status code and set body as response payload.   return err;  }  }    resource function get createAccount(string name)  returns record {|*http:Created; PersonAccount body;|} {    Inline response records are useful to return headers and body along with status code. In this instance the  return type is a subtype of record, hence 201 response will be sent.   PersonAccount account = {accountNo: 84230, name: name};  return {  mediaType: \"application/account+json\",  headers: {  \"Location\": \"/myServer/084230\"  },  body: account  };  } }    # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_resource_returns.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    Run the cURL command below to invoke bank/branch resource. curl -v \"http://localhost:9090/bank/branch\" > GET /bank/branch HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < content-type: application/json+id < content-length: 32 < server: ballerina < date: Sat, 15 May 2021 16:14:10 +0530 < * Connection #0 to host localhost left intact {\"branch\":[\"Colombo, Srilanka\"]}* Closing connection 0    Run the cURL command below to invoke second resource. curl -v \"http://localhost:9090/bank/open\" > GET /bank/open HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < content-type: text/plain < content-length: 12 < server: ballerina < date: Sat, 15 May 2021 16:16:56 +0530 < * Connection #0 to host localhost left intact Bank is open* Closing connection 0    Run the cURL command below to invoke second resource again. curl -v \"http://localhost:9090/bank/close\" > GET /bank/close HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 14 < server: ballerina < date: Sat, 15 May 2021 16:18:36 +0530 < * Connection #0 to host localhost left intact Bank is closed* Closing connection 0    Run the cURL command below to invoke bank/createAccount resource. curl -v \"http://localhost:9090/bank/createAccount?name=bal\" > GET /bank/createAccount?name=bal HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 201 Created < Location: /myServer/084230 < content-type: application/account+json < content-length: 33 < server: ballerina < date: Sat, 15 May 2021 16:19:31 +0530 < * Connection #0 to host localhost left intact {\"name\":\"bal\", \"accountNo\":84230}* Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-restrict-by-media-type.html","name":"Restrict By Media Type","summary":"You can configure resources of HTTP services to restrict the types of media they consume and produce.\n This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.\n For more information on the underlying module,\n see the .The consumes and produces annotations ...","content":"/  /  / Restrict By Media Type  import ballerina/http;  service on new http:Listener(9092) {  // The `consumes` and `produces` annotations of the [resource configuration](https://docs.central.ballerina.io/ballerina/http/latest/records/HttpResourceConfig)  // contain MIME types as an array of strings. The resource can only consume/accept `text/json` and  // `application/json` media types. Therefore, the `Content-Type` header  // of the request must be in one of these two types. The resource can produce  // `application/xml` payloads. Therefore, you need to set the `Accept` header accordingly.  @http:ResourceConfig {  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function post infoService(@http:Payload json msg)  returns xml|http:InternalServerError {  // Get the value, which is relevant to the key \"name\".  json|error nameString = msg.name;  if (nameString is json) {  // Create the XML payload and send back a response.  xml name = xml `<name>${<string>nameString}</name>`;  return name;  }  return { body: \"Invalid json: `name` not present\"};  } }    Restrict By Media Type  You can configure resources of HTTP services to restrict the types of media they consume and produce.  This is done through the ‘consumes’ and ‘produces’ annotation attributes of the ResourceConfig annotation, which is used with resources.  For more information on the underlying module,  see the .    import ballerina/http;    service on new http:Listener(9092) {    @http:ResourceConfig {  consumes: [\"text/json\", \"application/json\"],  produces: [\"application/xml\"]  }  resource function post infoService(@http:Payload json msg)  returns xml|http:InternalServerError {    The consumes and produces annotations of the contain MIME types as an array of strings. The resource can only consume/accept text/json and  application/json media types. Therefore, the Content-Type header  of the request must be in one of these two types. The resource can produce  application/xml payloads. Therefore, you need to set the Accept header accordingly.   json|error nameString = msg.name;  if (nameString is json) {    Get the value, which is relevant to the key “name”.   xml name = xml `<name>${<string>nameString}</name>`;  return name;  }  return { body: \"Invalid json: `name` not present\"};  } }    Create the XML payload and send back a response.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run restrict_by_media_type.bal # Service deployment [ballerina/http] started HTTP/WS listener 0.0.0.0:9092    # To invoke the service, execute the following cURL request. curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' > POST /infoService HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.64.1 > Accept:application/xml > Content-Type:application/json > Content-Length: 20 > * upload completely sent off: 20 out of 20 bytes < HTTP/1.1 200 OK < content-type: application/xml < content-length: 22 < server: ballerina < date: Wed, 23 Sep 2020 10:25:55 +0530 < * Connection #0 to host localhost left intact <name>Ballerina</name>* Closing connection 0    # To invoke the service using unsupported media type, execute the following cURL request. The content type of the # request is not listed under the `consumes` resource configuration. curl -v http://localhost:9092/infoService -H \"Accept:application/xml\" -H \"Content-Type:text/plain\" -d \"Hello ballerina\" > POST /infoService HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.64.1 > Accept:application/xml > Content-Type:text/plain > Content-Length: 15 > * upload completely sent off: 15 out of 15 bytes < HTTP/1.1 415 Unsupported Media Type < content-type: text/plain < content-length: 0 < server: ballerina < date: Wed, 23 Sep 2020 10:26:50 +0530 < * Connection #0 to host localhost left intact * Closing connection 0    # To invoke the service with a media type that is not acceptable, execute the following cURL request. The media type mentioned # in the Accept header is not listed under the `produces` resource configuration. curl -v http://localhost:9092/infoService -H \"Accept:text/html\" -H \"Content-Type:application/json\" -d '{\"name\":\"Ballerina\"}' > POST /infoService HTTP/1.1 > Host: localhost:9092 > User-Agent: curl/7.64.1 > Accept:text/html > Content-Type:application/json > Content-Length: 20 > * upload completely sent off: 20 out of 20 bytes < HTTP/1.1 406 Not Acceptable < content-type: text/plain < content-length: 0 < server: ballerina < date: Wed, 23 Sep 2020 10:27:28 +0530 < * Connection #0 to host localhost left intact * Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-request-with-multiparts.html","name":"Request With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in http requests along with nested parts.\n When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).\n You can loop through this array and handle the received body parts according to your requirement.\n ...","content":"/  /  / Request With Multiparts  import ballerina/http; import ballerina/log; import ballerina/mime;  http:Client clientEP = check new (\"http://localhost:9090\");  //Binds the listener to the service. service /multiparts on new http:Listener(9090) {   resource function post decode(http:Request request)  returns http:Response|http:InternalServerError{  http:Response response = new;  // [Extracts bodyparts](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getBodyParts) from the request.  var bodyParts = request.getBodyParts();   if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  return response;  } else {  log:printError(bodyParts.message());  return {body:\"Error in decoding multiparts!\"};  }  }   resource function get encode(http:Request req)  returns http:Response|http:InternalServerError {  //Create a json body part.  mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});  //Create an `xml` body part as a file upload.  mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));  // This file path is relative to where the ballerina is running.  // If your file is located outside, please  // give the absolute file path instead.  xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);  // Create an array to hold all the body parts.  mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;  // [Set the body parts](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#setBodyParts) to the request.  // Here the content-type is set as multipart form data.  // This also works with any other multipart media type.  // eg:- `multipart/mixed`, `multipart/related` etc.  // You need to pass the content type that suit your requirement.  request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  http:Response|error returnResponse =  clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  return returnResponse;  } else {  return {body:\"Error occurred while sending multipart request!\"};  }  } }  // The content logic that handles the body parts vary based on your requirement. function handleContent(mime:Entity bodyPart) {  // [Get the media type](https://docs.central.ballerina.io/ballerina/mime/latest/functions#getMediaType) from the body part retrieved from the request.  var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  //[Extracts `xml` data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getXml) from the body part.  var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(payload.message());  }  } else if (mime:APPLICATION_JSON == baseType) {  //[Extracts `json` data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getJson) from the body part.  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(payload.message());  }  } else if (mime:TEXT_PLAIN == baseType) {  //[Extracts text data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getText) from the body part.  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(payload.message());  }  }  } }  function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    Request With Multiparts  Ballerina supports encoding and decoding multipart content in http requests along with nested parts.  When you request multiparts from the HTTP inbound request, you get an array of body parts (an array of entities).  You can loop through this array and handle the received body parts according to your requirement.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log; import ballerina/mime;    http:Client clientEP = check new (\"http://localhost:9090\");    service /multiparts on new http:Listener(9090) {    Binds the listener to the service.   resource function post decode(http:Request request)  returns http:Response|http:InternalServerError{  http:Response response = new;    var bodyParts = request.getBodyParts();    from the request.   if (bodyParts is mime:Entity[]) {  foreach var part in bodyParts {  handleContent(part);  }  response.setPayload(<@untainted>bodyParts);  return response;  } else {  log:printError(bodyParts.message());  return {body:\"Error in decoding multiparts!\"};  }  }    resource function get encode(http:Request req)  returns http:Response|http:InternalServerError {    mime:Entity jsonBodyPart = new;  jsonBodyPart.setContentDisposition(  getContentDispositionForFormData(\"json part\"));  jsonBodyPart.setJson({\"name\": \"wso2\"});    Create a json body part.   mime:Entity xmlFilePart = new;  xmlFilePart.setContentDisposition(  getContentDispositionForFormData(\"xml file part\"));    Create an xml body part as a file upload.   xmlFilePart.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:APPLICATION_XML);    This file path is relative to where the ballerina is running.  If your file is located outside, please  give the absolute file path instead.   mime:Entity[] bodyParts = [jsonBodyPart, xmlFilePart];  http:Request request = new;    Create an array to hold all the body parts.   request.setBodyParts(bodyParts, contentType = mime:MULTIPART_FORM_DATA);  http:Response|error returnResponse =  clientEP->post(\"/multiparts/decode\", request);  if (returnResponse is http:Response) {  return returnResponse;  } else {  return {body:\"Error occurred while sending multipart request!\"};  }  } }    to the request.  Here the content-type is set as multipart form data.  This also works with any other multipart media type.  eg:- multipart/mixed, multipart/related etc.  You need to pass the content type that suit your requirement.   function handleContent(mime:Entity bodyPart) {    The content logic that handles the body parts vary based on your requirement.   var mediaType = mime:getMediaType(bodyPart.getContentType());  if (mediaType is mime:MediaType) {  string baseType = mediaType.getBaseType();  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    from the body part retrieved from the request.   var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(payload.toString());  } else {  log:printError(payload.message());  }  } else if (mime:APPLICATION_JSON == baseType) {    from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(payload.toJsonString());  } else {  log:printError(payload.message());  }  } else if (mime:TEXT_PLAIN == baseType) {    from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(payload);  } else {  log:printError(payload.message());  }  }  } }    from the body part.   function getContentDispositionForFormData(string partName)  returns (mime:ContentDisposition) {  mime:ContentDisposition contentDisposition = new;  contentDisposition.name = partName;  contentDisposition.disposition = \"form-data\";  return contentDisposition; }    # In the directory, which contains the `.bal` file, create a directory named `file`, # and add an XML files named `test.xml` in it. # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run request_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 time = 2021-01-21 22:00:17,167 level = INFO module = \"\" message = \"{\"name\":\"ballerina\"}\" time = 2021-01-21 22:01:18,466 level = INFO module = \"\" message = \"{\"name\":\"wso2\"}\" time = 2021-01-21 22:01:18,682 level = INFO module = \"\" message = \"<ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang>\" ^C[ballerina/http] stopped HTTP/WS listener 0.0.0.0:9090    # Start multipartDemoService # The cURL command, which you need to execute to decode a multipart request curl -F \"part1={\\\"name\\\":\\\"ballerina\\\"};type=application/json\" http://localhost:9090/multiparts/decode -H \"Content-Type: multipart/mixed\" -H 'Expect:' --f710b4a02896b88a content-disposition: attachment;name=\"part1\" content-type: application/json content-id: 0    {\"name\":\"ballerina\"} --f710b4a02896b88a--    # The cURL command, which you need to execute to encode the parts of the body and send a multipart request via the Ballerina service curl -v http://localhost:9090/multiparts/encode > GET /multiparts/encode HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < content-type: multipart/form-data; boundary=bd7547c98465dae2 < date: Wed, 23 Sep 2020 10:20:17 +0530 < server: ballerina < content-length: 398 < --bd7547c98465dae2 content-disposition: form-data;name=\"json part\" content-type: application/json content-id: 0    {\"name\":\"wso2\"} --bd7547c98465dae2 content-disposition: form-data;name=\"xml file part\" content-type: application/xml content-id: 1    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --bd7547c98465dae2-- * Connection #0 to host localhost left intact * Closing connection 0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-basic-auth-file-user-store.html","name":"Service - Basic Auth File User Store","summary":"An HTTP service/resource can be secured using Basic auth and optionally by\n enforcing authorization. Then, it validates the Basic auth token sent in the\n Authorization header against the provided configurations. This reads data\n from a file, which has a TOML format. This stores the usernames, passwords\n for authentication, and scopes ...","content":"/  /  / Service - Basic Auth File User Store  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );  // The service can be secured with Basic auth and can be authorized optionally. // Using Basic auth with the file user store can be enabled by setting the // `http:FileUserStoreConfig` configurations. // Authorization is based on scopes. A scope maps to one or more groups. // Authorization can be enabled by setting the `string|string[]` type // configurations. @http:ServiceConfig {  auth: [  {  fileUserStoreConfig: {},  scopes: [\"admin\"]  }  ] } service /foo on securedEP {   // It is optional to override the authentication and authorization  // configurations at the resource levels. Otherwise, the service auth  // configurations will be applied automatically to the resources as well.  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - Basic Auth File User Store  An HTTP service/resource can be secured using Basic auth and optionally by  enforcing authorization. Then, it validates the Basic auth token sent in the  Authorization header against the provided configurations. This reads data  from a file, which has a TOML format. This stores the usernames, passwords  for authentication, and scopes for authorization.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s).  In the authorization phase, the scopes of the service/resource are compared  against the scope included in the user store for at least one match between  the two sets.  Config.toml has defined three users - Alice, Bob and Eve. Each user has a  password and optionally assigned scopes as an array.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );    @http:ServiceConfig {  auth: [  {  fileUserStoreConfig: {},  scopes: [\"admin\"]  }  ] } service /foo on securedEP {    The service can be secured with Basic auth and can be authorized optionally.  Using Basic auth with the file user store can be enabled by setting the  http:FileUserStoreConfig configurations.  Authorization is based on scopes. A scope maps to one or more groups.  Authorization can be enabled by setting the string|string[] type  configurations.   resource function get bar() returns string {  return \"Hello, World!\";  } }    It is optional to override the authentication and authorization  configurations at the resource levels. Otherwise, the service auth  configurations will be applied automatically to the resources as well.   [[ballerina.auth.users]] username=\"alice\" password=\"alice@123\" scopes=[\"developer\"]    [[ballerina.auth.users]] username=\"ldclakmal\" password=\"ldclakmal@123\" scopes=[\"developer\", \"admin\"]    [[ballerina.auth.users]] username=\"eve\" password=\"eve@123\"    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # Ensure that the `Config.toml` file is populated correctly with the user # information. echo '[[\"ballerina.auth.users\"]] username=\"alice\" password=\"password1\" scopes=[\"scope1\"] [[\"ballerina.auth.users\"]] username=\"bob\" password=\"password2\" scopes=[\"scope2\", \"scope3\"]' > Config.toml # (You may need to change the certificate file path and private key file path.) bal run http_service_basic_auth_file_user_store.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-jwt-auth.html","name":"Service - JWT Auth","summary":"An HTTP service/resource can be secured using JWT and by enforcing\n authorization optionally. Then, it validates the JWT sent in the\n Authorization header against the provided configurations.\n Ballerina uses the concept of scopes for authorization. A resource declared\n in a service can be bound to one/more scope(s). The scope can ...","content":"/  /  / Service - JWT Auth  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );  // The service can be secured with JWT authentication and can be authorized // optionally. JWT authentication can be enabled by setting the // `http:JwtValidatorConfig` configurations. // Authorization is based on scopes. A scope maps to one or more groups. // Authorization can be enabled by setting the `string|string[]` type // configurations. @http:ServiceConfig {  auth: [  {  jwtValidatorConfig: {  issuer: \"wso2\",  audience: \"ballerina\",  signatureConfig: {  certFile: \"../resource/path/to/public.crt\"  },  scopeKey: \"scp\"  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {   // It is optional to override the authentication and authorization  // configurations at the resource levels. Otherwise, the service auth  // configurations will be applied automatically to the resources as well.  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - JWT Auth  An HTTP service/resource can be secured using JWT and by enforcing  authorization optionally. Then, it validates the JWT sent in the  Authorization header against the provided configurations.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scope can be included  in the JWT using a custom claim attribute. That custom claim attribute  also can be configured as the scopeKey.  In the authorization phase, the scopes of the service/resource are compared  against the scope included in the JWT for at least one match between the two  sets.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );    @http:ServiceConfig {  auth: [  {  jwtValidatorConfig: {  issuer: \"wso2\",  audience: \"ballerina\",  signatureConfig: {  certFile: \"../resource/path/to/public.crt\"  },  scopeKey: \"scp\"  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {    The service can be secured with JWT authentication and can be authorized  optionally. JWT authentication can be enabled by setting the  http:JwtValidatorConfig configurations.  Authorization is based on scopes. A scope maps to one or more groups.  Authorization can be enabled by setting the string|string[] type  configurations.   resource function get bar() returns string {  return \"Hello, World!\";  } }    It is optional to override the authentication and authorization  configurations at the resource levels. Otherwise, the service auth  configurations will be applied automatically to the resources as well.   # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, private key file path and # trusted certificate file path.) bal run http_service_jwt_auth.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-basic-auth-ldap-user-store.html","name":"Service - Basic Auth LDAP User Store","summary":"An HTTP service/resource can be secured using Basic auth and by enforcing\n authorization optionally. Then, it validates the Basic auth token sent in\n the Authorization header against the provided configurations. This reads\n data from the configured LDAP. This stores usernames, passwords for\n authentication, and scopes for authorization.\n Ballerina uses the ...","content":"/  /  / Service - Basic Auth LDAP User Store  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );  // The service can be secured with Basic auth and can be authorized optionally. // Basic auth using the LDAP user store can be enabled by setting the // `http:LdapUserStoreConfig` configurations. // Authorization is based on scopes. A scope maps to one or more groups. // Authorization can be enabled by setting the `string|string[]` type // configurations. @http:ServiceConfig {  auth: [  {  ldapUserStoreConfig: {  domainName: \"avix.lk\",  connectionUrl: \"ldap://localhost:389\",  connectionName: \"cn=admin,dc=avix,dc=lk\",  connectionPassword: \"avix123\",  userSearchBase: \"ou=Users,dc=avix,dc=lk\",  userEntryObjectClass: \"inetOrgPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",  userNameListFilter: \"(objectClass=inetOrgPerson)\",  groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeout: 5,  readTimeout: 60  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {   // It is optional to override the authentication and authorization  // configurations at the resource levels. Otherwise, the service auth  // configurations will be applied automatically to the resources as well.  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - Basic Auth LDAP User Store  An HTTP service/resource can be secured using Basic auth and by enforcing  authorization optionally. Then, it validates the Basic auth token sent in  the Authorization header against the provided configurations. This reads  data from the configured LDAP. This stores usernames, passwords for  authentication, and scopes for authorization.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s).  In the authorization phase, the scopes of the service/resource are compared  against the scope included in the user store for at least one match between  the two sets.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );    @http:ServiceConfig {  auth: [  {  ldapUserStoreConfig: {  domainName: \"avix.lk\",  connectionUrl: \"ldap://localhost:389\",  connectionName: \"cn=admin,dc=avix,dc=lk\",  connectionPassword: \"avix123\",  userSearchBase: \"ou=Users,dc=avix,dc=lk\",  userEntryObjectClass: \"inetOrgPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=inetOrgPerson)(uid=?))\",  userNameListFilter: \"(objectClass=inetOrgPerson)\",  groupSearchBase: [\"ou=Groups,dc=avix,dc=lk\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeout: 5,  readTimeout: 60  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {    The service can be secured with Basic auth and can be authorized optionally.  Basic auth using the LDAP user store can be enabled by setting the  http:LdapUserStoreConfig configurations.  Authorization is based on scopes. A scope maps to one or more groups.  Authorization can be enabled by setting the string|string[] type  configurations.   resource function get bar() returns string {  return \"Hello, World!\";  } }    It is optional to override the authentication and authorization  configurations at the resource levels. Otherwise, the service auth  configurations will be applied automatically to the resources as well.   # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path and private key file path.) bal run http_service_basic_auth_ldap_user_store.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-retry.html","name":"Retry","summary":"The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.\n For more information on the underlying module,\n see the .Define the endpoint to the call the mockHelloService.Retry configuration options.Initial retry interval in seconds.Number of retry attempts before giving up.Multiplier ...","content":"/  /  / Retry  import ballerina/http; import ballerina/log; import ballerina/lang.runtime;  // Define the endpoint to the call the `mockHelloService`. http:Client backendClientEP = check new (\"http://localhost:8080\", {  // Retry configuration options.  retryConfig: {   // Initial retry interval in seconds.  interval: 3,   // Number of retry attempts before giving up.  count: 3,   // Multiplier of the retry interval to exponentially increase  // the retry interval.  backOffFactor: 2.0,   // Upper limit of the retry interval in seconds. If  // `interval` into `backOffFactor` value exceeded  // `maxWaitInterval` interval value,  // `maxWaitInterval` will be considered as the retry  // interval.  maxWaitInterval: 20   },  timeout: 2  }  );   service /'retry on new http:Listener(9090) {   // Parameters include a reference to the caller and an object of the  // request data.  resource function 'default .(http:Caller caller, http:Request request) {   http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(<@untainted>backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload((<@untainted error>backendResponse).message());  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  }   } }  int counter = 0;  // This sample service is used to mock connection timeouts and service outages. // The service outage is mocked by stopping/starting this service. // This should run separately from the `retryDemoService` service. service /hello on new http:Listener(8080) {   resource function get .(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");  // Delay the response by 5 seconds to mimic network level delays.  runtime:sleep(5);   var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }  function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\",  'error = result);  } }    Retry  The HTTP retry client tries sending over the same request to the backend service when there is a network level failure.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log; import ballerina/lang.runtime;    http:Client backendClientEP = check new (\"http://localhost:8080\", {    Define the endpoint to the call the mockHelloService.   retryConfig: {    Retry configuration options.   interval: 3,    Initial retry interval in seconds.   count: 3,    Number of retry attempts before giving up.   backOffFactor: 2.0,    Multiplier of the retry interval to exponentially increase  the retry interval.   maxWaitInterval: 20    Upper limit of the retry interval in seconds. If  interval into backOffFactor value exceeded  maxWaitInterval interval value,  maxWaitInterval will be considered as the retry  interval.   },  timeout: 2  }  );    service /'retry on new http:Listener(9090) {    resource function 'default .(http:Caller caller, http:Request request) {    Parameters include a reference to the caller and an object of the  request data.   http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);    if (backendResponse is http:Response) {  var responseToCaller = caller->respond(<@untainted>backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  response.setPayload((<@untainted error>backendResponse).message());  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   } }    int counter = 0;    service /hello on new http:Listener(8080) {    This sample service is used to mock connection timeouts and service outages.  The service outage is mocked by stopping/starting this service.  This should run separately from the retryDemoService service.   resource function get .(http:Caller caller, http:Request req) {  counter = counter + 1;  if (counter % 4 != 0) {  log:printInfo(  \"Request received from the client to delayed service.\");    runtime:sleep(5);    Delay the response by 5 seconds to mimic network level delays.   var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  } else {  log:printInfo(  \"Request received from the client to healthy service.\");  var responseToCaller = caller->respond(\"Hello World!!!\");  handleRespondResult(responseToCaller);  }  } }    function handleRespondResult(error? result) {  if (result is http:ListenerError) {  log:printError(\"Error sending response from mock service\",  'error = result);  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_retry.bal.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 time = 2021-01-21 19:00:21,374 level = INFO module = \"\" message = \"Request received from the client to delayed service.\" time = 2021-01-21 19:00:26,379 level = INFO module = \"\" message = \"Request received from the client to delayed service.\" time = 2021-01-21 19:00:26,446 level = ERROR module = \"\" message = \"Error sending response from mock service\" error = \"Connection between remote client and host is closed\" time = 2021-01-21 19:00:31,387 level = ERROR module = \"\" message = \"Error sending response from mock service\" error = \"Connection between remote client and host is closed\" time = 2021-01-21 19:00:34,402 level = INFO module = \"\" message = \"Request received from the client to delayed service.\" time = 2021-01-21 19:00:39,409 level = ERROR module = \"\" message = \"Error sending response from mock service\" error = \"Connection between remote client and host is closed\" time = 2021-01-21 19:00:48,404 level = INFO module = \"\" message = \"Request received from the client to healthy service.\"    # If the request that was sent to the `retryDemoService` fails due to an error, the client tries sending the request again. curl -v http://localhost:9090/retry * Trying 127.0.0.1:9090... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /retry HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.68.0 > Accept: */* > * Mark bundle as not supporting multiuse < HTTP/1.1 200 OK < content-type: text/plain < date: Mon, 21 Sep 2020 20:20:20 +0530 < server: ballerina < content-length: 14 < * Connection #0 to host localhost left intact Hello World!!!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-mutual-ssl.html","name":"Service - Mutual SSL","summary":"Ballerina supports mutual SSL, which is a certificate-based authentication\n process in which two parties (the client and server) authenticate each other by\n verifying the digital certificates. It ensures that both parties are assured\n of each other’s identity.\n For more information on the underlying module,\n see the .An HTTP listener can ...","content":"/  /  / Service - Mutual SSL  import ballerina/http;  // An HTTP listener can be configured to accept new connections that are // secured via mutual SSL. // The [http:ListenerSecureSocket](https://docs.central.ballerina.io/ballerina/http/latest/records/ListenerSecureSocket) record provides the SSL-related listener configurations. listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  },  // Enables mutual SSL.  mutualSsl: {  verifyClient: http:REQUIRE,  cert: \"../resource/path/to/public.crt\"  },  // Enables the preferred SSL protocol and its versions.  protocol: {  name: http:TLS,  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },  // Configures the preferred ciphers.  ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } );  service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - Mutual SSL  Ballerina supports mutual SSL, which is a certificate-based authentication  process in which two parties (the client and server) authenticate each other by  verifying the digital certificates. It ensures that both parties are assured  of each other’s identity.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  },    An HTTP listener can be configured to accept new connections that are  secured via mutual SSL.  The record provides the SSL-related listener configurations.   mutualSsl: {  verifyClient: http:REQUIRE,  cert: \"../resource/path/to/public.crt\"  },    Enables mutual SSL.   protocol: {  name: http:TLS,  versions: [\"TLSv1.2\", \"TLSv1.1\"]  },    Enables the preferred SSL protocol and its versions.   ciphers: [\"TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA\"]  } );    Configures the preferred ciphers.   service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, private key file path, and # trusted certificate file path.) bal run http_service_mutual_ssl.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-response-with-multiparts.html","name":"Response With Multiparts","summary":"Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.\n When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of\n entities). If the received parts contain nested parts, you can loop through the ...","content":"/  /  / Response With Multiparts  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  // Creates an endpoint for the client. http:Client clientEP = check new (\"http://localhost:9092\");  // Creates a listener for the service. listener http:Listener multipartEP = new (9090);  service /multiparts on new http:Listener(9092) {   resource function get encode_out_response() returns http:Response {  // Creates an enclosing entity to hold the child parts.  mime:Entity parentPart = new;   // Creates a child part with the JSON content.  mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});  // Creates another child part with a file.  mime:Entity childPart2 = new;  // This file path is relative to where the Ballerina is running.  //If your file is located outside, please give the  //absolute file path instead.  childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);  // Creates an array to hold the child parts.  mime:Entity[] childParts = [childPart1, childPart2];  // [Sets the child parts to the parent part](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#setBodyParts).  parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);  // Creates an array to hold the parent part and set it to the response.  mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  return outResponse;  } }  // Binds the listener to the service. service /multiparts on multipartEP {   // This resource accepts multipart responses.  resource function get decode_in_response()  returns string|http:InternalServerError {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {  // [Extracts the body parts](https://docs.central.ballerina.io/ballerina/http/latest/classes/Response#getBodyParts) from the response.  var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {  //Loops through body parts.  foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  return \"Body Parts Received!\";  } else {  return { body: \"Invalid payload\"};  }  } else {  return { body: \"Connection error\"};  }  } }  // Gets the child parts that are nested within the parent. function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  childParts.message());  }  } }  //The content logic that handles the body parts //vary based on your requirement. function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {  // [Extracts XML data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getXml) from the body part.  var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(\"XML data: \" + payload.toString());  } else {  log:printError(\"Error in parsing XML data\", 'error = payload);  }  } else if (mime:APPLICATION_JSON == baseType) {  // [Extracts JSON data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getJson) from the body part.  var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", 'error = payload);  }  } else if (mime:TEXT_PLAIN == baseType) {  // [Extracts text data](https://docs.central.ballerina.io/ballerina/mime/latest/classes/Entity#getText) from the body part.  var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", 'error = payload);  }  } else if (mime:APPLICATION_PDF == baseType) {  // [Extracts the byte stream](https://docs.central.ballerina.io/ballerina/http/latest/classes/Response#getByteStream) from the body part and saves it as a file.  var payload = bodyPart.getByteStream();  if (payload is stream<byte[], io:Error?>) {  //Writes the incoming stream to a file using `io:fileWriteBlocksFromStream` API by providing the file location to which the content should be written to.  io:Error? result = io:fileWriteBlocksFromStream(  \"./files/ReceivedFile.pdf\", payload);   if (result is error) {  log:printError(\"Error occurred while writing \",  'error = result);  }  close(payload);  } else {  log:printError(\"Error in parsing byte channel :\",  'error = payload);  }  } }  //Gets the base type from a given content type. function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }  //Closes the byte stream. function close(stream<byte[], io:Error?> byteStream) {  var cr = byteStream.close();  if (cr is error) {  log:printError(\"Error occurred while closing the stream: \",  'error = cr);  } }    Response With Multiparts  Ballerina supports encoding and decoding multipart content in HTTP responses along with the nested parts.  When you request multiparts from an HTTP inbound response, you get an array of the parts of the body (an array of  entities). If the received parts contain nested parts, you can loop through the parent parts and get the child parts.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEP = check new (\"http://localhost:9092\");    Creates an endpoint for the client.   listener http:Listener multipartEP = new (9090);    Creates a listener for the service.   service /multiparts on new http:Listener(9092) {    resource function get encode_out_response() returns http:Response {    mime:Entity parentPart = new;    Creates an enclosing entity to hold the child parts.   mime:Entity childPart1 = new;  childPart1.setJson({\"name\": \"wso2\"});    Creates a child part with the JSON content.   mime:Entity childPart2 = new;    Creates another child part with a file.   childPart2.setFileAsEntityBody(\"./files/test.xml\",  contentType = mime:TEXT_XML);    This file path is relative to where the Ballerina is running. If your file is located outside, please give the absolute file path instead.   mime:Entity[] childParts = [childPart1, childPart2];    Creates an array to hold the child parts.   parentPart.setBodyParts(childParts,  contentType = mime:MULTIPART_MIXED);    .   mime:Entity[] immediatePartsToResponse = [parentPart];  http:Response outResponse = new;  outResponse.setBodyParts(immediatePartsToResponse,  contentType = mime:MULTIPART_FORM_DATA);  return outResponse;  } }    Creates an array to hold the parent part and set it to the response.   service /multiparts on multipartEP {    Binds the listener to the service.   resource function get decode_in_response()  returns string|http:InternalServerError {  http:Response inResponse = new;  var returnResult = clientEP->get(\"/multiparts/encode_out_response\");  http:Response res = new;  if (returnResult is http:Response) {    This resource accepts multipart responses.   var parentParts = returnResult.getBodyParts();  if (parentParts is mime:Entity[]) {    from the response.   foreach var parentPart in parentParts {  handleNestedParts(parentPart);  }  return \"Body Parts Received!\";  } else {  return { body: \"Invalid payload\"};  }  } else {  return { body: \"Connection error\"};  }  } }    Loops through body parts.   function handleNestedParts(mime:Entity parentPart) {  string contentTypeOfParent = parentPart.getContentType();  if (contentTypeOfParent.startsWith(\"multipart/\")) {  var childParts = parentPart.getBodyParts();  if (childParts is mime:Entity[]) {  log:printInfo(\"Nested Parts Detected!\");  foreach var childPart in childParts {  handleContent(childPart);  }  } else {  log:printError(\"Error retrieving child parts! \" +  childParts.message());  }  } }    Gets the child parts that are nested within the parent.   function handleContent(mime:Entity bodyPart) {  string baseType = getBaseType(bodyPart.getContentType());  if (mime:APPLICATION_XML == baseType || mime:TEXT_XML == baseType) {    The content logic that handles the body parts vary based on your requirement.   var payload = bodyPart.getXml();  if (payload is xml) {  log:printInfo(\"XML data: \" + payload.toString());  } else {  log:printError(\"Error in parsing XML data\", 'error = payload);  }  } else if (mime:APPLICATION_JSON == baseType) {    from the body part.   var payload = bodyPart.getJson();  if (payload is json) {  log:printInfo(\"JSON data: \" + payload.toJsonString());  } else {  log:printError(\"Error in parsing JSON data\", 'error = payload);  }  } else if (mime:TEXT_PLAIN == baseType) {    from the body part.   var payload = bodyPart.getText();  if (payload is string) {  log:printInfo(\"Text data: \" + payload);  } else {  log:printError(\"Error in parsing text data\", 'error = payload);  }  } else if (mime:APPLICATION_PDF == baseType) {    from the body part.   var payload = bodyPart.getByteStream();  if (payload is stream<byte[], io:Error?>) {    from the body part and saves it as a file.   io:Error? result = io:fileWriteBlocksFromStream(  \"./files/ReceivedFile.pdf\", payload);    Writes the incoming stream to a file using io:fileWriteBlocksFromStream API by providing the file location to which the content should be written to.   if (result is error) {  log:printError(\"Error occurred while writing \",  'error = result);  }  close(payload);  } else {  log:printError(\"Error in parsing byte channel :\",  'error = payload);  }  } }    function getBaseType(string contentType) returns string {  var result = mime:getMediaType(contentType);  if (result is mime:MediaType) {  return result.getBaseType();  } else {  panic result;  } }    Gets the base type from a given content type.   function close(stream<byte[], io:Error?> byteStream) {  var cr = byteStream.close();  if (cr is error) {  log:printError(\"Error occurred while closing the stream: \",  'error = cr);  } }    Closes the byte stream.   # In the directory, which contains the `.bal` file, create a directory named `files`, # and add an XML file named `test.xml` in it. # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run response_with_multiparts.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:9092 time = 2021-01-21 22:20:38,143 level = INFO module = \"\" message = \"Nested Parts Detected!\" time = 2021-01-21 22:20:38,185 level = INFO module = \"\" message = \"JSON data: {\"name\":\"wso2\"}\" time = 2021-01-21 22:20:38,324 level = INFO module = \"\" message = \"XML data: <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang>\" #To encode the outbound response with multiparts. curl -X GET http://localhost:9092/multiparts/encode_out_response --5afd3d91ee639af3 content-type: multipart/mixed;boundary=de5520ef3bc703d7    --de5520ef3bc703d7 content-type: application/json    {\"name\":\"wso2\"} --de5520ef3bc703d7 content-type: text/xml    <ballerinalang>  <version>0.963</version>  <test>test xml file to be used as a file part</test> </ballerinalang> --de5520ef3bc703d7--    --5afd3d91ee639af3--    #To decode the inbound response with multiparts. curl -X GET http://localhost:9090/multiparts/decode_in_response Body Parts Received!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-oauth2.html","name":"Service - OAuth2","summary":"An HTTP service/resource can be secured using OAuth2 and by enforcing\n authorization optionally. Then, it validates the OAuth2 token sent in the\n Authorization header against the provided configurations. This calls the\n configured introspection endpoint to validate.\n Ballerina uses the concept of scopes for authorization. A resource declared\n in a service ...","content":"/  /  / Service - OAuth2  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );  // The service can be secured with OAuth2 authentication and can be authorized // optionally. OAuth2 authentication can be enabled by setting the // `http:OAuth2IntrospectionConfig` configurations. // Authorization is based on scopes. A scope maps to one or more groups. // Authorization can be enabled by setting the `string|string[]` type // configurations. @http:ServiceConfig {  auth: [  {  oauth2IntrospectionConfig: {  url: \"https://localhost:9445/oauth2/introspect\",  tokenTypeHint: \"access_token\",  scopeKey: \"scp\",  clientConfig: {  customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4=\"},  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {   // It is optional to override the authentication and authorization  // configurations at the resource levels. Otherwise, the service auth  // configurations will be applied automatically to the resources as well.  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - OAuth2  An HTTP service/resource can be secured using OAuth2 and by enforcing  authorization optionally. Then, it validates the OAuth2 token sent in the  Authorization header against the provided configurations. This calls the  configured introspection endpoint to validate.  Ballerina uses the concept of scopes for authorization. A resource declared  in a service can be bound to one/more scope(s). The scope can be included  in the introspection response using a custom claim attribute. That custom  claim attribute is also can be configured as the scopeKey.  In the authorization phase, the scopes of the service/resource are compared  against the scope included in the introspection response for at least one  match between the two sets.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );    @http:ServiceConfig {  auth: [  {  oauth2IntrospectionConfig: {  url: \"https://localhost:9445/oauth2/introspect\",  tokenTypeHint: \"access_token\",  scopeKey: \"scp\",  clientConfig: {  customHeaders: {\"Authorization\": \"Basic YWRtaW46YWRtaW4=\"},  secureSocket: {  cert: \"../resource/path/to/public.crt\"  }  }  },  scopes: [\"admin\"]  }  ] } service /foo on securedEP {    The service can be secured with OAuth2 authentication and can be authorized  optionally. OAuth2 authentication can be enabled by setting the  http:OAuth2IntrospectionConfig configurations.  Authorization is based on scopes. A scope maps to one or more groups.  Authorization can be enabled by setting the string|string[] type  configurations.   resource function get bar() returns string {  return \"Hello, World!\";  } }    It is optional to override the authentication and authorization  configurations at the resource levels. Otherwise, the service auth  configurations will be applied automatically to the resources as well.   # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, private key file path and # trusted certificate file path.) bal run http_service_oauth2.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-service-ssl-tls.html","name":"Service - SSL/TLS","summary":"You can use the HTTPS listener to connect to or interact with an HTTPS client.\n Provide the http:ListenerSecureSocket configurations to the server to\n expose an HTTPS connection.\n For more information on the underlying module,\n see the .An HTTP listener can be configured to communicate through HTTPS as well.\n To secure ...","content":"/  /  / Service - SSL/TLS  import ballerina/http;  // An HTTP listener can be configured to communicate through HTTPS as well. // To secure an listener using HTTPS, the listener needs to be configured with // a certificate file and a private key file for the listener. // The [http:ListenerSecureSocket](https://docs.central.ballerina.io/ballerina/http/latest/records/ListenerSecureSocket) record // provides the SSL-related listener configurations of the listener. listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );  service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }    Service - SSL/TLS  You can use the HTTPS listener to connect to or interact with an HTTPS client.  Provide the http:ListenerSecureSocket configurations to the server to  expose an HTTPS connection.  For more information on the underlying module,  see the .    import ballerina/http;    listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"../resource/path/to/public.crt\",  keyFile: \"../resource/path/to/private.key\"  }  } );    An HTTP listener can be configured to communicate through HTTPS as well.  To secure an listener using HTTPS, the listener needs to be configured with  a certificate file and a private key file for the listener.  The record  provides the SSL-related listener configurations of the listener.   service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path and private key file path.) bal run http_service_ssl_tls.bal [ballerina/http] started HTTPS/WSS listener 0.0.0.0:9090    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/identity.html","name":"Identity","summary":"=== and !== operators test for identity. Identical for mutable basic types means stored at the same address.\n == and != are not defined for objects. -0.0 and +0.0 are equal but not identical.b1 will be true.b2 will be false.b3 will be true.b4 will be false.b5 will be true.b6 will ...","content":"/  /  / Identity  class MyClass {  int i = 0; }  public function main() {  MyClass obj1 = new MyClass();  MyClass obj2 = new MyClass();  // b1 will be true.  boolean b1 = (obj1 === obj1);  // b2 will be false.  boolean b2 = (obj1 === obj2);  // b3 will be true.  boolean b3 = ([1,2,3] == [1,2,3]);  // b4 will be false.  boolean b4 = ([1,2,3] === [1,2,3]);  // b5 will be true.  boolean b5 = (-0.0 == +0.0);  // b6 will be false.  boolean b6 = (-0.0 === +0.0); }    Identity  === and !== operators test for identity. Identical for mutable basic types means stored at the same address.  == and != are not defined for objects. -0.0 and +0.0 are equal but not identical.    class MyClass {  int i = 0; }    public function main() {  MyClass obj1 = new MyClass();  MyClass obj2 = new MyClass();    boolean b1 = (obj1 === obj1);    b1 will be true.   boolean b2 = (obj1 === obj2);    b2 will be false.   boolean b3 = ([1,2,3] == [1,2,3]);    b3 will be true.   boolean b4 = ([1,2,3] === [1,2,3]);    b4 will be false.   boolean b5 = (-0.0 == +0.0);    b5 will be true.   boolean b6 = (-0.0 === +0.0); }    b6 will be false.   bal run identity.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/identifiers.html","name":"Identifiers","summary":"Identifier syntax is similar to C. Keywords are reserved.You can have Unicode identifiers.Use \\u{H} to specify character using Unicode code point in hex.Prefix reserved keywords with a single quote.Prefix non-identifier character with a .This website uses cookies so that we can provide you with the best user experience. Read our ...","content":"/  /  / Identifiers  import ballerina/io;  // You can have Unicode identifiers. function พิมพ์ชื่อ(string ชื่อ) {  // Use \\u{H} to specify character using Unicode code point in hex.  io:println(ชื่\\u{E2D}); }  // Prefix reserved keywords with a single quote. string 'from = \"contact@ballerina.io\";  // Prefix non-identifier character with a \\. string first\\ name = \"Ballerina\";  public function main() {  พิมพ์ชื่อ(\"ආයුබෝවන්\"); }    Identifiers  Identifier syntax is similar to C. Keywords are reserved.    import ballerina/io;    function พิมพ์ชื่อ(string ชื่อ) {    You can have Unicode identifiers.   io:println(ชื่\\u{E2D}); }    Use \\u{H} to specify character using Unicode code point in hex.   string 'from = \"contact@ballerina.io\";    Prefix reserved keywords with a single quote.   string first\\ name = \"Ballerina\";    Prefix non-identifier character with a .   public function main() {  พิมพ์ชื่อ(\"ආයුබෝවන්\"); }    bal run identifiers.bal ආයුබෝවන්    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-timeout.html","name":"Timeout","summary":"The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.\n For more information on the underlying module,\n see the .Timeout configuration.Create an HTTP service bound to the listener endpoint.If backendResponse is an http:Response, it is sent back to the\n client. If backendResponse is an ...","content":"/  /  / Timeout  import ballerina/http; import ballerina/log; import ballerina/lang.runtime;  http:Client backendClientEP = check new (\"http://localhost:8080\", {  // Timeout configuration.  timeout: 10   });  // Create an HTTP service bound to the listener endpoint. service /timeout on new http:Listener(9090) {   resource function get .(http:Caller caller, http:Request request) {  http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);   // If `backendResponse` is an `http:Response`, it is sent back to the  // client. If `backendResponse` is an `http:ClientError`, an internal  // server error is returned to the client.  if (backendResponse is http:Response) {  var responseToCaller = caller->respond(<@untainted>backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = backendResponse.message();  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(<@untainted>errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  }   } }  // This sample service is used to mock connection timeouts. service /hello on new http:Listener(8080) {   resource function get .(http:Caller caller, http:Request req) {  // Delay the response by 15 seconds to mimic the network level delays.  runtime:sleep(15);   var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\",  'error = result);  }  } }    Timeout  The Timeout is used to gracefully handle network timeouts, which occur when using the HTTP Client.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/log; import ballerina/lang.runtime;    http:Client backendClientEP = check new (\"http://localhost:8080\", {    timeout: 10    Timeout configuration.   });    service /timeout on new http:Listener(9090) {    Create an HTTP service bound to the listener endpoint.   resource function get .(http:Caller caller, http:Request request) {  http:Response|error backendResponse =  backendClientEP->forward(\"/hello\", request);    if (backendResponse is http:Response) {  var responseToCaller = caller->respond(<@untainted>backendResponse);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  } else {  http:Response response = new;  response.statusCode = http:STATUS_INTERNAL_SERVER_ERROR;  string errorMessage = backendResponse.message();  string expectedMessage = \"Idle timeout triggered before \" +  \"initiating inbound response\";  if (errorMessage == expectedMessage) {  response.setPayload(  \"Request timed out. Please try again in sometime.\"  );  } else {  response.setPayload(<@untainted>errorMessage);  }  var responseToCaller = caller->respond(response);  if (responseToCaller is error) {  log:printError(\"Error sending response\",  'error = responseToCaller);  }  }    If backendResponse is an http:Response, it is sent back to the  client. If backendResponse is an http:ClientError, an internal  server error is returned to the client.   } }    service /hello on new http:Listener(8080) {    This sample service is used to mock connection timeouts.   resource function get .(http:Caller caller, http:Request req) {    runtime:sleep(15);    Delay the response by 15 seconds to mimic the network level delays.   var result = caller->respond(\"Hello World!!!\");  if (result is error) {  log:printError(\"Error sending response from mock service\",  'error = result);  }  } }    # To start the services, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_timeout.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 time = 2021-01-21 18:56:14,394 level = ERROR module = \"\" message = \"Error sending response from mock service\" error = \"Connection between remote client and host is closed\"    curl -v http://localhost:9090/timeout * Trying 127.0.0.1:9090... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 9090 (#0) > GET /timeout HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.68.0 > Accept: */* > * Mark bundle as not supporting multiuse < HTTP/1.1 500 Internal Server Error < content-type: text/plain < content-length: 48 < server: ballerina < date: Mon, 21 Sep 2020 20:36:56 +0530 < * Connection #0 to host localhost left intact Request timed out. Please try again in sometime.    Invoke the service using “cURL”.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/http-streaming.html","name":"Streaming","summary":"Ballerina supports HTTP input and output streaming capability based on the Ballerina stream type.\n For more information on the underlying module,\n see the .Creates an endpoint for the . as the request payload.Sends the request to the client with the file content..Writes the incoming stream to a file using io:fileWriteBlocksFromStream ...","content":"/  /  / Streaming  import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;  // Creates an endpoint for the [client](https://docs.central.ballerina.io/ballerina/http/latest/clients/Client). http:Client clientEndpoint = check new (\"http://localhost:9090\");  service /'stream on new http:Listener(9090) {   resource function get fileupload(http:Caller caller) {  http:Request request = new;   //[Sets the file](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#setFileAsPayload) as the request payload.  request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);   //Sends the request to the client with the file content.  http:Response|error clientResponse =  clientEndpoint->post(\"/stream/receiver\", request);   http:Response res = new;  if (clientResponse is http:Response) {  res = clientResponse;  } else {  log:printError(\"Error occurred while sending data to the client \",  'error = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  'error = result);  }  }   resource function post receiver(http:Caller caller,  http:Request request) {  http:Response res = new;  //[Retrieve the byte stream](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getByteStream).  stream<byte[], io:Error?>|error streamer = request.getByteStream();   if (streamer is stream<byte[], io:Error?>) {  //Writes the incoming stream to a file using `io:fileWriteBlocksFromStream` API by providing the file location to which the content should be written to.  io:Error? result = io:fileWriteBlocksFromStream(  \"./files/ReceivedFile.pdf\", streamer);   if (result is error) {  log:printError(\"error occurred while writing \",  'error = result);  setError(res, result);  } else {  res.setPayload(\"File Received!\");  }  close(streamer);  } else {  setError(res, streamer);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  'error = result);  }  } }  //Sets the error to the response. function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted>err.message()); }  //Closes the byte stream. function close(stream<byte[], io:Error?> byteStream) {  var cr = byteStream.close();  if (cr is error) {  log:printError(\"Error occurred while closing the stream: \",  'error = cr);  } }    Streaming  Ballerina supports HTTP input and output streaming capability based on the Ballerina stream type.  For more information on the underlying module,  see the .    import ballerina/http; import ballerina/io; import ballerina/log; import ballerina/mime;    http:Client clientEndpoint = check new (\"http://localhost:9090\");    Creates an endpoint for the .   service /'stream on new http:Listener(9090) {    resource function get fileupload(http:Caller caller) {  http:Request request = new;    request.setFileAsPayload(\"./files/BallerinaLang.pdf\",  contentType = mime:APPLICATION_PDF);    as the request payload.   http:Response|error clientResponse =  clientEndpoint->post(\"/stream/receiver\", request);    Sends the request to the client with the file content.   http:Response res = new;  if (clientResponse is http:Response) {  res = clientResponse;  } else {  log:printError(\"Error occurred while sending data to the client \",  'error = clientResponse);  setError(res, clientResponse);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error while while sending response to the caller\",  'error = result);  }  }    resource function post receiver(http:Caller caller,  http:Request request) {  http:Response res = new;    stream<byte[], io:Error?>|error streamer = request.getByteStream();    .   if (streamer is stream<byte[], io:Error?>) {    io:Error? result = io:fileWriteBlocksFromStream(  \"./files/ReceivedFile.pdf\", streamer);    Writes the incoming stream to a file using io:fileWriteBlocksFromStream API by providing the file location to which the content should be written to.   if (result is error) {  log:printError(\"error occurred while writing \",  'error = result);  setError(res, result);  } else {  res.setPayload(\"File Received!\");  }  close(streamer);  } else {  setError(res, streamer);  }  var result = caller->respond(res);  if (result is error) {  log:printError(\"Error occurred while sending response\",  'error = result);  }  } }    function setError(http:Response res, error err) {  res.statusCode = 500;  res.setPayload(<@untainted>err.message()); }    Sets the error to the response.   function close(stream<byte[], io:Error?> byteStream) {  var cr = byteStream.close();  if (cr is error) {  log:printError(\"Error occurred while closing the stream: \",  'error = cr);  } }    Closes the byte stream.   # In the directory, which contains the `.bal` file, create a directory named `files`, # and add a PDF file named `BallerinaLang.pdf` in it. # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run http_streaming.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    #Send a request to the streaming service. curl -X GET http://localhost:9090/stream/fileupload File Received!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/immutability.html","name":"Immutability","summary":"anydata values can be made immutable. Simple and string values are inherently immutable.\n A structural value can be constructed as mutable or immutable. A value includes an immutable flag.\n The immutable flag is fixed at the time of construction. Attempting to mutate an immutable structure\n causes a panic at runtime. ...","content":"/  /  / Immutability  import ballerina/io;  type Student record {|  int grade;  string name;  map<int> marks; |};  public function main() {  // Creates an immutable `Student` value using an intersection  // type with `readonly`.  Student & readonly student = {  grade: 12,  name: \"John\",  // The applicable contextually expected type for `marks`  // is now `map<int> & readonly`. Thus the value for `marks`  // will be constructed as an immutable map.  marks: {  \"Maths\": 75,  \"English\": 90  }  };  boolean x = student[\"marks\"] is map<int> & readonly;  io:println(x); }    Immutability  anydata values can be made immutable. Simple and string values are inherently immutable.  A structural value can be constructed as mutable or immutable. A value includes an immutable flag.  The immutable flag is fixed at the time of construction. Attempting to mutate an immutable structure  causes a panic at runtime. Immutability is deep: an immutable structure can only have immutable  members. An immutable value is safe for concurrent access without locking.    import ballerina/io;    type Student record {|  int grade;  string name;  map<int> marks; |};    public function main() {    Student & readonly student = {  grade: 12,  name: \"John\",    Creates an immutable Student value using an intersection  type with readonly.   marks: {  \"Maths\": 75,  \"English\": 90  }  };  boolean x = student[\"marks\"] is map<int> & readonly;  io:println(x); }    The applicable contextually expected type for marks  is now map<int> & readonly. Thus the value for marks  will be constructed as an immutable map.   bal run immutability.bal true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/ignoring-return-values-and-errors.html","name":"Ignoring Return Values and Errors","summary":"Ballerina does not allow silently ignoring return values.\n To ignore a return value, assign it to _; this is like\n an implicitly declared variable that cannot be referenced.\n When a return type includes an error, you have to do something\n with the error.\n _ is of type any: you cannot ...","content":"/  /  / Ignoring Return Values and Errors  import ballerina/io;  public function main() {  // Allowed only if return value is ().  doX();   // Allowed if return value does not include error.  _ = getX();   // Use checkpanic if you don't want to handle an error.  checkpanic tryX(true);  checkpanic tryX(false); }  function doX() {  io:println(\"Do X\"); }  function getX() returns boolean {  io:println(\"Get X\");  return true; }  function tryX(boolean x) returns error? {  io:println(\"Try X\");  if !x {  return error(\"error!\");  } }    Ignoring Return Values and Errors  Ballerina does not allow silently ignoring return values.  To ignore a return value, assign it to _; this is like  an implicitly declared variable that cannot be referenced.  When a return type includes an error, you have to do something  with the error.  _ is of type any: you cannot use _ to ignore an error.  checkpanic is like check, but panics on error rather than  returning.    import ballerina/io;    public function main() {    doX();    Allowed only if return value is ().   _ = getX();    Allowed if return value does not include error.   checkpanic tryX(true);  checkpanic tryX(false); }    Use checkpanic if you don’t want to handle an error.   function doX() {  io:println(\"Do X\"); }    function getX() returns boolean {  io:println(\"Get X\");  return true; }    function tryX(boolean x) returns error? {  io:println(\"Try X\");  if !x {  return error(\"error!\");  } }    bal run ignoring_return_values_and_errors.bal Do X Get X Try X Try X error: error!  at ignoring_return_values_and_errors:tryX(ignoring_return_values_and_errors.bal:27)  ignoring_return_values_and_errors:main(ignoring_return_values_and_errors.bal:12)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/inferring-isolated.html","name":"Inferring Isolated","summary":"isolated is a complex feature, which would be a lot for an application developer to understand.\n A typical Ballerina application consists of a single module that imports multiple library modules.\n Within a single module, we can infer isolated qualifiers. Object w/o mutable fields is\n inherently isolated. Application developer’s responsibility is ...","content":"/  /  / Inferring Isolated  import ballerina/io;  public function main() {  // function's default worker, worker `A` and `B` run concurrently.  worker A {  // It is safe to access the parameters of `sayHello` for the  // duration of the function call.  string a = sayHello(\"John\");  io:println(a);  }   worker B {  string b = sayHello(\"Anne\");  io:println(b);  }   // `sayHello` is inferred to be an `isolated` function.  boolean c = sayHello is isolated function (string str) returns string;  io:println(c); }  function sayHello(string name) returns string {  return \"Hello \" + name; }    Inferring Isolated  isolated is a complex feature, which would be a lot for an application developer to understand.  A typical Ballerina application consists of a single module that imports multiple library modules.  Within a single module, we can infer isolated qualifiers. Object w/o mutable fields is  inherently isolated. Application developer’s responsibility is to use lock statement where  needed. - access self in a service object with mutable state. - access mutable module-level variables. Compiler can inform developer where missing locks are preventing a service object or method from  being isolated.    import ballerina/io;    public function main() {    worker A {    function’s default worker, worker A and B run concurrently.   string a = sayHello(\"John\");  io:println(a);  }    It is safe to access the parameters of sayHello for the  duration of the function call.   worker B {  string b = sayHello(\"Anne\");  io:println(b);  }    boolean c = sayHello is isolated function (string str) returns string;  io:println(c); }    sayHello is inferred to be an isolated function.   function sayHello(string name) returns string {  return \"Hello \" + name; }    bal run inferring_isolated.bal true Hello Anne Hello John    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/init-return-type.html","name":"Init Return Type","summary":"init function has a return type, which must be subtype of error?. If init returns (),\n then new returns the newly constructed object. If init returns an error, then new returns\n that error. If init does not specify a return type, then the return type defaults to () as usual,\n ...","content":"/  /  / Init Return Type  import ballerina/io;  // Defines a class called `File`. class File {  string path;  string contents;  // `init()` method is used to initialize the `object`  // when creating a new `object`.  function init(string p, string? c) returns error? {  self.path = p;  self.contents = check c.ensureType(string);  } }  public function main() returns error? {  // `new` returns the newly constructed `File` object.  File f = check new File(\"test.txt\", \"Hello World\");  io:println(f.contents); }    Init Return Type  init function has a return type, which must be subtype of error?. If init returns (),  then new returns the newly constructed object. If init returns an error, then new returns  that error. If init does not specify a return type, then the return type defaults to () as usual,  meaning that new will never return an error.    import ballerina/io;    class File {  string path;  string contents;    Defines a class called File.   function init(string p, string? c) returns error? {  self.path = p;  self.contents = check c.ensureType(string);  } }    init() method is used to initialize the object  when creating a new object.   public function main() returns error? {    File f = check new File(\"test.txt\", \"Hello World\");  io:println(f.contents); }    new returns the newly constructed File object.   bal run init_return_type.bal Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/integers.html","name":"Integers","summary":"The int type is 64-bit signed integers (same as long in Java) and supports usuall arithmetic operators: + - / %.\n Operator precedenc is same as C. Integer overflow is a runtime error in Ballerina.Integer literals can be hexadecimal (but not octal).You can use compound assignment operations such as += ...","content":"/  /  / Integers  import ballerina/io;  public function main() {  int m = 1;   // Integer literals can be hexadecimal (but not octal).  int n = 0xFFFF;   // You can use compound assignment operations such as `+=` and `-=`. n += m;  io:println(n); }    Integers  The int type is 64-bit signed integers (same as long in Java) and supports usuall arithmetic operators: + - / %.  Operator precedenc is same as C. Integer overflow is a runtime error in Ballerina.    import ballerina/io;    public function main() {  int m = 1;    int n = 0xFFFF;    Integer literals can be hexadecimal (but not octal).   n += m;  io:println(n); }    You can use compound assignment operations such as += and -=.   bal run integers.bal 65536    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/inter-worker-message-passing.html","name":"Inter-Worker Message Passing","summary":"Use -> W or <- W to send a message to or receive a message from worker W (use\n function to refer to the function’s default worker).\n Messages are copied using clone(); implies immutable values are passed\n without copy.\n Message sends and receives are paired up at compile-time.\n Each pair ...","content":"/  /  / Inter-Worker Message Passing  import ballerina/io;  public function main() {   worker A {  // Use `-> W` to send a message to worker `W`.  1 -> B;  2 -> C;   }   worker B {  // Use `<- W` to receive a message from worker `W`.  int x1 = <- A;   // Use `function` to refer to the function's default worker.  x1 -> function;  }   worker C {  int x2 = <- A;  x2 -> function;  }   int y1 = <- B;  int y2 = <- C;  io:println(y1 + y2); }    Inter-Worker Message Passing  Use -> W or <- W to send a message to or receive a message from worker W (use  function to refer to the function’s default worker).  Messages are copied using clone(); implies immutable values are passed  without copy.  Message sends and receives are paired up at compile-time.  Each pair turns into horizontal line in the sequence diagram.  Easy to use and safe, but limited expressiveness.    import ballerina/io;    public function main() {    worker A {    1 -> B;  2 -> C;    Use -> W to send a message to worker W.   }    worker B {    int x1 = <- A;    Use <- W to receive a message from worker W.   x1 -> function;  }    Use function to refer to the function’s default worker.   worker C {  int x2 = <- A;  x2 -> function;  }    int y1 = <- B;  int y2 = <- C;  io:println(y1 + y2); }    bal run inter_worker_message_passing.bal 3    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/inter-worker-failure-propagation.html","name":"Inter-Worker Failure Propagation","summary":"Workers may need to call functions that can return an error.\n Pairing up of sends and receives guarantees that each send will be\n received, and vice-versa, provided neither sending nor receiving worker\n has failed.\n Send to or receive from failed worker will propagate the failure.Workers may need to call functions ...","content":"/  /  / Inter-Worker Failure Propagation  import ballerina/io;  int counter = 0;  function demo() returns int|error {  worker A returns error? {  // Workers may need to call functions that can return an error.  // Pairing up of sends and receives guarantees that each send will be  // received, and vice-versa, provided neither sending nor receiving worker // has failed.  error? res = foo();  if res is error {  return res;  }  42 -> function;  }   // Send to or receive from failed worker will propagate the failure.  int x = check <- A;  return x; }  function foo() returns error? {  if counter == 1 {  return error(\"maximum count exceeded\");  }   counter += 1; }  public function main() returns error? {  int a = check demo();  io:println(a);   int b = check demo();  io:println(b); }    Inter-Worker Failure Propagation  Workers may need to call functions that can return an error.  Pairing up of sends and receives guarantees that each send will be  received, and vice-versa, provided neither sending nor receiving worker  has failed.  Send to or receive from failed worker will propagate the failure.    import ballerina/io;    int counter = 0;    function demo() returns int|error {  worker A returns error? {    error? res = foo();  if res is error {  return res;  }  42 -> function;  }    Workers may need to call functions that can return an error.  Pairing up of sends and receives guarantees that each send will be  received, and vice-versa, provided neither sending nor receiving worker  has failed.   int x = check <- A;  return x; }    Send to or receive from failed worker will propagate the failure.   function foo() returns error? {  if counter == 1 {  return error(\"maximum count exceeded\");  }    counter += 1; }    public function main() returns error? {  int a = check demo();  io:println(a);    int b = check demo();  io:println(b); }    bal run inter_worker_failure_propagation.bal 42 error: maximum count exceeded {}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/io-bytes.html","name":"Read/Write Bytes","summary":"This example demonstrates how bytes can be read and written through the I/O APIs.\n For more information on the underlying module,\n see the .Initializes the image paths.Reads the file content as a byte array using the given file path.Writes the already-read content to the given destination file.Reads the file as ...","content":"/  /  / Read/Write Bytes  import ballerina/io;  public function main() returns error? {  // Initializes the image paths.  string imagePath = \"./files/ballerina.jpg\";  string imageCopyPath1 = \"./files/ballerinaCopy1.jpg\";  string imageCopyPath2 = \"./files/ballerinaCopy2.jpg\";   // Reads the file content as a byte array using the given file path.  byte[] bytes = check io:fileReadBytes(imagePath);  // Writes the already-read content to the given destination file.  check io:fileWriteBytes(imageCopyPath1, bytes);  io:println(\"Successfully copied the image as a byte array.\");   // Reads the file as a stream of blocks. The default block size is 4KB.  // Here, the default size is overridden by the value 2KB.  stream<io:Block, io:Error?> blockStream = check  io:fileReadBlocksAsStream(imagePath, 2048);  // If the file reading was successful, then,  // the content will be written to the given destination file using the given stream.  check io:fileWriteBlocksFromStream(imageCopyPath2, blockStream);  io:println(\"Successfully copied the image as a stream.\"); }    Read/Write Bytes  This example demonstrates how bytes can be read and written through the I/O APIs.  For more information on the underlying module,  see the .    import ballerina/io;    public function main() returns error? {    string imagePath = \"./files/ballerina.jpg\";  string imageCopyPath1 = \"./files/ballerinaCopy1.jpg\";  string imageCopyPath2 = \"./files/ballerinaCopy2.jpg\";    Initializes the image paths.   byte[] bytes = check io:fileReadBytes(imagePath);    Reads the file content as a byte array using the given file path.   check io:fileWriteBytes(imageCopyPath1, bytes);  io:println(\"Successfully copied the image as a byte array.\");    Writes the already-read content to the given destination file.   stream<io:Block, io:Error?> blockStream = check  io:fileReadBlocksAsStream(imagePath, 2048);    Reads the file as a stream of blocks. The default block size is 4KB.  Here, the default size is overridden by the value 2KB.   check io:fileWriteBlocksFromStream(imageCopyPath2, blockStream);  io:println(\"Successfully copied the image as a stream.\"); }    If the file reading was successful, then,  the content will be written to the given destination file using the given stream.   # In the directory, which contains the `.bal` file, create a directory named `files`, # and add an image file named `ballerina.jpg` in it as follows. # tree . # ├── files # │ └── ballerina.jpeg # └── io_bytes.bal bal run io_bytes.bal # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below.    Successfully copied the image as a byte array. Successfully copied the image as a stream.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/io-csv.html","name":"Read/Write CSV","summary":"This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O API.\n For more information on the underlying module,\n see the .Initializes the CSV file path and content.Writes the given content string[][] to a CSV file.If the write operation was successful, then, performs a ...","content":"/  /  / Read/Write CSV  import ballerina/io;  public function main() returns error? {  // Initializes the CSV file path and content.  string csvFilePath1 = \"./files/csvFile1.csv\";  string csvFilePath2 = \"./files/csvFile2.csv\";  string[][] csvContent = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];   // Writes the given content string[][] to a CSV file.  check io:fileWriteCsv(csvFilePath1, csvContent);  // If the write operation was successful, then, performs a read operation to read the CSV content as a string array of arrays.  string[][] readCsv = check io:fileReadCsv(csvFilePath1);  io:println(readCsv);   // Writes the given content stream to a CSV file.  check io:fileWriteCsvFromStream(csvFilePath2, csvContent.toStream());  // If the write operation was successful, then, perform a read operation to read the CSV content as a stream.  stream<string[], io:Error?> csvStream = check  io:fileReadCsvAsStream(csvFilePath2);  // Iterates through the stream and prints the content.  error? e = csvStream.forEach(function(string[] val) {  io:println(val);  }); }    Read/Write CSV  This sample demonstrates how to read/write from/to a CSV file using the CSV channel of the I/O API.  For more information on the underlying module,  see the .    import ballerina/io;    public function main() returns error? {    string csvFilePath1 = \"./files/csvFile1.csv\";  string csvFilePath2 = \"./files/csvFile2.csv\";  string[][] csvContent = [[\"1\", \"James\", \"10000\"], [\"2\", \"Nathan\", \"150000\"],  [\"3\", \"Ronald\", \"120000\"], [\"4\", \"Roy\", \"6000\"],  [\"5\", \"Oliver\", \"1100000\"]];    Initializes the CSV file path and content.   check io:fileWriteCsv(csvFilePath1, csvContent);    Writes the given content string[][] to a CSV file.   string[][] readCsv = check io:fileReadCsv(csvFilePath1);  io:println(readCsv);    If the write operation was successful, then, performs a read operation to read the CSV content as a string array of arrays.   check io:fileWriteCsvFromStream(csvFilePath2, csvContent.toStream());    Writes the given content stream to a CSV file.   stream<string[], io:Error?> csvStream = check  io:fileReadCsvAsStream(csvFilePath2);    If the write operation was successful, then, perform a read operation to read the CSV content as a stream.   error? e = csvStream.forEach(function(string[] val) {  io:println(val);  }); }    Iterates through the stream and prints the content.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run io_csv.bal    [[\"1\",\"James\",\"10000\"],[\"2\",\"Nathan\",\"150000\"],[\"3\",\"Ronald\",\"120000\"],[\"4\",\"Roy\",\"6000\"],[\"5\",\"Oliver\",\"1100000\"]] [\"1\",\"James\",\"10000\"] [\"2\",\"Nathan\",\"150000\"] [\"3\",\"Ronald\",\"120000\"] [\"4\",\"Roy\",\"6000\"] [\"5\",\"Oliver\",\"1100000\"]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/io-json.html","name":"Read/Write JSON","summary":"This sample demonstrates how to read JSON content from a file and write JSON content\n to a file using the character channel, readJson(), and writeJson() of the I/O API.\n For more information on the underlying module,\n see the .Initializes the JSON file path and content.Writes the given JSON to a ...","content":"/  /  / Read/Write JSON  import ballerina/io;  public function main() returns error? {  // Initializes the JSON file path and content.  string jsonFilePath = \"./files/jsonFile.json\";  json jsonContent = {\"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }};   // Writes the given JSON to a file.  check io:fileWriteJson(jsonFilePath, jsonContent);  // If the write operation was successful, then, performs a read operation to read the JSON content.  json readJson = check io:fileReadJson(jsonFilePath);  io:println(readJson); }    Read/Write JSON  This sample demonstrates how to read JSON content from a file and write JSON content  to a file using the character channel, readJson(), and writeJson() of the I/O API.  For more information on the underlying module,  see the .    import ballerina/io;    public function main() returns error? {    string jsonFilePath = \"./files/jsonFile.json\";  json jsonContent = {\"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }};    Initializes the JSON file path and content.   check io:fileWriteJson(jsonFilePath, jsonContent);    Writes the given JSON to a file.   json readJson = check io:fileReadJson(jsonFilePath);  io:println(readJson); }    If the write operation was successful, then, performs a read operation to read the JSON content.   # In the directory, which contains the `.bal` file, create a directory named `files`. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run io_json.bal    {\"Store\":{\"@id\":\"AST\",\"name\":\"Anne\",\"address\":{\"street\":\"Main\",\"city\":\"94\"},\"codes\":[\"4\",\"8\"]}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/io-xml.html","name":"Read/Write XML","summary":"This example demonstrates how XML content can be read from a file and written\n to a file using a character channel and the readXml() and writeXml() functions of the I/O API.\n For more information on the underlying module,\n see the .Initializes the XML file path and content.Writes the given XML ...","content":"/  /  / Read/Write XML  import ballerina/io;  public function main() returns error? {  // Initializes the XML file path and content.  string xmlFilePath = \"./files/xmlFile.xml\";  xml xmlContent = xml `<book>The Lost World</book>`;   // Writes the given XML to a file.  check io:fileWriteXml(xmlFilePath, xmlContent);  // If the write operation was successful, then, performs a read operation to read the XML content.  xml readXml = check io:fileReadXml(xmlFilePath);  io:println(readXml); }    Read/Write XML  This example demonstrates how XML content can be read from a file and written  to a file using a character channel and the readXml() and writeXml() functions of the I/O API.  For more information on the underlying module,  see the .    import ballerina/io;    public function main() returns error? {    string xmlFilePath = \"./files/xmlFile.xml\";  xml xmlContent = xml `<book>The Lost World</book>`;    Initializes the XML file path and content.   check io:fileWriteXml(xmlFilePath, xmlContent);    Writes the given XML to a file.   xml readXml = check io:fileReadXml(xmlFilePath);  io:println(readXml); }    If the write operation was successful, then, performs a read operation to read the XML content.   # In the directory, which contains the `.bal` file, create a directory named `files`. # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run io_xml.bal    <book>The Lost World</book>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/io-strings.html","name":"Read/Write Strings","summary":"This demonstrates how string could be read and written through I/O APIs.\n For more information on the underlying module,\n see the .Initializes the text path and the content.Writes the given string to a file.If the write operation was successful, then, reads the content as a string.Writes the given array of ...","content":"/  /  / Read/Write Strings  import ballerina/io;  public function main() returns error? {  // Initializes the text path and the content.  string textFilePath1 = \"./files/textfile1.txt\";  string textFilePath2 = \"./files/textfile2.txt\";  string textFilePath3 = \"./files/textfile3.txt\";  string textContent = \"Ballerina is an open source programming language.\";  string[] lines = [\"The Big Bang Theory\", \"F.R.I.E.N.D.S\",  \"Game of Thrones\", \"LOST\"];   // Writes the given string to a file.  check io:fileWriteString(textFilePath1, textContent);  // If the write operation was successful, then, reads the content as a string.  string readContent = check io:fileReadString(textFilePath1);  io:println(readContent);   // Writes the given array of lines to a file.  check io:fileWriteLines(textFilePath2, lines);  // If the write operation was successful, then, performs a read operation to read the lines as an array.  string[] readLines = check io:fileReadLines(textFilePath2);  io:println(readLines);   // Writes the given stream of lines to a file.  check io:fileWriteLinesFromStream(textFilePath3, lines.toStream());  // If the write operation was successful, then, performs a read operation to read the lines as a stream.  stream<string, io:Error?> lineStream = check  io:fileReadLinesAsStream(textFilePath3);  // Iterates through the stream and prints the content.  error? e = lineStream.forEach(function(string val) {  io:println(val);  }); }    Read/Write Strings  This demonstrates how string could be read and written through I/O APIs.  For more information on the underlying module,  see the .    import ballerina/io;    public function main() returns error? {    string textFilePath1 = \"./files/textfile1.txt\";  string textFilePath2 = \"./files/textfile2.txt\";  string textFilePath3 = \"./files/textfile3.txt\";  string textContent = \"Ballerina is an open source programming language.\";  string[] lines = [\"The Big Bang Theory\", \"F.R.I.E.N.D.S\",  \"Game of Thrones\", \"LOST\"];    Initializes the text path and the content.   check io:fileWriteString(textFilePath1, textContent);    Writes the given string to a file.   string readContent = check io:fileReadString(textFilePath1);  io:println(readContent);    If the write operation was successful, then, reads the content as a string.   check io:fileWriteLines(textFilePath2, lines);    Writes the given array of lines to a file.   string[] readLines = check io:fileReadLines(textFilePath2);  io:println(readLines);    If the write operation was successful, then, performs a read operation to read the lines as an array.   check io:fileWriteLinesFromStream(textFilePath3, lines.toStream());    Writes the given stream of lines to a file.   stream<string, io:Error?> lineStream = check  io:fileReadLinesAsStream(textFilePath3);    If the write operation was successful, then, performs a read operation to read the lines as a stream.   error? e = lineStream.forEach(function(string val) {  io:println(val);  }); }    Iterates through the stream and prints the content.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run io_strings.bal    Ballerina is an open source programming language. [\"The Big Bang Theory\",\"F.R.I.E.N.D.S\",\"Game of Thrones\",\"LOST\"] The Big Bang Theory F.R.I.E.N.D.S Game of Thrones LOST    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/isolated-functions.html","name":"Isolated Functions","summary":"Informal concept: a call to an isolated function is concurrency-safe if it is called with arguments\n that are safe at least until the call returns. \n A function defined as isolated: \n - has access to mutable state only through its parameters. \n - has unrestricted access to immutable state. ...","content":"/  /  / Isolated Functions  import ballerina/io;  type R record {  int v; };  final int N = getN();  function getN() returns int {  return 100; }  // Can access mutable state that is passed as a parameter. isolated function set(R r) returns R {  // Can access non-`isolated` module-level state only if the variable  // is `final` and the type is a subtype of `readonly` or  // `isolated object {}`.  r.v = N;  return r; }  R r = {v: 0};  // This is not `isolated`. function setGlobal(int n) {  r.v = n; }  // The initialization expression of an `isolated` variable // has to be an isolated expression, which itself will be // an isolated root. isolated R r2 = {v: 0};  isolated function setGlobalIsolated(int n) {  // An `isolated` variable can be accessed within  // a `lock` statement.  lock {  r2.v = n;  } }  public function main() {  setGlobal(200);  io:println(r);   setGlobalIsolated(200);  // Accesses the `isolated` variable within a  // `lock` statement.  lock {  io:println(r2);  }   io:println(set(r)); }    Isolated Functions  Informal concept: a call to an isolated function is concurrency-safe if it is called with arguments  that are safe at least until the call returns. A function defined as isolated: - has access to mutable state only through its parameters. - has unrestricted access to immutable state. - can only call functions that are isolated. Constraints are enforced at compile-time. isolated is a part of the function type.  Weaker concept than pure function. Combining isolated functions and lock allows isolated functions to use  lock to access mutable module-level state. Key concept is isolated root. A value r is an isolated root if mutable state reachable  from r cannot be reached from outside except through r. An expression is an  isolated expression if it follows rules that guarantee that its value will be an  isolated root. e.g., - an expression with a type that is a subtype of readonly is always isolated. - an expression [E1, E2] is isolated if E1 and E2 are isolated. - an expression f(E1, E2) is isolated if E1 and E1 are isolated, and  the type of f is an isolated function.    import ballerina/io;    type R record {  int v; };    final int N = getN();    function getN() returns int {  return 100; }    isolated function set(R r) returns R {    Can access mutable state that is passed as a parameter.   r.v = N;  return r; }    Can access non-isolated module-level state only if the variable  is final and the type is a subtype of readonly or  isolated object {}.   R r = {v: 0};    function setGlobal(int n) {  r.v = n; }    This is not isolated.   isolated R r2 = {v: 0};    The initialization expression of an isolated variable  has to be an isolated expression, which itself will be  an isolated root.   isolated function setGlobalIsolated(int n) {    lock {  r2.v = n;  } }    An isolated variable can be accessed within  a lock statement.   public function main() {  setGlobal(200);  io:println(r);    setGlobalIsolated(200);    lock {  io:println(r2);  }    Accesses the isolated variable within a  lock statement.   io:println(set(r)); }    bal run isolated_functions.bal {\"v\":200} {\"v\":200} {\"v\":100}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/isolated-methods.html","name":"Isolated Methods","summary":"Object methods can be isolated. An isolated method is same as an isolated function with\n self treated as a parameter. An isolated method call is concurrency-safe if both the object\n is safe and the arguments are safe. This is not quite enough for service concurrency: when\n a Listener makes calls ...","content":"/  /  / Isolated Methods  import ballerina/io;  class EvenNumber {  int i = 1;   // `isolated` method.  isolated function generate() returns int {  lock {  // Uses `self` to access mutable field `i`  // within a `lock` statement.  return self.i * 2;  }  } }  public function main() {  EvenNumber e = new;  int c = e.generate();  io:println(c); }    Isolated Methods  Object methods can be isolated. An isolated method is same as an isolated function with  self treated as a parameter. An isolated method call is concurrency-safe if both the object  is safe and the arguments are safe. This is not quite enough for service concurrency: when  a Listener makes calls to a remote or resource method, - it can ensure the safety of arguments it passes. - it has no way to ensure the safety of the object itself (since the object may have fields).    import ballerina/io;    class EvenNumber {  int i = 1;    isolated function generate() returns int {  lock {    isolated method.   return self.i * 2;  }  } }    Uses self to access mutable field i  within a lock statement.   public function main() {  EvenNumber e = new;  int c = e.generate();  io:println(c); }    bal run isolated_methods.bal 2    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/isolated-objects.html","name":"Isolated Objects","summary":"An object defined as isolated is similar to a module with isolated module-level variables.\n Mutable fields of an isolated object \n - must be private and so can only be accessed using self. \n - must be initialized with an isolated expression. \n - must only be accessed within a ...","content":"/  /  / Isolated Objects  import ballerina/io;  // An `isolated` object’s mutable state is `isolated` from the // rest of the program. isolated class Counter {  // `n` is a mutable field.  private int n = 0;   isolated function get() returns int {  lock {  // `n` can only be accessed using `self`.  return self.n;  }  }   isolated function inc() {  lock {  self.n += 1;  }  } }  public function main() {  // The object’s mutable state is accessible only via the  // object itself making it an “isolated root”.  Counter c = new;  c.inc();  int v = c.get();  io:println(v); }    Isolated Objects  An object defined as isolated is similar to a module with isolated module-level variables.  Mutable fields of an isolated object - must be private and so can only be accessed using self. - must be initialized with an isolated expression. - must only be accessed within a lock statement. - lock statement must follow the same rules for self as for an isolated variable. - field is mutable unless it is final and has type that is subtype of readonly. Isolated root concept treats isolated objects as opaque. Isolated functions can access a final  variable whose type is an isolated object.    import ballerina/io;    isolated class Counter {    An isolated object’s mutable state is isolated from the  rest of the program.   private int n = 0;    n is a mutable field.   isolated function get() returns int {  lock {    return self.n;  }  }    n can only be accessed using self.   isolated function inc() {  lock {  self.n += 1;  }  } }    public function main() {    Counter c = new;  c.inc();  int v = c.get();  io:println(v); }    The object’s mutable state is accessible only via the  object itself making it an “isolated root”.   bal run isolated_objects.bal 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/isolated-variables.html","name":"Isolated Variables","summary":"When a variable is declared as isolated, compiler guarantees that it is an isolated root and\n accessed only within a lock statement. An isolated variable declaration must be at module-level,\n not public, and initialized with an isolated expression. A lock statement that accesses an\n isolated variable must maintain isolated root ...","content":"/  /  / Isolated Variables  import ballerina/io;  // Initializes an `isolated` variable using // an `isolated` expression. isolated int[] stack = [];  isolated function push(int n) {  // Accesses `isolated` variable within a  // `lock` statement.  lock {  stack.push(n);  } }  isolated function pop() returns int {  lock {  return stack.pop();  } }  public function main() {  push(10);  push(20);  io:println(pop()); }    Isolated Variables  When a variable is declared as isolated, compiler guarantees that it is an isolated root and  accessed only within a lock statement. An isolated variable declaration must be at module-level,  not public, and initialized with an isolated expression. A lock statement that accesses an  isolated variable must maintain isolated root invariant: - access only one isolated variable. - call only isolated functions. - transfers of values in and out must use isolated expressions. The isolated functions are allowed to access isolated module-level variables,  provided they follow the above rules.    import ballerina/io;    isolated int[] stack = [];    Initializes an isolated variable using  an isolated expression.   isolated function push(int n) {    lock {  stack.push(n);  } }    Accesses isolated variable within a  lock statement.   isolated function pop() returns int {  lock {  return stack.pop();  } }    public function main() {  push(10);  push(20);  io:println(pop()); }    bal run isolated_variables.bal 20    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/jdbc-atomic-batch-execute-operation.html","name":"Atomic Batch Execute","summary":"This example demonstrates how to use the JDBC client to execute a batch of\n DDL/DML operations with the help of a transaction to achieve the atomic behaviour.\n Note that the relevant database driver JAR should be defined in the Ballerina.toml\n file as a dependency.\n This sample is based on an ...","content":"/  /  / Atomic Batch Execute  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;  public function main() returns error? {  // Initializes the JDBC client.  jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");  // Runs the prerequisite setup for the example.  check beforeExample(jdbcClient);   // Records with the duplicate `registrationID` entry. Here it is registrationID = 1.  var insertRecords = [  {firstName: \"Linda\", lastName: \"Jones\", registrationID: 2,  creditLimit: 10000.75, country: \"USA\"},  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Camellia\", lastName: \"Potter\", registrationID: 4,  creditLimit: 2000.25, country: \"USA\"}  ];   // Creates a batch parameterized query.  sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;   // The transaction block can be used to roll back if any error occurred.  transaction {  var result = jdbcClient -> batchExecute(insertQueries);  if result is sql:BatchExecuteError {  io:println(result.message());  io:println(result.detail()?.executionResults);  io:println(\"Rollback transaction.\\n\");  rollback;  } else {  error? err = commit;  if err is error {  io:println(\"Error occurred while committing: \", err);  }  }  }   // Checks the data after the batch execution.  stream<record{}, error> resultStream =  jdbcClient -> query(\"SELECT * FROM Customers\");   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });   // Performs the cleanup after the example.  check afterExample(jdbcClient); }  // Initializes the database as a prerequisite to the example. function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {  // Creates a table in the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER UNIQUE, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);   // Adds records to the newly-created table.  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`); }  // Cleans up the database after running the example. function afterExample(jdbc:Client jdbcClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);  // Closes the JDBC client.  check jdbcClient.close(); }    Atomic Batch Execute  This example demonstrates how to use the JDBC client to execute a batch of  DDL/DML operations with the help of a transaction to achieve the atomic behaviour.  Note that the relevant database driver JAR should be defined in the Ballerina.toml  file as a dependency.  This sample is based on an H2 database and the H2 database driver JAR need to be added to Ballerina.toml file.  For a sample configuration and more information on the underlying module, see the import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;    public function main() returns error? {    jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");    Initializes the JDBC client.   check beforeExample(jdbcClient);    Runs the prerequisite setup for the example.   var insertRecords = [  {firstName: \"Linda\", lastName: \"Jones\", registrationID: 2,  creditLimit: 10000.75, country: \"USA\"},  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Camellia\", lastName: \"Potter\", registrationID: 4,  creditLimit: 2000.25, country: \"USA\"}  ];    Records with the duplicate registrationID entry. Here it is registrationID = 1.   sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;    Creates a batch parameterized query.   transaction {  var result = jdbcClient -> batchExecute(insertQueries);  if result is sql:BatchExecuteError {  io:println(result.message());  io:println(result.detail()?.executionResults);  io:println(\"Rollback transaction.\\n\");  rollback;  } else {  error? err = commit;  if err is error {  io:println(\"Error occurred while committing: \", err);  }  }  }    The transaction block can be used to roll back if any error occurred.   stream<record{}, error> resultStream =  jdbcClient -> query(\"SELECT * FROM Customers\");    Checks the data after the batch execution.   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });    check afterExample(jdbcClient); }    Performs the cleanup after the example.   function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER UNIQUE, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`); }    Adds records to the newly-created table.   function afterExample(jdbc:Client jdbcClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);    Cleans the database.   check jdbcClient.close(); }    Closes the JDBC client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    [ballerina/http] started HTTP/WS listener 172.18.0.1:46043 Error while executing batch command starting with: 'INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES ( ? , ? ,  ? , ? , ? )'.Unique index or primary key violation: \"PUBLIC.CONSTRAINT_INDEX_6 ON PUBLIC.CUSTOMERS(REGISTRATIONID) VALUES 1\"; SQL statement: INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES ( ? , ? ,  ? , ? , ? ) [23505-199]. [{\"affectedRowCount\":1,\"lastInsertId\":null},{\"affectedRowCount\":-3,\"lastInsertId\":null},{\"affectedRowCount\":1,\"lastInsertId\":null}] Rollback transaction.    Data in Customers table: {\"CUSTOMERID\":1,\"FIRSTNAME\":\"Peter\",\"LASTNAME\":\"Stuart\",\"REGISTRATIONID\":1,\"CREDITLIMIT\":5000.75,\"COUNTRY\":\"USA\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/jdbc-batch-execute-operation.html","name":"Batch Execute","summary":"This example demonstrates how to use the JDBC client to execute a batch of\n DDL/DML operations. Note that the relevant database driver JAR\n should be defined in the Ballerina.toml file as a dependency.\n This sample is based on an H2 database and the H2 database driver JAR need to be ...","content":"/  /  / Batch Execute  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;  public function main() returns error? {  // Initializes the JDBC client.  jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");  // Runs the prerequisite setup for the example.  check beforeExample(jdbcClient);   // The records to be inserted.  var insertRecords = [  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2,  creditLimit: 8000.00, country: \"USA\"},  {firstName: \"Bill\", lastName: \"John\", registrationID: 3,  creditLimit: 3000.25, country: \"USA\"}  ];   // Creates a batch parameterized query.  sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;  // Inserts the records with the auto-generated ID.  sql:ExecutionResult[] result = check jdbcClient -> batchExecute(insertQueries);   int[] generatedIds = [];  foreach var summary in result {  generatedIds.push(<int> summary.lastInsertId);  }  io:println(\"\\nInsert success, generated IDs are: \", generatedIds, \"\\n\");   // Checks the data after the batch execution.  stream<record{}, error> resultStream =  jdbcClient -> query(\"SELECT * FROM Customers\");   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });   // Performs the cleanup after the example.  check afterExample(jdbcClient); }  // Initializes the database as a prerequisite to the example. function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {  // Creates a table in the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`); }  // Cleans up the database after running the example. function afterExample(jdbc:Client jdbcClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);  // Closes the JDBC client.  check jdbcClient.close(); }    Batch Execute  This example demonstrates how to use the JDBC client to execute a batch of  DDL/DML operations. Note that the relevant database driver JAR  should be defined in the Ballerina.toml file as a dependency.  This sample is based on an H2 database and the H2 database driver JAR need to be added to the Ballerina.toml file.  For a sample configuration and more information on the underlying module, see the .    import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;    public function main() returns error? {    jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");    Initializes the JDBC client.   check beforeExample(jdbcClient);    Runs the prerequisite setup for the example.   var insertRecords = [  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2,  creditLimit: 8000.00, country: \"USA\"},  {firstName: \"Bill\", lastName: \"John\", registrationID: 3,  creditLimit: 3000.25, country: \"USA\"}  ];    The records to be inserted.   sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;  Creates a batch parameterized query.   sql:ExecutionResult[] result = check jdbcClient -> batchExecute(insertQueries);    Inserts the records with the auto-generated ID.   int[] generatedIds = [];  foreach var summary in result {  generatedIds.push(<int> summary.lastInsertId);  }  io:println(\"\\nInsert success, generated IDs are: \", generatedIds, \"\\n\");    stream<record{}, error> resultStream =  jdbcClient -> query(\"SELECT * FROM Customers\");    Checks the data after the batch execution.   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });    check afterExample(jdbcClient); }    Performs the cleanup after the example.   function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`); }    Creates a table in the database.   function afterExample(jdbc:Client jdbcClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);    Cleans the database.   check jdbcClient.close(); }    Closes the JDBC client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Insert success, generated IDs are: [1,2,3]    Data in Customers table: {\"CUSTOMERID\":1,\"FIRSTNAME\":\"Peter\",\"LASTNAME\":\"Stuart\",\"REGISTRATIONID\":1,\"CREDITLIMIT\":5000.75,\"COUNTRY\":\"USA\"} {\"CUSTOMERID\":2,\"FIRSTNAME\":\"Stephanie\",\"LASTNAME\":\"Mike\",\"REGISTRATIONID\":2,\"CREDITLIMIT\":8000.0,\"COUNTRY\":\"USA\"} {\"CUSTOMERID\":3,\"FIRSTNAME\":\"Bill\",\"LASTNAME\":\"John\",\"REGISTRATIONID\":3,\"CREDITLIMIT\":3000.25,\"COUNTRY\":\"USA\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/jdbc-execute-operation.html","name":"DML and DDL Operation","summary":"This example demonstrates how to use the JDBC client with DDL and\n DML operations. Note that the relevant database driver JAR\n should be defined in the Ballerina.toml file as a dependency.\n This sample is based on an H2 database and the H2 database driver JAR need to be added to ...","content":"/  /  / DML and DDL Operation  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;  public function main() returns error? {  // Initializes the JDBC client.  jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");  // Runs the prerequisite setup for the example.  check beforeExample(jdbcClient);   float newCreditLimit = 15000.5;   // Creates a parameterized query for the record update.  sql:ParameterizedQuery updateQuery = `UPDATE Customers SET creditLimit = ${newCreditLimit} where customerId = 1`;   sql:ExecutionResult result = check jdbcClient -> execute(updateQuery);  io:println(\"Updated Row count: \", result?.affectedRowCount);   string firstName = \"Dan\";   // Creates a parameterized query for deleting the records.  sql:ParameterizedQuery deleteQuery =  `DELETE FROM Customers WHERE firstName = ${firstName}`;  result = check jdbcClient -> execute(deleteQuery);  io:println(\"Deleted Row count: \", result.affectedRowCount);   // Performs the cleanup after the example.  check afterExample(jdbcClient); }  // Initializes the database as a prerequisite to the example. function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {  //Creates a table in the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);   // Inserts data into the table. The result will have the `affectedRowCount`  // and `lastInsertedId` with the auto-generated ID of the last row.  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);   io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId); }  // Cleans up the database after running the example. function afterExample(jdbc:Client jdbcClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);  // Closes the JDBC client.  check jdbcClient.close(); }    DML and DDL Operation  This example demonstrates how to use the JDBC client with DDL and  DML operations. Note that the relevant database driver JAR  should be defined in the Ballerina.toml file as a dependency.  This sample is based on an H2 database and the H2 database driver JAR need to be added to Ballerina.toml file.  For a sample configuration and more information on the underlying module, see the .    import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;    public function main() returns error? {    jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");    Initializes the JDBC client.   check beforeExample(jdbcClient);    Runs the prerequisite setup for the example.   float newCreditLimit = 15000.5;    sql:ParameterizedQuery updateQuery = `UPDATE Customers SET creditLimit = ${newCreditLimit} where customerId = 1`;    Creates a parameterized query for the record update.   sql:ExecutionResult result = check jdbcClient -> execute(updateQuery);  io:println(\"Updated Row count: \", result?.affectedRowCount);    string firstName = \"Dan\";    sql:ParameterizedQuery deleteQuery =  `DELETE FROM Customers WHERE firstName = ${firstName}`;  result = check jdbcClient -> execute(deleteQuery);  io:println(\"Deleted Row count: \", result.affectedRowCount);    Creates a parameterized query for deleting the records.   check afterExample(jdbcClient); }    Performs the cleanup after the example.   function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);    Inserts data into the table. The result will have the affectedRowCount  and lastInsertedId with the auto-generated ID of the last row.   io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId); }    function afterExample(jdbc:Client jdbcClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);    Cleans the database.   check jdbcClient.close(); }    Closes the JDBC client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Rows affected: 1 Generated Customer ID: 2 Updated Row count: 1 Deleted Row count: 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/join-clause.html","name":"Join Clause","summary":"Query can take advantage of table keys by using a join clause. Performs an inner equijoin.\n The result is similar to using nested from clause and where clause. It is implemented as\n a hash join: table keys allow you to avoid building a hash table. The type to join on ...","content":"/  /  / Join Clause  import ballerina/io;  type User record {|  readonly int id;  string name; |};  type Login record {|  int userId;  string time; |};  public function main() {  table<User> key(id) users = table [  {id: 1234, name: \"Keith\"},  {id: 6789, name: \"Anne\"}  ];   Login[] logins = [  {userId: 6789, time: \"20:10:23\"},  {userId: 1234, time: \"10:30:02\"},  {userId: 3987, time: \"12:05:00\"}  ];   string[] loginLog = from var login in logins  // The `join` clause iterates any iterable value similarly to the  // `from` clause.  join var user in users  // The `on` condition is used to match the `login` with the `user`  // based on the `userId`. The iteration is skipped when the  // condition is not satisfied.  on login.userId equals user.id  select user.name + \":\" + login.time;  io:println(loginLog); }    Join Clause  Query can take advantage of table keys by using a join clause. Performs an inner equijoin.  The result is similar to using nested from clause and where clause. It is implemented as  a hash join: table keys allow you to avoid building a hash table. The type to join on must be anydata.    import ballerina/io;    type User record {|  readonly int id;  string name; |};    type Login record {|  int userId;  string time; |};    public function main() {  table<User> key(id) users = table [  {id: 1234, name: \"Keith\"},  {id: 6789, name: \"Anne\"}  ];    Login[] logins = [  {userId: 6789, time: \"20:10:23\"},  {userId: 1234, time: \"10:30:02\"},  {userId: 3987, time: \"12:05:00\"}  ];    string[] loginLog = from var login in logins    join var user in users    The join clause iterates any iterable value similarly to the  from clause.   on login.userId equals user.id  select user.name + \":\" + login.time;  io:println(loginLog); }    The on condition is used to match the login with the user  based on the userId. The iteration is skipped when the  condition is not satisfied.   bal run join_clause.bal [\"Anne:20:10:23\",\"Keith:10:30:02\"]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/json-numbers.html","name":"JSON Numbers","summary":"Ballerina has three numeric types; but JSON has one.\n The json type allows int|float|decimal.\n toJsonString will convert int|float|decimal into JSON numeric syntax.\n fromJsonString converts JSON numeric syntax into int, if possible, and\n otherwise decimal.\n cloneWithType or ensureType will convert from int or decimal into user’s\n chosen numeric type.\n Net result ...","content":"/  /  / JSON Numbers  import ballerina/io;  public function main() returns error? {  int a = 1;  float b = 2.1;  decimal c = 3.24;   // The `json` type allows `int|float|decimal`.  json[] d = [a, b, c];   // `toJsonString` will convert `int|float|decimal` into JSON // numeric syntax.  string e = d.toJsonString();   io:println(e);   // `fromJsonString` converts JSON numeric syntax into `int`, // if possible, and otherwise `decimal`.  json f = check e.fromJsonString();   io:println(f);   json[] g = <json[]> f;   io:println(typeof g[0]);  io:println(typeof g[1]);  io:println(typeof g[2]);   // `cloneWithType` or `ensureType` will convert from `int` or `decimal` into user's  // chosen numeric type.  float h = check g[2].ensureType();  io:println(h);   // `-0` is an edge case: represented as `float`.  string i = \"-0\";  io:println(typeof check i.fromJsonString()); }    JSON Numbers  Ballerina has three numeric types; but JSON has one.  The json type allows int|float|decimal.  toJsonString will convert int|float|decimal into JSON numeric syntax.  fromJsonString converts JSON numeric syntax into int, if possible, and  otherwise decimal.  cloneWithType or ensureType will convert from int or decimal into user’s  chosen numeric type.  Net result is that you can use json to exchange full range of all three Ballerina  numeric types.  -0 is an edge case: represented as float.    import ballerina/io;    public function main() returns error? {  int a = 1;  float b = 2.1;  decimal c = 3.24;    json[] d = [a, b, c];    The json type allows int|float|decimal.   string e = d.toJsonString();    toJsonString will convert int|float|decimal into JSON  numeric syntax.   io:println(e);    json f = check e.fromJsonString();    fromJsonString converts JSON numeric syntax into int,  if possible, and otherwise decimal.   io:println(f);    json[] g = <json[]> f;    io:println(typeof g[0]);  io:println(typeof g[1]);  io:println(typeof g[2]);    float h = check g[2].ensureType();  io:println(h);    cloneWithType or ensureType will convert from int or decimal into user’s  chosen numeric type.   string i = \"-0\";  io:println(typeof check i.fromJsonString()); }    -0 is an edge case: represented as float.   bal run json_numbers.bal [1, 2.1, 3.24] [1,2.1,3.24] typedesc int typedesc decimal typedesc decimal 3.24 typedesc float    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/jdbc-complex-type-queries.html","name":"Query With Complex Types","summary":"This example demonstrates how to use the JDBC client with complex data types\n such as arrays, binary, blobs, clob, and date/time fields. Note that the\n relevant database driver JAR should be defined in the Ballerina.toml file as a dependency.\n This sample is based on an H2 database and the H2 ...","content":"/  /  / Query With Complex Types  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql; import ballerina/time;  type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};  type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};  type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Utc timestamp_type;  string datetime_type; |};  public function main() returns error? {  // Initializes the JDBC client.  jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");  // Runs the prerequisite setup for the example.  check beforeExample(jdbcClient);   // Since the `rowType` is provided as a `BinaryType`, the `resultStream` // will have `BinaryType` records.  stream<record{}, error> resultStream = jdbcClient -> query(`SELECT * FROM BINARY_TYPES`, BinaryType);  stream<BinaryType, sql:Error> binaryResultStream = <stream<BinaryType, sql:Error>> resultStream;   io:println(\"Binary types Result :\");  // Iterates the `binaryResultStream`.  error? e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });   // Since the `rowType` is provided as an `ArrayType`, the `resultStream2` will  // have `ArrayType` records.  stream<record{}, error> resultStream2 = jdbcClient -> query(`SELECT * FROM ARRAY_TYPES`, ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream2;   io:println(\"Array types Result :\");  // Iterates the `arrayResultStream`.  error? e2 = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });   // Since the `rowType` is provided as a `DateTimeType`, the `resultStream3`  // will have `DateTimeType` records. The `Date`, `Time`, `DateTime`, and  // `Timestamp` fields of the database table can be mapped to `time:Utc`,  // string, and int types in Ballerina.  stream<record{}, error> resultStream3 = jdbcClient -> query(`SELECT * FROM DATE_TIME_TYPES`, DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream3;   io:println(\"DateTime types Result :\");  // Iterates the `dateResultStream`.  error? e3 = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });   // Performs the cleanup after the example.  check afterExample(jdbcClient); }  // Initializes the database as a prerequisite to the example. function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {  // Creates complex data type tables in the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE BINARY_TYPES (row_id INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024), binary_type BINARY(27), PRIMARY KEY (row_id))`);  result = check jdbcClient -> execute(`CREATE TABLE ARRAY_TYPES (row_id INTEGER NOT NULL, int_array ARRAY, long_array ARRAY, float_array ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY, PRIMARY KEY (row_id))`);   result = check jdbcClient -> execute(`CREATE TABLE DATE_TIME_TYPES(row_id INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type timestamp, datetime_type datetime, PRIMARY KEY (row_id))`);   // Adds the records to the newly-created tables.  result = check jdbcClient -> execute(`INSERT INTO BINARY_TYPES (row_id, blob_type, clob_type, binary_type) VALUES (1, X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT('very long text', CLOB), X'77736F322062616C6C6572696E612062696E61727920746573742E')`);   result = check jdbcClient -> execute(`INSERT INTO ARRAY_TYPES (row_id, int_array, long_array, float_array, double_array, boolean_array, string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, 300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, 8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))`);   result = check jdbcClient -> execute(`Insert into DATE_TIME_TYPES (row_id, date_type, time_type, timestamp_type, datetime_type) values (1, '2017-05-23', '14:15:23', '2017-01-25 16:33:55', '2017-01-25 16:33:55')`); }  // Cleans up the database after running the example. function afterExample(jdbc:Client jdbcClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE BINARY_TYPES`);  result = check jdbcClient -> execute(`DROP TABLE ARRAY_TYPES`);  result = check jdbcClient -> execute(`DROP TABLE DATE_TIME_TYPES`);  // Closes the JDBC client.  check jdbcClient.close(); }    Query With Complex Types  This example demonstrates how to use the JDBC client with complex data types  such as arrays, binary, blobs, clob, and date/time fields. Note that the  relevant database driver JAR should be defined in the Ballerina.toml file as a dependency.  This sample is based on an H2 database and the H2 database driver JAR need to be added to Ballerina.toml file.  For a sample configuration and more information on the underlying module, see the .    import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql; import ballerina/time;    type BinaryType record {|  int row_id;  byte[] blob_type;  string clob_type;  byte[] binary_type; |};    type ArrayType record {|  int row_id;  int[] int_array;  int[] long_array;  decimal[] float_array;  float[] double_array;  boolean[] boolean_array;  string[] string_array; |};    type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Utc timestamp_type;  string datetime_type; |};    public function main() returns error? {    jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");    Initializes the JDBC client.   check beforeExample(jdbcClient);    Runs the prerequisite setup for the example.   stream<record{}, error> resultStream = jdbcClient -> query(`SELECT * FROM BINARY_TYPES`, BinaryType);  stream<BinaryType, sql:Error> binaryResultStream = <stream<BinaryType, sql:Error>> resultStream;    Since the rowType is provided as a BinaryType, the resultStream  will have BinaryType records.   io:println(\"Binary types Result :\");    error? e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });    Iterates the binaryResultStream.   stream<record{}, error> resultStream2 = jdbcClient -> query(`SELECT * FROM ARRAY_TYPES`, ArrayType);  stream<ArrayType, sql:Error> arrayResultStream =  <stream<ArrayType, sql:Error>>resultStream2;    Since the rowType is provided as an ArrayType, the resultStream2 will  have ArrayType records.   io:println(\"Array types Result :\");    error? e2 = arrayResultStream.forEach(function(ArrayType result) {  io:println(result);  });    Iterates the arrayResultStream.   stream<record{}, error> resultStream3 = jdbcClient -> query(`SELECT * FROM DATE_TIME_TYPES`, DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream3;    Since the rowType is provided as a DateTimeType, the resultStream3  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Utc,  string, and int types in Ballerina.   io:println(\"DateTime types Result :\");    error? e3 = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });    Iterates the dateResultStream.   check afterExample(jdbcClient); }    Performs the cleanup after the example.   function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE BINARY_TYPES (row_id INTEGER NOT NULL, blob_type BLOB(1024), clob_type CLOB(1024), binary_type BINARY(27), PRIMARY KEY (row_id))`);  result = check jdbcClient -> execute(`CREATE TABLE ARRAY_TYPES (row_id INTEGER NOT NULL, int_array ARRAY, long_array ARRAY, float_array ARRAY, double_array ARRAY, boolean_array ARRAY, string_array ARRAY, PRIMARY KEY (row_id))`);    Creates complex data type tables in the database.   result = check jdbcClient -> execute(`CREATE TABLE DATE_TIME_TYPES(row_id INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type timestamp, datetime_type datetime, PRIMARY KEY (row_id))`);    result = check jdbcClient -> execute(`INSERT INTO BINARY_TYPES (row_id, blob_type, clob_type, binary_type) VALUES (1, X'77736F322062616C6C6572696E6120626C6F6220746573742E', CONVERT('very long text', CLOB), X'77736F322062616C6C6572696E612062696E61727920746573742E')`);    Adds the records to the newly-created tables.   result = check jdbcClient -> execute(`INSERT INTO ARRAY_TYPES (row_id, int_array, long_array, float_array, double_array, boolean_array, string_array) VALUES (1, (1, 2, 3), (100000000, 200000000, 300000000), (245.23, 5559.49, 8796.123), (245.23, 5559.49, 8796.123), (TRUE, FALSE, TRUE), ('Hello', 'Ballerina'))`);    result = check jdbcClient -> execute(`Insert into DATE_TIME_TYPES (row_id, date_type, time_type, timestamp_type, datetime_type) values (1, '2017-05-23', '14:15:23', '2017-01-25 16:33:55', '2017-01-25 16:33:55')`); }    function afterExample(jdbc:Client jdbcClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE BINARY_TYPES`);  result = check jdbcClient -> execute(`DROP TABLE ARRAY_TYPES`);  result = check jdbcClient -> execute(`DROP TABLE DATE_TIME_TYPES`);    Cleans the database.   check jdbcClient.close(); }    Closes the JDBC client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Binary types Result : {\"row_id\":1,\"blob_type\":[119,115,111,50,32,98,97,108,108,101,114,105,110,97,32,98,108,111,98,32,116,101,115,116,46],\"clob_type\":\"very long text\",\"binary_type\":[119,115,111,50,32,98,97,108,108,101,114,105,110,97,32,98,105,110,97,114,121,32,116,101,115,116,46]} Array types Result : {\"row_id\":1,\"int_array\":[1,2,3],\"long_array\":[100000000,200000000,300000000],\"float_array\":[245.23,5559.49,8796.123],\"double_array\":[245.23,5559.49,8796.123],\"boolean_array\":[true,false,true],\"string_array\":[\"Hello\",\"Ballerina\"]} DateTime types Result : {\"row_id\":1,\"date_type\":\"2017-05-23\",\"time_type\":31523000,\"timestamp_type\":1485342235 0,\"datetime_type\":\"2017-01-25 16:33:55.0\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/json-type.html","name":"JSON Type","summary":"json type is a union: `()|boolean|int|float|decimal|string|json[]|map<json>. A json value can\n be converted to and from JSON format straightforwardly, except for choice of Ballerina numeric type.\n Ballerina syntax is compatible with JSON and allows null for () for JSON compatibility.\n json is anydata without table and xml. toJson recursively converts anydata ...","content":"/  /  / JSON Type  import ballerina/io; import ballerina/lang.value;  json j = { \"x\": 1, \"y\": 2 };  // Returns the `string` that represents `j` in `JSON` format. string s = j.toJsonString();  // Parses a `string` in `JSON` format and returns the the value that it represents. json j2 = check value:fromJsonString(s);  // Allows `null` for `JSON` compatibility. json j3 = null;  public function main() {  io:println(s);  io:println(j2); }    JSON Type  json type is a union: `()|boolean|int|float|decimal|string|json[]|map<json>. A json value can  be converted to and from JSON format straightforwardly, except for choice of Ballerina numeric type.  Ballerina syntax is compatible with JSON and allows null for () for JSON compatibility.  json is anydata without table and xml. toJson recursively converts anydata to json.  table values are converted to arrays. xml values are converted to strings.json and xml  types are not parallel.    import ballerina/io; import ballerina/lang.value;    json j = { \"x\": 1, \"y\": 2 };    string s = j.toJsonString();    Returns the string that represents j in JSON format.   json j2 = check value:fromJsonString(s);    Parses a string in JSON format and returns the the value that it represents.   json j3 = null;    Allows null for JSON compatibility.   public function main() {  io:println(s);  io:println(j2); }    bal run json_type.bal {\"x\":1, \"y\":2} {\"x\":1,\"y\":2}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/jdbc-query-operation.html","name":"Simple Query","summary":"This example demonstrates how to use the JDBC client select query operations\n with the stream return type. Note that the relevant database driver JAR\n should be defined in the Ballerina.toml file as a dependency.\n This sample is based on an H2 database and the H2 database driver JAR need to ...","content":"/  /  / Simple Query  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;  // Defines a record to load the query result schema as shown below in the // 'getDataWithTypedQuery' function. In this example, all columns of the // customer table will be loaded. Therefore, the `Customer` record will be // created with all the columns. The column name of the result and the // defined field name of the record will be matched case insensitively. type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};  public function main() returns error? {  // Initializes the JDBC client.  jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");  // Runs the prerequisite setup for the example.  check beforeExample(jdbcClient);   // Selects the rows in the database table via the query remote operation.  // The result is returned as a stream and the elements of the stream can  // be either a record or an error. The name and type of the attributes // within the record from the `resultStream` will be automatically // identified based on the column name and type of the query result.  stream<record{}, error> resultStream =  jdbcClient -> query(`SELECT * FROM Customers`);   // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  });   // The result of the count operation is provided as a record stream.  stream<record{}, error> resultStream2 =  jdbcClient -> query(`SELECT COUNT(*) AS total FROM Customers`);   // Since the above count query will return only a single row,  // the `next()` operation is sufficient to retrieve the data.  record {|record {} value;|}|error? result = resultStream2.next();  // Checks the result and retrieves the value for the total.  if result is record {|record {} value;|} {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } // In general cases, the stream will be closed automatically  // when the stream is fully consumed or any error is encountered.  // However, in case if the stream is not fully consumed, the stream  // should be closed specifically.  error? er = resultStream.close();   // The result is returned as a `Customer` record stream and the elements  // of the stream can be either a `Customer` record or an error.  stream<record{}, error> resultStream3 =  jdbcClient->query(`SELECT * FROM Customers`, Customer);   // Casts the generic record type to the `Customer` stream type.  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream3;   // Iterates the customer stream.  e = customerStream.forEach(function(Customer customer) {  io:println(\"Full Customer details: \", customer);  });   // Performs the cleanup after the example.  check afterExample(jdbcClient); }  // Initializes the database as a prerequisite to the example. function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {  // Creates a table in the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);   // Adds records to the newly-created table.  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`); }  // Cleans up the database after running the example. function afterExample(jdbc:Client jdbcClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);  // Closes the JDBC client.  check jdbcClient.close(); }    Simple Query  This example demonstrates how to use the JDBC client select query operations  with the stream return type. Note that the relevant database driver JAR  should be defined in the Ballerina.toml file as a dependency.  This sample is based on an H2 database and the H2 database driver JAR need to be added to Ballerina.toml file.  For a sample configuration and more information on the underlying module, see the .    import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;    type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Defines a record to load the query result schema as shown below in the  ‘getDataWithTypedQuery’ function. In this example, all columns of the  customer table will be loaded. Therefore, the Customer record will be  created with all the columns. The column name of the result and the  defined field name of the record will be matched case insensitively.   public function main() returns error? {    jdbc:Client jdbcClient = check new (\"jdbc:h2:file:./target/bbes/java_jdbc\",  \"rootUser\", \"rootPass\");    Initializes the JDBC client.   check beforeExample(jdbcClient);    Runs the prerequisite setup for the example.   stream<record{}, error> resultStream =  jdbcClient -> query(`SELECT * FROM Customers`);    Selects the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error. The name and type of the attributes  within the record from the resultStream will be automatically  identified based on the column name and type of the query result.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   stream<record{}, error> resultStream2 =  jdbcClient -> query(`SELECT COUNT(*) AS total FROM Customers`);    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream2.next();    Since the above count query will return only a single row,  the next() operation is sufficient to retrieve the data.   if result is record {|record {} value;|} {  io:println(\"Total rows in customer table : \", result.value[\"TOTAL\"]);  } Checks the result and retrieves the value for the total.   error? er = resultStream.close();    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream  should be closed specifically.   stream<record{}, error> resultStream3 =  jdbcClient->query(`SELECT * FROM Customers`, Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream3;    Casts the generic record type to the Customer stream type.   e = customerStream.forEach(function(Customer customer) {  io:println(\"Full Customer details: \", customer);  });    Iterates the customer stream.   check afterExample(jdbcClient); }    Performs the cleanup after the example.   function beforeExample(jdbc:Client jdbcClient) returns sql:Error? {    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`CREATE TABLE Customers(customerId INTEGER  NOT NULL IDENTITY, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check jdbcClient -> execute(`INSERT INTO Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`); }    Adds records to the newly-created table.   function afterExample(jdbc:Client jdbcClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check jdbcClient -> execute(`DROP TABLE Customers`);    Cleans the database.   check jdbcClient.close(); }    Closes the JDBC client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Full Customer details: {\"CUSTOMERID\":1,\"FIRSTNAME\":\"Peter\",\"LASTNAME\":\"Stuart\",\"REGISTRATIONID\":1,\"CREDITLIMIT\":5000.75,\"COUNTRY\":\"USA\"} Full Customer details: {\"CUSTOMERID\":2,\"FIRSTNAME\":\"Dan\",\"LASTNAME\":\"Brown\",\"REGISTRATIONID\":2,\"CREDITLIMIT\":10000.0,\"COUNTRY\":\"UK\"} Total rows in customer table : 2 Full Customer details: {\"customerId\":1,\"firstName\":\"Peter\",\"lastName\":\"Stuart\",\"registrationId\":1,\"creditLimit\":5000.75,\"country\":\"USA\"} Full Customer details: {\"customerId\":2,\"firstName\":\"Dan\",\"lastName\":\"Brown\",\"registrationId\":2,\"creditLimit\":10000.0,\"country\":\"UK\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-authentication-sasl-plain-producer.html","name":"SASL Authentication - Producer","summary":"This is an example of a Kafka producer using the SASL/PLAIN authentication.\n For this example to work properly, an active Kafka server must be present\n and it should be configured to use the SASL/PLAIN authentication mechanism.\n \n For more information on the underlying module,\n see the .The kafka:AuthenticationConfiguration is used ...","content":"/  /  / SASL Authentication - Producer  import ballerina/io; import ballerinax/kafka;  // The `kafka:AuthenticationConfiguration` is used to provide authentication-related details. kafka:AuthenticationConfiguration authConfig = {  // Provide the authentication mechanism used by the Kafka server.  mechanism: kafka:AUTH_SASL_PLAIN,  // Username and password should be set here in order to authenticate the producer.  // For information on how to secure values instead of directly using plain text values, see [Writing Secure Ballerina Code](https://ballerina.io/learn/user-guide/security/writing-secure-ballerina-code/#securing-sensitive-data-using-configurable-variables).  username: \"ballerina\",  password: \"ballerina-secret\" };  kafka:ProducerConfiguration producerConfigs = {  // Provide the relevant authentication configuration record to authenticate the producer.  auth: authConfig };  kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL, producerConfigs);  public function main() {  string message = \"Hello from Ballerina\";  kafka:Error? err = kafkaProducer->send({  topic: \"topic-sasl\",  value: message.toBytes()  });  // Checks for an error and notifies if an error has occurred.  if err is kafka:Error {  io:println(\"Error occurred when sending message \", 'error = err);  } else {  io:println(\"Message successfully sent.\");  } }    SASL Authentication - Producer  This is an example of a Kafka producer using the SASL/PLAIN authentication.  For this example to work properly, an active Kafka server must be present  and it should be configured to use the SASL/PLAIN authentication mechanism.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/kafka;    kafka:AuthenticationConfiguration authConfig = {    The kafka:AuthenticationConfiguration is used to provide authentication-related details.   mechanism: kafka:AUTH_SASL_PLAIN,    Provide the authentication mechanism used by the Kafka server.   username: \"ballerina\",  password: \"ballerina-secret\" };    Username and password should be set here in order to authenticate the producer.  For information on how to secure values instead of directly using plain text values, see .   kafka:ProducerConfiguration producerConfigs = {    auth: authConfig };    Provide the relevant authentication configuration record to authenticate the producer.   kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL, producerConfigs);    public function main() {  string message = \"Hello from Ballerina\";  kafka:Error? err = kafkaProducer->send({  topic: \"topic-sasl\",  value: message.toBytes()  });    if err is kafka:Error {  io:println(\"Error occurred when sending message \", 'error = err);  } else {  io:println(\"Message successfully sent.\");  } }    Checks for an error and notifies if an error has occurred.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_authentication_sasl_plain_producer.bal    # If the producer is authenticated and the message is sent successfully, # the following message will be printed in the console. Message successfully sent.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-authentication-sasl-plain-consumer.html","name":"SASL Authentication - Consumer","summary":"This is an example of a Kafka consumer using the SASL/PLAIN authentication.\n For this example to work properly, an active Kafka server must be present\n and it should be configured to use the SASL/PLAIN authentication mechanism.\n \n For more information on the underlying module,\n see the .The kafka:AuthenticationConfiguration is used ...","content":"/  /  / SASL Authentication - Consumer  import ballerinax/kafka; import ballerina/log;  // The `kafka:AuthenticationConfiguration` is used to provide authentication-related details. kafka:AuthenticationConfiguration authConfig = {  // Provide the authentication mechanism used by the Kafka server.  mechanism: kafka:AUTH_SASL_PLAIN,  // Username and password should be set here in order to authenticate the consumer.  // For information on how to secure values instead of directly using plain text values, see [Writing Secure Ballerina Code](https://ballerina.io/learn/user-guide/security/writing-secure-ballerina-code/#securing-sensitive-data-using-configurable-variables).  username: \"ballerina\",  password: \"ballerina-secret\" };  kafka:ConsumerConfiguration consumerConfig = {  groupId: \"test-group\",  clientId: \"sasl-consumer\",  offsetReset: \"earliest\",  topics: [\"topic-sasl\"],  // Provide the relevant authentication configuration record to authenticate the consumer.  auth: authConfig };  listener kafka:Listener kafkaListener = new(kafka:DEFAULT_URL, consumerConfig);  service kafka:Service on kafkaListener {  remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {  // Loops through the received consumer records.  foreach var consumerRecord in records {  // Converts the `byte[]` to a `string`.  string messageContent = check  string:fromBytes(consumerRecord.value);  log:printInfo(messageContent);  }  } }    SASL Authentication - Consumer  This is an example of a Kafka consumer using the SASL/PLAIN authentication.  For this example to work properly, an active Kafka server must be present  and it should be configured to use the SASL/PLAIN authentication mechanism.  For more information on the underlying module,  see the .    import ballerinax/kafka; import ballerina/log;    kafka:AuthenticationConfiguration authConfig = {    The kafka:AuthenticationConfiguration is used to provide authentication-related details.   mechanism: kafka:AUTH_SASL_PLAIN,    Provide the authentication mechanism used by the Kafka server.   username: \"ballerina\",  password: \"ballerina-secret\" };    Username and password should be set here in order to authenticate the consumer.  For information on how to secure values instead of directly using plain text values, see .   kafka:ConsumerConfiguration consumerConfig = {  groupId: \"test-group\",  clientId: \"sasl-consumer\",  offsetReset: \"earliest\",  topics: [\"topic-sasl\"],    auth: authConfig };    Provide the relevant authentication configuration record to authenticate the consumer.   listener kafka:Listener kafkaListener = new(kafka:DEFAULT_URL, consumerConfig);    service kafka:Service on kafkaListener {  remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {    foreach var consumerRecord in records {    Loops through the received consumer records.   string messageContent = check  string:fromBytes(consumerRecord.value);  log:printInfo(messageContent);  }  } }    Converts the byte[] to a string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_authentication_sasl_plain_consumer.bal    # The following lines will be printed in the Console when consumer starts. # If the consumer connected successfully, it will start to receive messages # from the subscribed topic(s). [ballerinax/kafka] kafka servers: localhost:9092 [ballerinax/kafka] subscribed topics: topic-sasl [ballerinax/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-consumer-client.html","name":"Consumer Client","summary":"This is an example on how to use a kafka:Consumer as a simple record\n consumer. The records from a subscribed topic can be retrieved using the\n poll() function.\n This consumer uses the builtin byte array deserializer for both the key and\n the value, which is the default deserializer in the ...","content":"/  /  / Consumer Client  import ballerinax/kafka; import ballerina/io;  kafka:ConsumerConfiguration consumerConfiguration = {  groupId: \"group-id\",  offsetReset: \"earliest\",  // Subscribes to the topic `test-kafka-topic`.  topics: [\"test-kafka-topic\"]  };  kafka:Consumer consumer = check new (kafka:DEFAULT_URL, consumerConfiguration);  public function main() returns error? {  // Polls the consumer for messages.  kafka:ConsumerRecord[] records = check consumer->poll(1);   foreach var kafkaRecord in records {  byte[] messageContent = kafkaRecord.value;  // Converts the `byte[]` to a `string`.  string message = check string:fromBytes(messageContent);   // Prints the retrieved Kafka record.  io:println(\"Received Message: \" + message);  } }    Consumer Client  This is an example on how to use a kafka:Consumer as a simple record  consumer. The records from a subscribed topic can be retrieved using the  poll() function.  This consumer uses the builtin byte array deserializer for both the key and  the value, which is the default deserializer in the kafka:Consumer. For  this example to work properly, an active Kafka broker should be present.  For more information on the underlying module,  see the .    import ballerinax/kafka; import ballerina/io;    kafka:ConsumerConfiguration consumerConfiguration = {  groupId: \"group-id\",  offsetReset: \"earliest\",    topics: [\"test-kafka-topic\"]    Subscribes to the topic test-kafka-topic.   };    kafka:Consumer consumer = check new (kafka:DEFAULT_URL, consumerConfiguration);    public function main() returns error? {    kafka:ConsumerRecord[] records = check consumer->poll(1);    Polls the consumer for messages.   foreach var kafkaRecord in records {  byte[] messageContent = kafkaRecord.value;    string message = check string:fromBytes(messageContent);    Converts the byte[] to a string.   io:println(\"Received Message: \" + message);  } }    Prints the retrieved Kafka record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_consumer_client.bal    # Then it will print the following lines in the Console, and the # received messages if there's any. [ballerinax/kafka] kafka servers: localhost:9092 [ballerinax/kafka] subscribed topics: test-kafka-topic    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-consumer-group-service.html","name":"Consumer Groups","summary":"This is an example of a Kafka consumer used as a listener to listen to a\n given topic/topics. The listener uses a group of concurrent consumers within\n the service. This consumer uses the builtin string deserializer for the\n values. For this example to work properly, an active Kafka broker should ...","content":"/  /  / Consumer Groups  import ballerinax/kafka; import ballerina/log;  kafka:ConsumerConfiguration consumerConfigs = {  // Uses two concurrent consumers to work as a group.  concurrentConsumers: 2,   groupId: \"group-id\",  // Subscribes to the `test-kafka-topic`.  topics: [\"test-kafka-topic\"],   pollingInterval: 1 };  listener kafka:Listener kafkaListener =  new (kafka:DEFAULT_URL, consumerConfigs);  service kafka:Service on kafkaListener {  // This remote function executes when a message or a set of messages are published  // to the subscribed topic/topics.  remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {  // The set of Kafka records received by the service are processed one  // by one.  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }  function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  byte[] messageContent = kafkaRecord.value;  // Converts the `byte[]` to a `string`.  string message = check string:fromBytes(messageContent);   // Prints the retrieved message.  log:printInfo(\"Received Message: \" + message); }    Consumer Groups  This is an example of a Kafka consumer used as a listener to listen to a  given topic/topics. The listener uses a group of concurrent consumers within  the service. This consumer uses the builtin string deserializer for the  values. For this example to work properly, an active Kafka broker should be  present.  For more information on the underlying module,  see the .    import ballerinax/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {    concurrentConsumers: 2,    Uses two concurrent consumers to work as a group.   groupId: \"group-id\",    topics: [\"test-kafka-topic\"],    Subscribes to the test-kafka-topic.   pollingInterval: 1 };    listener kafka:Listener kafkaListener =  new (kafka:DEFAULT_URL, consumerConfigs);    service kafka:Service on kafkaListener {    remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {    This remote function executes when a message or a set of messages are published  to the subscribed topic/topics.   foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }  } }    The set of Kafka records received by the service are processed one  by one.   function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  byte[] messageContent = kafkaRecord.value;    string message = check string:fromBytes(messageContent);    Converts the byte[] to a string.   log:printInfo(\"Received Message: \" + message); }    Prints the retrieved message.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_consumer_group_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerinax/kafka] kafka servers: localhost:9092 [ballerinax/kafka] subscribed topics: test-kafka-topic [ballerinax/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-producer.html","name":"Producer","summary":"This is an example on how to send messages to a Kafka topic using a\n kafka:Producer object. The producer is configured to send string\n values and int keys. For this example to work properly, an active Kafka\n broker should be present.\n For more information on the underlying module,\n see the ...","content":"/  /  / Producer  import ballerinax/kafka;  kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL);  public function main() returns error? {  string message = \"Hello World, Ballerina\";  // Sends the message to the Kafka topic.  check kafkaProducer->send({  topic: \"test-kafka-topic\",  value: message.toBytes() });   // Flushes the sent messages.  check kafkaProducer->'flush(); }    Producer  This is an example on how to send messages to a Kafka topic using a  kafka:Producer object. The producer is configured to send string  values and int keys. For this example to work properly, an active Kafka  broker should be present.  For more information on the underlying module,  see the .    import ballerinax/kafka;    kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL);    public function main() returns error? {  string message = \"Hello World, Ballerina\";    check kafkaProducer->send({  topic: \"test-kafka-topic\",  value: message.toBytes() });    Sends the message to the Kafka topic.   check kafkaProducer->'flush(); }    Flushes the sent messages.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_producer.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-consumer-service.html","name":"Consumer Service","summary":"This is an example, which creates a Kafka consumer used as a listener\n to a service with manual offset commits.\n This consumer uses the builtin int deserializer for the keys and the\n builtin string deserializer for the values. For this example to work\n properly, an active Kafka broker should be ...","content":"/  /  / Consumer Service  import ballerinax/kafka; import ballerina/log;  kafka:ConsumerConfiguration consumerConfigs = {  groupId: \"group-id\",  // Subscribes to the topic `test-kafka-topic`.  topics: [\"test-kafka-topic\"],   pollingInterval: 1,  // Sets the `autoCommit` to `false` so that the records should be committed manually.  autoCommit: false };  listener kafka:Listener kafkaListener =  new (kafka:DEFAULT_URL, consumerConfigs);  service kafka:Service on kafkaListener {  remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {  // The set of Kafka records received by the service are processed one by one.  foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }   // Commits offsets of the returned records by marking them as consumed.  kafka:Error? commitResult = caller->commit();   if commitResult is error {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", 'error = commitResult);  }  } }  function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {  // The value should be a `byte[]` since the byte[] deserializer is used  // for the value.  byte[] value = kafkaRecord.value;   // Converts the `byte[]` to a `string`.  string messageContent = check string:fromBytes(value);  log:printInfo(\"Received Message: \" + messageContent); }    Consumer Service  This is an example, which creates a Kafka consumer used as a listener  to a service with manual offset commits.  This consumer uses the builtin int deserializer for the keys and the  builtin string deserializer for the values. For this example to work  properly, an active Kafka broker should be present.  For more information on the underlying module,  see the .    import ballerinax/kafka; import ballerina/log;    kafka:ConsumerConfiguration consumerConfigs = {  groupId: \"group-id\",    topics: [\"test-kafka-topic\"],    Subscribes to the topic test-kafka-topic.   pollingInterval: 1,    autoCommit: false };    Sets the autoCommit to false so that the records should be committed manually.   listener kafka:Listener kafkaListener =  new (kafka:DEFAULT_URL, consumerConfigs);    service kafka:Service on kafkaListener {  remote function onConsumerRecord(kafka:Caller caller,  kafka:ConsumerRecord[] records) {    foreach var kafkaRecord in records {  processKafkaRecord(kafkaRecord);  }    The set of Kafka records received by the service are processed one by one.   kafka:Error? commitResult = caller->commit();    Commits offsets of the returned records by marking them as consumed.   if commitResult is error {  log:printError(\"Error occurred while committing the \" +  \"offsets for the consumer \", 'error = commitResult);  }  } }    function processKafkaRecord(kafka:ConsumerRecord kafkaRecord) {    byte[] value = kafkaRecord.value;    The value should be a byte[] since the byte[] deserializer is used  for the value.   string messageContent = check string:fromBytes(value);  log:printInfo(\"Received Message: \" + messageContent); }    Converts the byte[] to a string.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run kafka_consumer_service.bal    # If the listener started successfully, the following lines will be printed in # the Console. [ballerinax/kafka] kafka servers: localhost:9092 [ballerinax/kafka] subscribed topics: test-kafka-topic [ballerinax/kafka] started kafka listener    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/kafka-producer-transactional.html","name":"Transactional Producer","summary":"This example shows you how to do transactional message producing by sending\n messages to kafka brokers atomically using the kafka:Producer object. For\n this example to work properly, an active Kafka broker should be present.\n \n For more information on the underlying module,\n see the .The enableIdempotence should set to true ...","content":"/  /  / Transactional Producer  import ballerina/io; import ballerinax/kafka;  kafka:ProducerConfiguration producerConfigs = {  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,  // The `enableIdempotence` should set to `true` to make a producer transactional.  enableIdempotence: true,   // A `transactionalId` must be provided to make a producer transactional.  transactionalId: \"test-transactional-id\" };  kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL, producerConfigs);  public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();  // Creates a producer config with optional parameters.  // The `transactionalId` enables transactional message production.  kafkaAdvancedTransactionalProduce(serializedMessage); }  function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  kafka:Error? sendResult = kafkaProducer->send({  topic: \"test-kafka-topic\",  value: message,  partition: 0  });  // Checks for an error and notifies if an error has occurred.  if sendResult is kafka:Error {  io:println(\"Error occurred when sending message \",  'error = sendResult);  }   var commitResult = commit;  if commitResult is () {  io:println(\"Transaction successful\");  } else {  io:println(\"Transaction unsuccessful \" + commitResult.message());  }  } }    Transactional Producer  This example shows you how to do transactional message producing by sending  messages to kafka brokers atomically using the kafka:Producer object. For  this example to work properly, an active Kafka broker should be present.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/kafka;    kafka:ProducerConfiguration producerConfigs = {  clientId: \"basic-producer\",  acks: \"all\",  retryCount: 3,    enableIdempotence: true,    The enableIdempotence should set to true to make a producer transactional.   transactionalId: \"test-transactional-id\" };    A transactionalId must be provided to make a producer transactional.   kafka:Producer kafkaProducer = check new (kafka:DEFAULT_URL, producerConfigs);    public function main() {  string message = \"Hello World Transaction Message\";  byte[] serializedMessage = message.toBytes();    kafkaAdvancedTransactionalProduce(serializedMessage); }    Creates a producer config with optional parameters.  The transactionalId enables transactional message production.   function kafkaAdvancedTransactionalProduce(byte[] message) {  transaction {  kafka:Error? sendResult = kafkaProducer->send({  topic: \"test-kafka-topic\",  value: message,  partition: 0  });    if sendResult is kafka:Error {  io:println(\"Error occurred when sending message \",  'error = sendResult);  }    Checks for an error and notifies if an error has occurred.   var commitResult = commit;  if commitResult is () {  io:println(\"Transaction successful\");  } else {  io:println(\"Transaction unsuccessful \" + commitResult.message());  }  } }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run --experimental kafka_message_producer_transactional.bal    # If the producer successfully sent the message, the following will be printed # in the Console. [ballerina/http] started HTTP/WS listener 192.168.1.2:57457 Transaction successful    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/langlib-functions.html","name":"Langlib Functions","summary":"Langlib is a small library defined by language providing fundamental operations on built-in datatypes.\n Langlib functions can be called using convenient method-call syntax, but these types are not objects!\n There exists a ballerina/lang.T module for each built-in type T and they are automatically imported using T prefix.You can call Langlib ...","content":"/  /  / Langlib Functions  import ballerina/io;  public function main() {  // You can call Langlib functions using the method-call syntax.  string s = \"abc\".substring(1, 2);  io:println(s);   // n will be 1  int n = s.length();   // `s.length()` is same as `string:length(s)`.  int m = string:length(s); }    Langlib Functions  Langlib is a small library defined by language providing fundamental operations on built-in datatypes.  Langlib functions can be called using convenient method-call syntax, but these types are not objects!  There exists a ballerina/lang.T module for each built-in type T and they are automatically imported using T prefix.    import ballerina/io;    public function main() {    string s = \"abc\".substring(1, 2);  io:println(s);    You can call Langlib functions using the method-call syntax.   int n = s.length();    n will be 1   int m = string:length(s); }    s.length() is same as string:length(s).   bal run langlib_functions.bal b    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/let-clause.html","name":"Let Clause","summary":"Query expressions can have let clauses. They can be anywhere between from and select\n clauses. Multiple where clauses are also allowed. The semantics are similar to XQuery FLWOR.The let clause binds the variables.The where clause provides a way to perform conditional execution.This website uses cookies so that we can provide ...","content":"/  /  / Let Clause  import ballerina/io;  type Person record {  string first;  string last;  int yearOfBirth; };  public function main() {  Person[] persons = [  {first: \"Melina\", last: \"Kodel\", yearOfBirth: 1994},  {first: \"Tom\", last: \"Riddle\", yearOfBirth: 1926}  ];   string[] names = from var {first, last} in persons  // The `let` clause binds the variables.  let int len1 = first.length()  // The `where` clause provides a way to perform conditional execution.  where len1 > 0  let int len2 = last.length()  where len2 > 0  let string name = first + \" \" + last  select name;  io:println(names); }    Let Clause  Query expressions can have let clauses. They can be anywhere between from and select  clauses. Multiple where clauses are also allowed. The semantics are similar to XQuery FLWOR.    import ballerina/io;    type Person record {  string first;  string last;  int yearOfBirth; };    public function main() {  Person[] persons = [  {first: \"Melina\", last: \"Kodel\", yearOfBirth: 1994},  {first: \"Tom\", last: \"Riddle\", yearOfBirth: 1926}  ];    string[] names = from var {first, last} in persons    let int len1 = first.length()    The let clause binds the variables.   where len1 > 0  let int len2 = last.length()  where len2 > 0  let string name = first + \" \" + last  select name;  io:println(names); }    The where clause provides a way to perform conditional execution.   bal run let_clause.bal [\"Melina Kodel\",\"Tom Riddle\"]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/limit-clause.html","name":"Limit Clause","summary":"The limit clause limits the number of results from the earlier clauses.The limit clause limits the number of output items to 3.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can ...","content":"/  /  / Limit Clause  import ballerina/io;  type Employee record {  string firstName;  string lastName;  decimal salary; };  public function main() {  Employee[] employees = [  {firstName: \"Jones\", lastName: \"Welsh\", salary: 1000.00},  {firstName: \"Anne\", lastName: \"Frank\", salary: 5000.00},  {firstName: \"Michael\", lastName: \"Cain\", salary: 10000.00},  {firstName: \"Tom\", lastName: \"Hiddleston\", salary: 2000.00}  ];   Employee[] top3 = from var e in employees  order by e.salary descending  // The `limit` clause limits the number of output items to 3.  limit 3  select e;   foreach var emp in top3 {  io:println(emp);  } }    Limit Clause  The limit clause limits the number of results from the earlier clauses.    import ballerina/io;    type Employee record {  string firstName;  string lastName;  decimal salary; };    public function main() {  Employee[] employees = [  {firstName: \"Jones\", lastName: \"Welsh\", salary: 1000.00},  {firstName: \"Anne\", lastName: \"Frank\", salary: 5000.00},  {firstName: \"Michael\", lastName: \"Cain\", salary: 10000.00},  {firstName: \"Tom\", lastName: \"Hiddleston\", salary: 2000.00}  ];    Employee[] top3 = from var e in employees  order by e.salary descending    limit 3  select e;    The limit clause limits the number of output items to 3.   foreach var emp in top3 {  io:println(emp);  } }    bal run limit_clause.bal {\"firstName\":\"Michael\",\"lastName\":\"Cain\",\"salary\":10000.00} {\"firstName\":\"Anne\",\"lastName\":\"Frank\",\"salary\":5000.00} {\"firstName\":\"Tom\",\"lastName\":\"Hiddleston\",\"salary\":2000.00}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/lock-statement.html","name":"Lock Statement","summary":"The lock statement allows mutable state to be safely accessed from multiple strands that are running on\n separate threads. Semantics are like an atomic section: execution of outermost lock block is not\n interleaved. Naive implementation uses single, global, recursive lock. Efficient implementation can do\n compile-time lock inference.Locks the global variable ...","content":"/  /  / Lock Statement  import ballerina/io;  int n = 0;  function inc() {  // Locks the global variable `n` and increments it by 1.  lock {  n += 1;  }  io:println(n); }  public function main() {  inc(); }    Lock Statement  The lock statement allows mutable state to be safely accessed from multiple strands that are running on  separate threads. Semantics are like an atomic section: execution of outermost lock block is not  interleaved. Naive implementation uses single, global, recursive lock. Efficient implementation can do  compile-time lock inference.    import ballerina/io;    int n = 0;    function inc() {    lock {  n += 1;  }  io:println(n); }    Locks the global variable n and increments it by 1.   public function main() {  inc(); }    bal run lock_statement.bal 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/logging-configuration.html","name":"Configure Logging","summary":"The Ballerina Log API contains the application log handling functions.\n For more information on the underlying module,\n see the .The Ballerina log API provides functions to log at four levels, which are\n DEBUG, ERROR, INFO, and WARN.This website uses cookies so that we can provide you with the best user ...","content":"/  /  / Configure Logging  import ballerina/log;  public function main() {  // The Ballerina log API provides functions to log at four levels, which are  // `DEBUG`, `ERROR`, `INFO`, and `WARN`.  log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printInfo(\"info log\");  log:printWarn(\"warn log\"); }    Configure Logging  The Ballerina Log API contains the application log handling functions.  For more information on the underlying module,  see the .    import ballerina/log;    public function main() {    log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printInfo(\"info log\");  log:printWarn(\"warn log\"); }    The Ballerina log API provides functions to log at four levels, which are  DEBUG, ERROR, INFO, and WARN.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run logging_configuration.bal time = 2021-05-25T11:06:54.998+05:30 level = ERROR module = \"\" message = \"error log\" time = 2021-05-25T11:06:55.009+05:30 level = INFO module = \"\" message = \"info log\" time = 2021-05-25T11:06:55.010+05:30 level = WARN module = \"\" message = \"warn log\" # As shown in the output, only the `INFO` and higher level logs are logged by default.    # The log level can be configured via a Ballerina configuration file. # To set the global log level to `DEBUG`, place the entry given below in the `Config.toml` file and run the sample. # ``` # [ballerina.log] # level = \"DEBUG\" # ``` time = 2021-05-25T11:11:24.898+05:30 level = DEBUG module = \"\" message = \"debug log\" time = 2021-05-25T11:11:24.914+05:30 level = ERROR module = \"\" message = \"error log\" time = 2021-05-25T11:11:24.915+05:30 level = INFO module = \"\" message = \"info log\" time = 2021-05-25T11:11:24.915+05:30 level = WARN module = \"\" message = \"warn log\" # As shown in the output, now the `DEBUG` and higher level logs are logged.    # Each module can also be assigned its own log level. To assign a # log level to a module, provide the following entry in the `Config.toml` file: # # ``` # [[ballerina.log.modules]] # name = \"[ORG_NAME]/[MODULE_NAME]\" # level = \"[LOG_LEVEL]\" # ```    # By default, log messages are logged to the console in the LogFmt format. # To set the output format to JSON, place the entry given below in the `Config.toml` file and run the sample. # ``` # [ballerina.log] # format = \"json\" # ``` {\"time\":\"2021-05-25T11:14:43.986+05:30\", \"level\":\"ERROR\", \"module\":\"\", \"message\":\"error log\"} {\"time\":\"2021-05-25T11:14:44.005+05:30\", \"level\":\"INFO\", \"module\":\"\", \"message\":\"info log\"} {\"time\":\"2021-05-25T11:14:44.006+05:30\", \"level\":\"WARN\", \"module\":\"\", \"message\":\"warn log\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/logging.html","name":"Logging","summary":"The Ballerina Log API contains the application log handling functions.\n For more information on the underlying module,\n see the .The Ballerina log API provides functions to log at four levels, which are\n DEBUG, ERROR, INFO, and WARN.You can pass any number of key/value pairs, which need to be displayed in ...","content":"/  /  / Logging  import ballerina/log;  public function main() {  // The Ballerina log API provides functions to log at four levels, which are  // `DEBUG`, `ERROR`, `INFO`, and `WARN`.  log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printInfo(\"info log\");  log:printWarn(\"warn log\");   // You can pass any number of key/value pairs, which need to be displayed in the log message.  // These can be of the `anydata` type including int, string, and boolean.  log:printInfo(\"info log\", id = 845315, name = \"foo\", successful = true);   // Optionally, an error can be passed to the functions.  error e = error(\"something went wrong!\");  log:printError(\"error log with cause\", 'error = e, id = 845315,  name = \"foo\"); }    Logging  The Ballerina Log API contains the application log handling functions.  For more information on the underlying module,  see the .    import ballerina/log;    public function main() {    log:printDebug(\"debug log\");  log:printError(\"error log\");  log:printInfo(\"info log\");  log:printWarn(\"warn log\");    The Ballerina log API provides functions to log at four levels, which are  DEBUG, ERROR, INFO, and WARN.   log:printInfo(\"info log\", id = 845315, name = \"foo\", successful = true);    You can pass any number of key/value pairs, which need to be displayed in the log message.  These can be of the anydata type including int, string, and boolean.   error e = error(\"something went wrong!\");  log:printError(\"error log with cause\", 'error = e, id = 845315,  name = \"foo\"); }    Optionally, an error can be passed to the functions.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run logging.bal time = 2021-05-25T11:29:58.290+05:30 level = DEBUG module = \"\" message = \"debug log\" time = 2021-05-25T11:29:58.305+05:30 level = ERROR module = \"\" message = \"error log\" time = 2021-05-25T11:29:58.306+05:30 level = INFO module = \"\" message = \"info log\" time = 2021-05-25T11:29:58.307+05:30 level = WARN module = \"\" message = \"warn log\" time = 2021-05-25T11:29:58.307+05:30 level = INFO module = \"\" message = \"info log\" name = \"foo\" id = 845315 successful = true time = 2021-05-25T11:29:58.317+05:30 level = ERROR module = \"\" message = \"error log with cause\" error = \"something went wrong!\" name = \"foo\" id = 845315    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/logging-with-context.html","name":"Logging with Context","summary":"The Ballerina Log API contains the application log handling functions.\n For more information on the underlying module,\n see the .The Ballerina log API provides functions to log at four levels, which are\n DEBUG, ERROR, INFO, and WARN.\n You can pass key/value pairs where the values are function pointers.\n These functions ...","content":"/  /  / Logging with Context  import ballerina/log; import ballerina/random; import ballerina/time;  public function main() {  // The Ballerina log API provides functions to log at four levels, which are  // `DEBUG`, `ERROR`, `INFO`, and `WARN`.  // You can pass key/value pairs where the values are function pointers.  // These functions can return values, which change dynamically.  // The following log prints the current UTC time as a key/value pair.  log:printInfo(\"info log\",  current_time = isolated function() returns string {  return time:utcToString(time:utcNow());});  // The following log prints a random percentage as a key/value pair.  log:printInfo(\"info log\",  percentage = isolated function() returns float {  return random:createDecimal() * 100.0;}); }    Logging with Context  The Ballerina Log API contains the application log handling functions.  For more information on the underlying module,  see the .    import ballerina/log; import ballerina/random; import ballerina/time;    public function main() {    log:printInfo(\"info log\",  current_time = isolated function() returns string {  return time:utcToString(time:utcNow());});    The Ballerina log API provides functions to log at four levels, which are  DEBUG, ERROR, INFO, and WARN.  You can pass key/value pairs where the values are function pointers.  These functions can return values, which change dynamically.  The following log prints the current UTC time as a key/value pair.   log:printInfo(\"info log\",  percentage = isolated function() returns float {  return random:createDecimal() * 100.0;}); }    The following log prints a random percentage as a key/value pair.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run logging_with_context.bal time = 2021-05-25T10:34:25.460+05:30 level = INFO module = \"\" message = \"info log\" current_time = \"2021-05-25T05:04:25.473981Z\" time = 2021-05-25T10:34:25.487+05:30 level = INFO module = \"\" message = \"info log\" percentage = 38.4141353500368    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/maps.html","name":"Maps","summary":"map<T> is a map from strings to T. map syntax is similar to JSON. Maps are mutable: m[k] is an\n lvalue. foreach will iterate over values of the map. m[k]gets entry fork;nilif missing.\n Usem.get(k)when you know that there is an entry fork.m.keys()can be used to iterate over keys,\n to get ...","content":"/  /  / Maps  import ballerina/io;  public function main() {  // Creates a `map` constrained by the type `int`.  map<int> m = {  \"x\": 1,  \"y\": 2  };   // Gets the entry for `x`.  int? v = m[\"x\"];  io:println(v);   // Adds a new entry for `z`.  m[\"z\"] = 5;   // Using `m[\"x\"]` wouldn't work here because type would be `int?`.  // not `int`.  m[\"z\"] = m.get(\"x\"); }    Maps  map<T> is a map from strings to T. map syntax is similar to JSON. Maps are mutable: m[k] is an  lvalue. foreach will iterate over values of the map. m[k]gets entry fork;nilif missing.  Usem.get(k)when you know that there is an entry fork.m.keys()can be used to iterate over keys,  to get the keys as anarrayof strings.==and!=` on maps is deep: two maps are equal if they  have the same set of keys and the values for each key are equal.    import ballerina/io;    public function main() {    map<int> m = {  \"x\": 1,  \"y\": 2  };    Creates a map constrained by the type int.   int? v = m[\"x\"];  io:println(v);    Gets the entry for x.   m[\"z\"] = 5;    Adds a new entry for z.   m[\"z\"] = m.get(\"x\"); }    Using m[\"x\"] wouldn’t work here because type would be int?.  not int.   bal run maps.bal 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/match-statement-with-maps.html","name":"Match Statement With Maps","summary":"Match statement can be used to match maps.\n Patterns on the left hand side in a match statement can have variable\n parts that can be captured.\n Useful for working directly with json.\n Match semantics are open (may have fields other than those specified in the pattern).Match statement can be used ...","content":"/  /  / Match Statement With Maps  import ballerina/io;  function foo(json j) returns error? {  match j {  // Match statement can be used to match maps.  // Patterns on the left hand side in a match statement can have variable  // parts that can be captured.  // Match semantics are open (may have fields other than those // specified in the pattern).  {command: \"add\", amount: var x} => {  decimal n = check x.ensureType(decimal);  add(n);  }  _ => {  return error(\"invalid command\");  }  } }  decimal total = 0;  function add(decimal amount) {  total += amount;  io:println(\"Total: \", total); }  public function main() returns error? {  check foo({command: \"add\", amount: 100, status: \"pending\"}); check foo({command: \"add\", amount: 10}); check foo({command: \"subtract\", amount: 100}); }    Match Statement With Maps  Match statement can be used to match maps.  Patterns on the left hand side in a match statement can have variable  parts that can be captured.  Useful for working directly with json.  Match semantics are open (may have fields other than those specified in the pattern).    import ballerina/io;    function foo(json j) returns error? {  match j {    {command: \"add\", amount: var x} => {  decimal n = check x.ensureType(decimal);  add(n);  }  _ => {  return error(\"invalid command\");  }  } }    Match statement can be used to match maps.  Patterns on the left hand side in a match statement can have variable  parts that can be captured.  Match semantics are open (may have fields other than those  specified in the pattern).   decimal total = 0;    function add(decimal amount) {  total += amount;  io:println(\"Total: \", total); }    public function main() returns error? {  check foo({command: \"add\", amount: 100, status: \"pending\"}); check foo({command: \"add\", amount: 10}); check foo({command: \"subtract\", amount: 100}); }    bal run match_statement_with_maps.bal Total: 100.0 Total: 110.0 error: invalid command {}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/manage-scheduled-jobs.html","name":"Manage Scheduled Jobs","summary":"The task library provides functions to manage the scheduled jobs such as pause, resume,\n unschedule, and etc.\n For more information on the underlying module,\n see the .Creates a job to be executed by the scheduler.Executes this function when the scheduled trigger fires.Gets the current time.Increases the time by three seconds ...","content":"/  /  / Manage Scheduled Jobs  import ballerina/io; import ballerina/lang.runtime; import ballerina/task; import ballerina/time;  // Creates a job to be executed by the scheduler. class Job {   *task:Job;  int i = 1;  string jobIdentifier;   // Executes this function when the scheduled trigger fires.  public function execute() {  self.i += 1;  io:println(self.jobIdentifier + \", MyCounter: \", self.i);  }   isolated function init(int i, string jobIdentifier) {  self.i = i;  self.jobIdentifier = jobIdentifier;  } }  public function main() returns error? {   // Gets the current time.  time:Utc currentUtc = time:utcNow();  // Increases the time by three seconds to set the starting delay for the scheduling job.  time:Utc newTime = time:utcAddSeconds(currentUtc, 5);  // Gets the `time:Civil` for the given time.  time:Civil time = time:utcToCivil(newTime);   // Schedules the tasks to execute the job every second.  task:JobId id1 = check task:scheduleJobRecurByFrequency(new Job(0, \"1st Job\"), 1);  task:JobId id2 = check task:scheduleJobRecurByFrequency(new Job(0, \"2nd Job\"), 3);  // Schedules the one-time job at the specified time.  task:JobId id3 = check task:scheduleOneTimeJob(new Job(0, \"3rd Job\"), time);   // Waits for 3 seconds.  runtime:sleep(3);   // Gets all the running jobs.  task:JobId[] result = task:getRunningJobs();  io:println(\"No of running jobs: \", result.length());   // Pauses the specified job.  check task:pauseJob(id1);  io:println(\"Pasused the 1st job.\");  // Waits for 3 seconds.  runtime:sleep(3);   // Resumes the specified job.  check task:resumeJob(id1);  io:println(\"Resumed the 1st job.\");   // Gets all the running jobs.  result = task:getRunningJobs();  io:println(\"No of running jobs: \", result.length());   // Waits for 3 seconds.  runtime:sleep(3);   // Unschedules the jobs.  check task:unscheduleJob(id1);  check task:unscheduleJob(id2); }    Manage Scheduled Jobs  The task library provides functions to manage the scheduled jobs such as pause, resume,  unschedule, and etc.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/lang.runtime; import ballerina/task; import ballerina/time;    class Job {    Creates a job to be executed by the scheduler.   *task:Job;  int i = 1;  string jobIdentifier;    public function execute() {  self.i += 1;  io:println(self.jobIdentifier + \", MyCounter: \", self.i);  }    Executes this function when the scheduled trigger fires.   isolated function init(int i, string jobIdentifier) {  self.i = i;  self.jobIdentifier = jobIdentifier;  } }    public function main() returns error? {    time:Utc currentUtc = time:utcNow();    Gets the current time.   time:Utc newTime = time:utcAddSeconds(currentUtc, 5);    Increases the time by three seconds to set the starting delay for the scheduling job.   time:Civil time = time:utcToCivil(newTime);    Gets the time:Civil for the given time.   task:JobId id1 = check task:scheduleJobRecurByFrequency(new Job(0, \"1st Job\"), 1);  task:JobId id2 = check task:scheduleJobRecurByFrequency(new Job(0, \"2nd Job\"), 3);    Schedules the tasks to execute the job every second.   task:JobId id3 = check task:scheduleOneTimeJob(new Job(0, \"3rd Job\"), time);    Schedules the one-time job at the specified time.   runtime:sleep(3);    Waits for 3 seconds.   task:JobId[] result = task:getRunningJobs();  io:println(\"No of running jobs: \", result.length());    Gets all the running jobs.   check task:pauseJob(id1);  io:println(\"Pasused the 1st job.\");    Pauses the specified job.   runtime:sleep(3);    Waits for 3 seconds.   check task:resumeJob(id1);  io:println(\"Resumed the 1st job.\");    Resumes the specified job.   result = task:getRunningJobs();  io:println(\"No of running jobs: \", result.length());    Gets all the running jobs.   runtime:sleep(3);    Waits for 3 seconds.   check task:unscheduleJob(id1);  check task:unscheduleJob(id2); }    Unschedules the jobs.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run manage_scheduled_jobs.bal 1st Job, MyCounter: 1 2nd Job, MyCounter: 1 1st Job, MyCounter: 2 1st Job, MyCounter: 3 1st Job, MyCounter: 4 2nd Job, MyCounter: 2 No of running jobs: 3 Pasused the 1st job. 3rd Job, MyCounter: 1 2nd Job, MyCounter: 3 Resumed the 1st job. 1st Job, MyCounter: 5 1st Job, MyCounter: 6 No of running jobs: 2 1st Job, MyCounter: 7 1st Job, MyCounter: 8 1st Job, MyCounter: 9 1st Job, MyCounter: 10 2nd Job, MyCounter: 4    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/match-statement.html","name":"Match Statement","summary":"match statement is similar to switch statement in C and JavaScript. It matches the value not the type.\n == is used to test whether left hand side matches the value being matched. Left hand side can be a\n simple literal (nil, boolean, int, float, string) identifier referring to a constant.\n ...","content":"/  /  / Match Statement  import ballerina/io;  const KEY = \"xyzzy\";  function matchTest(any v) returns string {  // The value of the `v` variable is matched against the  // given value match patterns.  match v {  17 => {  return \"number\";  }  true => {  return \"boolean\";  }  \"str\" => {  return \"string\";  }  KEY => {  return \"constant\";  }  0|1 => {  return \"or\";  }  _ => {  return \"any\";  }  } }  public function main() {  io:println(matchTest(\"str\"));  io:println(matchTest(17));  io:println(matchTest(20.5)); }    Match Statement  match statement is similar to switch statement in C and JavaScript. It matches the value not the type.  == is used to test whether left hand side matches the value being matched. Left hand side can be a  simple literal (nil, boolean, int, float, string) identifier referring to a constant.  Left hand side of _ matches if the value is of type any. You can use | to match more than one value.    import ballerina/io;    const KEY = \"xyzzy\";    function matchTest(any v) returns string {    match v {  17 => {  return \"number\";  }  true => {  return \"boolean\";  }  \"str\" => {  return \"string\";  }  KEY => {  return \"constant\";  }  0|1 => {  return \"or\";  }  _ => {  return \"any\";  }  } }    The value of the v variable is matched against the  given value match patterns.   public function main() {  io:println(matchTest(\"str\"));  io:println(matchTest(17));  io:println(matchTest(20.5)); }    bal run match_statement.bal string number any    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/module-lifecycle.html","name":"Module Lifecycle","summary":"All modules are initialized at program startup. Module intialization is ordered so that if module A imports module B,\n  then module A is initialized after module B. intialization phase ends by calling main function. \n A module’s listeners are registered during module initialization.\n If there are registered listeners, then ...","content":"/  /  / Module Lifecycle  import ballerina/io;  // Usually it is an error to import a module without using it, but if you want to import a module because of what its initialization does, // then use `as _` as in this example. import ballerina/grpc as _;  // A module can have an `init` function just like an object. // The initialization of a module ends by called its `init` function if there is one. function init() {  io:println(\"Hello world\"); }    Module Lifecycle  All modules are initialized at program startup. Module intialization is ordered so that if module A imports module B,  then module A is initialized after module B. intialization phase ends by calling main function. A module’s listeners are registered during module initialization.  If there are registered listeners, then initialization phase is followed by listening phase. Listening phase starts by calling start method on each registered listener. Listening phase is terminated by signal (e.g. SIGINT, SIGTERM).    import ballerina/io;    import ballerina/grpc as _;    Usually it is an error to import a module without using it, but if you want to import a module because of what its initialization does,  then use as _ as in this example.   function init() {  io:println(\"Hello world\"); }    A module can have an init function just like an object.  The initialization of a module ends by called its init function if there is one.   bal run module_lifecycle.bal Hello world    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/multiple-key-fields.html","name":"Multiple Key Fields","summary":"A table provides access to its members using a key that comes from the read-only fields of the member.\n It is a key sequence, which is used to provide keyed access to its members. The key sequence is an ordered\n sequence of field names.t has a key sequence with firstName ...","content":"/  /  / Multiple Key Fields  import ballerina/io;  type Employee record {  readonly string firstName;  readonly string lastName;  int salary; };  public function main() {  // `t` has a key sequence with `firstName` and `lastName` fields.  table<Employee> key(firstName, lastName) t = table [  {firstName: \"John\", lastName: \"Smith\", salary: 100},  {firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}  ];   // The key sequence provides keyed access to members of the `table`.  Employee? e = t[\"Fred\", \"Bloggs\"];  io:println(e); }    Multiple Key Fields  A table provides access to its members using a key that comes from the read-only fields of the member.  It is a key sequence, which is used to provide keyed access to its members. The key sequence is an ordered  sequence of field names.    import ballerina/io;    type Employee record {  readonly string firstName;  readonly string lastName;  int salary; };    public function main() {    table<Employee> key(firstName, lastName) t = table [  {firstName: \"John\", lastName: \"Smith\", salary: 100},  {firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}  ];    t has a key sequence with firstName and lastName fields.   Employee? e = t[\"Fred\", \"Bloggs\"];  io:println(e); }    The key sequence provides keyed access to members of the table.   bal run multiple_key_fields.bal {\"firstName\":\"Fred\",\"lastName\":\"Bloggs\",\"salary\":200}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/multiple-wait.html","name":"Multiple Wait","summary":"The wait action can be used to wait for multiple named workers.\n Works with futures also.The wait action can be used to wait for multiple named workers.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish ...","content":"/  /  / Multiple Wait  import ballerina/http; import ballerina/io;  type Result record {  string|error a;  string|error b; };  function multiFetch(string urlA, string urlB) returns Result {  worker WA returns string|error {  return fetch(urlA);  }  worker WB returns string|error {  return fetch(urlB);  }   // The `wait` action can be used to wait for multiple named workers.  return wait {a: WA, b: WB}; }  public function main() returns error? {  Result res = multiFetch(\"https://postman-echo.com/get?lang=ballerina\",  \"https://postman-echo.com/get?greeting=hello\");  io:println(res); }  function fetch(string url) returns string|error {  http:Client cl = check new (url);  map<json> payload = check cl->get(\"\");  return payload[\"args\"].toString(); }    Multiple Wait  The wait action can be used to wait for multiple named workers.  Works with futures also.    import ballerina/http; import ballerina/io;    type Result record {  string|error a;  string|error b; };    function multiFetch(string urlA, string urlB) returns Result {  worker WA returns string|error {  return fetch(urlA);  }  worker WB returns string|error {  return fetch(urlB);  }    return wait {a: WA, b: WB}; }    The wait action can be used to wait for multiple named workers.   public function main() returns error? {  Result res = multiFetch(\"https://postman-echo.com/get?lang=ballerina\",  \"https://postman-echo.com/get?greeting=hello\");  io:println(res); }    function fetch(string url) returns string|error {  http:Client cl = check new (url);  map<json> payload = check cl->get(\"\");  return payload[\"args\"].toString(); }    bal run multiple_wait.bal {\"a\":\"{\"lang\":\"ballerina\"}\",\"b\":\"{\"greeting\":\"hello\"}\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/mysql-atomic-batch-execute-operation.html","name":"Atomic Batch Execute","summary":"This example demonstrates how to use the MySQL client to execute a batch of\n DDL/DML operations with the help of a transaction to achieve the atomic behaviour.\n Note that the MySQL database driver JAR should be defined in\n the Ballerina.toml file as a dependency.\n For a sample configuration and more ...","content":"/  /  / Atomic Batch Execute  import ballerina/io; import ballerinax/mysql; import ballerina/sql;  public function main() returns error? {  // Runs the prerequisite setup for the example.  check beforeExample();   // Initializes the MySQL client.  mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");   // Records with the duplicate `registrationID` entry. Here it is `registrationID` = 1.  var insertRecords = [  {firstName: \"Linda\", lastName: \"Jones\", registrationID: 4,  creditLimit: 10000.75, country: \"USA\"},  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Camellia\", lastName: \"Potter\", registrationID: 5,  creditLimit: 2000.25, country: \"USA\"}  ];   // Creates a batch parameterized query.  sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;   // The transaction block can be used to roll back if any error occurred.  transaction {  var result = mysqlClient -> batchExecute(insertQueries);  if result is sql:BatchExecuteError {  io:println(result.message());  io:println(result.detail()?.executionResults);  io:println(\"Rollback transaction.\\n\");  rollback;  } else {  error? err = commit;  if err is error {  io:println(\"Error occurred while committing: \", err);  }  }  }   // Checks the data after the batch execution.  stream<record{}, error> resultStream =  mysqlClient -> query(\"SELECT * FROM Customers\");   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });   // Performs a cleanup after the example.  check afterExample(mysqlClient); }  // Initializes the database as a prerequisite to the example. function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");   // Creates a database.  sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);   // Creates a table in the database.  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER UNIQUE, creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))`);   // Adds records to the newly-created table.  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);   check mysqlClient.close(); }  // Cleans up the database after running the example. function afterExample(mysql:Client mysqlClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);  // Closes the MySQL client.  check mysqlClient.close(); }    Atomic Batch Execute  This example demonstrates how to use the MySQL client to execute a batch of  DDL/DML operations with the help of a transaction to achieve the atomic behaviour.  Note that the MySQL database driver JAR should be defined in  the Ballerina.toml file as a dependency.  For a sample configuration and more information on the underlying module, see the .  The MySQL connector uses database properties from MySQL version 8.0.13 onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.13.    import ballerina/io; import ballerinax/mysql; import ballerina/sql;    public function main() returns error? {    check beforeExample();    Runs the prerequisite setup for the example.   mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");    Initializes the MySQL client.   var insertRecords = [  {firstName: \"Linda\", lastName: \"Jones\", registrationID: 4,  creditLimit: 10000.75, country: \"USA\"},  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Camellia\", lastName: \"Potter\", registrationID: 5,  creditLimit: 2000.25, country: \"USA\"}  ];    Records with the duplicate registrationID entry. Here it is registrationID = 1.   sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;    Creates a batch parameterized query.   transaction {  var result = mysqlClient -> batchExecute(insertQueries);  if result is sql:BatchExecuteError {  io:println(result.message());  io:println(result.detail()?.executionResults);  io:println(\"Rollback transaction.\\n\");  rollback;  } else {  error? err = commit;  if err is error {  io:println(\"Error occurred while committing: \", err);  }  }  }    The transaction block can be used to roll back if any error occurred.   stream<record{}, error> resultStream =  mysqlClient -> query(\"SELECT * FROM Customers\");    Checks the data after the batch execution.   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });    check afterExample(mysqlClient); }    Performs a cleanup after the example.   function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);    Creates a database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER UNIQUE, creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);    Adds records to the newly-created table.   check mysqlClient.close(); }    function afterExample(mysql:Client mysqlClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);    Cleans the database.   check mysqlClient.close(); }    Closes the MySQL client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    [ballerina/http] started HTTP/WS listener 172.18.0.1:42983 Error while executing batch command starting with: 'INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES ( ? , ? ,  ? , ? , ? )'.Duplicate entry '1' for key 'Customers.registrationID'. [{\"affectedRowCount\":1,\"lastInsertId\":null},{\"affectedRowCount\":-3,\"lastInsertId\":null},{\"affectedRowCount\":1,\"lastInsertId\":null}] Rollback transaction.    Data in Customers table: {\"customerId\":1,\"firstName\":\"Peter\",\"lastName\":\"Stuart\",\"registrationID\":1,\"creditLimit\":5000.75,\"country\":\"USA\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/mysql-batch-execute-operation.html","name":"Batch Execute","summary":"This example demonstrates how to use the MySQL client to execute a batch of\n DDL/DML operations. Note that the MySQL database driver JAR should be defined in\n the Ballerina.toml file as a dependency.\n For a sample configuration and more information on the underlying module, see the .\n The MySQL connector ...","content":"/  /  / Batch Execute  import ballerina/io; import ballerinax/mysql; import ballerina/sql;  public function main() returns error? {  // Runs the prerequisite setup for the example.  check beforeExample();   // Initializes the MySQL client.  mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");   // The records to be inserted.  var insertRecords = [  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2,  creditLimit: 8000.00, country: \"USA\"},  {firstName: \"Bill\", lastName: \"John\", registrationID: 3,  creditLimit: 3000.25, country: \"USA\"}  ];   // Creates a batch parameterized query.  sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;  // Inserts the records with the auto-generated ID.  sql:ExecutionResult[] result = check mysqlClient -> batchExecute(insertQueries);   int[] generatedIds = [];  foreach var summary in result {  generatedIds.push(<int> summary.lastInsertId);  }  io:println(\"\\nInsert success, generated IDs are: \", generatedIds, \"\\n\");   // Checks the data after the batch execution.  stream<record{}, error> resultStream =  mysqlClient -> query(\"SELECT * FROM Customers\");   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });   // Performs the cleanup after the example.  check afterExample(mysqlClient); }  // Initializes the database as a prerequisite to the example. function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");   // Creates a database.  sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);  // Creates a table in the database.  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))`); check mysqlClient.close(); }  // Cleans up the database after running the example. function afterExample(mysql:Client mysqlClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);  // Closes the MySQL client.  check mysqlClient.close(); }    Batch Execute  This example demonstrates how to use the MySQL client to execute a batch of  DDL/DML operations. Note that the MySQL database driver JAR should be defined in  the Ballerina.toml file as a dependency.  For a sample configuration and more information on the underlying module, see the .  The MySQL connector uses database properties from MySQL version 8.0.13 onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.13.    import ballerina/io; import ballerinax/mysql; import ballerina/sql;    public function main() returns error? {    check beforeExample();    Runs the prerequisite setup for the example.   mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");    Initializes the MySQL client.   var insertRecords = [  {firstName: \"Peter\", lastName: \"Stuart\", registrationID: 1,  creditLimit: 5000.75, country: \"USA\"},  {firstName: \"Stephanie\", lastName: \"Mike\", registrationID: 2,  creditLimit: 8000.00, country: \"USA\"},  {firstName: \"Bill\", lastName: \"John\", registrationID: 3,  creditLimit: 3000.25, country: \"USA\"}  ];    The records to be inserted.   sql:ParameterizedQuery[] insertQueries =  from var data in insertRecords  select `INSERT INTO Customers  (firstName, lastName, registrationID, creditLimit, country)  VALUES (${data.firstName}, ${data.lastName},  ${data.registrationID}, ${data.creditLimit}, ${data.country})`;  Creates a batch parameterized query.   sql:ExecutionResult[] result = check mysqlClient -> batchExecute(insertQueries);    Inserts the records with the auto-generated ID.   int[] generatedIds = [];  foreach var summary in result {  generatedIds.push(<int> summary.lastInsertId);  }  io:println(\"\\nInsert success, generated IDs are: \", generatedIds, \"\\n\");    stream<record{}, error> resultStream =  mysqlClient -> query(\"SELECT * FROM Customers\");    Checks the data after the batch execution.   io:println(\"Data in Customers table:\");  error? e = resultStream.forEach(function(record {} result) {  io:println(result.toString());  });    check afterExample(mysqlClient); }    Performs the cleanup after the example.   function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);  Creates a database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300), PRIMARY KEY (customerId))`); Creates a table in the database.   check mysqlClient.close(); }    function afterExample(mysql:Client mysqlClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);    Cleans the database.   check mysqlClient.close(); }    Closes the MySQL client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Insert success, generated IDs are: [1,2,3]    Data in Customers table: {\"customerId\":1,\"firstName\":\"Peter\",\"lastName\":\"Stuart\",\"registrationID\":1,\"creditLimit\":5000.75,\"country\":\"USA\"} {\"customerId\":2,\"firstName\":\"Stephanie\",\"lastName\":\"Mike\",\"registrationID\":2,\"creditLimit\":8000.0,\"country\":\"USA\"} {\"customerId\":3,\"firstName\":\"Bill\",\"lastName\":\"John\",\"registrationID\":3,\"creditLimit\":3000.25,\"country\":\"USA\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/named-worker-return-values.html","name":"Named Worker Return Values","summary":"Named workers have a return type, which defaults to nil.\n A return statement in a named worker terminates\n the worker, not the function.\n Similarly, when check is used and the expression evaluates\n to an error, the error value is returned terminating the worker.\n Waiting on a named worker will give ...","content":"/  /  / Named Worker Return Values  import ballerina/io;  function demo(string s) returns int|error {  // Named workers have a return type, which defaults to nil  // if not specified.  worker A returns int|error {  // A return statement in a named worker terminates // the worker, not the function.  // Similarly, when `check` is used and the expression evaluates  // to an error, the error value is returned terminating only the worker.  int x = check int:fromString(s);  return x + 1;  }   io:println(\"In function worker\");   // Waiting on a named worker will give its return value.  int y = check wait A;  return y + 1; }  public function main() returns error? {  int res = check demo(\"50\");  io:println(res);   res = check demo(\"50m\");  io:println(res); }    Named Worker Return Values  Named workers have a return type, which defaults to nil.  A return statement in a named worker terminates  the worker, not the function.  Similarly, when check is used and the expression evaluates  to an error, the error value is returned terminating the worker.  Waiting on a named worker will give its return value.    import ballerina/io;    function demo(string s) returns int|error {    worker A returns int|error {    Named workers have a return type, which defaults to nil  if not specified.   int x = check int:fromString(s);  return x + 1;  }    A return statement in a named worker terminates  the worker, not the function.  Similarly, when check is used and the expression evaluates  to an error, the error value is returned terminating only the worker.   io:println(\"In function worker\");    int y = check wait A;  return y + 1; }    Waiting on a named worker will give its return value.   public function main() returns error? {  int res = check demo(\"50\");  io:println(res);    res = check demo(\"50m\");  io:println(res); }    bal run named_worker_return_values.bal In function worker 52 In function worker error: {ballerina/lang.int}NumberParsingError {\"message\":\"'string' value '50m' cannot be converted to 'int'\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/mysql-complex-type-queries.html","name":"Query With Complex Types","summary":"This example demonstrates how to use the MySQL client with complex data types\n such as JSON, binary, blobs, and date/time fields. Note that the MySQL database\n driver JAR should be defined in the Ballerina.toml file as a dependency.\n For a sample configuration and more information on the underlying module, see ...","content":"/  /  / Query With Complex Types  import ballerina/io; import ballerinax/mysql; import ballerina/sql; import ballerina/time;  type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};  type JsonType record {|  int row_id;  json json_doc;  json json_array; |};  type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Utc timestamp_type;  string datetime_type; |};  public function main() returns error? {  // Runs the prerequisite setup for the example.  check beforeExample();   // Initializes the MySQL client.  mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");   // Since the `rowType` is provided as a `BinaryType`, the `resultStream` // will have `BinaryType` records.  stream<record{}, error> resultStream = mysqlClient -> query(`SELECT * FROM BINARY_TYPES`, BinaryType);  stream<BinaryType, sql:Error> binaryResultStream = <stream<BinaryType, sql:Error>> resultStream;   io:println(\"Binary types Result :\");  // Iterates the `binaryResultStream`.  error? e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });   // Since the `rowType` is provided as an `JsonType`, the `resultStream2` will  // have `JsonType` records.  stream<record{}, error> resultStream2 = mysqlClient -> query(`SELECT * FROM JSON_TYPES`, JsonType);  stream<JsonType, sql:Error> jsonResultStream =  <stream<JsonType, sql:Error>> resultStream2;   io:println(\"Json type Result :\");  // Iterates the `jsonResultStream`.  error? e2 = jsonResultStream.forEach(function(JsonType result) {  io:println(result);  });   // Since the `rowType` is provided as a `DateTimeType`, the `resultStream3`  // will have `DateTimeType` records. The `Date`, `Time`, `DateTime`, and  // `Timestamp` fields of the database table can be mapped to `time:Utc`,  // string, and int types in Ballerina.  stream<record{}, error> resultStream3 = mysqlClient -> query(`SELECT * FROM DATE_TIME_TYPES`, DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream3;   io:println(\"DateTime types Result :\");  // Iterates the `dateResultStream`.  error? e3 = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });   // Performs the cleanup after the example.  check afterExample(mysqlClient); }  // Initializes the database as a prerequisite to the example. function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");   // Creates a database.  sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);  // Create complex data type tables in the database.  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.BINARY_TYPES (row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type BINARY(27), PRIMARY KEY (row_id))`);  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.JSON_TYPES (row_id INTEGER NOT NULL, json_doc JSON, json_array JSON, PRIMARY KEY (row_id))`);   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type timestamp, datetime_type datetime, PRIMARY KEY (row_id))`);   // Adds the records to the newly-created tables.  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.BINARY_TYPES (row_id, blob_type, binary_type) VALUES (1, X'77736F322062616C6C6572696E6120626C6F6220746573742E', X'77736F322062616C6C6572696E612062696E61727920746573742E')`);   result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.JSON_TYPES (row_id, json_doc, json_array) VALUES (1, '{\"firstName\" : \"Jhon\", \"lastName\" : \"Bob\", \"age\" : 18}', JSON_ARRAY(1, 2, 3))`);   result = check mysqlClient -> execute(`Insert into MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, timestamp_type, datetime_type) values (1, '2017-05-23', '14:15:23', '2017-01-25 16:33:55', '2017-01-25 16:33:55')`);  check mysqlClient.close(); }  // Cleans up the database after running the example. function afterExample(mysql:Client mysqlClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);  // Closes the MySQL client.  check mysqlClient.close(); }    Query With Complex Types  This example demonstrates how to use the MySQL client with complex data types  such as JSON, binary, blobs, and date/time fields. Note that the MySQL database  driver JAR should be defined in the Ballerina.toml file as a dependency.  For a sample configuration and more information on the underlying module, see the .  The MySQL connector uses database properties from MySQL version 8.0.13 onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.13.    import ballerina/io; import ballerinax/mysql; import ballerina/sql; import ballerina/time;    type BinaryType record {|  int row_id;  byte[] blob_type;  byte[] binary_type; |};    type JsonType record {|  int row_id;  json json_doc;  json json_array; |};    type DateTimeType record {|  int row_id;  string date_type;  int time_type;  time:Utc timestamp_type;  string datetime_type; |};    public function main() returns error? {    check beforeExample();    Runs the prerequisite setup for the example.   mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");    Initializes the MySQL client.   stream<record{}, error> resultStream = mysqlClient -> query(`SELECT * FROM BINARY_TYPES`, BinaryType);  stream<BinaryType, sql:Error> binaryResultStream = <stream<BinaryType, sql:Error>> resultStream;    Since the rowType is provided as a BinaryType, the resultStream  will have BinaryType records.   io:println(\"Binary types Result :\");    error? e = binaryResultStream.forEach(function(BinaryType result) {  io:println(result);  });    Iterates the binaryResultStream.   stream<record{}, error> resultStream2 = mysqlClient -> query(`SELECT * FROM JSON_TYPES`, JsonType);  stream<JsonType, sql:Error> jsonResultStream =  <stream<JsonType, sql:Error>> resultStream2;    Since the rowType is provided as an JsonType, the resultStream2 will  have JsonType records.   io:println(\"Json type Result :\");    error? e2 = jsonResultStream.forEach(function(JsonType result) {  io:println(result);  });    Iterates the jsonResultStream.   stream<record{}, error> resultStream3 = mysqlClient -> query(`SELECT * FROM DATE_TIME_TYPES`, DateTimeType);  stream<DateTimeType, sql:Error> dateResultStream =  <stream<DateTimeType, sql:Error>>resultStream3;    Since the rowType is provided as a DateTimeType, the resultStream3  will have DateTimeType records. The Date, Time, DateTime, and  Timestamp fields of the database table can be mapped to time:Utc,  string, and int types in Ballerina.   io:println(\"DateTime types Result :\");    error? e3 = dateResultStream.forEach(function(DateTimeType result) {  io:println(result);  });    Iterates the dateResultStream.   check afterExample(mysqlClient); }    Performs the cleanup after the example.   function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);  Creates a database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.BINARY_TYPES (row_id INTEGER NOT NULL, blob_type BLOB(1024), binary_type BINARY(27), PRIMARY KEY (row_id))`);  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.JSON_TYPES (row_id INTEGER NOT NULL, json_doc JSON, json_array JSON, PRIMARY KEY (row_id))`);    Create complex data type tables in the database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.DATE_TIME_TYPES(row_id INTEGER NOT NULL, date_type DATE, time_type TIME, timestamp_type timestamp, datetime_type datetime, PRIMARY KEY (row_id))`);    result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.BINARY_TYPES (row_id, blob_type, binary_type) VALUES (1, X'77736F322062616C6C6572696E6120626C6F6220746573742E', X'77736F322062616C6C6572696E612062696E61727920746573742E')`);    Adds the records to the newly-created tables.   result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.JSON_TYPES (row_id, json_doc, json_array) VALUES (1, '{\"firstName\" : \"Jhon\", \"lastName\" : \"Bob\", \"age\" : 18}', JSON_ARRAY(1, 2, 3))`);    result = check mysqlClient -> execute(`Insert into MYSQL_BBE.DATE_TIME_TYPES (row_id, date_type, time_type, timestamp_type, datetime_type) values (1, '2017-05-23', '14:15:23', '2017-01-25 16:33:55', '2017-01-25 16:33:55')`);  check mysqlClient.close(); }    function afterExample(mysql:Client mysqlClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);    Cleans the database.   check mysqlClient.close(); }    Closes the MySQL client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Binary types Result : {\"row_id\":1,\"blob_type\":[119,115,111,50,32,98,97,108,108,101,114,105,110,97,32,98,108,111,98,32,116,101,115,116,46],\"binary_type\":[119,115,111,50,32,98,97,108,108,101,114,105,110,97,32,98,105,110,97,114,121,32,116,101,115,116,46]} Json type Result : {\"row_id\":1,\"json_doc\":{\"age\":18,\"lastName\":\"Bob\",\"firstName\":\"Jhon\"},\"json_array\":[1,2,3]} DateTime types Result : {\"row_id\":1,\"date_type\":\"2017-05-23\",\"time_type\":11723000,\"timestamp_type\":1485342235 0,\"datetime_type\":\"2017-01-25 11:03:55.0\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/named-workers-and-futures.html","name":"Named Workers and Futures","summary":"Futures and workers are the same thing.\n A reference to a named worker can be implicitly converted into a future.\n start is sugar for calling a function with a named worker and returning\n the named worker as a future.\n Cancellation of futures only happens at yield points.Futures and workers are ...","content":"/  /  / Named Workers and Futures  import ballerina/io;  function demo() returns future<int> {  worker A returns int {  return 42;  }  // Futures and workers are the same thing.  // A reference to a named worker can be implicitly converted into a future.  return A; }  type FuncInt function () returns int;  function startInt(FuncInt f) returns future<int> {  // `start` is sugar for calling a function with a named worker and returning  // the named worker as a future.  return start f(); }  public function main() {  future<int> a = demo();  int b = wait a;  io:println(b);   future<int> c = startInt(() => 100);  int d = wait c;  io:println(d); }    Named Workers and Futures  Futures and workers are the same thing.  A reference to a named worker can be implicitly converted into a future.  start is sugar for calling a function with a named worker and returning  the named worker as a future.  Cancellation of futures only happens at yield points.    import ballerina/io;    function demo() returns future<int> {  worker A returns int {  return 42;  }  return A; }    Futures and workers are the same thing.  A reference to a named worker can be implicitly converted into a future.   type FuncInt function () returns int;    function startInt(FuncInt f) returns future<int> {    return start f(); }    start is sugar for calling a function with a named worker and returning  the named worker as a future.   public function main() {  future<int> a = demo();  int b = wait a;  io:println(b);    future<int> c = startInt(() => 100);  int d = wait c;  io:println(d); }    bal run named_workers_and_futures.bal 42 100    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/mysql-execute-operation.html","name":"DML and DDL Operation","summary":"This example demonstrates how to use the MySQL client with the DDL and  DML\n operations. Note that the MySQL database driver JAR should be defined in the Ballerina.toml file as a dependency.\n For a sample configuration and more information on the underlying module, see the .\n The MySQL connector ...","content":"/  /  / DML and DDL Operation  import ballerina/io; import ballerinax/mysql; import ballerina/sql;  public function main() returns error? {  // Runs the prerequisite setup for the example.  check beforeExample();   // Initializes the MySQL client.  mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");   float newCreditLimit = 15000.5;   // Creates a parameterized query for the record update.  sql:ParameterizedQuery updateQuery = `UPDATE Customers SET creditLimit = ${newCreditLimit} where customerId = 1`;   sql:ExecutionResult result = check mysqlClient -> execute(updateQuery);  io:println(\"Updated Row count: \", result?.affectedRowCount);   string firstName = \"Dan\";   // Creates a parameterized query for deleting the records.  sql:ParameterizedQuery deleteQuery =  `DELETE FROM Customers WHERE firstName = ${firstName}`;  result = check mysqlClient -> execute(deleteQuery);  io:println(\"Deleted Row count: \", result.affectedRowCount);   // Performs the cleanup after the example.  check afterExample(mysqlClient); }  // Initializes the database as a prerequisite to the example. function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");   // Creates a database.  sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);   //Creates a table in the database.  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),PRIMARY KEY (customerId))`);   // Inserts data into the table. The result will have the `affectedRowCount`  // and `lastInsertedId` with the auto-generated ID of the last row.  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);   io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId); check mysqlClient.close(); }  // Cleans up the database after running the example. function afterExample(mysql:Client mysqlClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);  // Closes the MySQL client.  check mysqlClient.close(); }    DML and DDL Operation  This example demonstrates how to use the MySQL client with the DDL and DML  operations. Note that the MySQL database driver JAR should be defined in the Ballerina.toml file as a dependency.  For a sample configuration and more information on the underlying module, see the .  The MySQL connector uses database properties from MySQL version 8.0.13 onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.13.    import ballerina/io; import ballerinax/mysql; import ballerina/sql;    public function main() returns error? {    check beforeExample();    Runs the prerequisite setup for the example.   mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");    Initializes the MySQL client.   float newCreditLimit = 15000.5;    sql:ParameterizedQuery updateQuery = `UPDATE Customers SET creditLimit = ${newCreditLimit} where customerId = 1`;    Creates a parameterized query for the record update.   sql:ExecutionResult result = check mysqlClient -> execute(updateQuery);  io:println(\"Updated Row count: \", result?.affectedRowCount);    string firstName = \"Dan\";    sql:ParameterizedQuery deleteQuery =  `DELETE FROM Customers WHERE firstName = ${firstName}`;  result = check mysqlClient -> execute(deleteQuery);  io:println(\"Deleted Row count: \", result.affectedRowCount);    Creates a parameterized query for deleting the records.   check afterExample(mysqlClient); }    Performs the cleanup after the example.   function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);    Creates a database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers  (customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300), registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers (firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);    Inserts data into the table. The result will have the affectedRowCount  and lastInsertedId with the auto-generated ID of the last row.   io:println(\"Rows affected: \", result.affectedRowCount);  io:println(\"Generated Customer ID: \", result.lastInsertId); check mysqlClient.close(); }    function afterExample(mysql:Client mysqlClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);    Cleans the database.   check mysqlClient.close(); }    Closes the MySQL client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Rows affected: 1 Generated Customer ID: 2 Updated Row count: 1 Deleted Row count: 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/named-workers.html","name":"Named Workers","summary":"Normally all of a function’s code belongs to the function’s default worker,\n which has a single logical thread of control.\n A function can also declare named workers, which run concurrently with the\n function’s default worker and other named workers.\n Code before any named workers is executed before named workers start.\n ...","content":"/  /  / Named Workers  import ballerina/io;  public function main() {  // Code before any named workers is executed before named // workers start.  io:println(\"Initializing\");  final string greeting = \"Hello\";   // A function can declare named workers, which run concurrently with the  // function's default worker and other named workers.  worker A {  // Variables declared before all named workers and function // parameters are accessible in named workers.  io:println(greeting + \" from worker A\");  }   worker B {  io:println(greeting + \" from worker B\");  }   io:println(greeting + \" from function worker\"); }    Named Workers  Normally all of a function’s code belongs to the function’s default worker,  which has a single logical thread of control.  A function can also declare named workers, which run concurrently with the  function’s default worker and other named workers.  Code before any named workers is executed before named workers start.  Variables declared before all named workers and function parameters are  accessible in named workers.    import ballerina/io;    public function main() {    io:println(\"Initializing\");  final string greeting = \"Hello\";    Code before any named workers is executed before named  workers start.   worker A {    A function can declare named workers, which run concurrently with the  function’s default worker and other named workers.   io:println(greeting + \" from worker A\");  }    Variables declared before all named workers and function  parameters are accessible in named workers.   worker B {  io:println(greeting + \" from worker B\");  }    io:println(greeting + \" from function worker\"); }    bal run named_workers.bal Initializing Hello from function worker Hello from worker B Hello from worker A    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-basic-pub-sub.html","name":"Publish/Subscribe","summary":"The NATS client is used either to produce a message to a subject or consume a message from a subject.\n In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.\n For instructions on installing the NATS ...","content":"/  /  / Publish/Subscribe  import ballerinax/nats;  public function main() returns error? {  string message = \"Hello from Ballerina\";  // Initializes a NATS client.  nats:Client natsClient = check new(nats:DEFAULT_URL);   // Produces a message to the specified subject.  check natsClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo.bbe\"});   // Closes the client connection.  check natsClient.close(); } import ballerina/log; import ballerinax/nats;  // Initializes a NATS listener. listener nats:Listener subscription = new(nats:DEFAULT_URL);  // Binds the consumer to listen to the messages published // to the 'demo.bbe' subject. service \"demo.bbe\" on subscription {   remote function onMessage(nats:Message message) returns error? {   // Logs the incoming message.  string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }  } }    Publish/Subscribe  The NATS client is used either to produce a message to a subject or consume a message from a subject.  In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.  For instructions on installing the NATS server,  go to .  This is a simple publish/subscribe messaging pattern example.  For more information on the underlying module,  see the .    import ballerinax/nats;    public function main() returns error? {  string message = \"Hello from Ballerina\";    nats:Client natsClient = check new(nats:DEFAULT_URL);    Initializes a NATS client.   check natsClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo.bbe\"});    Produces a message to the specified subject.   check natsClient.close(); }    Closes the client connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal    import ballerina/log; import ballerinax/nats;    listener nats:Listener subscription = new(nats:DEFAULT_URL);    Initializes a NATS listener.   service \"demo.bbe\" on subscription {    Binds the consumer to listen to the messages published  to the ‘demo.bbe’ subject.   remote function onMessage(nats:Message message) returns error? {    string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }  } }    Logs the incoming message.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo.bbe time = 2021-05-19T10:15:49.269+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/mysql-query-operation.html","name":"Simple Query","summary":"This example demonstrates how to use the MySQL client select query operations\n with the stream return type. Note that the MySQL database driver JAR should\n be defined in the Ballerina.toml file as a dependency.\n For a sample configuration and more information on the underlying module, see the .\n The MySQL ...","content":"/  /  / Simple Query  import ballerina/io; import ballerinax/mysql; import ballerina/sql;  // Defines a record to load the query result schema as shown below in the // 'getDataWithTypedQuery' function. In this example, all columns of the // customer table will be loaded. Therefore, the `Customer` record will be // created with all the columns. The column name of the result and the // defined field name of the record will be matched case insensitively. type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};  public function main() returns error? {  // Runs the prerequisite setup for the example.  check beforeExample();   // Initializes the MySQL client.  mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");   // Select the rows in the database table via the query remote operation.  // The result is returned as a stream and the elements of the stream can  // be either a record or an error. The name and type of the attributes // within the record from the `resultStream` will be automatically // identified based on the column name and type of the query result.  stream<record{}, error> resultStream =  mysqlClient -> query(`SELECT * FROM Customers`);   // If there is any error during the execution of the SQL query or  // iteration of the result stream, the result stream will terminate and  // return the error.  error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  });   // The result of the count operation is provided as a record stream.  stream<record{}, error> resultStream2 =  mysqlClient -> query(`SELECT COUNT(*) AS total FROM Customers`);   // Since the above count query will return only a single row,  // the `next()` operation is sufficient to retrieve the data.  record {|record {} value;|}|error? result = resultStream2.next();  // Checks the result and retrieves the value for the total.  if result is record {|record {} value;|} {  io:println(\"Total rows in customer table : \", result.value[\"total\"]);  } // In general cases, the stream will be closed automatically  // when the stream is fully consumed or any error is encountered.  // However, in case if the stream is not fully consumed, the stream  // should be closed specifically.  error? er = resultStream.close();   // The result is returned as a `Customer` record stream and the elements  // of the stream can be either a `Customer` record or an error.  stream<record{}, error> resultStream3 =  mysqlClient->query(`SELECT * FROM Customers`, Customer);   // Casts the generic record type to the `Customer` stream type.  stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream3;   // Iterates the customer stream.  error? e2 = customerStream.forEach(function(Customer customer) {  io:println(\"Full Customer details: \", customer);  });   // Performs the cleanup after the example.  check afterExample(mysqlClient); }  // Initializes the database as a prerequisite to the example. function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");   // Creates a database.  sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);   // Creates a table in the database.  result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);   // Adds the records to the newly-created table.  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers(firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers(firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);   check mysqlClient.close(); }  // Cleans up the database after running the example. function afterExample(mysql:Client mysqlClient) returns sql:Error? {  // Cleans the database.  sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);  // Closes the MySQL client.  check mysqlClient.close(); }    Simple Query  This example demonstrates how to use the MySQL client select query operations  with the stream return type. Note that the MySQL database driver JAR should  be defined in the Ballerina.toml file as a dependency.  For a sample configuration and more information on the underlying module, see the .  The MySQL connector uses database properties from MySQL version 8.0.13 onwards. Therefore, it is  recommended to use a MySQL driver version greater than 8.0.13.    import ballerina/io; import ballerinax/mysql; import ballerina/sql;    type Customer record {|  int customerId;  string lastName;  string firstName;  int registrationId;  float creditLimit;  string country; |};    Defines a record to load the query result schema as shown below in the  ‘getDataWithTypedQuery’ function. In this example, all columns of the  customer table will be loaded. Therefore, the Customer record will be  created with all the columns. The column name of the result and the  defined field name of the record will be matched case insensitively.   public function main() returns error? {    check beforeExample();    Runs the prerequisite setup for the example.   mysql:Client mysqlClient = check new (user = \"root\",  password = \"Test@123\", database = \"MYSQL_BBE\");    Initializes the MySQL client.   stream<record{}, error> resultStream =  mysqlClient -> query(`SELECT * FROM Customers`);    Select the rows in the database table via the query remote operation.  The result is returned as a stream and the elements of the stream can  be either a record or an error. The name and type of the attributes  within the record from the resultStream will be automatically  identified based on the column name and type of the query result.   error? e = resultStream.forEach(function(record {} result) {  io:println(\"Full Customer details: \", result);  });    If there is any error during the execution of the SQL query or  iteration of the result stream, the result stream will terminate and  return the error.   stream<record{}, error> resultStream2 =  mysqlClient -> query(`SELECT COUNT(*) AS total FROM Customers`);    The result of the count operation is provided as a record stream.   record {|record {} value;|}|error? result = resultStream2.next();    Since the above count query will return only a single row,  the next() operation is sufficient to retrieve the data.   if result is record {|record {} value;|} {  io:println(\"Total rows in customer table : \", result.value[\"total\"]);  } Checks the result and retrieves the value for the total.   error? er = resultStream.close();    In general cases, the stream will be closed automatically  when the stream is fully consumed or any error is encountered.  However, in case if the stream is not fully consumed, the stream  should be closed specifically.   stream<record{}, error> resultStream3 =  mysqlClient->query(`SELECT * FROM Customers`, Customer);    The result is returned as a Customer record stream and the elements  of the stream can be either a Customer record or an error.   stream<Customer, sql:Error> customerStream =  <stream<Customer, sql:Error>>resultStream3;    Casts the generic record type to the Customer stream type.   error? e2 = customerStream.forEach(function(Customer customer) {  io:println(\"Full Customer details: \", customer);  });    Iterates the customer stream.   check afterExample(mysqlClient); }    Performs the cleanup after the example.   function beforeExample() returns sql:Error? {  mysql:Client mysqlClient = check new (user = \"root\", password = \"Test@123\");    Initializes the database as a prerequisite to the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`CREATE DATABASE MYSQL_BBE`);    Creates a database.   result = check mysqlClient -> execute(`CREATE TABLE MYSQL_BBE.Customers(customerId INTEGER NOT NULL AUTO_INCREMENT, firstName VARCHAR(300), lastName VARCHAR(300),  registrationID INTEGER, creditLimit DOUBLE, country VARCHAR(300),  PRIMARY KEY (customerId))`);    Creates a table in the database.   result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers(firstName,  lastName, registrationID,creditLimit,country) VALUES ('Peter',  'Stuart', 1, 5000.75, 'USA')`);  result = check mysqlClient -> execute(`INSERT INTO MYSQL_BBE.Customers(firstName,  lastName, registrationID,creditLimit,country) VALUES ('Dan', 'Brown',  2, 10000, 'UK')`);    Adds the records to the newly-created table.   check mysqlClient.close(); }    function afterExample(mysql:Client mysqlClient) returns sql:Error? {    Cleans up the database after running the example.   sql:ExecutionResult result =  check mysqlClient -> execute(`DROP DATABASE MYSQL_BBE`);    Cleans the database.   check mysqlClient.close(); }    Closes the MySQL client.   # Create a Ballerina project. # Copy the example to the project and add relevant database driver jar details to the `Ballerina.toml` file. # Execute the command below to build and run the project. bal run    Full Customer details: {\"customerId\":1,\"firstName\":\"Peter\",\"lastName\":\"Stuart\",\"registrationID\":1,\"creditLimit\":5000.75,\"country\":\"USA\"} Full Customer details: {\"customerId\":2,\"firstName\":\"Dan\",\"lastName\":\"Brown\",\"registrationID\":2,\"creditLimit\":10000.0,\"country\":\"UK\"} Total rows in customer table : 2 Full Customer details: {\"customerId\":1,\"firstName\":\"Peter\",\"lastName\":\"Stuart\",\"registrationId\":1,\"creditLimit\":5000.75,\"country\":\"USA\"} Full Customer details: {\"customerId\":2,\"firstName\":\"Dan\",\"lastName\":\"Brown\",\"registrationId\":2,\"creditLimit\":10000.0,\"country\":\"UK\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-streaming-durable-subscriptions.html","name":"Durable Subscriptions","summary":"This sample demonstrates creating a durable subscription\n in the NATS Streaming server. Regular subscriptions remember\n their position while the client is connected. If the client\n disconnects, the position is lost. Durable subscriptions\n remember their position even if the client is disconnected.\n For more information on the underlying module,\n see the ...","content":"/  /  / Durable Subscriptions  import ballerina/io; import ballerinax/stan;  // Produces a message to a subject in the NATS sever. public function main() returns error? {  string message = \"Hello from Ballerina\";  stan:Client stanClient = check new(stan:DEFAULT_URL);   // Produces a message to the specified subject.  string result = check stanClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result + \" received for the produced message.\");  // Closes the client connection.  check stanClient.close(); } import ballerina/log; import ballerinax/stan;  // Initializes the NATS Streaming listener with a specific client ID. listener stan:Listener lis = new(stan:DEFAULT_URL, clientId = \"c0\");  // Provides the durable name to create a durable subscription. @stan:ServiceConfig {  subject: \"demo\",  durableName: \"sample-name\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Received message: \" + messageData);  }  } }    Durable Subscriptions  This sample demonstrates creating a durable subscription  in the NATS Streaming server. Regular subscriptions remember  their position while the client is connected. If the client  disconnects, the position is lost. Durable subscriptions  remember their position even if the client is disconnected.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/stan;    public function main() returns error? {  string message = \"Hello from Ballerina\";  stan:Client stanClient = check new(stan:DEFAULT_URL);    Produces a message to a subject in the NATS sever.   string result = check stanClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result + \" received for the produced message.\");    Produces a message to the specified subject.   check stanClient.close(); }    Closes the client connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/log; import ballerinax/stan;    listener stan:Listener lis = new(stan:DEFAULT_URL, clientId = \"c0\");    Initializes the NATS Streaming listener with a specific client ID.   @stan:ServiceConfig {  subject: \"demo\",  durableName: \"sample-name\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Provides the durable name to create a durable subscription.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Received message: \" + messageData);  }  } }    Prints the incoming message in the console.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo time = 2021-05-20T13:03:23.344+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    # Stop the subscriber and publish some messages while it is stopped. # Run the subscriber again. # All messages which had been published while the subscriber # wasn't running should be received.    bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo time = 2021-05-20T13:03:46.928+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-basic-request-reply.html","name":"Request/Reply","summary":"The NATS client is used either to produce a message to a subject or consume a message from a subject.\n In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.\n For instructions on installing the NATS ...","content":"/  /  / Request/Reply  import ballerina/io; import ballerinax/nats;  public function main() returns error? {  string message = \"Hello from Ballerina\";  // Initializes a NATS client.  nats:Client natsClient = check new(nats:DEFAULT_URL);   // Sends a request and returns the reply.  nats:Message reply = check natsClient->requestMessage({  content: <@untainted>message.toBytes(),  subject: \"demo.bbe\"});   // Prints the reply message.  string replyContent = check string:fromBytes(reply.content);  io:println(\"Reply message: \" + replyContent);   // Closes the client connection.  check natsClient.close(); } import ballerina/log; import ballerinax/nats;  // Initializes the NATS listener. listener nats:Listener subscription = new(nats:DEFAULT_URL);  // Binds the consumer to listen to the messages published // to the 'demo.bbe' subject. service \"demo.bbe\" on subscription {   remote function onRequest(nats:Message message) returns string {   // Logs the incoming message.  string|error messageContent = string:fromBytes(message.content);  if (messageContent is string) {  log:printInfo(\"Received message: \" + messageContent);  }   // Sends the reply message to the `replyTo` subject  // of the received message.  return \"Hello Back!\";  } }    Request/Reply  The NATS client is used either to produce a message to a subject or consume a message from a subject.  In order to execute this example, it is required that a NATS server is up and running on its default host, port, and cluster.  For instructions on installing the NATS server,  go to .  This is a simple request/reply messaging pattern example.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/nats;    public function main() returns error? {  string message = \"Hello from Ballerina\";    nats:Client natsClient = check new(nats:DEFAULT_URL);    Initializes a NATS client.   nats:Message reply = check natsClient->requestMessage({  content: <@untainted>message.toBytes(),  subject: \"demo.bbe\"});    Sends a request and returns the reply.   string replyContent = check string:fromBytes(reply.content);  io:println(\"Reply message: \" + replyContent);    Prints the reply message.   check natsClient.close(); }    Closes the client connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal    Reply message: Hello Back!    import ballerina/log; import ballerinax/nats;    listener nats:Listener subscription = new(nats:DEFAULT_URL);    Initializes the NATS listener.   service \"demo.bbe\" on subscription {    Binds the consumer to listen to the messages published  to the ‘demo.bbe’ subject.   remote function onRequest(nats:Message message) returns string {    string|error messageContent = string:fromBytes(message.content);  if (messageContent is string) {  log:printInfo(\"Received message: \" + messageContent);  }    Logs the incoming message.   return \"Hello Back!\";  } }    Sends the reply message to the replyTo subject  of the received message.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo.bbe time = 2021-05-19T10:14:09.200+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-streaming-pub-sub.html","name":"Publish/Subscribe","summary":"This sample demonstrates a basic publish/subscribe implementation of the NATS Streaming client\n In order to run this sample, a NATS Streaming server should be\n running on the corresponding port used in the sample.\n For more information on the underlying module,\n see the .Produces a message to a subject in the ...","content":"/  /  / Publish/Subscribe  import ballerina/io; import ballerinax/stan;  // Produces a message to a subject in the NATS sever. public function main() returns error? {  string message = \"Hello from Ballerina\";  stan:Client stanClient = check new(stan:DEFAULT_URL);   // Produces a message to the specified subject.  string result = check stanClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result + \" received for the produced message.\");  // Closes the client connection.  check stanClient.close(); } import ballerina/log; import ballerinax/stan;  // Initializes the NATS Streaming listener. listener stan:Listener lis = new(stan:DEFAULT_URL);  // Binds the consumer to listen to the messages published to the 'demo' subject. @stan:ServiceConfig {  subject: \"demo\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Received message: \" + messageData);  }  } }    Publish/Subscribe  This sample demonstrates a basic publish/subscribe implementation of the NATS Streaming client  In order to run this sample, a NATS Streaming server should be  running on the corresponding port used in the sample.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/stan;    public function main() returns error? {  string message = \"Hello from Ballerina\";  stan:Client stanClient = check new(stan:DEFAULT_URL);    Produces a message to a subject in the NATS sever.   string result = check stanClient->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result + \" received for the produced message.\");    Produces a message to the specified subject.   check stanClient.close(); }    Closes the client connection.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal GUID m2jS6SLLefK325DWTkkwBh received for the produced message.    import ballerina/log; import ballerinax/stan;    listener stan:Listener lis = new(stan:DEFAULT_URL);    Initializes the NATS Streaming listener.   @stan:ServiceConfig {  subject: \"demo\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Received message: \" + messageData);  }  } }    Prints the incoming message in the console.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo time = 2021-05-20T12:51:47.417+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nil.html","name":"Nil","summary":"Ballerina’s version of null is called nil and written as ().\n Ballerina types do not implicitly allow nil.\n Type T? means T or nil. You can use == and != to test whether a value is nil: no implicit coversion to boolean.Here type int? indicates that the value of v ...","content":"/  /  / Nil  import ballerina/io;  // Here type `int?` indicates that the value of `v` can be an `int` or `()`. int? v = ();  // Here the value of `n` annot be `()`. int n = v == () ? 0 : v;  // Elvis operator `x ?: y` returns `x` if it is not `nil` and y otherwise. int m = v ?: 0;  // Falling off the end of a function or `return` by itself is equivalent to `return ()`. function foo() returns () {  return (); }  // Leaving off return type is equivalent to `returns ()`. public function main() {  io:println(v); }    Nil  Ballerina’s version of null is called nil and written as ().  Ballerina types do not implicitly allow nil.  Type T? means T or nil. You can use == and != to test whether a value is nil: no implicit coversion to boolean.    import ballerina/io;    int? v = ();    Here type int? indicates that the value of v can be an int or ().   int n = v == () ? 0 : v;    Here the value of n annot be ().   int m = v ?: 0;    Elvis operator x ?: y returns x if it is not nil and y otherwise.   function foo() returns () {  return (); }    Falling off the end of a function or return by itself is equivalent to return ().   public function main() {  io:println(v); }    Leaving off return type is equivalent to returns ().   bal run nil.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-streaming-queue-group.html","name":"Queue Groups","summary":"This sample demonstrates leveraging the NATS built-in load balancing\n feature called “distributed queues”. All subscribers with the\n same queue name form the queue group.  As messages on the registered\n subject are published, one member of the group is chosen randomly\n to receive the message. Although queue groups have multiple ...","content":"/  /  / Queue Groups  import ballerina/io; import ballerinax/stan;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS Streaming sever. public function main() returns error? {  string message = \"\";  stan:Client publisher = check new(stan:DEFAULT_URL);   while (message != ESCAPE) {  message = io:readln(\"Message: \");  if message != ESCAPE {   // Produces a message to the specified subject.  string result = check publisher->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result +  \" received for the produced message.\");  }  } } import ballerina/log; import ballerinax/stan;  // Initializes the NATS Streaming listeners. listener stan:Listener lis = new(stan:DEFAULT_URL);  // Binds the consumer to listen to the messages published to the 'demo' subject. // Belongs to the queue group named \"sample-queue-group\" @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  }  } }  // Belongs to the queue group named \"sample-queue-group\" @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  }  } }  // Belongs to the queue group named \"sample-queue-group\" @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  }  } }    Queue Groups  This sample demonstrates leveraging the NATS built-in load balancing  feature called “distributed queues”. All subscribers with the  same queue name form the queue group. As messages on the registered  subject are published, one member of the group is chosen randomly  to receive the message. Although queue groups have multiple subscribers,  each message is consumed by only one.  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/stan;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() returns error? {  string message = \"\";  stan:Client publisher = check new(stan:DEFAULT_URL);    Produces a message to a subject in the NATS Streaming sever.   while (message != ESCAPE) {  message = io:readln(\"Message: \");  if message != ESCAPE {    string result = check publisher->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result +  \" received for the produced message.\");  }  } }    Produces a message to the specified subject.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal Message: First Message GUID ywNe3mXd96jFL33ouJbFfg received for the produced message. Message: Second Message GUID ywNe3mXd96jFL33ouJbFkp received for the produced message. Message: Third Message GUID ywNe3mXd96jFL33ouJbFpy received for the produced message.    import ballerina/log; import ballerinax/stan;    listener stan:Listener lis = new(stan:DEFAULT_URL);    Initializes the NATS Streaming listeners.   @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Belongs to the queue group named “sample-queue-group”   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to first queue group member: \"  + messageData);  }  } }    Prints the incoming message in the console.   @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Belongs to the queue group named “sample-queue-group”   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to second queue group member: \"  + messageData);  }  } }    Prints the incoming message in the console.   @stan:ServiceConfig {  subject: \"demo\",  queueGroup: \"sample-queue-group\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Belongs to the queue group named “sample-queue-group”   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to third queue group member: \"  + messageData);  }  } }    Prints the incoming message in the console.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command. # `queue-group.bal` contains three services belonging to the same # queue group. # When several messages are published, it can be noticed that # each message is received by only one queue group member. bal run queue-group.bal Message Received to first queue group member: First Message Message Received to third queue group member: Second Message Message Received to second queue group member: Third Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/object.html","name":"Object","summary":"Object is a separate basic type.\n An object value has named methods and fields.\n Methods and fields are in the same symbol space.\n A class both defines an object type and provides a way to construct an object.\n Apply new operator to a class to get an object.\n Call method ...","content":"/  /  / Object  import ballerina/io;  class MyClass {  int n;   function init(int n) {  self.n = n;  }   function func() {  self.n += 1;  } }  public function main() {  // Apply `new` operator to a class to get an object.  MyClass x = new MyClass(1234);   // Call method using `obj.foo(args)`.  x.func();   // Access field using `obj.x`.  int n = x.n;   io:println(n); }    Object  Object is a separate basic type.  An object value has named methods and fields.  Methods and fields are in the same symbol space.  A class both defines an object type and provides a way to construct an object.  Apply new operator to a class to get an object.  Call method using obj.foo(args).  Access field using obj.x.    import ballerina/io;    class MyClass {  int n;    function init(int n) {  self.n = n;  }    function func() {  self.n += 1;  } }    public function main() {    MyClass x = new MyClass(1234);    Apply new operator to a class to get an object.   x.func();    Call method using obj.foo(args).   int n = x.n;    Access field using obj.x.   io:println(n); }    bal run object.bal 1235    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/open-records.html","name":"Open Records","summary":"Record types are by default open: they allow fields other than those specified. The type of unspecified\n fields are anydata. Records are maps. Open records belongs to map<anydata>. Use quoted keys for\n fields not mentioned in the record type.Person type allows additional fields with anydata values.Employee type allows additional fields ...","content":"/  /  / Open Records  import ballerina/io;  // `Person` type allows additional fields with `anydata` values. type Person record {  string name; };  // `Employee` type allows additional fields with `anydata` values. type Employee record {  string name;  int id; };  // Adds an additional `id` field to `e`. Employee e = {  name: \"James\", id: 10 };  // You can assign an `Employee` type value to a `Person`. Person p = e;  Person p2 = {  name: \"John\", \"country\": \"UK\" };  // You can assign a `Person` type value to a `map`. map<anydata> m = p2;  public function main() {  io:println(p);  io:println(m); }    Open Records  Record types are by default open: they allow fields other than those specified. The type of unspecified  fields are anydata. Records are maps. Open records belongs to map<anydata>. Use quoted keys for  fields not mentioned in the record type.    import ballerina/io;    type Person record {  string name; };    Person type allows additional fields with anydata values.   type Employee record {  string name;  int id; };    Employee type allows additional fields with anydata values.   Employee e = {  name: \"James\", id: 10 };    Adds an additional id field to e.   Person p = e;    You can assign an Employee type value to a Person.   Person p2 = {  name: \"John\", \"country\": \"UK\" };    map<anydata> m = p2;    You can assign a Person type value to a map.   public function main() {  io:println(p);  io:println(m); }    bal run open_records.bal {\"name\":\"James\",\"id\":10} {\"name\":\"John\",\"country\":\"UK\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/nats-streaming-start-position.html","name":"Historical Message Replay","summary":"This sample demonstrates leveraging the historical\n message replay feature of Streaming NATS.\n New subscriptions may specify a starting position in the stream of\n messages stored for the channel of the subscribed subject.\n Message delivery may begin at:\n 1. The earliest message stored for this subject\n 2. The most recently stored ...","content":"/  /  / Historical Message Replay  import ballerina/io; import ballerinax/stan;  // Represents the escape character. const string ESCAPE = \"!q\";  // Produces a message to a subject in the NATS Streaming sever. public function main() returns error? {  string message = \"\";  stan:Client publisher = check new(stan:DEFAULT_URL);   while (message != ESCAPE) {  message = io:readln(\"Message: \");  if message != ESCAPE {   // Produces a message to the specified subject.  string result = check publisher->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result +  \" received for the produced message.\");  }  } } import ballerina/log; import ballerinax/stan;  // Initializes the NATS Streaming listener. listener stan:Listener lis = new(stan:DEFAULT_URL);  // Binds the consumer to listen to the messages published to the 'demo' subject. // By default, only new messages are received. @stan:ServiceConfig {  subject: \"demo\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  }  } }  // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives all the messages from the beginning. @stan:ServiceConfig {  subject: \"demo\",  startPosition: stan:FIRST } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  }  } }  // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages starting from the last received message. @stan:ServiceConfig {  subject: \"demo\",  startPosition: stan:LAST_RECEIVED } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service \" +  \"receiveFromLastReceived: \" + messageData);  }  } }  [stan:SEQUENCE_NUMBER, int] sequenceNo = [stan:SEQUENCE_NUMBER, 3]; // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages starting from the provided sequence number. @stan:ServiceConfig {  subject: \"demo\",  startPosition: sequenceNo } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  }  } }  [stan:TIME_DELTA_START, int] timeDelta = [stan:TIME_DELTA_START, 5]; // Binds the consumer to listen to the messages published to the 'demo' subject. // Receives messages since the provided historical time delta. @stan:ServiceConfig {  subject: \"demo\",  startPosition: timeDelta } service stan:Service on lis {  remote function onMessage(stan:Message message) {  // Prints the incoming message in the console.  string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  }  } }    Historical Message Replay  This sample demonstrates leveraging the historical  message replay feature of Streaming NATS.  New subscriptions may specify a starting position in the stream of  messages stored for the channel of the subscribed subject.  Message delivery may begin at:  1. The earliest message stored for this subject  2. The most recently stored message for this subject  prior to the start of the current subscription.  3. A historical offset from the current server date/time  (e.g., the last 30 seconds).  4. A specific message sequence number  For more information on the underlying module,  see the .    import ballerina/io; import ballerinax/stan;    const string ESCAPE = \"!q\";    Represents the escape character.   public function main() returns error? {  string message = \"\";  stan:Client publisher = check new(stan:DEFAULT_URL);    Produces a message to a subject in the NATS Streaming sever.   while (message != ESCAPE) {  message = io:readln(\"Message: \");  if message != ESCAPE {    string result = check publisher->publishMessage({  content: <@untainted>message.toBytes(),  subject: \"demo\"});  io:println(\"GUID \" + result +  \" received for the produced message.\");  }  } }    Produces a message to the specified subject.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run publisher.bal Message: First Message GUID UBMEgrERHdxZRqUBP05PtD received for the produced message. Message: Second Message GUID UBMEgrERHdxZRqUBP05Puz received for the produced message. Message: Third Message GUID UBMEgrERHdxZRqUBP05Pwl received for the produced message. Message: Forth Message GUID UBMEgrERHdxZRqUBP05PyX received for the produced message.    import ballerina/log; import ballerinax/stan;    listener stan:Listener lis = new(stan:DEFAULT_URL);    Initializes the NATS Streaming listener.   @stan:ServiceConfig {  subject: \"demo\" } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  By default, only new messages are received.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveNewOnly: \"  + messageData);  }  } }    Prints the incoming message in the console.   @stan:ServiceConfig {  subject: \"demo\",  startPosition: stan:FIRST } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives all the messages from the beginning.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveFromBegining: \"  + messageData);  }  } }    Prints the incoming message in the console.   @stan:ServiceConfig {  subject: \"demo\",  startPosition: stan:LAST_RECEIVED } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the last received message.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service \" +  \"receiveFromLastReceived: \" + messageData);  }  } }    Prints the incoming message in the console.   [stan:SEQUENCE_NUMBER, int] sequenceNo = [stan:SEQUENCE_NUMBER, 3];    @stan:ServiceConfig {  subject: \"demo\",  startPosition: sequenceNo } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages starting from the provided sequence number.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveFromGivenIndex: \"  + messageData);  }  } }    Prints the incoming message in the console.   [stan:TIME_DELTA_START, int] timeDelta = [stan:TIME_DELTA_START, 5];    @stan:ServiceConfig {  subject: \"demo\",  startPosition: timeDelta } service stan:Service on lis {  remote function onMessage(stan:Message message) {    Binds the consumer to listen to the messages published to the ‘demo’ subject.  Receives messages since the provided historical time delta.   string|error messageData = string:fromBytes(message.content);  if messageData is string {  log:printInfo(\"Message Received to service receiveSinceTimeDelta: \"  + messageData);  }  } }    Prints the incoming message in the console.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. # When you start the subscriber after publishing several messages, # You'll notice that, # 1. `receiveSinceTimeDelta` service receives the messages if # the messages were sent within a historical offset of 5 seconds # from the current server date/time # 2. `receiveFromGivenIndex` service receives services messages # starting from the third message published. # 3. `receiveFromLastReceived` service receives messages starting # from the last published message. # 4. `receiveFromBeginning` service receives all messages ever # published # 5. `receiveNewOnly` service receives only the messages, which are # published after the subscriber starts.    bal run subscriber.bal    [ballerinax/nats] Client subscribed for subject demo Message Received to service receiveSinceTimeDelta: Third Message Message Received to service receiveFromGivenIndex: Third Message Message Received to service receiveFromLastReceived: Third Message Message Received to service receiveFromBeginning: First Message Message Received to service receiveFromBeginning: Second Message Message Received to service receiveFromBeginning: Third Message Message Received to service receiveFromGivenIndex: Forth Message Message Received to service receiveFromLastReceived: Forth Message Message Received to service receiveNewOnly: Forth Message Message Received to service receiveSinceTimeDelta: Forth Message Message Received to service receiveFromBeginning: Forth Message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/ordering.html","name":"Ordering","summary":"Ordering works consistently with <, <=, >, >= operators. Some comparisons involving\n () and float NaN are considered unordered. order by clause allows expressions not just\n field access. A library module can enable Unicode-aware sorting by providing a\n unicode:sortKey(str, locale) function.The order by clause sorts the output items based on ...","content":"/  /  / Ordering  import ballerina/io;  type Employee record {  string firstName;  string lastName;  decimal salary; };  public function main() {  Employee[] employees = [  {firstName: \"Jones\", lastName: \"Welsh\", salary: 1000.00},  {firstName: \"Anne\", lastName: \"Frank\", salary: 5000.00}  ];   Employee[] sorted = from var e in employees  // The `order by` clause sorts the output items based on the  // given `order-key` and `order-direction`. The `order-key`  // must be an `ordered` type. The `order-direction` is `ascending`  // if not specified explicitly.  order by e.lastName ascending, e.firstName ascending  select e;  io:println(sorted); }    Ordering  Ordering works consistently with <, <=, >, >= operators. Some comparisons involving  () and float NaN are considered unordered. order by clause allows expressions not just  field access. A library module can enable Unicode-aware sorting by providing a  unicode:sortKey(str, locale) function.    import ballerina/io;    type Employee record {  string firstName;  string lastName;  decimal salary; };    public function main() {  Employee[] employees = [  {firstName: \"Jones\", lastName: \"Welsh\", salary: 1000.00},  {firstName: \"Anne\", lastName: \"Frank\", salary: 5000.00}  ];    Employee[] sorted = from var e in employees    order by e.lastName ascending, e.firstName ascending  select e;  io:println(sorted); }    The order by clause sorts the output items based on the  given order-key and order-direction. The order-key  must be an ordered type. The order-direction is ascending  if not specified explicitly.   bal run ordering.bal [{\"firstName\":\"Anne\",\"lastName\":\"Frank\",\"salary\":5000.00},{\"firstName\":\"Jones\",\"lastName\":\"Welsh\",\"salary\":1000.00}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/panics.html","name":"Panics","summary":"Ballerina distinguishes normal errors from abnormal errors.\n Normal errors are handled by returning error values.\n Abnormal errors are handled using the panic statement.\n Abnormal errors should typically result in immediate program termination.\n e.g., programming bug or out of memory\n A panic has an associated error value.n must not be 0.Panic ...","content":"/  /  / Panics  import ballerina/io;  // `n` must not be `0`. function divide(int m, int n) returns int {  if n == 0 {  // Panic if `n` is `0`.  panic error(\"division by 0\");  }  return m/n; }  public function main() {  int x = divide(1, 0);   // Since `divide(1, 0)` panics, the program will  // terminate and the following code will not be  // executed.  io:println(x); }    Panics  Ballerina distinguishes normal errors from abnormal errors.  Normal errors are handled by returning error values.  Abnormal errors are handled using the panic statement.  Abnormal errors should typically result in immediate program termination.  e.g., programming bug or out of memory  A panic has an associated error value.    import ballerina/io;    function divide(int m, int n) returns int {  if n == 0 {    n must not be 0.   panic error(\"division by 0\");  }  return m/n; }    Panic if n is 0.   public function main() {  int x = divide(1, 0);    io:println(x); }    Since divide(1, 0) panics, the program will  terminate and the following code will not be  executed.   bal run panics.bal error: division by 0  at panics:divide(panics.bal:7)  panics:main(panics.bal:13)    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/plain-data.html","name":"Plain Data","summary":"Ballerina has concept of “plain data”: data that is independent of any specific code operating on the data.\n The network interfaces between programs are based on plain data. It is the opposite of objects, which combine\n data and code. Plain data supports deep copy and deep equality. Plain data supports ...","content":"/  /  / Plain Data  Plain Data  Ballerina has concept of “plain data”: data that is independent of any specific code operating on the data.  The network interfaces between programs are based on plain data. It is the opposite of objects, which combine  data and code. Plain data supports deep copy and deep equality. Plain data supports serialization/deserialization  without coupling. Key goal of Ballerina is to facilitate programs that work on plain data.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/programs-and-modules.html","name":"Programs and Modules","summary":"Every Ballerina program consists of modules. Modules are one or more .bal files.\n Module names take the form org/x.y.z.This import declaration binds the prefix io to the ballerina/io module.\n The prefix by default comes form the last part of the module name.\n The ballerina org name is reserved for the ...","content":"/  /  / Programs and Modules  // This import declaration binds the prefix `io` to the `ballerina/io` module. // The prefix by default comes form the last part of the module name. // The `ballerina` org name is reserved for the standard library modules. import ballerina/io;  // `main` function is the program entry point. // `public` makes function visible outside the module. public function main() {  // Here `io:println` means function `println` is in module bound to prefix `io`  io:println(\"Hello, World!\"); }    Programs and Modules  Every Ballerina program consists of modules. Modules are one or more .bal files.  Module names take the form org/x.y.z.    import ballerina/io;    This import declaration binds the prefix io to the ballerina/io module.  The prefix by default comes form the last part of the module name.  The ballerina org name is reserved for the standard library modules.   public function main() {    main function is the program entry point.  public makes function visible outside the module.   io:println(\"Hello, World!\"); }    Here io:println means function println is in module bound to prefix io   bal run programs_and_modules.bal Hello, World!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/querying-tables.html","name":"Querying Tables","summary":"Tables can be nicely combined with query expressions unlike maps. Basic type of the output of\n query expression is determined by the contextually expected type and the input type.from clause iterates employees table.\n The contextually expected type of the query expression is an int[].This website uses cookies so that we ...","content":"/  /  / Querying Tables  import ballerina/io;  type Employee record {|  readonly int id;  string firstName;  string lastName;  int salary; |};  public function main() {  table<Employee> key(id) employees = table [  {id: 1, firstName: \"John\", lastName: \"Smith\", salary: 100},  {id: 2, firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}  ];   // `from` clause iterates `employees` `table`.  // The contextually expected type of the `query expression` is an `int[]`.  int[] salaries = from var {salary} in employees  select salary;  io:println(salaries); }    Querying Tables  Tables can be nicely combined with query expressions unlike maps. Basic type of the output of  query expression is determined by the contextually expected type and the input type.    import ballerina/io;    type Employee record {|  readonly int id;  string firstName;  string lastName;  int salary; |};    public function main() {  table<Employee> key(id) employees = table [  {id: 1, firstName: \"John\", lastName: \"Smith\", salary: 100},  {id: 2, firstName: \"Fred\", lastName: \"Bloggs\", salary: 200}  ];    int[] salaries = from var {salary} in employees  select salary;  io:println(salaries); }    from clause iterates employees table.  The contextually expected type of the query expression is an int[].   bal run querying_tables.bal [100,200]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/query-expressions.html","name":"Query Expressions","summary":"Query-like expressions start with from clause and end with select clause. It is a\n list comprehension, based on mathematical “set builder” notation.The from clause works similar to a foreach statement.The select clause is evaluated for each iteration.This is based on \n { 10 × i | i ∈ nums } ...","content":"/  /  / Query Expressions  import ballerina/io;  public function main() {  int[] nums = [1, 2, 3, 4];   // The `from` clause works similar to a `foreach` statement.  int[] numsTimes10 = from var i in nums  // The `select` clause is evaluated for each iteration.  select i * 10;  io:println(numsTimes10);   // This is based on <br></br>  // `{ 10 × i | i ∈ nums }` <br></br>  // `{ i | i mod 2 = 0, i ∈ nums }` <br></br>  // set builder notation.  int[] evenNums = from var i in nums  where i % 2 == 0  select i;  io:println(evenNums); }    Query Expressions  Query-like expressions start with from clause and end with select clause. It is a  list comprehension, based on mathematical “set builder” notation.    import ballerina/io;    public function main() {  int[] nums = [1, 2, 3, 4];    int[] numsTimes10 = from var i in nums    The from clause works similar to a foreach statement.   select i * 10;  io:println(numsTimes10);    The select clause is evaluated for each iteration.   int[] evenNums = from var i in nums  where i % 2 == 0  select i;  io:println(evenNums); }    This is based on { 10 × i | i ∈ nums } { i | i mod 2 = 0, i ∈ nums } set builder notation.   bal run query_expressions.bal [10,20,30,40] [2,4]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/querying-with-streams.html","name":"Querying With Streams","summary":"If stream terminates with error, result of query expression is an error. You cannot use foreach\n on stream type with termination type that allows error. Instead use from with do clause; the\n result is a subtype of error?. Use stream keyword in front of from to create a stream which ...","content":"/  /  / Querying With Streams  type Error error;  type LS stream<string, Error?>;  // This method strips the blank lines. function strip(LS lines) returns LS {  // Creates a `stream` from `query expression`.  LS res = stream from var line in lines  where line.trim().length() > 0  select line;  return res; }  function count(LS lines) returns int|Error {  int nLines = 0;  // Counts the number of lines by iterating the `stream`  // in `query action`.  var res = check from var line in lines  do {  nLines += 1;  };  return nLines; }    Querying With Streams  If stream terminates with error, result of query expression is an error. You cannot use foreach  on stream type with termination type that allows error. Instead use from with do clause; the  result is a subtype of error?. Use stream keyword in front of from to create a stream which is  lazily evaluated. The failure of check within the query will cause the stream to produce an  error termination value.    type Error error;    type LS stream<string, Error?>;    function strip(LS lines) returns LS {    This method strips the blank lines.   LS res = stream from var line in lines  where line.trim().length() > 0  select line;  return res; }    Creates a stream from query expression.   function count(LS lines) returns int|Error {  int nLines = 0;    var res = check from var line in lines  do {  nLines += 1;  };  return nLines; }    Counts the number of lines by iterating the stream  in query action.   bal run querying_with_streams.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/rabbitmq-consumer-with-client-acknowledgement.html","name":"Client Acknowledgements","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The received messages are acknowledged manually.\n By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge\n all messages once consumed.\n For more information on the underlying module,\n see the .The consumer service listens ...","content":"/  /  / Client Acknowledgements  import ballerina/log; import ballerinax/rabbitmq;  listener rabbitmq:Listener channelListener =  new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);  // The consumer service listens to the \"MyQueue\" queue. // The `ackMode` is by default rabbitmq:AUTO_ACK where messages are acknowledged // immediately after consuming. @rabbitmq:ServiceConfig {  queueName: \"MyQueue\" } // Attaches the service to the listener. service rabbitmq:Service on channelListener {  remote function onMessage(rabbitmq:Message message,  rabbitmq:Caller caller) {  string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }   // Positively acknowledges a single message.  rabbitmq:Error? result = caller->basicAck();  } }    Client Acknowledgements  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The received messages are acknowledged manually.  By default, the ackMode is rabbitmq:AUTO_ACK, which will automatically acknowledge  all messages once consumed.  For more information on the underlying module,  see the .    import ballerina/log; import ballerinax/rabbitmq;    listener rabbitmq:Listener channelListener =  new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);    @rabbitmq:ServiceConfig {  queueName: \"MyQueue\" }    The consumer service listens to the “MyQueue” queue.  The ackMode is by default rabbitmq:AUTO_ACK where messages are acknowledged  immediately after consuming.   service rabbitmq:Service on channelListener {  remote function onMessage(rabbitmq:Message message,  rabbitmq:Caller caller) {  string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }    Attaches the service to the listener.   rabbitmq:Error? result = caller->basicAck();  } }    Positively acknowledges a single message.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer_with_client_acknowledgement.bal' file and runthe 'bal run' command below.    bal run rabbitmq_consumer_with_client_acknowledgement.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    [ballerinax/rabbitmq] Consumer service started for queue MyQueue time = 2021-05-20T14:53:56.067+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/rabbitmq-consumer.html","name":"Consumer","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener.\n The Ballerina RabbitMQ connection used here can be re-used to create\n multiple channels.\n Multiple services consuming messages from the same queue or from\n different queues can be attached to the same Listener.\n For ...","content":"/  /  / Consumer  import ballerina/log; import ballerinax/rabbitmq;  listener rabbitmq:Listener channelListener =  new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);  // The consumer service listens to the \"MyQueue\" queue. // The `ackMode` is by default rabbitmq:AUTO_ACK where messages are acknowledged // immediately after consuming. @rabbitmq:ServiceConfig {  queueName: \"MyQueue\" } // Attaches the service to the listener. service rabbitmq:Service on channelListener {  remote function onMessage(rabbitmq:Message message) {  string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }  } }    Consumer  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener.  The Ballerina RabbitMQ connection used here can be re-used to create  multiple channels.  Multiple services consuming messages from the same queue or from  different queues can be attached to the same Listener.  For more information on the underlying module,  see the .    import ballerina/log; import ballerinax/rabbitmq;    listener rabbitmq:Listener channelListener =  new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);    @rabbitmq:ServiceConfig {  queueName: \"MyQueue\" }    The consumer service listens to the “MyQueue” queue.  The ackMode is by default rabbitmq:AUTO_ACK where messages are acknowledged  immediately after consuming.   service rabbitmq:Service on channelListener {  remote function onMessage(rabbitmq:Message message) {  string|error messageContent = string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"Received message: \" + messageContent);  }  } }    Attaches the service to the listener.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_consumer.bal' file, and run the 'bal run' command below.    bal run rabbitmq_consumer.bal    # The RabbitMQ consumer runs as a Ballerina service and listens to the subscribed queue.    [ballerinax/rabbitmq] Consumer service started for queue MyQueue time = 2021-05-20T14:49:11.011+05:30 level = INFO module = \"\" message = \"Received message: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/rabbitmq-producer.html","name":"Producer","summary":"In this example, messages are sent to two different queues,\n to one queue using the same channel and to the other using two different channels.\n For more information on the underlying module,\n see the .Creates a ballerina RabbitMQ client.Declares the queue, MyQueue.Publishing messages to an exchange using a routing key.\n ...","content":"/  /  / Producer  import ballerinax/rabbitmq;  public function main() returns error? {  // Creates a ballerina RabbitMQ client.  rabbitmq:Client newClient =  check new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);   // Declares the queue, MyQueue.  check newClient->queueDeclare(\"MyQueue\");   // Publishing messages to an exchange using a routing key.  // Publishes the message using newClient and the routing key named MyQueue.  string message = \"Hello from Ballerina\";  check newClient->publishMessage({ content: message.toBytes(),  routingKey: \"MyQueue\" }); }    Producer  In this example, messages are sent to two different queues,  to one queue using the same channel and to the other using two different channels.  For more information on the underlying module,  see the .    import ballerinax/rabbitmq;    public function main() returns error? {    rabbitmq:Client newClient =  check new(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);    Creates a ballerina RabbitMQ client.   check newClient->queueDeclare(\"MyQueue\");    Declares the queue, MyQueue.   string message = \"Hello from Ballerina\";  check newClient->publishMessage({ content: message.toBytes(),  routingKey: \"MyQueue\" }); }    Publishing messages to an exchange using a routing key.  Publishes the message using newClient and the routing key named MyQueue.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_producer.bal' file, and run the 'bal run' command below.    bal run rabbitmq_producer.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/rabbitmq-transaction-consumer.html","name":"SASL Authentication - Consumer","summary":"In this example, the messages are consumed from an\n existing queue using the Ballerina RabbitMQ message listener\n and Ballerina transactions.\n Upon successful execution of the transaction block,\n the acknowledgement will commit or rollback in the case of any error.\n Messages will not be re-queued in the case of a rollback\n ...","content":"/  /  / SASL Authentication - Consumer  import ballerina/log; import ballerinax/rabbitmq;  // The consumer service listens to the \"MyQueue\" queue. @rabbitmq:ServiceConfig {  queueName: \"MyQueue\",  autoAck: false } // Attaches the service to the listener. service /transactionConsumer on  new rabbitmq:Listener(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT) {   // Gets triggered when a message is received by the queue.  remote function onMessage(rabbitmq:Message message,  rabbitmq:Caller caller) {   string|error messageContent = 'string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"The message received: \" + messageContent);  }   // Acknowledges a single message positively.  // The acknowledgement gets committed upon successful execution of the transaction,  // or will rollback otherwise.  transaction {  rabbitmq:Error? result = caller->basicAck();  if (result is error) {  log:printError(  \"Error occurred while acknowledging the message.\");  }  var res = commit;  }  } }    SASL Authentication - Consumer  In this example, the messages are consumed from an  existing queue using the Ballerina RabbitMQ message listener  and Ballerina transactions.  Upon successful execution of the transaction block,  the acknowledgement will commit or rollback in the case of any error.  Messages will not be re-queued in the case of a rollback  automatically unless negatively acknowledged by the user.  For more information on the underlying module,  see the .    import ballerina/log; import ballerinax/rabbitmq;    @rabbitmq:ServiceConfig {  queueName: \"MyQueue\",  autoAck: false }    The consumer service listens to the “MyQueue” queue.   service /transactionConsumer on  new rabbitmq:Listener(rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT) {    Attaches the service to the listener.   remote function onMessage(rabbitmq:Message message,  rabbitmq:Caller caller) {    Gets triggered when a message is received by the queue.   string|error messageContent = 'string:fromBytes(message.content);  if messageContent is string {  log:printInfo(\"The message received: \" + messageContent);  }    transaction {  rabbitmq:Error? result = caller->basicAck();  if (result is error) {  log:printError(  \"Error occurred while acknowledging the message.\");  }  var res = commit;  }  } }    Acknowledges a single message positively.  The acknowledgement gets committed upon successful execution of the transaction,  or will rollback otherwise.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_transaction_consumer.bal' file, and run the 'bal run' command below.    bal run rabbitmq_transaction_consumer.bal    # The RabbitMQ transaction consumer runs as a Ballerina service and listens to the subscribed queue.    [ballerina/http] started HTTP/WS listener 192.168.1.2:51642 [ballerinax/rabbitmq] Consumer service started for queue MyQueue time = 2021-01-18 15:15:36,514 level = INFO module = \"\" message = \"The message received: Hello from Ballerina\"    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/rabbitmq-transaction-producer.html","name":"Transactional Producer","summary":"In this example, a message is sent to an existing queue\n using the Ballerina RabbitMQ channel and Ballerina transactions.\n Upon successful execution of the transaction block,\n the channel will commit and rollback in the case of any error.\n For more information on the underlying module,\n see the .Creates a ballerina ...","content":"/  /  / Transactional Producer  import ballerinax/rabbitmq;  public function main() returns error? {  // Creates a ballerina RabbitMQ Client.  rabbitmq:Client newClient =  check new (rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);   // Declares the queue.  check newClient->queueDeclare(\"MyQueue\");  transaction {  string message = \"Hello from Ballerina\";  // Publishes the message using the routing key named \"MyQueue\".  check newClient->publishMessage({ content: message.toBytes(),  routingKey: \"MyQueue\" });  var result = commit;  } }    Transactional Producer  In this example, a message is sent to an existing queue  using the Ballerina RabbitMQ channel and Ballerina transactions.  Upon successful execution of the transaction block,  the channel will commit and rollback in the case of any error.  For more information on the underlying module,  see the .    import ballerinax/rabbitmq;    public function main() returns error? {    rabbitmq:Client newClient =  check new (rabbitmq:DEFAULT_HOST, rabbitmq:DEFAULT_PORT);    Creates a ballerina RabbitMQ Client.   check newClient->queueDeclare(\"MyQueue\");  transaction {  string message = \"Hello from Ballerina\";    Declares the queue.   check newClient->publishMessage({ content: message.toBytes(),  routingKey: \"MyQueue\" });  var result = commit;  } }    Publishes the message using the routing key named “MyQueue”.   # Make sure to have the RabbitMQ broker running. # # Navigate to the directory that contains the # 'rabbitmq_transaction_producer.bal' file, and run the 'bal run' command below.    $ bal run rabbitmq_transaction_producer.bal    [ballerina/http] started HTTP/WS listener 192.168.1.2:51659    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/random-numbers.html","name":"Random Numbers","summary":"The random library provides functions related to random number generation.\n For more information on the underlying module,\n see the .Generates a random decimal number between 0.0 and 1.0.Generates a random number between the given start(inclusive) and end(exclusive) values.This website uses cookies so that we can provide you with the best ...","content":"/  /  / Random Numbers  import ballerina/io; import ballerina/random;  public function main() returns error? {  // Generates a random decimal number between 0.0 and 1.0.  float randomDecimal = random:createDecimal();  io:println(\"Random decimal number: \", randomDecimal);   // Generates a random number between the given start(inclusive) and end(exclusive) values.  int randomInteger = check random:createIntInRange(1, 100);  io:println(\"Random integer number in range: \", randomInteger); }    Random Numbers  The random library provides functions related to random number generation.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/random;    public function main() returns error? {    float randomDecimal = random:createDecimal();  io:println(\"Random decimal number: \", randomDecimal);    Generates a random decimal number between 0.0 and 1.0.   int randomInteger = check random:createIntInRange(1, 100);  io:println(\"Random integer number in range: \", randomInteger); }    Generates a random number between the given start(inclusive) and end(exclusive) values.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run random_numbers.bal Random decimal number: 0.6146990788006506 Random integer number in range: 94    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/readonly-and-isolated.html","name":"Readonly and Isolated","summary":"isolated functions can access final variables with readonly type without locking. Relies on the fact that\n immutability is deep. isolated for functions complements readonly for data.Accesses m directly without locking.This website uses cookies so that we can provide you with the best user experience. Read our  to find out ...","content":"/  /  / Readonly and Isolated  import ballerina/io;  type Entry map<json>; type RoMap readonly & map<Entry>;  final RoMap m = loadMap();  function loadMap() returns RoMap {  readonly & Entry entry1 = {  \"munich\": {latitude: \"48.1351N\", longtitude: \"11.5820E\"},  \"berlin\": {latitude: \"52.5200N\", longtitude: \"13.4050E\"}  };  readonly & Entry entry2 = {  \"bordeaux\": {latitude: \"44.8378N\", longtitude: \"0.5792W\"},  \"paris\": {latitude: \"48.8566N\", longtitude: \"2.3522E\"}  };  RoMap roMap = {\"germany\": entry1, \"france\": entry2};  return roMap; }  isolated function lookup(string s) returns readonly & Entry? {  // Accesses `m` directly without locking.  return m[s]; }  public function main() {  io:println(lookup(\"france\")); }    Readonly and Isolated  isolated functions can access final variables with readonly type without locking. Relies on the fact that  immutability is deep. isolated for functions complements readonly for data.    import ballerina/io;    type Entry map<json>; type RoMap readonly & map<Entry>;    final RoMap m = loadMap();    function loadMap() returns RoMap {  readonly & Entry entry1 = {  \"munich\": {latitude: \"48.1351N\", longtitude: \"11.5820E\"},  \"berlin\": {latitude: \"52.5200N\", longtitude: \"13.4050E\"}  };  readonly & Entry entry2 = {  \"bordeaux\": {latitude: \"44.8378N\", longtitude: \"0.5792W\"},  \"paris\": {latitude: \"48.8566N\", longtitude: \"2.3522E\"}  };  RoMap roMap = {\"germany\": entry1, \"france\": entry2};  return roMap; }    isolated function lookup(string s) returns readonly & Entry? {    return m[s]; }    Accesses m directly without locking.   public function main() {  io:println(lookup(\"france\")); }    bal run readonly_and_isolated.bal {\"bordeaux\":{\"latitude\":\"44.8378N\",\"longtitude\":\"0.5792W\"},\"paris\":{\"latitude\":\"48.8566N\",\"longtitude\":\"2.3522E\"}}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/readonly-type.html","name":"Readonly Type","summary":"The readonly type consists of values that are immutable. For structural type T, T & readonly means\n immutable T. T & readonly is subtype of T and subtype of readonly. Guaranteed that if declared\n type of a value is a subtype of readonly, then at runtime the value can never ...","content":"/  /  / Readonly Type  import ballerina/io;  // Value of `s` is an immutable array. readonly & string[] s = [  \"foo\", \"bar\" ];  type Row record {  // Both field and its value are immutable.  readonly string[] k;  int value; };  table<Row> key(k) t = table [  // Can safely use `s` as a key.  { k: s, value: 17 } ];  public function main() {  io:println(t); }    Readonly Type  The readonly type consists of values that are immutable. For structural type T, T & readonly means  immutable T. T & readonly is subtype of T and subtype of readonly. Guaranteed that if declared  type of a value is a subtype of readonly, then at runtime the value can never be mutated. It is enforced  by runtime checks on the mutating structures. With readonly field, both the field and its value  are immutable.    import ballerina/io;    readonly & string[] s = [  \"foo\", \"bar\" ];    Value of s is an immutable array.   type Row record {    readonly string[] k;  int value; };    Both field and its value are immutable.   table<Row> key(k) t = table [    { k: s, value: 17 } ];    Can safely use s as a key.   public function main() {  io:println(t); }    bal run readonly_type.bal [{\"k\":[\"foo\",\"bar\"],\"value\":17}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/raw-templates.html","name":"Raw Templates","summary":"A raw template is a backtick template without a tag. Exposes result of phase 1 without further processing.\n Raw template is evaluated by evaluating each expression and creating an object containing. \n - an array of the strings separated by insertions. \n - an array of the results of expression ...","content":"/  /  / Raw Templates  import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;  jdbc:Client dbClient = check new (url = \"jdbc:h2:file:./master/orderdb\",  user = \"test\", password = \"test\");  public function main() returns error? {  // Uses a raw template to create `Orders` table.  _ = check dbClient->execute(`CREATE TABLE IF NOT EXISTS Orders  (orderId INTEGER NOT NULL IDENTITY,  customerId INTEGER, noOfItems INTEGER,  PRIMARY KEY (orderId))`);  // Uses a raw template to insert values to `Orders` table.  _ = check dbClient->execute(`INSERT INTO Orders (orderId, customerId, noOfItems)  VALUES (1, 1, 20)`);  _ = check dbClient->execute(`INSERT INTO Orders (orderId, customerId, noOfItems)  VALUES (2, 1, 15)`);   stream<record {| anydata...; |}, sql:Error?> strm = getOrders(1);  record {|record {} value;|}|sql:Error? v = strm.next();  while (v is record {|record {} value;|}) {  record {} value = v.value;  io:println(value);  v = strm.next();  } }  function getOrders(int customerId) returns stream<record {| anydata...; |}, sql:Error?> {  // In this raw template `customerId` variable is interpolated in the literal.  return dbClient->query(`SELECT * FROM orders  WHERE customerId = ${customerId}`); }    Raw Templates  A raw template is a backtick template without a tag. Exposes result of phase 1 without further processing.  Raw template is evaluated by evaluating each expression and creating an object containing. - an array of the strings separated by insertions. - an array of the results of expression evaluation and an array of strings separating. Important use case: SQL parameters.    import ballerina/io; import ballerinax/java.jdbc; import ballerina/sql;    jdbc:Client dbClient = check new (url = \"jdbc:h2:file:./master/orderdb\",  user = \"test\", password = \"test\");    public function main() returns error? {    _ = check dbClient->execute(`CREATE TABLE IF NOT EXISTS Orders  (orderId INTEGER NOT NULL IDENTITY,  customerId INTEGER, noOfItems INTEGER,  PRIMARY KEY (orderId))`);    Uses a raw template to create Orders table.   _ = check dbClient->execute(`INSERT INTO Orders (orderId, customerId, noOfItems)  VALUES (1, 1, 20)`);  _ = check dbClient->execute(`INSERT INTO Orders (orderId, customerId, noOfItems)  VALUES (2, 1, 15)`);    Uses a raw template to insert values to Orders table.   stream<record {| anydata...; |}, sql:Error?> strm = getOrders(1);  record {|record {} value;|}|sql:Error? v = strm.next();  while (v is record {|record {} value;|}) {  record {} value = v.value;  io:println(value);  v = strm.next();  } }    function getOrders(int customerId) returns stream<record {| anydata...; |}, sql:Error?> {    return dbClient->query(`SELECT * FROM orders  WHERE customerId = ${customerId}`); }    In this raw template customerId variable is interpolated in the literal.   bal run raw_templates.bal {\"ORDERID\":1,\"CUSTOMERID\":1,\"NOOFITEMS\":20} {\"ORDERID\":2,\"CUSTOMERID\":1,\"NOOFITEMS\":15}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/records.html","name":"Records","summary":"A record type has specific named fields. Fields can be accessed with r.x. Records are mutable: r.x is an\n lvalue. Records can be constructed using a similar syntax to a map. Typically a record type is combined\n with a type definition. The name of the type is not significant: a ...","content":"/  /  / Records  import ballerina/io;  // Defines a record type named `Coord`. type Coord record {  int x;  int y; };  public function main() {  // Creates a `record`, specifying values for its fields.  record { int x; int y; } r = {  x: 1,  y: 2  };   // Creates a `Coord` record.  Coord c = {  x: 1,  y: 2  };   // a will be 2  int a = r.y;  // b will be 1.  int b = c.x; }    Records  A record type has specific named fields. Fields can be accessed with r.x. Records are mutable: r.x is an  lvalue. Records can be constructed using a similar syntax to a map. Typically a record type is combined  with a type definition. The name of the type is not significant: a record is just a collection of fields.  Record equality works same as map equality.    import ballerina/io;    type Coord record {  int x;  int y; };    Defines a record type named Coord.   public function main() {    record { int x; int y; } r = {  x: 1,  y: 2  };    Creates a record, specifying values for its fields.   Coord c = {  x: 1,  y: 2  };    Creates a Coord record.   int a = r.y;    a will be 2   int b = c.x; }    b will be 1.   bal run records.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/receive-email-using-listener.html","name":"Receive Emails Using a Listener","summary":"The email listener is used to receive (with POP3 or IMAP4) emails\n using the SSL or STARTTLS protocols. This sample includes receiving\n emails from a listener with default configurations over SSL using\n the default ports.\n For more information on the underlying module,\n see the .Creates the listener with the connection ...","content":"/  /  / Receive Emails Using a Listener  import ballerina/email; import ballerina/io;  // Creates the listener with the connection parameters and the protocol-related // configuration. The polling interval specifies the time duration between each // poll performed by the listener in seconds. listener email:PopListener emailListener = check new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  pollingInterval: 2,  port: 995 });  // One or many services can listen to the email listener for the // periodically-polled emails. service \"emailObserver\" on emailListener {   // When an email is successfully received, the `onMessage` method is  // called.  remote function onMessage(email:Message emailMessage) {  io:println(\"POP Listener received an email.\");  io:println(\"Email Subject: \", emailMessage.subject);  io:println(\"Email Body: \", emailMessage?.body);  }   // When an error occurs during the email poll operations, the `onError`  // method is called.  remote function onError(email:Error emailError) {  io:println(\"Error while polling for the emails: \"  + emailError.message());  }   // When the listener is closed, the `onClose` method is called.  remote function onClose(email:Error? closeError) {  io:println(\"Closed the listener.\");  }  }    Receive Emails Using a Listener  The email listener is used to receive (with POP3 or IMAP4) emails  using the SSL or STARTTLS protocols. This sample includes receiving  emails from a listener with default configurations over SSL using  the default ports.  For more information on the underlying module,  see the .    import ballerina/email; import ballerina/io;    listener email:PopListener emailListener = check new ({  host: \"pop.email.com\",  username: \"reader@email.com\",  password: \"pass456\",  pollingInterval: 2,  port: 995 });    Creates the listener with the connection parameters and the protocol-related  configuration. The polling interval specifies the time duration between each  poll performed by the listener in seconds.   service \"emailObserver\" on emailListener {    One or many services can listen to the email listener for the  periodically-polled emails.   remote function onMessage(email:Message emailMessage) {  io:println(\"POP Listener received an email.\");  io:println(\"Email Subject: \", emailMessage.subject);  io:println(\"Email Body: \", emailMessage?.body);  }    When an email is successfully received, the onMessage method is  called.   remote function onError(email:Error emailError) {  io:println(\"Error while polling for the emails: \"  + emailError.message());  }    When an error occurs during the email poll operations, the onError  method is called.   remote function onClose(email:Error? closeError) {  io:println(\"Closed the listener.\");  }    When the listener is closed, the onClose method is called.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run email.bal    # Subject and the content body of the listened emails will be printed for each # of the polled emails.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/receive-email-using-client.html","name":"Receive Emails Using a Client","summary":"The email client is used to receive (with POP3 or IMAP4) emails\n using the SSL or STARTTLS protocols. This sample includes receiving\n emails with default configurations over SSL using the default\n ports.\n For more information on the underlying module,\n see the .Creates the client with the connection parameters, host, username, ...","content":"/  /  / Receive Emails Using a Client  import ballerina/email; import ballerina/io;  public function main() returns error? {  // Creates the client with the connection parameters, host, username, and  // password. An error is returned in a failure. The default port number  // `995` is used over SSL with these configurations.  email:PopClient popClient = check new (\"pop.email.com\", \"reader@email.com\",  \"pass456\");   // Reads the first unseen email received by the POP3 server. `()` is  // returned when there are no new unseen emails. In error cases, an  // error is returned.  email:Message? emailResponse = check popClient->receiveMessage();   if (emailResponse is email:Message) {  io:println(\"POP client received an email.\");  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse?.body);  // When no emails are available in the server, `()` is returned.  } else {  io:println(\"There are no emails in the INBOX.\");  }   // Closes the POP3 store, which would close the TCP connection.  email:Error? closeStatus = popClient->close();   // Creates the client with the connection parameters, host, username, and  // password. An error is received in a failure. The default port number  // `993` is used over SSL with these configurations.  email:ImapClient imapClient = check new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");   // Reads the first unseen email received by the IMAP4 server. `()` is  // returned when there are no new unseen emails. In error cases, an  // error is returned.  emailResponse = check imapClient->receiveMessage();   if (emailResponse is email:Message) {  io:println(\"IMAP client received an email.\");  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse?.body);  // When no emails are available in the server, `()` is returned.  } else {  io:println(\"There are no emails in the INBOX.\");  }   // Closes the IMAP store which would close the TCP connection.  closeStatus = imapClient->close();  }    Receive Emails Using a Client  The email client is used to receive (with POP3 or IMAP4) emails  using the SSL or STARTTLS protocols. This sample includes receiving  emails with default configurations over SSL using the default  ports.  For more information on the underlying module,  see the .    import ballerina/email; import ballerina/io;    public function main() returns error? {    email:PopClient popClient = check new (\"pop.email.com\", \"reader@email.com\",  \"pass456\");    Creates the client with the connection parameters, host, username, and  password. An error is returned in a failure. The default port number  995 is used over SSL with these configurations.   email:Message? emailResponse = check popClient->receiveMessage();    Reads the first unseen email received by the POP3 server. () is  returned when there are no new unseen emails. In error cases, an  error is returned.   if (emailResponse is email:Message) {  io:println(\"POP client received an email.\");  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse?.body);    } else {  io:println(\"There are no emails in the INBOX.\");  }    When no emails are available in the server, () is returned.   email:Error? closeStatus = popClient->close();    Closes the POP3 store, which would close the TCP connection.   email:ImapClient imapClient = check new (\"imap.email.com\",  \"reader@email.com\", \"pass456\");    Creates the client with the connection parameters, host, username, and  password. An error is received in a failure. The default port number  993 is used over SSL with these configurations.   emailResponse = check imapClient->receiveMessage();    Reads the first unseen email received by the IMAP4 server. () is  returned when there are no new unseen emails. In error cases, an  error is returned.   if (emailResponse is email:Message) {  io:println(\"IMAP client received an email.\");  io:println(\"Email Subject: \", emailResponse.subject);  io:println(\"Email Body: \", emailResponse?.body);    } else {  io:println(\"There are no emails in the INBOX.\");  }    When no emails are available in the server, () is returned.   closeStatus = imapClient->close();    Closes the IMAP store which would close the TCP connection.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run email.bal    # Subject and the content body of the received emails would be printed.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/regular-expressions.html","name":"Regular Expressions","summary":"The regex library provides functionalities for searching, splitting, and replacing\n the set of characters of the string by using the regular expression.\n For more information on the underlying module,\n see the .Checks whether the given string matches the provided regex.\n You need to provide the original string and the regex ...","content":"/  /  / Regular Expressions  import ballerina/io; import ballerina/regex;  public function main() {   // Checks whether the given string matches the provided regex.  // You need to provide the original `string` and the regex to  // this string, which is to be matched with.  boolean isMatched = regex:matches(\"This Should Match\", \"Th.*ch\");  io:println(\"Is the given string matched with the original string: \",  isMatched);   // Replaces each occurrence of the substrings, which match the provided  // regular expression from the given original string value with the  // provided replacement string.  string new_string = regex:replaceAll(\"Ballerina is great\", \"\\\\s+\", \"_\");  io:println(\"Replaced string: \", new_string);   // Replaces the first substring that matches the given regular expression  // with the provided `replacement` string.  new_string = regex:replaceFirst(\"ReplacethisthisTextThis\", \"this\", \" \");  io:println(\"String after replacing first Match: \", new_string);   // Retrieves an array of strings by splitting a string using the provided  // delimiter.  string[] names = regex:split(\"amal, kamal, nimal, sunimal\", \",\");  io:println(\"No of names: \", names.length()); }    Regular Expressions  The regex library provides functionalities for searching, splitting, and replacing  the set of characters of the string by using the regular expression.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/regex;    public function main() {    boolean isMatched = regex:matches(\"This Should Match\", \"Th.*ch\");  io:println(\"Is the given string matched with the original string: \",  isMatched);    Checks whether the given string matches the provided regex.  You need to provide the original string and the regex to  this string, which is to be matched with.   string new_string = regex:replaceAll(\"Ballerina is great\", \"\\\\s+\", \"_\");  io:println(\"Replaced string: \", new_string);    Replaces each occurrence of the substrings, which match the provided  regular expression from the given original string value with the  provided replacement string.   new_string = regex:replaceFirst(\"ReplacethisthisTextThis\", \"this\", \" \");  io:println(\"String after replacing first Match: \", new_string);    Replaces the first substring that matches the given regular expression  with the provided replacement string.   string[] names = regex:split(\"amal, kamal, nimal, sunimal\", \",\");  io:println(\"No of names: \", names.length()); }    Retrieves an array of strings by splitting a string using the provided  delimiter.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run regex_expressions.bal Is the given string matched with the original string: true Replaced string: Ballerina_is_great String after replacing first Match: Replace thisTextThis No of names: 4    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/resource-method-typing.html","name":"Resource Method Typing","summary":"Resource method arguments can use user-defined types.\n Listener will use introspection to map from protocol format\n (typically JSON) to user-defined type, using cloneWithType.\n Return value that is subtype of anydata will be mapped from\n user-defined type to protocol format, typically JSON, using toJson.\n Can generate API description (e.g. OpenAPI) from ...","content":"/  /  / Resource Method Typing  import ballerina/http;  type Args record {|  decimal x;  decimal y; |};  listener http:Listener h = new (9090);  service /calc on h {  // Resource method arguments can use user-defined types.  // Annotations can be used to refine the mapping between // Ballerina-declared type and wire format.  resource function post add(@http:Payload Args args) returns decimal {  return args.x + args.y;  } }    Resource Method Typing  Resource method arguments can use user-defined types.  Listener will use introspection to map from protocol format  (typically JSON) to user-defined type, using cloneWithType.  Return value that is subtype of anydata will be mapped from  user-defined type to protocol format, typically JSON, using toJson.  Can generate API description (e.g. OpenAPI) from Ballerina  service declaration.  Annotations can be used to refine the mapping between  Ballerina-declared type and wire format.    import ballerina/http;    type Args record {|  decimal x;  decimal y; |};    listener http:Listener h = new (9090);    service /calc on h {    resource function post add(@http:Payload Args args) returns decimal {  return args.x + args.y;  } }    Resource method arguments can use user-defined types.  Annotations can be used to refine the mapping between  Ballerina-declared type and wire format.   bal run resource_method_typing.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:9090    curl http://localhost:9090/calc/add -d \"{\\\"x\\\": 1.0, \\\"y\\\": 2.0}\" 3.0    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/resource-path-parameters.html","name":"Resource Path Parameters","summary":"Path segments can be treated as parameters in Ballerina.Here is how you can make path segments as parameters.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your ...","content":"/  /  / Resource Path Parameters  import ballerina/http;  service /demo on new http:Listener(8080) {  // Here is how you can make path segments as parameters.  resource function get greeting/hello/[string name]() returns string {  return \"Hello, \" + name;  } }    Resource Path Parameters  Path segments can be treated as parameters in Ballerina.    import ballerina/http;    service /demo on new http:Listener(8080) {    resource function get greeting/hello/[string name]() returns string {  return \"Hello, \" + name;  } }    Here is how you can make path segments as parameters.   bal run resource_path_parameters.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    # Run this cURL command to invoke the resource. curl \"localhost:8080/demo/greeting/hello/Ballerina\" Hello, Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/resource-methods.html","name":"Resource Methods","summary":"Service objects use remote methods to expose services in procedural style: remote methods are named by verbs. \n Service objects user resource methods to expose services in an RESTful style: resources are named by nounds. \n Resources are motivated by HTTP, but are general enough also to work for GraphQL.\n ...","content":"/  /  / Resource Methods  import ballerina/http;  // Service declaration specifies base path for the resource names. The base path is `/` in this example. service / on new http:Listener(8080) {  // Resource method is associated with combination of accessor (`get`) and resource name (`hello`). // Accessors are determined by the network protocal.  // In HTTP resources, function parameters come from query parameters.  resource function get hello(string name) returns string {  return \"Hello, \" + name;  } }    Resource Methods  Service objects use remote methods to expose services in procedural style: remote methods are named by verbs. Service objects user resource methods to expose services in an RESTful style: resources are named by nounds. Resources are motivated by HTTP, but are general enough also to work for GraphQL.  resource methods are network-oriented generalization of OO getter/setter concept.    import ballerina/http;    service / on new http:Listener(8080) {    Service declaration specifies base path for the resource names. The base path is / in this example.   resource function get hello(string name) returns string {  return \"Hello, \" + name;  } }    Resource method is associated with combination of accessor (get) and resource name (hello).  Accessors are determined by the network protocal.  In HTTP resources, function parameters come from query parameters.   bal run resource_methods.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    # Run this cURL command to invoke the resource. curl \"localhost:8080/hello?name=Ballerina\" Hello, Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/security-jwt-issue-validate.html","name":"JWT Issue/Validate","summary":"This example demonstrates how to issue a self-signed JWT and\n validate a JWT.\n For more information on the underlying module,\n see the .Defines the JWT issuer configurations with the private key file configurations, which are used to self-sign the JWT.Signature can be created using either the private key configurations or ...","content":"/  /  / JWT Issue/Validate  import ballerina/io; import ballerina/jwt;  public function main() returns error? {  // Defines the JWT issuer configurations with the private key file configurations, which are used to self-sign the JWT.  jwt:IssuerConfig issuerConfig = {  username: \"ballerina\",  issuer: \"wso2\",  audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  keyId: \"NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ\",  expTime: 3600,  // Signature can be created using either the private key configurations or keystore configurations.  // [jwt:IssuerSignatureConfig](https://docs.central.ballerina.io/ballerina/jwt/latest/records/IssuerSignatureConfig)  signatureConfig: {  config: {  keyFile: \"../resource/path/to/private.key\"  }  }  };   // Issues a JWT based on the provided header, payload, and private key.  string jwt = check jwt:issue(issuerConfig);  io:println(\"Issued JWT: \", jwt);   // Defines the JWT validator configurations with the public certificate file configurations, which are used to  // validate the signature of JWT.  jwt:ValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  clockSkew: 60,  // Signature can be validated using the public certificate file, truststore configurations, or JWKS configurations.  // [jwt:ValidatorSignatureConfig](https://docs.central.ballerina.io/ballerina/jwt/latest/records/ValidatorSignatureConfig)  signatureConfig: {  certFile: \"../resource/path/to/public.crt\"  }  };   // Validates the created JWT.  jwt:Payload payload = check jwt:validate(jwt, validatorConfig);  io:println(\"Validated JWT Payload: \", payload.toString()); }    JWT Issue/Validate  This example demonstrates how to issue a self-signed JWT and  validate a JWT.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/jwt;    public function main() returns error? {    jwt:IssuerConfig issuerConfig = {  username: \"ballerina\",  issuer: \"wso2\",  audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  keyId: \"NTAxZmMxNDMyZDg3MTU1ZGM0MzEzODJhZWI4NDNlZDU1OGFkNjFiMQ\",  expTime: 3600,    Defines the JWT issuer configurations with the private key file configurations, which are used to self-sign the JWT.   signatureConfig: {  config: {  keyFile: \"../resource/path/to/private.key\"  }  }  };    Signature can be created using either the private key configurations or keystore configurations.  string jwt = check jwt:issue(issuerConfig);  io:println(\"Issued JWT: \", jwt);    Issues a JWT based on the provided header, payload, and private key.   jwt:ValidatorConfig validatorConfig = {  issuer: \"wso2\",  audience: \"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  clockSkew: 60,    Defines the JWT validator configurations with the public certificate file configurations, which are used to  validate the signature of JWT.   signatureConfig: {  certFile: \"../resource/path/to/public.crt\"  }  };    Signature can be validated using the public certificate file, truststore configurations, or JWKS configurations.  jwt:Payload payload = check jwt:validate(jwt, validatorConfig);  io:println(\"Validated JWT Payload: \", payload.toString()); }    Validates the created JWT.   # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, trusted certificate file # path and private key file path.) bal run security_jwt_issue_validate.bal Issued JWT: eyJhbGciOiJSUzI1NiIsICJ0eXAiOiJKV1QiLCAia2lkIjoiTlRBeFptTXhORE15WkR  nM01UVTFaR00wTXpFek9ESmhaV0k0TkRObFpEVTFPR0ZrTmpGaU1RIn0.eyJpc3MiOi  JiYWxsZXJpbmEiLCAic3ViIjoiYWRtaW4iLCAiYXVkIjoidkV3emJjYXNKVlFtMWpWW  UhVSENqaHhaNHRZYSIsICJqdGkiOiI1NWEwYjc1NC04OTVmLTQyNzktODg0My1iNzQ1  ZTExYTU3ZTkiLCAiZXhwIjoxNjExMTI3MDIzLCAibmJmIjoxNjExMTIzNDIzLCAiaWF  0IjoxNjExMTIzNDIzfQ.DMJDjJEFiQN7d_2CXGfXX_UR8Fi7Witr3aVGm4K7amEm3xN  cbh1bZmKO2ir-oP2_ikoM1_ETO7i4E4LKJHNAEdhqj8YHyKpbszaEq5zouMOtdFcI7i  TS8LyYDnyLEQQ6sa9L9NoMz3xULeF8epk0eaN1vVA-ijndVkZlMjaXJNf9Bgzn2qJOd  sQ6F0GeC4WKEt-xcEY5C2_haEDotSOYhUzEqh6D1fRtrGy7GaH5gzx99n-xjn8NZbTD  F0VnD6c1kJPe25FiPz24l9KdaCE1i2WbuzEhZWMclHW5RcTXVkLLkjQ4DvxfE-riGmK  qPN1gatWViZQF_VGBK-G7rEhi9Q Validated JWT Payload: {\"iss\":\"ballerina\",\"sub\":\"admin\",  \"aud\":\"vEwzbcasJVQm1jVYHUHCjhxZ4tYa\",  \"jti\":\"55a0b754-895f-4279-8843-b745e11a57e9\",  \"exp\":1611127023,\"nbf\":1611123423,\"iat\":1611123423}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/sequence-diagrams.html","name":"Sequence Diagrams","summary":"A function can be viewed as a sequence diagram.\n The diagram has a lifeline (vertical line) for each worker (both named\n worker and function’s default worker).\n The diagram also has a lifeline for each client object parameter or variable in\n the initialization section, representing the remote system to which the ...","content":"/  /  / Sequence Diagrams  import ballerina/http; import ballerina/io;  // A function can be viewed as a sequence diagram. // The diagram has a lifeline (vertical line) for each worker (both named // worker and function's default worker). public function main() returns error? {  // The diagram also has a lifeline for each client object parameter or variable in // the initialization section, representing the remote system to which the client // object is sending messages.  http:Client cl = check new (\"https://www.mocky.io\");   // Each remote method call on a client object is represented as a horizontal line  // between the lifeline of the worker making the call and the remote system.  string payload = check cl->get(\"/v2/5ae082123200006b00510c3d/\");   io:println(payload); }    Sequence Diagrams  A function can be viewed as a sequence diagram.  The diagram has a lifeline (vertical line) for each worker (both named  worker and function’s default worker).  The diagram also has a lifeline for each client object parameter or variable in  the initialization section, representing the remote system to which the client  object is sending messages.  Each remote method call on a client object is represented as a horizontal line  between the lifeline of the worker making the call and the remote system.    import ballerina/http; import ballerina/io;    public function main() returns error? {    A function can be viewed as a sequence diagram.  The diagram has a lifeline (vertical line) for each worker (both named  worker and function’s default worker).   http:Client cl = check new (\"https://www.mocky.io\");    The diagram also has a lifeline for each client object parameter or variable in  the initialization section, representing the remote system to which the client  object is sending messages.   string payload = check cl->get(\"/v2/5ae082123200006b00510c3d/\");    Each remote method call on a client object is represented as a horizontal line  between the lifeline of the worker making the call and the remote system.   io:println(payload); }    bal run sequence_diagrams.bal Hello World    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/send-email.html","name":"Send Emails","summary":"The Email Connector is used to send (with SMTP) emails\n using the SSL or STARTTLS protocols. This sample\n includes sending emails with default configurations\n over SSL using the default ports.\n For more information on the underlying module,\n see the .Creates an SMTP client with the connection parameters, host, username,\n and ...","content":"/  /  / Send Emails  import ballerina/email;  public function main() returns error? {  // Creates an SMTP client with the connection parameters, host, username,  // and password. The default port number `465` is used over SSL with these  // configurations. `SmtpConfig` can be configured and passed to this  // client if the port or security is to be customized.  email:SmtpClient smtpClient = check new (\"smtp.email.com\",  \"sender@email.com\" , \"pass123\");   // Defines the email that is required to be sent.  email:Message email = {  // \"TO\", \"CC\", and \"BCC\" address lists are added as follows.  // Only the \"TO\" address list is mandatory out of these three.  to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],  // Subject of the email is added as follows. This field is mandatory.  subject: \"Sample Email\",  // Body content (text) of the email is added as follows.  // This field is optional.  body: \"This is a sample email.\",  // Email author's address is added as follows. This field is mandatory.  'from: \"author@email.com\",  // Email sender service address is added as follows.  // This field is optional. `Sender` is same as the `'from` when the  // email author himself sends the email.  sender: \"sender@email.com\",  // List of recipients when replying to the email is added as follows.  // This field is optional. These addresses are required when the emails  // are to be replied to some other address(es) other than the sender or  // the author.  replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };   // Sends the email message with the client. The `send` method can be used  // instead, if the email is required to be sent with mandatory and optional  // parameters instead of configuring an `email:Message` record.  check smtpClient->sendMessage(email);  }    Send Emails  The Email Connector is used to send (with SMTP) emails  using the SSL or STARTTLS protocols. This sample  includes sending emails with default configurations  over SSL using the default ports.  For more information on the underlying module,  see the .    import ballerina/email;    public function main() returns error? {    email:SmtpClient smtpClient = check new (\"smtp.email.com\",  \"sender@email.com\" , \"pass123\");    Creates an SMTP client with the connection parameters, host, username,  and password. The default port number 465 is used over SSL with these  configurations. SmtpConfig can be configured and passed to this  client if the port or security is to be customized.   email:Message email = {    Defines the email that is required to be sent.   to: [\"receiver1@email.com\", \"receiver2@email.com\"],  cc: [\"receiver3@email.com\", \"receiver4@email.com\"],  bcc: [\"receiver5@email.com\"],    “TO”, “CC”, and “BCC” address lists are added as follows.  Only the “TO” address list is mandatory out of these three.   subject: \"Sample Email\",    Subject of the email is added as follows. This field is mandatory.   body: \"This is a sample email.\",    Body content (text) of the email is added as follows.  This field is optional.   'from: \"author@email.com\",    Email author’s address is added as follows. This field is mandatory.   sender: \"sender@email.com\",    Email sender service address is added as follows.  This field is optional. Sender is same as the 'from when the  email author himself sends the email.   replyTo: [\"replyTo1@email.com\", \"replyTo2@email.com\"]  };    List of recipients when replying to the email is added as follows.  This field is optional. These addresses are required when the emails  are to be replied to some other address(es) other than the sender or  the author.   check smtpClient->sendMessage(email);    Sends the email message with the client. The send method can be used  instead, if the email is required to be sent with mandatory and optional  parameters instead of configuring an email:Message record.   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run email.bal    # Check the inbox to view the sent emails.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/sequences.html","name":"Sequences","summary":"Ballerina has two basic types that are sequences: string, xml. A value is a sequence of basic type T\n if it is \n - an empty sequence of basic type T, \n - a singleton of basic type T, or \n - a concatenation of two sequences of basic type ...","content":"/  /  / Sequences  Sequences  Ballerina has two basic types that are sequences: string, xml. A value is a sequence of basic type T  if it is - an empty sequence of basic type T, - a singleton of basic type T, or - a concatenation of two sequences of basic type T. Sequences differ from arrays: - sequences are flat: no nesting. - there is no difference between a singleton x and a sequence consisting of just x. - basic type of sequence determines basic type of members. Membership of a sequence is immutable (e.g., cannot mutate a sequence of one item into a sequence of two items).  A sequence has no identity: two sequences are === if their members are ===.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/service-declaration.html","name":"Service Declaration","summary":"A service represents a collection of remotely accessible methods attached to particular listener.\n A service declaration is syntactic sugar for creating services in Ballerina.\n A service declaration gets desugared into several things including create a listener object,\n registering it with module, creating service object, attaching the service object to the ...","content":"/  /  / Service Declaration  import ballerina/udp; import ballerina/io;  // You can combine listener declaration into service declaration as shown in this exampe. service on new udp:Listener(8080) {  remote function onDatagram(readonly & udp:Datagram dg) {  io:println(\"bytes received: \", dg.data.length());  } }    Service Declaration  A service represents a collection of remotely accessible methods attached to particular listener.  A service declaration is syntactic sugar for creating services in Ballerina.  A service declaration gets desugared into several things including create a listener object,  registering it with module, creating service object, attaching the service object to the listener object, etc,.  The type of listener determines required type of remote methods.    import ballerina/udp; import ballerina/io;    service on new udp:Listener(8080) {  remote function onDatagram(readonly & udp:Datagram dg) {  io:println(\"bytes received: \", dg.data.length());  } }    You can combine listener declaration into service declaration as shown in this exampe.   bal run service_declaration.bal bytes received: 17    # Use the following Netcat (or nc) command to send packets to the service. nc -u localhost 8080 Hello, Ballerina    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/strands.html","name":"Strands","summary":"By default, named workers are multitasked cooperatively, not preemptively.\n Each named worker has a “strand” (logical thread of control) and execution\n switches been strands only at specific “yield” points such as doing a wait\n or when a library function invokes a system call that would block.\n This avoids the need ...","content":"/  /  / Strands  import ballerina/io;  public function main() {  // By default, named workers are multitasked cooperatively, not preemptively.  // Each named worker has a \"strand\" (logical thread of control) and execution  // switches been strands only at specific \"yield\" points.  worker A {  io:println(\"In worker A\");  }   // An annotation can be used to make a strand run on a separate thread.  @strand {  thread: \"any\"  } worker B {  io:println(\"In worker B\");  }   io:println(\"In function worker\"); }    Strands  By default, named workers are multitasked cooperatively, not preemptively.  Each named worker has a “strand” (logical thread of control) and execution  switches been strands only at specific “yield” points such as doing a wait  or when a library function invokes a system call that would block.  This avoids the need for users to lock variables that are accessed from  multiple named workers.  An annotation can be used to make a strand run on a separate thread.    import ballerina/io;    public function main() {    worker A {  io:println(\"In worker A\");  }    By default, named workers are multitasked cooperatively, not preemptively.  Each named worker has a “strand” (logical thread of control) and execution  switches been strands only at specific “yield” points.   @strand {  thread: \"any\"  } worker B {  io:println(\"In worker B\");  }    An annotation can be used to make a strand run on a separate thread.   io:println(\"In function worker\"); }    bal run strands.bal In worker B In function worker In worker A    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/stream-type.html","name":"Stream Type","summary":"A stream represents a sequence of values that are generated as needed. The end of a stream is indicated with a\n termination value, which is error or nil. The type stream<T,E> is a stream where the members of the\n sequence are type T and termination value is type E. stream<T> ...","content":"/  /  / Stream Type  class EvenNumberGenerator {  int i = 0;  public isolated function next() returns record {| int value; |}|error? {  self.i += 2;  return { value: self.i };  } }  public function main() {  EvenNumberGenerator evenGen = new();  // Creates a `stream` passing an `EvenNumberGenerator` object  // to the `stream` constructor.  stream<int, error?> evenNumberStream = new(evenGen); }    Stream Type  A stream represents a sequence of values that are generated as needed. The end of a stream is indicated with a  termination value, which is error or nil. The type stream<T,E> is a stream where the members of the  sequence are type T and termination value is type E. stream<T> means stream<T,()>. The stream type  is a separate basic type, but like an object.    class EvenNumberGenerator {  int i = 0;  public isolated function next() returns record {| int value; |}|error? {  self.i += 2;  return { value: self.i };  } }    public function main() {  EvenNumberGenerator evenGen = new();    stream<int, error?> evenNumberStream = new(evenGen); }    Creates a stream passing an EvenNumberGenerator object  to the stream constructor.   bal run stream_type.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/strings.html","name":"Strings","summary":"The string type represents immutable sequence of zero or more Unicode characters.\n There is no separate character type: a character is represented by string of lenght 1.\n Two string values are == if both sequences have same characters.\n You can use < <= > >= operators on string values and ...","content":"/  /  / Strings  import ballerina/io;  public function main() {  // String literals use double quotes. You can use usual C escapse such as `\\t \\n`. // Numeric escapes specify Unicode code point using one or more hex digits `\\u{H}`.  string grin = \"\\u{1F600}\";   // String concatenation uses `+` operator.  string greeting = \"Hello\" + grin;  io:println(greeting);   // `greeting[1]` accesses character at index 1 (zero-based).  io:println(greeting[1]); }    Strings  The string type represents immutable sequence of zero or more Unicode characters.  There is no separate character type: a character is represented by string of lenght 1.  Two string values are == if both sequences have same characters.  You can use < <= > >= operators on string values and they work by comparing code points.  Unpaired surrogates are not allowed.    import ballerina/io;    public function main() {    string grin = \"\\u{1F600}\";    String literals use double quotes. You can use usual C escapse such as \\t \\n.  Numeric escapes specify Unicode code point using one or more hex digits \\u{H}.   string greeting = \"Hello\" + grin;  io:println(greeting);    String concatenation uses + operator.   io:println(greeting[1]); }    greeting[1] accesses character at index 1 (zero-based).   bal run strings.bal Helloὠ0 e    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/structured-keys.html","name":"Structured Keys","summary":"Key fields can be structured where they belong to any subtype of plain data. The Value of key field\n must be immutable. Initializer of readonly field will be constructed as immutable. In other cases,\n can use cloneReadOnly to create an immutable value.key field, name is of record type.This website uses ...","content":"/  /  / Structured Keys  import ballerina/io;  type Employee record {  readonly record {  string first;  string last;  } name;  int salary; };  public function main() {  // key field, `name` is of `record` type.  table<Employee> key(name) t = table [  {name: {first: \"John\", last: \"Smith\"}, salary: 100},  {name: {first: \"Fred\", last: \"Bloggs\"}, salary: 200}  ];   Employee? e = t[{first: \"Fred\", last: \"Bloggs\"}];  io:println(e); }    Structured Keys  Key fields can be structured where they belong to any subtype of plain data. The Value of key field  must be immutable. Initializer of readonly field will be constructed as immutable. In other cases,  can use cloneReadOnly to create an immutable value.    import ballerina/io;    type Employee record {  readonly record {  string first;  string last;  } name;  int salary; };    public function main() {    table<Employee> key(name) t = table [  {name: {first: \"John\", last: \"Smith\"}, salary: 100},  {name: {first: \"Fred\", last: \"Bloggs\"}, salary: 200}  ];    key field, name is of record type.   Employee? e = t[{first: \"Fred\", last: \"Bloggs\"}];  io:println(e); }    bal run structured_keys.bal {\"name\":{\"first\":\"Fred\",\"last\":\"Bloggs\"},\"salary\":200}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/table-concept.html","name":"Table Concept","summary":"Ballerina encourages use of its built-in data structures: array, map and table. A table is a\n collection of records; each record represents a row of the table. A table is plain data if\n and only if its rows are plain data. Table maintains invariant that each row is uniquely identified\n ...","content":"/  /  / Table Concept  Table Concept  Ballerina encourages use of its built-in data structures: array, map and table. A table is a  collection of records; each record represents a row of the table. A table is plain data if  and only if its rows are plain data. Table maintains invariant that each row is uniquely identified  by a key. Each row’s key is stored in fields, which must be immutable. Compared to maps: - key is part of the value, rather than separate. - type of the key is not restricted to string. - order of members is preserved. Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/structural-typing.html","name":"Structural Typing","summary":"Typing in Ballerina is structural: a type describes a set of values. Ballerina has semantic subtyping:\n subtype means subset. Universe of values is partitioned into basic types. Each value belongs to\n exactly one basic type. Can think of each value as being tagged with its basic type.\n There is a ...","content":"/  /  / Structural Typing  import ballerina/io;  public function main() {  // 1 belongs to `int`.  io:println(1 is int);  // [10, 20, 30] belongs to `int[]`.  io:println([10, 20, 30] is int[]); }    Structural Typing  Typing in Ballerina is structural: a type describes a set of values. Ballerina has semantic subtyping:  subtype means subset. Universe of values is partitioned into basic types. Each value belongs to  exactly one basic type. Can think of each value as being tagged with its basic type.  There is a complexity in making structural typing work with mutation. Immutable basic types (so far): nil, boolean, int, float, string Mutable basic types (so far): array, map and record    import ballerina/io;    public function main() {    io:println(1 is int);    1 belongs to int.   io:println([10, 20, 30] is int[]); }    [10, 20, 30] belongs to int[].   bal run structural_typing.bal true true    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/security-crypto.html","name":"Cryptographic Operations","summary":"The crypto stdlib provides functions usable to perform different cryptographic operations such as\n hashing, HMAC generation, checksum generation, encryption, decryption, digitally signing data and\n verifying digitally signed data.\n For more information on the underlying module,\n see the .Input value for hash operations.Hashing input value using the , and printing the ...","content":"/  /  / Cryptographic Operations  import ballerina/crypto; import ballerina/io; import ballerina/random;  function hash() returns error? {  // Input value for hash operations.  string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();   // Hashing input value using the [MD5 hashing algorithm](https://docs.central.ballerina.io/ballerina/crypto/latest/functions#hashMd5), and printing the hash value using the Hex encoding.  byte[] output = crypto:hashMd5(input);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());   // Hashing the input value using the SHA1 hashing algorithm, and printing the hash value using the Base64 encoding.  output = crypto:hashSha1(input);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());   // Hashing the input value using the SHA256 hashing algorithm, and printing the hash value using the Hex encoding.  output = crypto:hashSha256(input);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());   // Hashing the input value using the SHA384 hashing algorithm, and printing the hash value using the Base64 encoding.  output = crypto:hashSha384(input);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());   // Hashing the input value using the SHA512 hashing algorithm, and printing the hash value using the Hex encoding.  output = crypto:hashSha512(input);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());   // The Hex-encoded CRC32B checksum generation for the input value.  io:println(\"CRC32B for text: \" + crypto:crc32b(input)); }  function hmac() returns error? {  // Input value for HMAC operations.  string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();   // The key used for the HMAC generation.  string secret = \"somesecret\";  byte[] key = secret.toBytes();   // HMAC generation for the input value using the MD5 hashing algorithm, and printing the HMAC value using the Hex encoding.  byte[] output = check crypto:hmacMd5(input, key);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());   // HMAC generation for input the value using the SHA1 hashing algorithm, and printing the HMAC value using the Base64 encoding.  output = check crypto:hmacSha1(input, key);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());   // HMAC generation for the input value using the SHA256 hashing algorithm, and printing the HMAC value using the Hex encoding.  output = check crypto:hmacSha256(input, key);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());   // HMAC generation for the input value using the SHA384 hashing algorithm, and printing the HMAC value using the Base64 encoding.  output = check crypto:hmacSha384(input, key);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());   // HMAC generation for the input value using the SHA512 hashing algorithm, and printing the HMAC value using the Hex encoding.  output = check crypto:hmacSha512(input, key);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16()); }  function decodePrivateKey() returns crypto:PrivateKey|error {  // Obtaining the reference to an RSA private key by a key file.  string keyFile = \"../resource/path/to/private.key\";  crypto:PrivateKey privateKey =  check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile);   // Obtaining the reference to an RSA private key by an encrypted key file.  string encryptedKeyFile = \"../resource/path/to/encryptedPrivate.key\";  privateKey = check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile,  \"ballerina\");   // Obtaining the reference to an RSA private key stored within a PKCS#12 or PFX format archive file.  crypto:KeyStore keyStore = {  path: \"../resource/path/to/ballerinaKeystore.p12\",  password: \"ballerina\"  };  privateKey = check crypto:decodeRsaPrivateKeyFromKeyStore(keyStore,  \"ballerina\", \"ballerina\");   return privateKey; }  function decodePublicKey() returns crypto:PublicKey|error {  // Obtaining the reference to an RSA public key by a cert file.  string certFile = \"../resource/path/to/public.crt\";  crypto:PublicKey publicKey =  check crypto:decodeRsaPublicKeyFromCertFile(certFile);   // Obtaining reference to a RSA public key stored within a PKCS#12 or PFX format archive file.  crypto:TrustStore trustStore = {  path: \"../resource/path/to/ballerinaTruststore.p12\",  password: \"ballerina\"  };  publicKey = check crypto:decodeRsaPublicKeyFromTrustStore(trustStore,  \"ballerina\");   return publicKey; }  function sign() returns error? {  // Input value for the `sign` operations.  string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();   // Private and public keys for the `sign` and `verify` operations.  crypto:PrivateKey privateKey = check decodePrivateKey();  crypto:PublicKey publicKey = check decodePublicKey();   // Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.  byte[] output = check crypto:signRsaMd5(input, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());   boolean verified =  check crypto:verifyRsaMd5Signature(input, output, publicKey);  io:println(\"RSA-MD5 signature verified: \" + verified.toString());   // Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Base64 encoding.  output = check crypto:signRsaSha1(input, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());   verified = check crypto:verifyRsaSha1Signature(input, output, publicKey);  io:println(\"RSA-SHA1 signature verified: \" + verified.toString());   // Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.  output = check crypto:signRsaSha256(input, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());   verified = check crypto:verifyRsaSha256Signature(input, output, publicKey);  io:println(\"RSA-SHA256 signature verified: \" + verified.toString());   // Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Base64 encoding.  output = check crypto:signRsaSha384(input, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());   verified = check crypto:verifyRsaSha384Signature(input, output, publicKey);  io:println(\"RSA-SHA384 signature verified: \" + verified.toString());   // Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.  output = check crypto:signRsaSha512(input, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());   verified = check crypto:verifyRsaSha512Signature(input, output, publicKey);  io:println(\"RSA-SHA512 signature verified: \" + verified.toString()); }  function encrypt() returns error? {  // Input value for the `encrypt` operations.  string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();   // Private and public keys for the `encrypt` and `decrypt` operations.  crypto:PrivateKey privateKey = check decodePrivateKey();  crypto:PublicKey publicKey = check decodePublicKey();   // Encrypts and decrypts an input value using the `RSA ECB PKCS1` padding.  byte[] output = check crypto:encryptRsaEcb(input, publicKey);  output = check crypto:decryptRsaEcb(output, privateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `RSA ECB OAEPwithSHA512andMGF1` padding.  output = check crypto:encryptRsaEcb(input, publicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, privateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check string:fromBytes(output));   // Randomly generates a 128 bit key for the AES encryption.  byte[16] rsaKey = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKey[i] = <byte>(check random:createIntInRange(0, 255));  }   // Randomly generates a 128 bit IV for the AES encryption.  byte[16] iv = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  iv[i] = <byte>(check random:createIntInRange(0, 255));  }   // Encrypts and decrypts an input value using the `AES CBC PKCS5` padding.  output = check crypto:encryptAesCbc(input, rsaKey, iv);  output = check crypto:decryptAesCbc(output, rsaKey, iv);  io:println(\"AES CBC PKCS5 decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `AES CBC` without padding.  output = check crypto:encryptAesCbc(input, rsaKey, iv, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKey, iv, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `AES GCM PKCS5` padding.  output = check crypto:encryptAesGcm(input, rsaKey, iv);  output = check crypto:decryptAesGcm(output, rsaKey, iv);  io:println(\"AES GCM PKCS5 decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `AES GCM` without padding.  output = check crypto:encryptAesGcm(input, rsaKey, iv, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKey, iv, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `AES ECB PKCS5 padding`.  output = check crypto:encryptAesEcb(input, rsaKey);  output = check crypto:decryptAesEcb(output, rsaKey);  io:println(\"AES ECB PKCS5 decrypted value: \" +  check string:fromBytes(output));   // Encrypts and decrypts an input value using the `AES ECB` without padding.  output = check crypto:encryptAesEcb(input, rsaKey, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKey, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" +  check string:fromBytes(output)); }  public function main() returns error? {  check hash();  check hmac();  check sign();  check encrypt(); }    Cryptographic Operations  The crypto stdlib provides functions usable to perform different cryptographic operations such as  hashing, HMAC generation, checksum generation, encryption, decryption, digitally signing data and  verifying digitally signed data.  For more information on the underlying module,  see the .    import ballerina/crypto; import ballerina/io; import ballerina/random;    function hash() returns error? {    string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();    Input value for hash operations.   byte[] output = crypto:hashMd5(input);  io:println(\"Hex encoded hash with MD5: \" + output.toBase16());    Hashing input value using the , and printing the hash value using the Hex encoding.   output = crypto:hashSha1(input);  io:println(\"Base64 encoded hash with SHA1: \" + output.toBase64());    Hashing the input value using the SHA1 hashing algorithm, and printing the hash value using the Base64 encoding.   output = crypto:hashSha256(input);  io:println(\"Hex encoded hash with SHA256: \" + output.toBase16());    Hashing the input value using the SHA256 hashing algorithm, and printing the hash value using the Hex encoding.   output = crypto:hashSha384(input);  io:println(\"Base64 encoded hash with SHA384: \" + output.toBase64());    Hashing the input value using the SHA384 hashing algorithm, and printing the hash value using the Base64 encoding.   output = crypto:hashSha512(input);  io:println(\"Hex encoded hash with SHA512: \" + output.toBase16());    Hashing the input value using the SHA512 hashing algorithm, and printing the hash value using the Hex encoding.   io:println(\"CRC32B for text: \" + crypto:crc32b(input)); }    The Hex-encoded CRC32B checksum generation for the input value.   function hmac() returns error? {    string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();    Input value for HMAC operations.   string secret = \"somesecret\";  byte[] key = secret.toBytes();    The key used for the HMAC generation.   byte[] output = check crypto:hmacMd5(input, key);  io:println(\"Hex encoded HMAC with MD5: \" + output.toBase16());    HMAC generation for the input value using the MD5 hashing algorithm, and printing the HMAC value using the Hex encoding.   output = check crypto:hmacSha1(input, key);  io:println(\"Base64 encoded HMAC with SHA1: \" + output.toBase64());    HMAC generation for input the value using the SHA1 hashing algorithm, and printing the HMAC value using the Base64 encoding.   output = check crypto:hmacSha256(input, key);  io:println(\"Hex encoded HMAC with SHA256: \" + output.toBase16());    HMAC generation for the input value using the SHA256 hashing algorithm, and printing the HMAC value using the Hex encoding.   output = check crypto:hmacSha384(input, key);  io:println(\"Base64 encoded HMAC with SHA384: \" + output.toBase64());    HMAC generation for the input value using the SHA384 hashing algorithm, and printing the HMAC value using the Base64 encoding.   output = check crypto:hmacSha512(input, key);  io:println(\"Hex encoded HMAC with SHA512: \" + output.toBase16()); }    HMAC generation for the input value using the SHA512 hashing algorithm, and printing the HMAC value using the Hex encoding.   function decodePrivateKey() returns crypto:PrivateKey|error {    string keyFile = \"../resource/path/to/private.key\";  crypto:PrivateKey privateKey =  check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile);    Obtaining the reference to an RSA private key by a key file.   string encryptedKeyFile = \"../resource/path/to/encryptedPrivate.key\";  privateKey = check crypto:decodeRsaPrivateKeyFromKeyFile(keyFile,  \"ballerina\");    Obtaining the reference to an RSA private key by an encrypted key file.   crypto:KeyStore keyStore = {  path: \"../resource/path/to/ballerinaKeystore.p12\",  password: \"ballerina\"  };  privateKey = check crypto:decodeRsaPrivateKeyFromKeyStore(keyStore,  \"ballerina\", \"ballerina\");    Obtaining the reference to an RSA private key stored within a PKCS#12 or PFX format archive file.   return privateKey; }    function decodePublicKey() returns crypto:PublicKey|error {    string certFile = \"../resource/path/to/public.crt\";  crypto:PublicKey publicKey =  check crypto:decodeRsaPublicKeyFromCertFile(certFile);    Obtaining the reference to an RSA public key by a cert file.   crypto:TrustStore trustStore = {  path: \"../resource/path/to/ballerinaTruststore.p12\",  password: \"ballerina\"  };  publicKey = check crypto:decodeRsaPublicKeyFromTrustStore(trustStore,  \"ballerina\");    Obtaining reference to a RSA public key stored within a PKCS#12 or PFX format archive file.   return publicKey; }    function sign() returns error? {    string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();    Input value for the sign operations.   crypto:PrivateKey privateKey = check decodePrivateKey();  crypto:PublicKey publicKey = check decodePublicKey();    Private and public keys for the sign and verify operations.   byte[] output = check crypto:signRsaMd5(input, privateKey);  io:println(\"Hex encoded RSA-MD5 signature: \" + output.toBase16());    Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.   boolean verified =  check crypto:verifyRsaMd5Signature(input, output, publicKey);  io:println(\"RSA-MD5 signature verified: \" + verified.toString());    output = check crypto:signRsaSha1(input, privateKey);  io:println(\"Base64 encoded RSA-SHA1 signature: \" + output.toBase64());    Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Base64 encoding.   verified = check crypto:verifyRsaSha1Signature(input, output, publicKey);  io:println(\"RSA-SHA1 signature verified: \" + verified.toString());    output = check crypto:signRsaSha256(input, privateKey);  io:println(\"Hex encoded RSA-SHA256 signature: \" + output.toBase16());    Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.   verified = check crypto:verifyRsaSha256Signature(input, output, publicKey);  io:println(\"RSA-SHA256 signature verified: \" + verified.toString());    output = check crypto:signRsaSha384(input, privateKey);  io:println(\"Base64 encoded RSA-SHA384 signature: \" + output.toBase64());    Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Base64 encoding.   verified = check crypto:verifyRsaSha384Signature(input, output, publicKey);  io:println(\"RSA-SHA384 signature verified: \" + verified.toString());    output = check crypto:signRsaSha512(input, privateKey);  io:println(\"Hex encoded RSA-SHA512 signature: \" + output.toBase16());    Signing the input value using the RSA-MD5 signature algorithms, and printing the signature value using the Hex encoding.   verified = check crypto:verifyRsaSha512Signature(input, output, publicKey);  io:println(\"RSA-SHA512 signature verified: \" + verified.toString()); }    function encrypt() returns error? {    string value = \"Hello Ballerina!\";  byte[] input = value.toBytes();    Input value for the encrypt operations.   crypto:PrivateKey privateKey = check decodePrivateKey();  crypto:PublicKey publicKey = check decodePublicKey();    Private and public keys for the encrypt and decrypt operations.   byte[] output = check crypto:encryptRsaEcb(input, publicKey);  output = check crypto:decryptRsaEcb(output, privateKey);  io:println(\"RSA ECB PKCS1 decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the RSA ECB PKCS1 padding.   output = check crypto:encryptRsaEcb(input, publicKey,  crypto:OAEPwithSHA512andMGF1);  output = check crypto:decryptRsaEcb(output, privateKey,  crypto:OAEPwithSHA512andMGF1);  io:println(\"RSA ECB OAEPwithSHA512andMGF1 decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the RSA ECB OAEPwithSHA512andMGF1 padding.   byte[16] rsaKey = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  rsaKey[i] = <byte>(check random:createIntInRange(0, 255));  }    Randomly generates a 128 bit key for the AES encryption.   byte[16] iv = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];  foreach var i in 0 ... 15 {  iv[i] = <byte>(check random:createIntInRange(0, 255));  }    Randomly generates a 128 bit IV for the AES encryption.   output = check crypto:encryptAesCbc(input, rsaKey, iv);  output = check crypto:decryptAesCbc(output, rsaKey, iv);  io:println(\"AES CBC PKCS5 decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the AES CBC PKCS5 padding.   output = check crypto:encryptAesCbc(input, rsaKey, iv, crypto:NONE);  output = check crypto:decryptAesCbc(output, rsaKey, iv, crypto:NONE);  io:println(\"AES CBC no padding decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the AES CBC without padding.   output = check crypto:encryptAesGcm(input, rsaKey, iv);  output = check crypto:decryptAesGcm(output, rsaKey, iv);  io:println(\"AES GCM PKCS5 decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the AES GCM PKCS5 padding.   output = check crypto:encryptAesGcm(input, rsaKey, iv, crypto:NONE);  output = check crypto:decryptAesGcm(output, rsaKey, iv, crypto:NONE);  io:println(\"AES GCM no padding decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the AES GCM without padding.   output = check crypto:encryptAesEcb(input, rsaKey);  output = check crypto:decryptAesEcb(output, rsaKey);  io:println(\"AES ECB PKCS5 decrypted value: \" +  check string:fromBytes(output));    Encrypts and decrypts an input value using the AES ECB PKCS5 padding.   output = check crypto:encryptAesEcb(input, rsaKey, crypto:NONE);  output = check crypto:decryptAesEcb(output, rsaKey, crypto:NONE);  io:println(\"AES ECB no padding decrypted value: \" +  check string:fromBytes(output)); }    Encrypts and decrypts an input value using the AES ECB without padding.   public function main() returns error? {  check hash();  check hmac();  check sign();  check encrypt(); }    # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. # (You may need to change the certificate file path, private key file path and keystore/truststore file path.) bal run security_crypto.bal Hex encoded hash with MD5: 0605402ee16d8e96511a58ff105bc24a Base64 encoded hash with SHA1: /8fwbGIevBvv2Nl3gEL9DtWas+Q= Hex encoded hash with SHA256: a984a643c350b17f0738bac0fef17f2cd91d91e04596351d0af  670c79adc12d5 Base64 encoded hash with SHA384: lselzItgAZHQmqNbkf/s2aRjBSd93O3ayc0PB0Dxk6AEo1s4  4zyTz/Qp0FJO1n6b Hex encoded hash with SHA512: a6f0770f1582f49396a97fbd5973ac22a3a578ac6a991786427  dfec17dbd984d8d6289771ac6f44176160a3dcd59f4a8c6b3ab97bef0caa5c67a3fac78c8e946 CRC32B for text: db9230c5 Hex encoded HMAC with MD5: b69fa2cc698e0923a7eea9d8f2b156fe Base64 encoded HMAC with SHA1: AkWFajkb/gml703Zf4pPgxrjam4= Hex encoded HMAC with SHA256: 13a3369b8ba326fd311d4500b06a5214a02ed2a033917108f6b  9af58b7ede381 Base64 encoded HMAC with SHA384: 0AjKoWLhNPgdobGTPJs0PdkA0W9wkJtzUvXigzC1ZmXDJJsx  p4icks4JrPiwHGm6 Hex encoded HMAC with SHA512: 27588ad08e772a6bba5fca5f45cf467819c8de69a70a42be6fe  3eb09ceb3bfeb8b2976bda8ea5c10dcfa2294b12cb0b50b22a06309bada98af21857904a03205 Hex encoded RSA-MD5 signature: 2cfd121e4ff2409d1b2482ebbf37d0c035884d6d858e307e44  60b092d79cb20abb624a0dfae76b73b1fc85447be3060a36b318813f0115b1919e5efa7a7f9b1  173ec869f56fd9448d99770e1565db1c69a04fd0075fa0e33423a7e829a8b9c25a4dd2c68f3ee  e021c0c4ff27979750b395384e280afd87af5274c8d2d99ad4438d9bfc9b2c5a2814212ba29ce  6ff70cbe30a5c23f86b0330e143c4d8813ff10092cd313c6861706d37df5f4bb4e9fc72354975  ee1786cf24c79b9edfa909968f198c4da37464f3d214a68fb39956717e92d667bb5a9a7f5986b  a055d431813d4053a028873499f98c94fd6b5c6fd5aefad432669f957ab4ce9e91c5e77b36ec0 RSA-MD5 signature verified: true Base64 encoded RSA-SHA1 signature: bYMHKKVkjbOUp9ly3AdW9/euxF94krkkF9SDk2FfbVEc0m  qpGIxVoZlPiFxszurZF1YPcqOSeOehDkaHXUMfQkTjBq7XlcePtkywy0fChqw8/SWqZR8nbYv97tt  8+MVTkymbm26syQLwYNLiGp/EsN6X+fJpkdakwHE+TrdE+rEFrNysGyAm1DWwc4c+l7MEmSYMUnh/  GWPY5r2knOOdDA3mr+XyrsxzFRWZgO7ebVvEQfq9XkRp8kdiGVgpLS5au0jKj3EpbCdS1prFgy3gr  kuSJTTUQCwgPo7WSjWbuehFGni7rbas8HIqNlyWF0qUyznJ3eqbUwZ95QqOoVWZoQ== RSA-SHA1 signature verified: true Hex encoded RSA-SHA256 signature: 215c6ea96c9e82348430c6bb02e715560b4fbd3afcf24fb  eb41ff12d4d68a797d61c4d6f822807688e4dc604e212b3cc7ac563b3cbe4e5690e2aebaf4e3d  f35c19d4b0f7043f50501f390634303577053b029d495104c0e98bc887f0be744ef6f726f7192  01907ad4e86cef82eb030b60c384f7034a85159081e598e197bb8904a9123f39d190796dc7fd9  46157547c10523999b8fa956d4119dbfe3c1435911c0585cf3c537964516706772e87f2470557  40cc4867ac6b99d7bf699fce1b59956c7f55368c8c88c9d47e51ef120ed3f27c3e555691a6971  42c78cbd72c23b81b43fa5ab67164a35f8e8c6bf1da187d3feb866add13f1fb9576a2f7887535  311 RSA-SHA256 signature verified: true Base64 encoded RSA-SHA384 signature: BjQ40dffGiRQ4zo1s+ld+zKhJL21RbO5sW3L2+4xmonU  t126u9D4/FZ2sM1QGGamj8btB9otiYmWr9sFm4fTs1EX6vrxcCGCAiDdkMxiRs7kShaz2x/BjJQ7c  Od9OY+amwo7DQ/FAk9mNOt4lFUpjc9WyEW9F1PEJRXZQvMmVabDu8lp/Fh02lmEquG15DT5qT0jRx  RJiS8CNa+97cMZdOmF2KeADfRbNJSz70mZ76MrsNxYIXYIiJzJBQod0efQr0Sr/HDn4JDVph9rpDM  3p8m94TyXvSOwxwxzZWRLEwB0ANdfDmbrW4bOpxfZZFmy1hltqNJQ9G0BcKOHsZDj6Q== RSA-SHA384 signature verified: true Hex encoded RSA-SHA512 signature: 15428fdc7b26d18b1f3eae4569399ae6ebfd430c8f073bf  2fa77ebfe1ad5645640374ea4a4aeadd252af3a198e55e69ad2a910e28470d9b54748887de06a  5c3ed7ab12399a404359332553e051e8ae0f3ef741faa15a21ad17a9c235e5f91d567bcca0e5a  6117689dccada4a33ee897514f7a8a32f12dac0087f5dcbb094c93c792f672e1685618ac5d93a  a9d30f6d8e306145ef2d1b9cfdc04d6c61b43376089a78471e8e03d97ee3b57e1b734a23f4436  6a99234a0abeb1d36d01c474833b4c2beaf430dae06ab95a1c951645fb1e0a5e7b9eed44d40e3  5036f2cd2764df6cc04fe1248e1bb772a53c8201a974109333a318ce57930494d4cb5e41d0dc8  f1c RSA-SHA512 signature verified: true RSA ECB PKCS1 decrypted value: Hello Ballerina! RSA ECB OAEPwithSHA512andMGF1 decrypted value: Hello Ballerina! AES CBC PKCS5 decrypted value: Hello Ballerina! AES CBC no padding decrypted value: Hello Ballerina! AES GCM PKCS5 decrypted value: Hello Ballerina! AES GCM no padding decrypted value: Hello Ballerina! AES ECB PKCS5 decrypted value: Hello Ballerina! AES ECB no padding decrypted value: Hello Ballerina!    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/table-syntax.html","name":"Table Syntax","summary":"A record field can be declared as readonly: cannot assign to the field after the record is created.\n table type gives type of row and name of key field. table constructor expression looks like an\n array constructor. foreach statement will iterate over a table’s rows in order. Use t[k]\n to ...","content":"/  /  / Table Syntax  import ballerina/io;  type Employee record {  readonly string name;  int salary; };  // Creates a `table` with `Employee` type members, where each // member is uniquely identified using their `name` field. table<Employee> key(name) t = table [  { name: \"John\", salary: 100 },  { name: \"Jane\", salary: 200 } ];  function increaseSalary(int n) {  // Iterates over the rows of `t` in the specified order.  foreach Employee e in t {  e.salary += n;  } }  public function main() {  // Retrieves `Employee` with key value `Fred`.  Employee? e = t[\"Fred\"];   increaseSalary(100)  io:println(t); }    Table Syntax  A record field can be declared as readonly: cannot assign to the field after the record is created.  table type gives type of row and name of key field. table constructor expression looks like an  array constructor. foreach statement will iterate over a table’s rows in order. Use t[k]  to access a row using its key.    import ballerina/io;    type Employee record {  readonly string name;  int salary; };    table<Employee> key(name) t = table [  { name: \"John\", salary: 100 },  { name: \"Jane\", salary: 200 } ];    Creates a table with Employee type members, where each  member is uniquely identified using their name field.   function increaseSalary(int n) {    foreach Employee e in t {  e.salary += n;  } }    Iterates over the rows of t in the specified order.   public function main() {    Employee? e = t[\"Fred\"];    Retrieves Employee with key value Fred.   increaseSalary(100)  io:println(t); }    bal run table_syntax.bal [{\"name\":\"John\",\"salary\":200},{\"name\":\"Jane\",\"salary\":300}]    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/task-frequency-job-execution.html","name":"Schedule Job recurrence by Frequency","summary":"A  task:scheduleJobRecurByFrequency() can be used to execute Ballerina jobs periodically.\n The task:Job and interval should be specified and optional configurations are start time,\n end time, and maximum count.\n For more information on the underlying module,\n see the .Creates a job to be executed by the scheduler.Executes this function when ...","content":"/  /  / Schedule Job recurrence by Frequency  import ballerina/io; import ballerina/lang.runtime; import ballerina/task;  // Creates a job to be executed by the scheduler. class Job {   *task:Job;  int i = 1;   // Executes this function when the scheduled trigger fires.  public function execute() {  self.i += 1;  io:println(\"MyCounter: \", self.i);  }   isolated function init(int i) {  self.i = i;  } }  public function main() returns error? {   // Schedules the task to execute the job every second.  task:JobId id = check task:scheduleJobRecurByFrequency(new Job(0), 1);   // Waits for nine seconds.  runtime:sleep(9);   // Unschedules the job.  check task:unscheduleJob(id); }    Schedule Job recurrence by Frequency  A task:scheduleJobRecurByFrequency() can be used to execute Ballerina jobs periodically.  The task:Job and interval should be specified and optional configurations are start time,  end time, and maximum count.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/lang.runtime; import ballerina/task;    class Job {    Creates a job to be executed by the scheduler.   *task:Job;  int i = 1;    public function execute() {  self.i += 1;  io:println(\"MyCounter: \", self.i);  }    Executes this function when the scheduled trigger fires.   isolated function init(int i) {  self.i = i;  } }    public function main() returns error? {    task:JobId id = check task:scheduleJobRecurByFrequency(new Job(0), 1);    Schedules the task to execute the job every second.   runtime:sleep(9);    Waits for nine seconds.   check task:unscheduleJob(id); }    Unschedules the job.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run task_frequency_job_execution.bal MyCounter: 1 MyCounter: 2 MyCounter: 3 MyCounter: 4 MyCounter: 5 MyCounter: 6 MyCounter: 7 MyCounter: 8 MyCounter: 9 MyCounter: 10    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/task-one-time-job-execution.html","name":"Schedule one time job","summary":"A  task:scheduleOneTimeJob() can be used to execute Ballerina jobs at a specific time.\n The task:Job and time should be specified to schedule the job.\n For more information on the underlying module,\n see the .Creates a job to be executed by the scheduler.Executes this function when the scheduled trigger fires.Gets ...","content":"/  /  / Schedule one time job  import ballerina/io; import ballerina/lang.runtime; import ballerina/task; import ballerina/time;  // Creates a job to be executed by the scheduler. class Job {   *task:Job;  int i = 1;   // Executes this function when the scheduled trigger fires.  public function execute() {  self.i += 1;  io:println(\"MyCounter: \", self.i);  }   isolated function init(int i) {  self.i = i;  } }  public function main() returns error? {  // Gets the current time.  time:Utc currentUtc = time:utcNow();  // Increases the time by three seconds to get the specified time for scheduling the job.  time:Utc newTime = time:utcAddSeconds(currentUtc, 3);  // Gets the `time:Civil` for the given time.  time:Civil time = time:utcToCivil(newTime);   // Schedules the one-time job at the specified time.  task:JobId result = check task:scheduleOneTimeJob(new Job(0), time);   // Waits for five seconds.  runtime:sleep(5); }    Schedule one time job  A task:scheduleOneTimeJob() can be used to execute Ballerina jobs at a specific time.  The task:Job and time should be specified to schedule the job.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/lang.runtime; import ballerina/task; import ballerina/time;    class Job {    Creates a job to be executed by the scheduler.   *task:Job;  int i = 1;    public function execute() {  self.i += 1;  io:println(\"MyCounter: \", self.i);  }    Executes this function when the scheduled trigger fires.   isolated function init(int i) {  self.i = i;  } }    public function main() returns error? {    time:Utc currentUtc = time:utcNow();    Gets the current time.   time:Utc newTime = time:utcAddSeconds(currentUtc, 3);    Increases the time by three seconds to get the specified time for scheduling the job.   time:Civil time = time:utcToCivil(newTime);    Gets the time:Civil for the given time.   task:JobId result = check task:scheduleOneTimeJob(new Job(0), time);    Schedules the one-time job at the specified time.   runtime:sleep(5); }    Waits for five seconds.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run task_one_time_job_execution.bal MyCounter: 1    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/tcp-client.html","name":"TCP Client","summary":"The TCP Client is used to connect to a remote TCP server.\n This sample demonstrates how the TCP client interacts with the TCP server.\n For more information on the underlying module,\n see the .Create a new TCP client by providing the remoteHost and remotePort.\n Optionally, you can provide the interface ...","content":"/  /  / TCP Client  import ballerina/io; import ballerina/tcp;  public function main() returns error? {   // Create a new TCP client by providing the `remoteHost` and `remotePort`.  // Optionally, you can provide the interface that the socket needs to bind // and the timeout in seconds, which specifies the read timeout value.  // tcp:Client client = check new (\"localhost\", 3000, localHost = \"localhost\",  // timeout = 5);  tcp:Client socketClient = check new (\"localhost\", 3000);   // Send the desired content to the server.  string msg = \"Hello Ballerina Echo from client\";  byte[] msgByteArray = msg.toBytes();  check socketClient->writeBytes(msgByteArray);   // Read the response from the server.  readonly & byte[] receivedData = check socketClient->readBytes();  io:println(\"Received: \", string:fromBytes(receivedData));   // Close the connection between the server and the client.  check socketClient->close(); }    TCP Client  The TCP Client is used to connect to a remote TCP server.  This sample demonstrates how the TCP client interacts with the TCP server.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/tcp;    public function main() returns error? {    tcp:Client socketClient = check new (\"localhost\", 3000);    Create a new TCP client by providing the remoteHost and remotePort.  Optionally, you can provide the interface that the socket needs to bind  and the timeout in seconds, which specifies the read timeout value.  tcp:Client client = check new (“localhost”, 3000, localHost = “localhost”,  timeout = 5);   string msg = \"Hello Ballerina Echo from client\";  byte[] msgByteArray = msg.toBytes();  check socketClient->writeBytes(msgByteArray);    Send the desired content to the server.   readonly & byte[] receivedData = check socketClient->readBytes();  io:println(\"Received: \", string:fromBytes(receivedData));    Read the response from the server.   check socketClient->close(); }    Close the connection between the server and the client.   # As a prerequisite, navigate to the directory that contains the # `tcp_listener.bal` file and use the `bal run` command below. bal run tcp_listener.bal    # To run the client, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run tcp_client.bal    # Print the response that is obtained from the server. Received: Hello Ballerina Echo from client    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/tcp-listener.html","name":"TCP Listener","summary":"The TCP Listener is used to expose a TCP service over the TCP protocol.\n This sample demonstrates how the TCP socket listener service interacts with the TCP client.\n For more information on the underlying module,\n see the .Bind the service to the port.This remote method is invoked when the new ...","content":"/  /  / TCP Listener  import ballerina/io; import ballerina/log; import ballerina/tcp;  // Bind the service to the port. service on new tcp:Listener(3000) {   // This remote method is invoked when the new client connects to the server.  remote function onConnect(tcp:Caller caller)  returns tcp:ConnectionService {  io:println(\"Client connected to echo server: \", caller.remotePort);  return new EchoService();  } }  service class EchoService {   // This remote method is invoked once the content is received from the client.  remote function onBytes(tcp:Caller caller, readonly & byte[] data) returns tcp:Error? {  io:println(\"Echo: \", string:fromBytes(data));  // Echoes back the data to the client from which the data is received.  check caller->writeBytes(data);  }   // This remote method is invoked in an erroneous situation,  // which occurs during the execution of the `onConnect` or `onBytes` method.  remote function onError(tcp:Error err) returns tcp:Error? {  log:printError(\"An error occurred\", 'error = err);  }   // This remote method is invoked when the connection is closed.  remote function onClose() returns tcp:Error? {  io:println(\"Client left\");  } }    TCP Listener  The TCP Listener is used to expose a TCP service over the TCP protocol.  This sample demonstrates how the TCP socket listener service interacts with the TCP client.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/log; import ballerina/tcp;    service on new tcp:Listener(3000) {    Bind the service to the port.   remote function onConnect(tcp:Caller caller)  returns tcp:ConnectionService {  io:println(\"Client connected to echo server: \", caller.remotePort);  return new EchoService();  } }    This remote method is invoked when the new client connects to the server.   service class EchoService {    remote function onBytes(tcp:Caller caller, readonly & byte[] data) returns tcp:Error? {  io:println(\"Echo: \", string:fromBytes(data));    This remote method is invoked once the content is received from the client.   check caller->writeBytes(data);  }    Echoes back the data to the client from which the data is received.   remote function onError(tcp:Error err) returns tcp:Error? {  log:printError(\"An error occurred\", 'error = err);  }    This remote method is invoked in an erroneous situation,  which occurs during the execution of the onConnect or onBytes method.   remote function onClose() returns tcp:Error? {  io:println(\"Client left\");  } }    This remote method is invoked when the connection is closed.   # To start the service, navigate to the directory that contains the # `.bal` file and use the `bal run` command below. bal run tcp_listener.bal    # The tcp listener starts listening to the port 61598 for incoming client requests. Client connected to echoServer: 48735 Echo: Hello Ballerina Echo from client Client left    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/temp-files-directories.html","name":"Temp Files and Directories","summary":"The Ballerina File API contains functions to perform temp file and directory operations.\n For more information on the underlying module,\n see the .Creates a temporary directory in the default tmp directory of the OS.Creates a temporary file in the default tmp directory of the OS.Creates a temporary file in a ...","content":"/  /  / Temp Files and Directories  import ballerina/file; import ballerina/io;  public function main() returns error? {   // Creates a temporary directory in the default `tmp` directory of the OS.  string tmpDir = check file:createTempDir();  io:println(\"Absolute path of the tmp directory: \", tmpDir);   // Creates a temporary file in the default `tmp` directory of the OS.  string tmpResult = check file:createTemp();  io:println(\"Absolute path of the tmp file: \", tmpResult);   // Creates a temporary file in a specific directory.  string tmp2Result = check file:createTemp(dir = tmpDir);  io:println(\"Absolute path of the tmp file: \", tmp2Result); }    Temp Files and Directories  The Ballerina File API contains functions to perform temp file and directory operations.  For more information on the underlying module,  see the .    import ballerina/file; import ballerina/io;    public function main() returns error? {    string tmpDir = check file:createTempDir();  io:println(\"Absolute path of the tmp directory: \", tmpDir);    Creates a temporary directory in the default tmp directory of the OS.   string tmpResult = check file:createTemp();  io:println(\"Absolute path of the tmp file: \", tmpResult);    Creates a temporary file in the default tmp directory of the OS.   string tmp2Result = check file:createTemp(dir = tmpDir);  io:println(\"Absolute path of the tmp file: \", tmp2Result); }    Creates a temporary file in a specific directory.   # To run this sample, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run temp_files_directories.bal Absolute path of the tmp directory: /var/folders/f2/1s2f2mzd30ldl_fzxk4_gq3c0000gn/T/90eb0a6f-200a-454d-9285-f3264a71cd80 Absolute path of the tmp file: /var/folders/f2/1s2f2mzd30ldl_fzxk4_gq3c0000gn/T/9b0ce907-51cd-4f6b-98f0-d99566e3870d Absolute path of the tmp file: /var/folders/f2/1s2f2mzd30ldl_fzxk4_gq3c0000gn/T/90eb0a6f-200a-454d-9285-f3264a71cd80/14c45332-37df-44d1-b24b-3dbcb7c7404c    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/time-utc-and-civil.html","name":"Time with Zone Offset","summary":"This sample demonstrates how to convert UTC to local time and\n vice versa.\n For more information on the underlying module,\n see the .Gets the current instant of the system clock (seconds from the epoch of\n 1970-01-01T00:00:00). The returned time:Utc value represents seconds\n from the epoch with nanoseconds precision.Converts a given ...","content":"/  /  / Time with Zone Offset  import ballerina/io; import ballerina/time;  public function main() returns error? {  // Gets the current instant of the system clock (seconds from the epoch of  // 1970-01-01T00:00:00). The returned `time:Utc` value represents seconds  // from the epoch with nanoseconds precision.  time:Utc utc1 = time:utcNow();  // Converts a given `time:Utc` value to a `time:Civil` value.  time:Civil civil1 = time:utcToCivil(utc1);  io:println(`Civil record: ${civil1.toString()}`);   // Converts a given `time:Civil` value to a `time:Utc` value.  // Note that, since `time:Civil` is used to represent localized time,  // it is mandatory to have the `utcOffset` field to be specified in the  // given `time:Civil` value.  time:Civil civil2 = {  year: 2021,  month: 4,  day: 13,  hour: 4,  minute: 50,  second: 50.52,  timeAbbrev: \"Asia/Colombo\",  utcOffset: {hours: 5, minutes: 30, seconds: 0d}  };  time:Utc utc2 = check time:utcFromCivil(civil2);  io:println(`UTC value of the civil record: ${utc2.toString()}`); }    Time with Zone Offset  This sample demonstrates how to convert UTC to local time and  vice versa.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/time;    public function main() returns error? {    time:Utc utc1 = time:utcNow();    Gets the current instant of the system clock (seconds from the epoch of  1970-01-01T00:00:00). The returned time:Utc value represents seconds  from the epoch with nanoseconds precision.   time:Civil civil1 = time:utcToCivil(utc1);  io:println(`Civil record: ${civil1.toString()}`);    Converts a given time:Utc value to a time:Civil value.   time:Civil civil2 = {  year: 2021,  month: 4,  day: 13,  hour: 4,  minute: 50,  second: 50.52,  timeAbbrev: \"Asia/Colombo\",  utcOffset: {hours: 5, minutes: 30, seconds: 0d}  };  time:Utc utc2 = check time:utcFromCivil(civil2);  io:println(`UTC value of the civil record: ${utc2.toString()}`); }    Converts a given time:Civil value to a time:Utc value.  Note that, since time:Civil is used to represent localized time,  it is mandatory to have the utcOffset field to be specified in the  given time:Civil value.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run time_utc_and_civil.bal Civil record: {\"timeAbbrev\":\"Z\",\"dayOfWeek\":1,\"year\":2021,\"month\":5,\"day\":24,\"hour\":7,\"minute\":7,\"second\":15.757818} UTC value of the civil record: 1618269650 0.52    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/time-utc.html","name":"UTC Time","summary":"This sample demonstrates how to obtain the current time from the epoch\n 1970-01-01T00:00:00\n For more information on the underlying module,\n see the .Gets the current instant of the system clock (seconds from the epoch of\n 1970-01-01T00:00:00). The returned time:Utc value represents seconds\n from the epoch with nanoseconds precision.\n The time:Utc ...","content":"/  /  / UTC Time  import ballerina/io; import ballerina/time;  public function main() returns error? {  // Gets the current instant of the system clock (seconds from the epoch of  // 1970-01-01T00:00:00). The returned `time:Utc` value represents seconds  // from the epoch with nanoseconds precision.  // The `time:Utc` is a tuple with `[int, decimal]`. The first member of the  // tuple represents the number of seconds from the epoch. The second  // member represents the rest of the nanoseconds from the epoch as a  // fraction.  time:Utc currentUtc = time:utcNow();  io:println(`Number of seconds from the epoch: ${currentUtc[0]}s`);  io:println(`Nanoseconds fraction: ${currentUtc[1]}s`); }    UTC Time  This sample demonstrates how to obtain the current time from the epoch  1970-01-01T00:00:00  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/time;    public function main() returns error? {    time:Utc currentUtc = time:utcNow();  io:println(`Number of seconds from the epoch: ${currentUtc[0]}s`);  io:println(`Nanoseconds fraction: ${currentUtc[1]}s`); }    Gets the current instant of the system clock (seconds from the epoch of  1970-01-01T00:00:00). The returned time:Utc value represents seconds  from the epoch with nanoseconds precision.  The time:Utc is a tuple with [int, decimal]. The first member of the  tuple represents the number of seconds from the epoch. The second  member represents the rest of the nanoseconds from the epoch as a  fraction.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run time_utc.bal Number of seconds from the epoch: 1621839972s Nanoseconds fraction: 0.005413000s    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/time-formatting-and-parsing.html","name":"Time formatting/Parsing","summary":"This sample demonstrates how time APIs can be used to convert UTC and\n local time to different string representations (RFC 5322 and RFC 3339)\n vice versa.\n For more information on the underlying module,\n see the .Converts a given RFC 3339 timestamp\n (e.g. 2007-12-03T10:15:30.12Z) string to a time:Utc value.Converts a given ...","content":"/  /  / Time formatting/Parsing  import ballerina/io; import ballerina/time;  public function main() returns error? {  // Converts a given RFC 3339 timestamp  // (e.g. `2007-12-03T10:15:30.12Z`) string to a `time:Utc` value.  time:Utc utc = check time:utcFromString(\"2007-12-03T10:15:30.120Z\");  io:println(\"UTC value: \" + utc.toString());   // Converts a given `time:Utc` to a RFC 3339 timestamp  // (e.g. `2007-12-03T10:15:30.00Z`) string.  string utcString = time:utcToString(utc);  io:println(`UTC string representation: ${utcString}`);   // Converts a given RFC 3339 timestamp(e.g. `2007-12-03T10:15:30.00Z`)  // to a `time:Civil` record.  time:Civil civil1 = check  time:civilFromString(\"2021-04-12T23:20:50.520+05:30[Asia/Colombo]\");  io:println(\"Converted civil value: \" + civil1.toString());   // Converts a given `time:Civil` value to a RFC 3339  // (e.g. `2007-12-03T10:15:30.00Z`) formatted string.  string civilString = check time:civilToString(civil1);  io:println(`Civil string representation: ${civilString}`);   // Converts a given UTC to an RFC 5322 formatted string  // (e.g `Mon, 3 Dec 2007 10:15:30 GMT`).  string emailFormattedString = time:utcToEmailString(utc, \"Z\");  io:println(`Email formatted string: ${emailFormattedString}`);   // Converts a given RFC 5322 formatted string  // (e.g `Mon, 3 Dec 2007 10:15:30 GMT`) to a `time:Civil` record.  time:Civil civil2 = check  time:civilFromEmailString(\"Wed, 10 Mar 2021 19:51:55 -0800 (PST)\");  io:println(`Civil record of the email string: ${civil2.toString()}`);   // Converts a given `time:Civil` record to an RFC 5322 formatted string  // (e.g `Mon, 3 Dec 2007 10:15:30 GMT`).  string emailString = check  time:civilToEmailString(civil2, time:PREFER_ZONE_OFFSET);  io:println(`Email string of the civil record: ${emailString}`);  }    Time formatting/Parsing  This sample demonstrates how time APIs can be used to convert UTC and  local time to different string representations (RFC 5322 and RFC 3339)  vice versa.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/time;    public function main() returns error? {    time:Utc utc = check time:utcFromString(\"2007-12-03T10:15:30.120Z\");  io:println(\"UTC value: \" + utc.toString());    Converts a given RFC 3339 timestamp  (e.g. 2007-12-03T10:15:30.12Z) string to a time:Utc value.   string utcString = time:utcToString(utc);  io:println(`UTC string representation: ${utcString}`);    Converts a given time:Utc to a RFC 3339 timestamp  (e.g. 2007-12-03T10:15:30.00Z) string.   time:Civil civil1 = check  time:civilFromString(\"2021-04-12T23:20:50.520+05:30[Asia/Colombo]\");  io:println(\"Converted civil value: \" + civil1.toString());    Converts a given RFC 3339 timestamp(e.g. 2007-12-03T10:15:30.00Z)  to a time:Civil record.   string civilString = check time:civilToString(civil1);  io:println(`Civil string representation: ${civilString}`);    Converts a given time:Civil value to a RFC 3339  (e.g. 2007-12-03T10:15:30.00Z) formatted string.   string emailFormattedString = time:utcToEmailString(utc, \"Z\");  io:println(`Email formatted string: ${emailFormattedString}`);    Converts a given UTC to an RFC 5322 formatted string  (e.g Mon, 3 Dec 2007 10:15:30 GMT).   time:Civil civil2 = check  time:civilFromEmailString(\"Wed, 10 Mar 2021 19:51:55 -0800 (PST)\");  io:println(`Civil record of the email string: ${civil2.toString()}`);    Converts a given RFC 5322 formatted string  (e.g Mon, 3 Dec 2007 10:15:30 GMT) to a time:Civil record.   string emailString = check  time:civilToEmailString(civil2, time:PREFER_ZONE_OFFSET);  io:println(`Email string of the civil record: ${emailString}`);    Converts a given time:Civil record to an RFC 5322 formatted string  (e.g Mon, 3 Dec 2007 10:15:30 GMT).   }    # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run time_formatting_and_parsing/time_formatting_and_parsing.bal UTC value: 1196676930 0.12 UTC string representation: 2007-12-03T10:15:30.120Z Converted civil value: {\"utcOffset\":{\"hours\":5,\"minutes\":30},\"timeAbbrev\":\"Asia/Colombo\",\"dayOfWeek\":1,\"year\":2021,\"month\":4,\"day\":12,\"hour\":23,\"minute\":20,\"second\":50.52} Civil string representation: 2021-04-12T17:50:50.520Z Email formatted string: Mon, 3 Dec 2007 10:15:30 Z Civil record of the email string: {\"utcOffset\":{\"hours\":-8,\"minutes\":0},\"timeAbbrev\":\"America/Los_Angeles\",\"dayOfWeek\":3,\"year\":2021,\"month\":3,\"day\":10,\"hour\":19,\"minute\":51,\"second\":55} Email string of the civil record: Wed, 10 Mar 2021 19:51:55 -0800    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/type-definitions.html","name":"Type Definitions","summary":"A type definition gives a name for a type. Its name is just an alias for the type, like typedef in C.Defines a type named MapArray.Creates a MapArray value.\n arr has elements which are of map<string> type.This website uses cookies so that we can provide you with the best user ...","content":"/  /  / Type Definitions  import ballerina/io;  // Defines a type named `MapArray`. type MapArray map<string>[];  public function main() {  // Creates a `MapArray` value.  // `arr` has elements which are of `map<string>` type.  MapArray arr = [  {\"x\": \"foo\"},  {\"y\": \"bar\"}  ];  io:println(arr[0]); }    Type Definitions  A type definition gives a name for a type. Its name is just an alias for the type, like typedef in C.    import ballerina/io;    type MapArray map<string>[];    Defines a type named MapArray.   public function main() {    MapArray arr = [  {\"x\": \"foo\"},  {\"y\": \"bar\"}  ];  io:println(arr[0]); }    Creates a MapArray value.  arr has elements which are of map<string> type.   bal run type_definitions.bal {\"x\":\"foo\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/type-inference.html","name":"Type Inference","summary":"Type inference is local and restricted to a single expression.\n Overuse Type inference can make code harder to understandvar says that type of variable from type of expression\n used to initialize itType inference with foreach statementInfer x as type MyClassInfer class for new as MyClassThis website uses cookies so that ...","content":"/  /  / Type Inference  import ballerina/io;  //`var` says that type of variable from type of expression // used to initialize it var x = \"str\";  function printLines(string[] sv) {  // Type inference with foreach statement  foreach var s in sv {  io:println(s);  } }  public function main() {  string[] s = [x, x];  printLines(s);   // Infer x as type MyClass  var x = new MyClass();   // Infer class for new as MyClass  MyClass y = new; }  class MyClass {  function foo() {   } }    Type Inference Type inference is local and restricted to a single expression.  Overuse Type inference can make code harder to understand    import ballerina/io;    var x = \"str\";    var says that type of variable from type of expression  used to initialize it   function printLines(string[] sv) {    foreach var s in sv {  io:println(s);  } }    Type inference with foreach statement   public function main() {  string[] s = [x, x];  printLines(s);    var x = new MyClass();    Infer x as type MyClass   MyClass y = new; }    Infer class for new as MyClass   class MyClass {  function foo() {    } }    bal run type_inference.bal str str    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/udp-client.html","name":"UDP Connectionless Client","summary":"The UDP Client is used to send data to a specific remote host using the UDP protocol.\n This sample demonstrates how to send a datagram to a remote server\n and print the echoed response.\n For more information on the underlying module,\n see the .Creates a new connectionless UDP client.\n Optionally, ...","content":"/  /  / UDP Connectionless Client  import ballerina/io; import ballerina/udp;  public function main() returns error? {  // Creates a new connectionless UDP client.  // Optionally, you can provide the address that the socket needs to bind // and the timeout in milliseconds, which specifies the read timeout value.  // E.g.: `udp:Client client = new (localHost = \"localhost\", timeout = 5);`  udp:Client socketClient = check new;   string msg = \"Hello Ballerina echo\";  udp:Datagram datagram = {  remoteHost: \"localhost\",  remotePort : 8080,  data : msg.toBytes()  };   // Sends the data to the remote host.  // The parameter is a Datagram record, which contains the `remoteHost`,  // `remotePort`, and the `data` to be sent.  check socketClient->sendDatagram(datagram);  io:println(\"Datagram was sent to the remote host.\");   // Waits until the data is received from the remote host.  readonly & udp:Datagram result = check socketClient->receiveDatagram();  io:println(\"Received: \", string:fromBytes(result.data)); // Closes the client and releases the bound port.  check socketClient->close(); }    UDP Connectionless Client  The UDP Client is used to send data to a specific remote host using the UDP protocol.  This sample demonstrates how to send a datagram to a remote server  and print the echoed response.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/udp;    public function main() returns error? {  udp:Client socketClient = check new;    Creates a new connectionless UDP client.  Optionally, you can provide the address that the socket needs to bind  and the timeout in milliseconds, which specifies the read timeout value.  E.g.: udp:Client client = new (localHost = \"localhost\", timeout = 5);   string msg = \"Hello Ballerina echo\";  udp:Datagram datagram = {  remoteHost: \"localhost\",  remotePort : 8080,  data : msg.toBytes()  };    check socketClient->sendDatagram(datagram);  io:println(\"Datagram was sent to the remote host.\");    Sends the data to the remote host.  The parameter is a Datagram record, which contains the remoteHost,  remotePort, and the data to be sent.   readonly & udp:Datagram result = check socketClient->receiveDatagram();  io:println(\"Received: \", string:fromBytes(result.data)); Waits until the data is received from the remote host.   check socketClient->close(); }    Closes the client and releases the bound port.   # To run the client, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run udp_client.bal    # This will print the output below upon a successful write. Datagram was sent to the remote host. # Print the response that is returned from the server as an echo. Received: Hello Ballerina echo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/udp-connect-client.html","name":"UDP Connection-Oriented Client","summary":"The ConnectClient is configured so that it only receives data from,\n and sends data to, the given remote peer address. Once connected,\n data may not be received from or sent to any other address.\n The client remains connected until it is explicitly disconnected or until it is closed.\n This sample ...","content":"/  /  / UDP Connection-Oriented Client  // This is the connection oriented client implementation of the UDP socket. import ballerina/io; import ballerina/udp;  public function main() returns error? {  // Creates a new connection-oriented UDP client by providing the  // `remoteHost` and the `remotePort`.  // Optionally, you can provide the interface that the socket needs to bind // and the timeout in milliseconds, which specifies the read timeout value.  // E.g.: `udp:Client client = new (\"www.ballerina.com\", 80,  // localHost = \"localhost\", timeout = 5);`  udp:ConnectClient socketClient = check new(\"localhost\", 8080);   string msg = \"Hello Ballerina echo\";   // Sends the data to the connected remote host.  // The parameter is a `byte[]`, which contains the data to be sent.  check socketClient->writeBytes(msg.toBytes());  io:println(\"Data was sent to the remote host.\");   // Waits until the data is received from the connected host.  readonly & byte[] result = check socketClient->readBytes();  io:println(\"Received: \", string:fromBytes(result));   // Closes the client and releases the bound port.  check socketClient->close(); }    UDP Connection-Oriented Client  The ConnectClient is configured so that it only receives data from,  and sends data to, the given remote peer address. Once connected,  data may not be received from or sent to any other address.  The client remains connected until it is explicitly disconnected or until it is closed.  This sample demonstrates how to send data to a connected server and print the echoed response.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/udp;    This is the connection oriented client implementation of the UDP socket.   public function main() returns error? {  udp:ConnectClient socketClient = check new(\"localhost\", 8080);    Creates a new connection-oriented UDP client by providing the  remoteHost and the remotePort.  Optionally, you can provide the interface that the socket needs to bind  and the timeout in milliseconds, which specifies the read timeout value.  E.g.: udp:Client client = new (\"www.ballerina.com\", 80,  localHost = \"localhost\", timeout = 5);   string msg = \"Hello Ballerina echo\";    check socketClient->writeBytes(msg.toBytes());  io:println(\"Data was sent to the remote host.\");    Sends the data to the connected remote host.  The parameter is a byte[], which contains the data to be sent.   readonly & byte[] result = check socketClient->readBytes();  io:println(\"Received: \", string:fromBytes(result));    Waits until the data is received from the connected host.   check socketClient->close(); }    Closes the client and releases the bound port.   # To run the connect client, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run udp_connect_client.bal    # This will print the output below upon a successful write. Data was sent to the remote host. # Print the response that is returned from the server as an echo. Received: Hello Ballerina echo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/udp-listener.html","name":"UDP Listener","summary":"The UDP Listener is used to expose a UDP service over the UDP protocol.\n The UDP Client/ConnectClient is used to send data to a remote UDP server.\n This sample demonstrates the UDP socket listener.\n For more information on the underlying module,\n see the .Binds the service to the port.\n Optionally, ...","content":"/  /  / UDP Listener  import ballerina/io; import ballerina/udp;  // Binds the service to the port. // Optionally, you can provide the `remoteHost` and `remotePort` to // configure the listener as a connected listener, which only // reads and writes to the configured remote host. // E.g.: `udp:Listener(8080, remoteHost // = \"www.remote-clinet.com\", remotePort = 9090)` service on new udp:Listener(8080) {   // This remote method is invoked once the content is received from the  // client. You may replace the `onBytes` method with `onDatagram`, which  // reads the data as `readonly & udp:Datagram`.  remote function onDatagram(readonly & udp:Datagram datagram) returns udp:Datagram|udp:Error? {  io:println(\"Received by listener: \", string:fromBytes(datagram.data));  // Echoes back the data to the same client.  // This is similar to calling `caller->sendDatagram(data);`.  return datagram;  } }    UDP Listener  The UDP Listener is used to expose a UDP service over the UDP protocol.  The UDP Client/ConnectClient is used to send data to a remote UDP server.  This sample demonstrates the UDP socket listener.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/udp;    service on new udp:Listener(8080) {    Binds the service to the port.  Optionally, you can provide the remoteHost and remotePort to  configure the listener as a connected listener, which only  reads and writes to the configured remote host.  E.g.: udp:Listener(8080, remoteHost  = \"www.remote-clinet.com\", remotePort = 9090)   remote function onDatagram(readonly & udp:Datagram datagram) returns udp:Datagram|udp:Error? {  io:println(\"Received by listener: \", string:fromBytes(datagram.data));    This remote method is invoked once the content is received from the  client. You may replace the onBytes method with onDatagram, which  reads the data as readonly & udp:Datagram.   return datagram;  } }    Echoes back the data to the same client.  This is similar to calling caller->sendDatagram(data);.   # To run the listener, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run udp_listener.bal    # This will print the output below upon a successful read by the listener. Received by listener: Hello Ballerina echo    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/unions.html","name":"Unions","summary":"T1|T2 is the union of the sets described by T1 and T2. T? is completely equivalent to T|().\n Unions are untagged. is operator tests whether a value belongs to a specific type. is operator in\n the condition causes declared type to be narrowed.A Name type value can be either a ...","content":"/  /  / Unions  import ballerina/io;  type StructuredName record {  string firstName;  string lastName; };  // A `Name` type value can be either a `StructuredName` or a `string`. type Name StructuredName|string;  public function main() {  // `name1` is a `StructuredName`.  Name name1 = {  firstName: \"Rowan\",  lastName: \"Atkinson\"  };  // `name2` is a `string`.  Name name2 = \"Leslie Banks\";   io:println(nameToString(name1));  io:println(nameToString(name2)); }  function nameToString(Name nm) returns string {  if nm is string {  return nm;  } else {  return nm.firstName + \" \" + nm.lastName;  } }    Unions  T1|T2 is the union of the sets described by T1 and T2. T? is completely equivalent to T|().  Unions are untagged. is operator tests whether a value belongs to a specific type. is operator in  the condition causes declared type to be narrowed.    import ballerina/io;    type StructuredName record {  string firstName;  string lastName; };    type Name StructuredName|string;    A Name type value can be either a StructuredName or a string.   public function main() {    Name name1 = {  firstName: \"Rowan\",  lastName: \"Atkinson\"  };    name1 is a StructuredName.   Name name2 = \"Leslie Banks\";    name2 is a string.   io:println(nameToString(name1));  io:println(nameToString(name2)); }    function nameToString(Name nm) returns string {  if nm is string {  return nm;  } else {  return nm.firstName + \" \" + nm.lastName;  } }    bal run unions.bal Rowan Atkinson Leslie Banks    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/url-encode-decode.html","name":"URL Encode/Decode Operations","summary":"Ballerina URL API supports encoding/decoding a URL or part of a URL.\n For more information on the underlying module,\n see the .Encoding a URL component into a string.Decoding an encoded URL component into a string.This website uses cookies so that we can provide you with the best user experience. Read ...","content":"/  /  / URL Encode/Decode Operations  import ballerina/url; import ballerina/io;  public function main() returns error? {  string value1 = \"data=value\";  // Encoding a URL component into a string.  string encoded = check url:encode(value1, \"UTF-8\");  io:println(\"URL encoded value: \", encoded);   string value2 = \"data%3Dvalue\";  // Decoding an encoded URL component into a string.  string decoded = check url:decode(value2, \"UTF-8\");  io:println(\"URL decoded value: \", decoded); }    URL Encode/Decode Operations  Ballerina URL API supports encoding/decoding a URL or part of a URL.  For more information on the underlying module,  see the .    import ballerina/url; import ballerina/io;    public function main() returns error? {  string value1 = \"data=value\";    string encoded = check url:encode(value1, \"UTF-8\");  io:println(\"URL encoded value: \", encoded);    Encoding a URL component into a string.   string value2 = \"data%3Dvalue\";    string decoded = check url:decode(value2, \"UTF-8\");  io:println(\"URL decoded value: \", decoded); }    Decoding an encoded URL component into a string.   # To run this sample, navigate to the directory that contains the `.bal` file, # and execute the `bal run` command below. bal run url_encode_decode.bal URL encoded value: data%3Dvalue URL decoded value: data=value    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/waiting-for-workers.html","name":"Waiting for Workers","summary":"Named workers can continue to execute after the function’s default worker\n terminates and the function returns.\n A worker (function or named) can use wait to wait for a named worker.A worker (function or named) can use wait to wait for a named worker.This website uses cookies so that we can ...","content":"/  /  / Waiting for Workers  import ballerina/io;  public function main() {  io:println(\"Initializing\");   worker A {  io:println(\"In worker A\");  }   io:println(\"In function worker\");   // A worker (function or named) can use `wait` to wait for a named worker.  wait A;   io:println(\"After wait A\"); }    Waiting for Workers  Named workers can continue to execute after the function’s default worker  terminates and the function returns.  A worker (function or named) can use wait to wait for a named worker.    import ballerina/io;    public function main() {  io:println(\"Initializing\");    worker A {  io:println(\"In worker A\");  }    io:println(\"In function worker\");    wait A;    A worker (function or named) can use wait to wait for a named worker.   io:println(\"After wait A\"); }    bal run waiting_for_workers.bal Initializing In function worker In worker A After wait A    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/uuid-generation.html","name":"Generate UUID","summary":"The uuid library provides functions related to UUID(Universal Unique Identifier).\n For more information on the underlying module,\n see the .Generates a UUID of type 1 as a string.Generates a UUID of type 1 as a UUID record.Generates a UUID of type 3 as a string.Generates a UUID of type 3 ...","content":"/  /  / Generate UUID  import ballerina/io; import ballerina/uuid;  public function main() returns error? {  // Generates a UUID of type 1 as a string.  string uuid1String = uuid:createType1AsString();  io:println(\"UUID of type 1 as a string: \", uuid1String);   // Generates a UUID of type 1 as a UUID record.  uuid:Uuid uuid1Record = check uuid:createType1AsRecord();  io:println(\"UUID of type 1 as a record: \", uuid1Record);   // Generates a UUID of type 3 as a string.  string uuid3String = check uuid:createType3AsString(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 3 as a string: \", uuid3String);   // Generates a UUID of type 3 as a record.  uuid:Uuid uuid3Record = check uuid:createType3AsRecord(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 3 as a record: \", uuid3Record);   // Generates a UUID of type 4 as a string.  string uuid4String = uuid:createType4AsString();  io:println(\"UUID of type 4 as a string: \", uuid4String);   // Generates a UUID of type 4 as a UUID record.  uuid:Uuid uuid4Record = check uuid:createType4AsRecord();  io:println(\"UUID of type 4 as a record: \", uuid4Record);   // Generates a UUID of type 5 as a string.  string uuid5String = check uuid:createType5AsString(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 5 as a string: \", uuid5String);   // Generates a UUID of type 5 as a record.  uuid:Uuid uuid5Record = check uuid:createType5AsRecord(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 5 as a record: \", uuid5Record);   // Generates a nil UUID as a string.  string nilUuidString = uuid:nilAsString();  io:println(\"Nil UUID as a string: \", nilUuidString);   // Generates a nil UUID as a UUID record.  uuid:Uuid nilUuidRecord = uuid:nilAsRecord();  io:println(\"Nil UUID as a record: \", nilUuidRecord); }    Generate UUID  The uuid library provides functions related to UUID(Universal Unique Identifier).  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/uuid;    public function main() returns error? {    string uuid1String = uuid:createType1AsString();  io:println(\"UUID of type 1 as a string: \", uuid1String);    Generates a UUID of type 1 as a string.   uuid:Uuid uuid1Record = check uuid:createType1AsRecord();  io:println(\"UUID of type 1 as a record: \", uuid1Record);    Generates a UUID of type 1 as a UUID record.   string uuid3String = check uuid:createType3AsString(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 3 as a string: \", uuid3String);    Generates a UUID of type 3 as a string.   uuid:Uuid uuid3Record = check uuid:createType3AsRecord(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 3 as a record: \", uuid3Record);    Generates a UUID of type 3 as a record.   string uuid4String = uuid:createType4AsString();  io:println(\"UUID of type 4 as a string: \", uuid4String);    Generates a UUID of type 4 as a string.   uuid:Uuid uuid4Record = check uuid:createType4AsRecord();  io:println(\"UUID of type 4 as a record: \", uuid4Record);    Generates a UUID of type 4 as a UUID record.   string uuid5String = check uuid:createType5AsString(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 5 as a string: \", uuid5String);    Generates a UUID of type 5 as a string.   uuid:Uuid uuid5Record = check uuid:createType5AsRecord(  uuid:NAME_SPACE_DNS, \"ballerina.io\");  io:println(\"UUID of type 5 as a record: \", uuid5Record);    Generates a UUID of type 5 as a record.   string nilUuidString = uuid:nilAsString();  io:println(\"Nil UUID as a string: \", nilUuidString);    Generates a nil UUID as a string.   uuid:Uuid nilUuidRecord = uuid:nilAsRecord();  io:println(\"Nil UUID as a record: \", nilUuidRecord); }    Generates a nil UUID as a UUID record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run uuid_generation.bal UUID of type 1 as a string: 01eb3f05-fbf8-1b92-8711-dc6a5719bb63 UUID of type 1 as a record: {\"timeLow\":32194310,\"timeMid\":7997,\"timeHiAndVersion\":5524,\"clockSeqHiAndReserved\":170,\"clockSeqLo\":116,\"node\":82490221220318} UUID of type 3 as a string: cea5c405-7d11-3fbb-bdfb-9b68497be28b UUID of type 3 as a record: {\"timeLow\":3466970117,\"timeMid\":32017,\"timeHiAndVersion\":16315,\"clockSeqHiAndReserved\":189,\"clockSeqLo\":251,\"node\":170872211759755} UUID of type 4 as a string: 73e0d74e-8a4a-40ce-b1d9-b5b522533852 UUID of type 4 as a record: {\"timeLow\":2795821625,\"timeMid\":5327,\"timeHiAndVersion\":20251,\"clockSeqHiAndReserved\":161,\"clockSeqLo\":71,\"node\":59752348973988} UUID of type 5 as a string: 08aab8bc-c69e-5ea8-8a52-dbb645c67fb5 UUID of type 5 as a record: {\"timeLow\":145406140,\"timeMid\":50846,\"timeHiAndVersion\":24232,\"clockSeqHiAndReserved\":138,\"clockSeqLo\":82,\"node\":241575901167541} Nil UUID as a string: 00000000-0000-0000-0000-000000000000 Nil UUID as a record: {\"timeLow\":0,\"timeMid\":0,\"timeHiAndVersion\":0,\"clockSeqHiAndReserved\":0,\"clockSeqLo\":0,\"node\":0}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/websocket-basic-sample.html","name":"Listener Functionalities","summary":"This example explains the basic functions of a WebSocket server.\n For more information on the underlying module,\n see the .Accept the WebSocket upgrade by returning a websocket:Service.This remote function is triggered when a new text message is received\n from a client.This website uses cookies so that we can provide you ...","content":"/  /  / Listener Functionalities  import ballerina/io; import ballerina/log; import ballerina/websocket;  @websocket:ServiceConfig {  subProtocols: [\"xml\", \"json\"],  idleTimeout: 120 } service /basic/ws on new websocket:Listener(9090) {  resource isolated function get .()  returns websocket:Service|websocket:UpgradeError {  // Accept the WebSocket upgrade by returning a `websocket:Service`.  return new WsService();  } }  service class WsService {  *websocket:Service;  // This `remote function` is triggered when a new text message is received  // from a client.  remote isolated function onTextMessage(websocket:Caller caller,  string text) {  io:println(\"\\ntext message: \" + text);  websocket:Error? err = caller->writeTextMessage(\"You said: \" + text);  if err is websocket:Error {  log:printError(\"Error occurred when sending text\", 'error = err);  }  } }    Listener Functionalities  This example explains the basic functions of a WebSocket server.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/log; import ballerina/websocket;    @websocket:ServiceConfig {  subProtocols: [\"xml\", \"json\"],  idleTimeout: 120 } service /basic/ws on new websocket:Listener(9090) {  resource isolated function get .()  returns websocket:Service|websocket:UpgradeError {    return new WsService();  } }    Accept the WebSocket upgrade by returning a websocket:Service.   service class WsService {  *websocket:Service;    remote isolated function onTextMessage(websocket:Caller caller,  string text) {  io:println(\"\\ntext message: \" + text);  websocket:Error? err = caller->writeTextMessage(\"You said: \" + text);  if err is websocket:Error {  log:printError(\"Error occurred when sending text\", 'error = err);  }  } }    This remote function is triggered when a new text message is received  from a client.   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run websocket_basic_sample.bal    # To check the sample, use a Chrome or Firefox JavaScript console and run the commands below. <br> # Change `xml` to another sub protocol to observe the behavior of the WebSocket server. var ws = new WebSocket(\"ws://localhost:9090/basic/ws\", \"xml\", \"my-protocol\");    ws.onmessage = function(frame) {console.log(frame.data)}; ws.onclose = function(frame) {console.log(frame)};    # Send a message. ws.send(\"hello world\");    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/websocket-binary-client.html","name":"Handle Binary Messages with Client","summary":"The WebSocket client can be used to connect to and interact with a WebSocket server in a Synchronous manner.This example demonstrates how to read and write binary messages using ballerina websocket client\n For more information on the underlying module,\n see the .Create a new .Write a binary message to the ...","content":"/  /  / Handle Binary Messages with Client  import ballerina/io; import ballerina/lang.'string; import ballerina/websocket;  public function main() returns error? {  // Create a new [WebSocket client](https://docs.central.ballerina.io/ballerina/websocket/latest/clients/Client).  websocket:Client wsClient = check new(\"ws://echo.websocket.org\");   // Write a binary message to the server using [writeBinaryMessage](https://docs.central.ballerina.io/ballerina/websocket/latest/clients/Client#writeBinaryMessage).  check wsClient->writeBinaryMessage(\"Binary message\".toBytes());   // Read a binary message echoed from the server using [readBinaryMessage](https://docs.central.ballerina.io/ballerina/websocket/latest/clients/Client#readBinaryMessage).  byte[] byteResp = check wsClient->readBinaryMessage();  string stringResp = check 'string:fromBytes(byteResp);  io:println(stringResp); }    Handle Binary Messages with Client  The WebSocket client can be used to connect to and interact with a WebSocket server in a Synchronous manner.This example demonstrates how to read and write binary messages using ballerina websocket client  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/lang.'string; import ballerina/websocket;    public function main() returns error? {    websocket:Client wsClient = check new(\"ws://echo.websocket.org\");    Create a new .   check wsClient->writeBinaryMessage(\"Binary message\".toBytes());    Write a binary message to the server using .   byte[] byteResp = check wsClient->readBinaryMessage();  string stringResp = check 'string:fromBytes(byteResp);  io:println(stringResp); }    Read a binary message echoed from the server using .   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run websocket_binary_client.bal    Binary message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/uuid-operations.html","name":"UUID Operations","summary":"The uuid library provides functions related to UUID(Universal Unique Identifier).\n For more information on the underlying module,\n see the .Tests a string to see if it is a valid UUID.Detects the RFC version of a UUID.Converts a UUID string to an array of bytes.Converts a UUID string to a UUID ...","content":"/  /  / UUID Operations  import ballerina/io; import ballerina/uuid;  public function main() returns error? {  // Tests a string to see if it is a valid UUID.  boolean valid = uuid:validate(\"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID validated: \", valid.toString());   // Detects the RFC version of a UUID.  uuid:Version v = check uuid:getVersion(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID version: \", v.toString());   // Converts a UUID string to an array of bytes.  byte[] uuidBytes1 = check uuid:toBytes(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID bytes: \", uuidBytes1);   // Converts a UUID string to a UUID record.  uuid:Uuid uuidRecord1 = check uuid:toRecord(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID record: \", uuidRecord1);   uuid:Uuid uuidRecord = {  timeLow: 1133987422,  timeMid: 13817,  timeHiAndVersion: 4587,  clockSeqHiAndReserved: 173,  clockSeqLo: 193,  node: 2485377957890  };  // Converts a UUID record to a UUID string.  string uuidString1 = check uuid:toString(uuidRecord);  io:println(\"UUID string: \", uuidString1);   // Converts a UUID record to an array of bytes.  byte[] uuidBytes2 = check uuid:toBytes(uuidRecord);  io:println(\"UUID bytes: \", uuidBytes2);   // Converts a UUID bytes array to a UUID string.  string uuidString2 = check uuid:toString(  [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2]);  io:println(\"UUID string: \", uuidString2);   // Converts a UUID bytes array to a UUID record.  uuid:Uuid uuidRecord2 = check uuid:toRecord(  [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2]);  io:println(\"UUID record: \", uuidRecord2); }    UUID Operations  The uuid library provides functions related to UUID(Universal Unique Identifier).  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/uuid;    public function main() returns error? {    boolean valid = uuid:validate(\"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID validated: \", valid.toString());    Tests a string to see if it is a valid UUID.   uuid:Version v = check uuid:getVersion(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID version: \", v.toString());    Detects the RFC version of a UUID.   byte[] uuidBytes1 = check uuid:toBytes(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID bytes: \", uuidBytes1);    Converts a UUID string to an array of bytes.   uuid:Uuid uuidRecord1 = check uuid:toRecord(  \"4397465e-35f9-11eb-adc1-0242ac120002\");  io:println(\"UUID record: \", uuidRecord1);    Converts a UUID string to a UUID record.   uuid:Uuid uuidRecord = {  timeLow: 1133987422,  timeMid: 13817,  timeHiAndVersion: 4587,  clockSeqHiAndReserved: 173,  clockSeqLo: 193,  node: 2485377957890  };    string uuidString1 = check uuid:toString(uuidRecord);  io:println(\"UUID string: \", uuidString1);    Converts a UUID record to a UUID string.   byte[] uuidBytes2 = check uuid:toBytes(uuidRecord);  io:println(\"UUID bytes: \", uuidBytes2);    Converts a UUID record to an array of bytes.   string uuidString2 = check uuid:toString(  [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2]);  io:println(\"UUID string: \", uuidString2);    Converts a UUID bytes array to a UUID string.   uuid:Uuid uuidRecord2 = check uuid:toRecord(  [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2]);  io:println(\"UUID record: \", uuidRecord2); }    Converts a UUID bytes array to a UUID record.   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run uuid_operations.bal UUID validated: true UUID version: V1 UUID bytes: [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2] UUID record: {\"timeLow\":1133987422,\"timeMid\":13817,\"timeHiAndVersion\":4587,\"clockSeqHiAndReserved\":173,\"clockSeqLo\":193,\"node\":2485377957890} UUID string: 4397465e-35f9-11eb-adc1-0242ac120002 UUID bytes: [67,151,70,94,53,249,17,235,173,193,2,66,172,18,0,2] UUID string: 4397465e-35f9-11eb-adc1-0242ac120002 UUID record: {\"timeLow\":1133987422,\"timeMid\":13817,\"timeHiAndVersion\":4587,\"clockSeqHiAndReserved\":173,\"clockSeqLo\":193,\"node\":2485377957890}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/websocket-text-client.html","name":"Handle Text Messages with Client","summary":"The WebSocket client can be used to connect to and interact with a WebSocket server in a Synchronous manner. This example demonstrates how to read and write text messages using ballerina websocket client\n For more information on the underlying module,\n see the .Create a new .Write a text message to ...","content":"/  /  / Handle Text Messages with Client  import ballerina/io; import ballerina/websocket;  public function main() returns error? {  // Create a new [WebSocket client](https://ballerina.io/swan-lake/learn/api-docs/ballerina/#/ballerina/websocket/latest/clients/Client).  websocket:Client wsClient = check new(\"ws://echo.websocket.org\");   // Write a text message to the server using [writeTextMessage](https://ballerina.io/swan-lake/learn/api-docs/ballerina/#/ballerina/websocket/latest/clients/Client#writeTextMessage).  check wsClient->writeTextMessage(\"Text message\");   // Read a text message echoed from the server using [readTextMessage](https://ballerina.io/swan-lake/learn/api-docs/ballerina/#/ballerina/websocket/latest/clients/Client#readTextMessage).  string textResp = check wsClient->readTextMessage();  io:println(textResp); }    Handle Text Messages with Client  The WebSocket client can be used to connect to and interact with a WebSocket server in a Synchronous manner. This example demonstrates how to read and write text messages using ballerina websocket client  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/websocket;    public function main() returns error? {    websocket:Client wsClient = check new(\"ws://echo.websocket.org\");    Create a new .   check wsClient->writeTextMessage(\"Text message\");    Write a text message to the server using .   string textResp = check wsClient->readTextMessage();  io:println(textResp); }    Read a text message echoed from the server using .   # To start the service, navigate to the directory that contains the # `.bal` file and execute the `bal run` command below. bal run websocket_text_client.bal    Text message    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/while-statement.html","name":"While Statement","summary":"The while statement is a more flexible iteration than foreach. break and continue statements\n can be used within the loops to alter control flow.Executes the code block that is defined within the while block\n as long as the value of v is not nil.This website uses cookies so that we ...","content":"/  /  / While Statement  import ballerina/io;  public function main() {  LinkedList link1 = {value: \"link1\", next: ()};  LinkedList link2 = {value: \"link2\", next: link1};  io:println(len(link2)); }  type LinkedList record {  string value;  LinkedList? next; };  function len(LinkedList ll) returns int {  int n = 0;  LinkedList? v = ll;  // Executes the code block that is defined within the `while` block  // as long as the value of `v` is not `nil`.  while v != () {  n += 1;  if v is LinkedList {  v = v.next;  }  }  return n; }    While Statement  The while statement is a more flexible iteration than foreach. break and continue statements  can be used within the loops to alter control flow.    import ballerina/io;    public function main() {  LinkedList link1 = {value: \"link1\", next: ()};  LinkedList link2 = {value: \"link2\", next: link1};  io:println(len(link2)); }    type LinkedList record {  string value;  LinkedList? next; };    function len(LinkedList ll) returns int {  int n = 0;  LinkedList? v = ll;    while v != () {  n += 1;  if v is LinkedList {  v = v.next;  }  }  return n; }    Executes the code block that is defined within the while block  as long as the value of v is not nil.   bal run while_statement.bal 2    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/websub-webhook-sample.html","name":"Websub Subscriber Service","summary":"Ballerina provides the capability to easily introduce subscriber services that are WebSub-compliant.\n Ballerina WebSub subscribers can specify the topic and hub to which they wish to subscribeThe Ballerina WebSub Subscriber service, which could be used as a WebHook Listener for GitHub.Annotation-based configurations specifying the subscription parameters.Defines the remote function that ...","content":"/  /  / Websub Subscriber Service  // The Ballerina WebSub Subscriber service, which could be used as a WebHook Listener for GitHub. import ballerina/websub; import ballerina/io;  // Annotation-based configurations specifying the subscription parameters. @websub:SubscriberServiceConfig {  target: [  \"https://api.github.com/hub\", \"https://github.com/<YOUR_ORGANIZATION>/<REPOSITORY>/events/push.json\"  ],  secret: \"<YOUR_SECRET_KEY>\",  httpConfig: {  auth: {  token: \"<YOUR_AUTH_TOKEN>\"  }  } } service /subscriber on new websub:Listener(9090) {  // Defines the remote function that accepts the event notification request for the WebHook.  remote function onEventNotification(  websub:ContentDistributionMessage event) returns error? {  var retrievedContent = event.content;  if (retrievedContent is json) {  if (retrievedContent.zen is string) {  int hookId = check retrievedContent.hook_id;  int senderId = check retrievedContent.sender.id;  io:println(string`PingEvent received for webhook [${hookId}]`);  io:println(string`Event sender [${senderId}]`);  } else if (retrievedContent.ref is string) {  string repositoryName = check retrievedContent.repository.name;  string lastUpdatedTime = check retrievedContent.repository.updated_at;  io:println(string`PushEvent received for [${repositoryName}]`);  io:println(string`Last updated at ${lastUpdatedTime}`);  }  } else {  io:println(\"Unrecognized content type, hence ignoring\");  }  } }    Websub Subscriber Service  Ballerina provides the capability to easily introduce subscriber services that are WebSub-compliant.  Ballerina WebSub subscribers can specify the topic and hub to which they wish to subscribe    import ballerina/websub; import ballerina/io;    The Ballerina WebSub Subscriber service, which could be used as a WebHook Listener for GitHub.   @websub:SubscriberServiceConfig {  target: [  \"https://api.github.com/hub\", \"https://github.com/<YOUR_ORGANIZATION>/<REPOSITORY>/events/push.json\"  ],  secret: \"<YOUR_SECRET_KEY>\",  httpConfig: {  auth: {  token: \"<YOUR_AUTH_TOKEN>\"  }  } } service /subscriber on new websub:Listener(9090) {    Annotation-based configurations specifying the subscription parameters.   remote function onEventNotification(  websub:ContentDistributionMessage event) returns error? {  var retrievedContent = event.content;  if (retrievedContent is json) {  if (retrievedContent.zen is string) {  int hookId = check retrievedContent.hook_id;  int senderId = check retrievedContent.sender.id;  io:println(string`PingEvent received for webhook [${hookId}]`);  io:println(string`Event sender [${senderId}]`);  } else if (retrievedContent.ref is string) {  string repositoryName = check retrievedContent.repository.name;  string lastUpdatedTime = check retrievedContent.repository.updated_at;  io:println(string`PushEvent received for [${repositoryName}]`);  io:println(string`Last updated at ${lastUpdatedTime}`);  }  } else {  io:println(\"Unrecognized content type, hence ignoring\");  }  } }    Defines the remote function that accepts the event notification request for the WebHook.   # To start the service, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run websub_webhook_sample.bal time = 2021-03-15 15:43:00,198 level = INFO module = ballerina/websub message = \"HTTPS is recommended but using HTTP\" time = 2021-03-15 15:43:01,960 level = INFO module = ballerina/websub message = \"Subscription request considered successful for non 202 status code: 204\" time = 2021-03-15 15:43:01,962 level = INFO module = ballerina/websub message = \"Subscription Request successfully sent to Hub[https://api.github.com/hub], for Topic[https://github.com/<your-org>/<your-repository/events/push.json], with Callback [<your-callback-url>]. Awaiting intent verification.\" [ballerina/http] started HTTP/WS listener 0.0.0.0:9090 PingEvent received for webhook [287075824] Event sender [77491511] PushEvent received for [Hello-World] Last updated at 2021-03-15T15:43:01Z    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-data-model.html","name":"XML Data Model","summary":"An xml value is a sequence representing the parsed content of an XML element. \n An xml value has four kinds of items. \n - element, processing instruction and comment item correspond 1:1 to XML infoset items. \n - text item corresponds to one or more Character Information Items. \n ...","content":"/  /  / XML Data Model  import ballerina/io;  public function main() {  // An XML element. There can be only one root element.  xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);   // An XML text.  xml x2 = xml `Hello, world!`;  io:println(x2);   // An XML comment.  xml x3 = xml `<!--I am a comment-->`;  io:println(x3);   // An XML processing instructions.  xml x4 = xml `<?target data?>`;  io:println(x4);   // Multiple XML items can be combined to form a sequence of XML.  // The resulting sequence is another XML on its own.  xml x5 = x1 + x2 + x3 + x4;  io:println(x5); }    XML Data Model  An xml value is a sequence representing the parsed content of an XML element. An xml value has four kinds of items. - element, processing instruction and comment item correspond 1:1 to XML infoset items. - text item corresponds to one or more Character Information Items. XML document is an xml sequence with only one element and no text. An element item is mutable  and consists of: - name: type string - attributes: type map<string> - children: type xml A text item is immutable. - it has no identity: == is the same as === - consecutive text items never occur in an xml value: they are always merged.    import ballerina/io;    public function main() {    xml x1 = xml `<book>The Lost World</book>`;  io:println(x1);    An XML element. There can be only one root element.   xml x2 = xml `Hello, world!`;  io:println(x2);    An XML text.   xml x3 = xml `<!--I am a comment-->`;  io:println(x3);    An XML comment.   xml x4 = xml `<?target data?>`;  io:println(x4);    An XML processing instructions.   xml x5 = x1 + x2 + x3 + x4;  io:println(x5); }    Multiple XML items can be combined to form a sequence of XML.  The resulting sequence is another XML on its own.   bal run xml.bal <book>The Lost World</book> Hello, world! <!--I am a comment--> <?target data?> <book>The Lost World</book>Hello, world!<!--I am a comment--><?target data?>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-json-conversion.html","name":"XML JSON Conversion","summary":"The xmldata:fromJson() and xmldata:toJson() functions are used to do the conversions between JSON and XML.\n For more information on the underlying module,\n see the .Creates a JSON object.Converts the JSON object to XML using a default attributePrefix (i.e., the @ character)\n and the default arrayEntryTag (i.e., root).Converts the XML to ...","content":"/  /  / XML JSON Conversion  import ballerina/io; import ballerina/xmldata;  public function main() returns error? {  // Creates a JSON object.  json jsonObject = {\"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }};  // Converts the JSON object to XML using a default `attributePrefix` (i.e., the `@` character)  // and the default `arrayEntryTag` (i.e., `root`).  xml? xmlData = check xmldata:fromJson(jsonObject);  io:println(xmlData);   if (xmlData is xml) {  // Converts the XML to JSON object using a default `attributePrefix` (i.e., the `@` character)  // and the default `preserveNamespaces` (i.e., `true`).  jsonObject = check xmldata:toJson(xmlData);  io:println(jsonObject);  } }    XML JSON Conversion  The xmldata:fromJson() and xmldata:toJson() functions are used to do the conversions between JSON and XML.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/xmldata;    public function main() returns error? {    json jsonObject = {\"Store\": {  \"@id\": \"AST\",  \"name\": \"Anne\",  \"address\": {  \"street\": \"Main\",  \"city\": \"94\"  },  \"codes\": [\"4\", \"8\"]  }};    Creates a JSON object.   xml? xmlData = check xmldata:fromJson(jsonObject);  io:println(xmlData);    Converts the JSON object to XML using a default attributePrefix (i.e., the @ character)  and the default arrayEntryTag (i.e., root).   if (xmlData is xml) {    jsonObject = check xmldata:toJson(xmlData);  io:println(jsonObject);  } }    Converts the XML to JSON object using a default attributePrefix (i.e., the @ character)  and the default preserveNamespaces (i.e., true).   # To run this sample, navigate to the directory that contains the # `.bal` file, and execute the `bal run` command below. bal run xml_json_conversion.bal <Store id=\"AST\"><name>Anne</name><address><street>Main</street><city>94</city></address><codes><root>4</root><root>8</root></codes></Store> {\"Store\":{\"name\":\"Anne\",\"address\":{\"street\":\"Main\",\"city\":\"94\"},\"codes\":{\"root\":[\"4\",\"8\"]}},\"@id\":\"AST\"}    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-namespaces.html","name":"XML Namespaces","summary":"The goal is to support for namespaces, but no added complexity if you don’t use them. Qualified name\n ns:x in XML is expanded into `{url}x where url is the namespace name bound to ns. XML namespace\n declarations are kept as attributes using standard binding of xmlns to\n .name will be ...","content":"/  /  / XML Namespaces  xml:Element e = xml`<p:e xmlns:p=\"http://example.com/\"/>`; // `name` will be `{http://example.com}e`. string name = e.getName();    XML Namespaces  The goal is to support for namespaces, but no added complexity if you don’t use them. Qualified name  ns:x in XML is expanded into `{url}x where url is the namespace name bound to ns. XML namespace  declarations are kept as attributes using standard binding of xmlns to  .    xml:Element e = xml`<p:e xmlns:p=\"http://example.com/\"/>`;    string name = e.getName();    name will be {http://example.com}e.   bal run xml_namespaces.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-navigation.html","name":"XML Navigation","summary":"XML navigation expressions allow for convenient navigation of XML\n element structure, in a similar way to XPath.x.<para> - every element in x named para.x/* - for every element e in x, the children of e.x/<para> - for every element e in x, every element named para in the children of ...","content":"/  /  / XML Navigation  import ballerina/io;  public function main() {  xml x = xml `<items>  <!--Contents-->  <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <planner>Daily Planner<kind>day</kind><pages>365</pages></planner>  <book>  <name>The Sign of Four</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <pen><kind>marker</kind><color>blue</color></pen>  </items>`;   // `x.<para>` - every element in `x` named `para`.  xml a = x.<items>;  io:println(a);   // `x/*` - for every element `e` in `x`, the children of `e`.  xml b = x/*;  io:println(b);   // `x/<para>` - for every element `e` in `x`, every element named para in the children of `e`.  xml c = x/<planner>;  io:println(c);   // `x/<th|td>` - for every element `e` in `x`, every element named `th` or `td` in the // children of `e`.  xml d = x/<planner|pen>;  io:println(d);   // `x/<*>` - for every element `e` in `x`, every element in the children of `e`.  xml e = x/<*>;  io:println(e);   // x/**/<para> - for every element `e` in `x`, every element named `para` in // the descendants of `e`.  xml f = x/**/<name>;  io:println(f);   // x/<para>[0] - for every element `e` in `x`, first element named `para` in // the children of `e`.  xml g = x/<book>[0];  io:println(g); }    XML Navigation XML navigation expressions allow for convenient navigation of XML  element structure, in a similar way to XPath.    import ballerina/io;    public function main() {  xml x = xml `<items>  <!--Contents-->  <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <planner>Daily Planner<kind>day</kind><pages>365</pages></planner>  <book>  <name>The Sign of Four</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <pen><kind>marker</kind><color>blue</color></pen>  </items>`;    xml a = x.<items>;  io:println(a);    x.<para> - every element in x named para.   xml b = x/*;  io:println(b);    x/* - for every element e in x, the children of e.   xml c = x/<planner>;  io:println(c);    x/<para> - for every element e in x, every element named para in the children of e.   xml d = x/<planner|pen>;  io:println(d);    x/<th|td> - for every element e in x, every element named th or td in the  children of e.   xml e = x/<*>;  io:println(e);    x/<*> - for every element e in x, every element in the children of e.   xml f = x/**/<name>;  io:println(f);    x/**/ - for every element e in x, every element named para in  the descendants of e.   xml g = x/<book>[0];  io:println(g); }    x/[0] - for every element e in x, first element named para in  the children of e.   bal run xml_navigation.bal <items>  <!--Contents-->  <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <planner>Daily Planner<kind>day</kind><pages>365</pages></planner>  <book>  <name>The Sign of Four</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <pen><kind>marker</kind><color>blue</color></pen>  </items>    <!--Contents-->  <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <planner>Daily Planner<kind>day</kind><pages>365</pages></planner>  <book>  <name>The Sign of Four</name>  <author><name>Arthur Conan Doyle</name></author>  </book>  <pen><kind>marker</kind><color>blue</color></pen>  <planner>Daily Planner<kind>day</kind><pages>365</pages></planner> <planner>Daily Planner<kind>day</kind><pages>365</pages></planner><pen><kind>marker</kind><color>blue</color></pen> <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book><planner>Daily Planner<kind>day</kind><pages>365</pages></planner><book>  <name>The Sign of Four</name>  <author><name>Arthur Conan Doyle</name></author>  </book><pen><kind>marker</kind><color>blue</color></pen> <name>A Study in Scarlet</name><name>Arthur Conan Doyle</name><name>The Sign of Four</name><name>Arthur Conan Doyle</name> <book>  <name>A Study in Scarlet</name>  <author><name>Arthur Conan Doyle</name></author>  </book>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-operations.html","name":"XML Operations","summary":"+ does concatenation.\n == does deep equals.\n foreach iterates over each item.\n x[i] gives i-th item (empty sequence if none).\n x.id accesses required attribute named id:\n result is error if there is no such attribute\n or if x is not a singleton.\n x?.id accesses optional attribute named id:\n result is ...","content":"/  /  / XML Operations  import ballerina/io;  public function main() returns error? {  xml x1 = xml `<name>Sherlock Holmes</name>`;  xml:Element x2 = xml `<details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details>`;   // `+` does concatenation.  xml x3 = x1 + x2;   io:println(x3);   xml x4 = xml `<name>Sherlock Holmes</name><details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details>`;  // `==` does deep equals.  boolean eq = x3 == x4;   io:println(eq);   // `foreach` iterates over each item.  foreach var item in x4 {  io:println(item);  }   // `x[i]` gives i-th item (empty sequence if none).  io:println(x3[0]);   // `x.id` accesses required attribute named `id`:  // result is `error` if there is no such attribute  // or if `x` is not a singleton.  xml x5 = xml `<para id=\"greeting\">Hello</para>`;  string id = check x5.id;   io:println(id);   // `x?.id` accesses optional attribute named `id`:  // result is `()` if there is no such attribute.  string? name = check x5?.name;   io:println(name is ());   // Mutate an element using `e.setChildren(x)`.  x2.setChildren(xml `<language>French</language>`);   io:println(x2);  io:println(x3); }    XML Operations  + does concatenation.  == does deep equals.  foreach iterates over each item.  x[i] gives i-th item (empty sequence if none).  x.id accesses required attribute named id:  result is error if there is no such attribute  or if x is not a singleton.  x?.id accesses optional attribute named id:  result is () if there is no such attribute.  Langlib lang.xml provides other operations.  Mutate an element using e.setChildren(x).    import ballerina/io;    public function main() returns error? {  xml x1 = xml `<name>Sherlock Holmes</name>`;  xml:Element x2 = xml `<details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details>`;    xml x3 = x1 + x2;    + does concatenation.   io:println(x3);    xml x4 = xml `<name>Sherlock Holmes</name><details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details>`;    boolean eq = x3 == x4;    == does deep equals.   io:println(eq);    foreach var item in x4 {  io:println(item);  }    foreach iterates over each item.   io:println(x3[0]);    x[i] gives i-th item (empty sequence if none).   xml x5 = xml `<para id=\"greeting\">Hello</para>`;  string id = check x5.id;    x.id accesses required attribute named id:  result is error if there is no such attribute  or if x is not a singleton.   io:println(id);    string? name = check x5?.name;    x?.id accesses optional attribute named id:  result is () if there is no such attribute.   io:println(name is ());    x2.setChildren(xml `<language>French</language>`);    Mutate an element using e.setChildren(x).   io:println(x2);  io:println(x3); }    bal run xml_operations.bal <name>Sherlock Holmes</name><details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details> false <name>Sherlock Holmes</name> <details>  <author>Sir Arthur Conan Doyle</author>  <language>English</language>  </details> <name>Sherlock Holmes</name> greeting true <details><language>French</language></details> <name>Sherlock Holmes</name><details><language>French</language></details>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-subtyping.html","name":"XML Subtyping","summary":"An xml value belongs to xml:Element if it is consists of just an element\n item. Similarly for xml:Comment and xml:ProcessingInstruction.\n An xml value belongs to xml:Text if it consists of a text item or is\n empty.\n An xml value belongs to the type xml<T> if each of its members belong\n ...","content":"/  /  / XML Subtyping  import ballerina/io;  // An `xml` value belongs to `xml:Element` if it is consists of just an element // item. xml:Element element = xml `<p>Hello</p>`;  // Similarly for `xml:Comment` and `xml:ProcessingInstruction`. xml:Comment comment = xml `<!--This is a comment-->`; xml:ProcessingInstruction procInst = xml `<?target data?>`;  public function main() {  // An xml value belongs to xml:Text if it consists of a text item or is empty.  xml:Text a = xml ``;  xml:Text b = xml `Hello World`;   string hello = \"Hello\";  string world = \"World\";  xml:Text c = stringToXml(hello + \" \" + world);  io:println(c);   xml:Element otherElement = xml `<q>World</q>`;   xml d = element + otherElement;  xml e = xml `<p>hello</p>World`;  // An `xml` value belongs to the type `xml<T>` if each of its members belong // to `T`.  io:println(element is xml<xml:Element>);  io:println(d is xml<xml:Element>);  io:println(e is xml<xml:Element>);   io:println(d);  rename(d, \"q\", \"r\");  io:println(d); }  function stringToXml(string s) returns xml:Text {  return xml:createText(s); }  // Functions in lang.xml use subtyping to provide safe and convenient typing. // For example, `x.elements()` returns element items in `x` as type // `xml<xml:Element>` and `e.getName()` and `e.setName()` are defined when // `e` has type `xml:Element`. function rename(xml x, string oldName, string newName) {  foreach xml:Element e in x.elements() {  if e.getName() == oldName {  e.setName(newName);  }  rename(e.getChildren(), oldName, newName);  } }    XML Subtyping  An xml value belongs to xml:Element if it is consists of just an element  item. Similarly for xml:Comment and xml:ProcessingInstruction.  An xml value belongs to xml:Text if it consists of a text item or is  empty.  An xml value belongs to the type xml<T> if each of its members belong  to T.  Functions in lang.xml use this to provide safe and convenient typing.  For example, x.elements() returns element items in x as type  xml<xml:Element> and e.getName() and e.setName() are defined when  e has type xml:Element.    import ballerina/io;    xml:Element element = xml `<p>Hello</p>`;    An xml value belongs to xml:Element if it is consists of just an element  item.   xml:Comment comment = xml `<!--This is a comment-->`; xml:ProcessingInstruction procInst = xml `<?target data?>`;    Similarly for xml:Comment and xml:ProcessingInstruction.   public function main() {    xml:Text a = xml ``;  xml:Text b = xml `Hello World`;    An xml value belongs to xml:Text if it consists of a text item or is empty.   string hello = \"Hello\";  string world = \"World\";  xml:Text c = stringToXml(hello + \" \" + world);  io:println(c);    xml:Element otherElement = xml `<q>World</q>`;    xml d = element + otherElement;  xml e = xml `<p>hello</p>World`;    io:println(element is xml<xml:Element>);  io:println(d is xml<xml:Element>);  io:println(e is xml<xml:Element>);    An xml value belongs to the type xml<T> if each of its members belong  to T.   io:println(d);  rename(d, \"q\", \"r\");  io:println(d); }    function stringToXml(string s) returns xml:Text {  return xml:createText(s); }    function rename(xml x, string oldName, string newName) {  foreach xml:Element e in x.elements() {  if e.getName() == oldName {  e.setName(newName);  }  rename(e.getChildren(), oldName, newName);  } }    Functions in lang.xml use subtyping to provide safe and convenient typing.  For example, x.elements() returns element items in x as type  xml<xml:Element> and e.getName() and e.setName() are defined when  e has type xml:Element.   bal run xml_subtyping.bal Hello World true true false <p>Hello</p><q>World</q> <p>Hello</p><r>World</r>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml.html","name":"XML","summary":"xml is a separate basic type. Uses sequence concept similar to XQuery and XPath2. Based on XML Infoset,\n rather than PSVI. Allows XMsyntax to be used to constructxmlvalues.xmltype is designed to\n work well for HTML as well as XML. Navigation syntax with XPath-like functionality. Works withquery\n expressions` to provide XQuery ...","content":"/  /  / XML  XML  xml is a separate basic type. Uses sequence concept similar to XQuery and XPath2. Based on XML Infoset,  rather than PSVI. Allows XMsyntax to be used to constructxmlvalues.xmltype is designed to  work well for HTML as well as XML. Navigation syntax with XPath-like functionality. Works withquery  expressions` to provide XQuery FLWOR-like functionality. No up pointers: elements do not have a reference to  parents or siblings.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-templates-and-query.html","name":"XML Templates and Query","summary":"XML templates combine nicely with query. (e.g., you can have a template containing a query expression\n containing a template).Uses a template containing a query expression containing a template.This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you ...","content":"/  /  / XML Templates and Query  import ballerina/io;  type Person record {|  string name;  string country; |};  function personsToXml(Person[] persons) returns xml {  // Uses a template containing a `query expression` containing a template.  return xml`<data>${from var {name, country} in persons  select xml`<person country=\"${country}\">${name}</person>`}</data>`; }  public function main() {  Person[] persons = [  {name: \"Jane\", country: \"USA\"},  {name: \"Mike\", country: \"Germany\"}  ];  io:println(personsToXml(persons)); }    XML Templates and Query  XML templates combine nicely with query. (e.g., you can have a template containing a query expression  containing a template).    import ballerina/io;    type Person record {|  string name;  string country; |};    function personsToXml(Person[] persons) returns xml {    return xml`<data>${from var {name, country} in persons  select xml`<person country=\"${country}\">${name}</person>`}</data>`; }    Uses a template containing a query expression containing a template.   public function main() {  Person[] persons = [  {name: \"Jane\", country: \"USA\"},  {name: \"Mike\", country: \"Germany\"}  ];  io:println(personsToXml(persons)); }    bal run xml_templates_and_query.bal <data><person country=\"USA\">Jane</person><person country=\"Germany\">Mike</person></data>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xml-templates.html","name":"XML Templates","summary":"xml values can be constructed using an XML template expression.\n Phase 2 processing for xml template tag parses strings using\n the XML 1.0 Recommendation’s grammar for content (what XML allows\n between a start-tag and an end-tag).\n Interpolated expressions can be in content (xml or string values)\n or in attribute values ...","content":"/  /  / XML Templates  import ballerina/io;  string url = \"https://ballerina.io\";  xml content = // `xml` values can be constructed using an XML template expression.  // Attribute values can have `string` values as interpolated expressions.  xml `<a href=\"${url}\">Ballerina</a> is an <em>exciting</em> new language!`;  // Interpolated expressions can also be in content (`xml` or `string` values). xml p = xml `<p>${content}</p>`;  public function main() {  io:println(content);  io:println(p); }    XML Templates  xml values can be constructed using an XML template expression.  Phase 2 processing for xml template tag parses strings using  the XML 1.0 Recommendation’s grammar for content (what XML allows  between a start-tag and an end-tag).  Interpolated expressions can be in content (xml or string values)  or in attribute values (string values).    import ballerina/io;    string url = \"https://ballerina.io\";    xml content = xml `<a href=\"${url}\">Ballerina</a> is an <em>exciting</em> new language!`;    xml values can be constructed using an XML template expression.  Attribute values can have string values as interpolated expressions.   xml p = xml `<p>${content}</p>`;    Interpolated expressions can also be in content (xml or string values).   public function main() {  io:println(content);  io:println(p); }    bal run xml_templates.bal <a href=\"https://ballerina.io\">Ballerina</a> is an <em>exciting</em> new language! <p><a href=\"https://ballerina.io\">Ballerina</a> is an <em>exciting</em> new language!</p>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xmlns-declarations.html","name":"XMLNS Declarations","summary":"The xmlns declarations are like import declarations, but bind the prefix to a namespace URL rather than\n a module. The xmlns declarations in the Ballerina module provide namespace context for parsing xml\n templates. The Qualified names in Ballerina modules are expanded into strings using the xmlns\n declarations in the module. ...","content":"/  /  / XMLNS Declarations  // The identifier followed by the `as` keyword is the prefix bound // to this namespace name. xmlns \"http://example.com\" as eg;  xml x = xml`<eg:doc>Hello</eg:doc>`;  xmlns \"http://example.com\" as ex;  // `b` will be `true`. boolean b = (x === x.<ex:doc>);  // `exdoc` will be `{http://example.com}doc`. string exdoc = ex:doc;    XMLNS Declarations  The xmlns declarations are like import declarations, but bind the prefix to a namespace URL rather than  a module. The xmlns declarations in the Ballerina module provide namespace context for parsing xml  templates. The Qualified names in Ballerina modules are expanded into strings using the xmlns  declarations in the module. The xmlns declarations also allowed at block level.    xmlns \"http://example.com\" as eg;    The identifier followed by the as keyword is the prefix bound  to this namespace name.   xml x = xml`<eg:doc>Hello</eg:doc>`;    xmlns \"http://example.com\" as ex;    boolean b = (x === x.<ex:doc>);    b will be true.   string exdoc = ex:doc;    exdoc will be {http://example.com}doc.   bal run xmlns_declarations.bal    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/by-example/xslt-transformation.html","name":"XSLT Transformation","summary":"This example demonstrates how XML content can be transformed to HTML using a given XSL transformation.\n For more information on the underlying module,\n see the .Gets an XML value, which needs to be transformed.Gets an XSL style sheet represented in an XML value. the XML content to another format.Returns an ...","content":"/  /  / XSLT Transformation  import ballerina/io; import ballerina/xslt;  public function main() returns error? {  // Gets an `XML` value, which needs to be transformed.  xml sourceXml = getXml();  // Gets an `XSL` style sheet represented in an XML value.  xml xsl = getXsl();  // [Transforms](https://docs.central.ballerina.io/ballerina/xslt/latest/functions#transform) the `XML` content to another format.  xml target = check xslt:transform(sourceXml, xsl);  io:println(\"Transformed XML: \", target); }  // Returns an `XML` element, which needs to be transformed. function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; }  // Returns an `XSL` style sheet represented by an XML element. function getXsl() returns xml {  return xml  `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    XSLT Transformation  This example demonstrates how XML content can be transformed to HTML using a given XSL transformation.  For more information on the underlying module,  see the .    import ballerina/io; import ballerina/xslt;    public function main() returns error? {    xml sourceXml = getXml();    Gets an XML value, which needs to be transformed.   xml xsl = getXsl();    Gets an XSL style sheet represented in an XML value.   xml target = check xslt:transform(sourceXml, xsl);  io:println(\"Transformed XML: \", target); }    the XML content to another format.   function getXml() returns xml {  return xml `<samples>  <song>  <title>Summer of 69</title>  <artist>Bryan Adams</artist>  <country>Canada</country>  <year>1984</year>  </song>  <song>  <title>Zombie</title>  <artist>Bad Wolves</artist>  <country>USA</country>  <year>2018</year>  </song>  </samples>`; }    Returns an XML element, which needs to be transformed.   function getXsl() returns xml {  return xml  `<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">  <xsl:template match=\"/\">  <html>  <body>  <h2>All time favourites</h2>  <table border=\"1\">  <tr bgcolor=\"#9acd33\">  <th>Title</th>  <th>Artist</th>  </tr>  <xsl:for-each select=\"samples/song\">  <tr>  <td>  <xsl:value-of select=\"title\"/>  </td>  <td>  <xsl:value-of select=\"artist\"/>  </td>  </tr>  </xsl:for-each>  </table>  </body>  </html>  </xsl:template>  </xsl:stylesheet>`; }    Returns an XSL style sheet represented by an XML element.   # To run this sample, navigate to the directory that contains the # `.bal` file and run the `bal run` command below. bal run xslt_transformation.bal Transformed XML: <html> <body> <h2>All time favourites</h2> <table border=\"1\"> <tr bgcolor=\"#9acd33\"> <th>Title</th><th>Artist</th> </tr> <tr> <td>Summer of 69</td><td>Bryan Adams</td> </tr> <tr> <td>Zombie</td><td>Bad Wolves</td> </tr> </table> </body> </html>    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/","name":"Let’s Learn Ballerina!","summary":"Ballerina is a comprehensive language that is easy to grasp for anyone with prior ...","content":"/ Let’s Learn Ballerina!  Let’s Learn Ballerina!  Ballerina is a comprehensive language that is easy to grasp for anyone with prior programming experience. Start learning with the material below.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/language-concepts/","name":"Language Concepts","summary":"Table of contents            The video series below explores the language concepts of Ballerina Swan Lake. The series covers how Ballerina provides basic functionalities common to most programming languages and what makes Ballerina distinctive, and also deep-dives into the significant features of ...","content":"/  / Language Concepts  Language Concepts  Table of contents The video series below explores the language concepts of Ballerina Swan Lake. The series covers how Ballerina provides basic functionalities common to most programming languages and what makes Ballerina distinctive, and also deep-dives into the significant features of the language.          You can also find the used for these presentations below.               Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/setting-up-intellij-idea/using-intellij-plugin-features/","name":"Using the features of the IntelliJ plugin","summary":"The sections below include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.Table of contents      You can run Ballerina main/service programs with a single click without adding or changing any configurations.The sections below include instructions on how to run ...","content":"/  /  / Using the features of the IntelliJ plugin  Using the features of the IntelliJ plugin  The sections below include information on the various capabilities that are facilitated by the IntelliJ Ballerina plugin for the development process.  Table of contents Running Ballerina Programs  You can run Ballerina main/service programs with a single click without adding or changing any configurations.  The sections below include instructions on how to run different elements of a Ballerina file.    Running the ‘Main’ Method  Follow the steps below to run the main function of a Ballerina file.    Click the green color icon located near the main function.   Click the corresponding **Run ** command.   This executes the main function of the Ballerina file and displays the output in the Run window.      Tip: Alternatively, you can right-click on the name of the file and run the main method of it.   Running Ballerina Services  Follow the steps below to run a service of a Ballerina file.    Click the green color icon located near the definition of the service.  Click the corresponding **Run **** command.  This starts the service and displays the output in the Run window. If you have multiple services in the Ballerina file, this starts all of them.      Tip: Alternatively, you can right-click on the name of the file and run the service(s) of it.   Debugging Ballerina Programs  You can debug Ballerina main/service programs with a few clicks.    Troubleshooting   Stepping over code lines in non-blocking paths (eg: action invocations) will not pause VM on the next line  workaround: manually put a breakpoint to the next line  There are some cases where stepping over gives unexpected behavior  Eg: When there are multiple workers and a wait expression waiting for them, even though step over hit and pass wait line in source, workers are not yet finished execution.  Viewing the Sequence Diagram  The underlying language semantics of Ballerina were designed by modeling how independent parties communicate via structured interactions. Subsequently, every Ballerina program can be displayed as a sequence diagram of its flow including endpoints as well as synchronous and asynchronous calls.  To view the sequence diagram of a Ballerina file, click the () in the top right corner of the IDE window as shown in the below example.    Importing Modules on the Fly  You can add import declarations to your Ballerina programs on the fly. When you select the module name from the lookup list, the module declaration will be added automatically.    Importing Unambiguous Modules  When you copy and paste Ballerina code to IntelliJ, this feature allows you to import unambiguous imports. You can apply these imports by clicking on the module name and pressing Alt + Enter keys.    Note: This is disabled by default since this might cause issues if the file contains grammar mistakes. Follow the steps below to enable it.  Open IntelliJ, click IntelliJ IDEA in the top menu, click Preferences, and then click Languages and Frameworks.  Tip: If you are using Windows, click File, click Settings, and then click Languages and Frameworks.  Click Ballerina and then click Auto Import.  Select the Add unambiguous imports on the fly checkbox and click OK.  Formatting Ballerina Codes  You can reformat the Ballerina codes by pressing the Ctrl+Alt+L keys.    Viewing Documentation  You can view the documentation of a function, remote function, etc., by pressing the Ctrl+Q keys or by hovering over the element while pressing the Ctrl key.    Adding Annotation Fields via Suggestions  You can add annotation fields to your code using the annotation field names that are suggested inside annotation attachments.    Using File Templates  Three types of Ballerina file templates are available.    Ballerina Main - contains a sample main program  Ballerina Service - contains a sample service  Empty File - contains an empty file     Using Code Snippet Templates  Code snippet templates contain boilerplate codes and allows you to write your code efficiently.    Checking Spellings  The spell-checker is enabled for all identifiers. You can rename all of the definitions and references as well.    Analyzing Semantics  The Ballerina IDEA plugin provides capabilities to diagnose and analyze the semantics of your Ballerina programs through the Ballerina Language Server.    Code Folding  You expand/collapse the following Ballerina code segments using the icons in the IntelliJ IDE.    imports  services  objects  records  functions and object functions  annotations  markdown documentation  multiline comments     Go to Definition  This option allows you to view the definition of a selected variable, function, an object etc., within the same file, in a separate file, in the same module, or in a file of a different module, of the same project or of the .    What’s Next?    For more information on the IntelliJ IDEA Ballerina plugin, see .  For information on all the tools and IDEs that are supported by Ballerina, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/ballerina-shell/","name":"Ballerina Shell","summary":"The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger. Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.Table of contents        This website uses cookies so that ...","content":"/  /  / Ballerina Shell  Ballerina Shell  The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger. Thus, you can run or debug your Ballerina programs easily via the VS Code Ballerina extension by launching its debugger.  Table of contents Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/cli-tools/bindgen-tool/","name":"BindGen Tool","summary":"The sections below demonstrate the functionality of the BindGen Tool.Table of contents        This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your ...","content":"/  /  /  / BindGen Tool  BindGen Tool  The sections below demonstrate the functionality of the BindGen Tool.  Table of contents Using the BindGen Tool    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/cli-tools/cli-commands/","name":"CLI Commands","summary":"The Ballerina Tool is your one-stop-shop for all the things you do in Ballerina.Table of contents        The Ballerina Tool is a command-line tool for managing Ballerina source code. It helps you to manage Ballerina packages and modules, test, build, and run programs, etc.It also enables ...","content":"/  /  /  / CLI Commands  CLI Commands  The Ballerina Tool is your one-stop-shop for all the things you do in Ballerina.  Table of contents Using the Ballerina Tool  The Ballerina Tool is a command-line tool for managing Ballerina source code. It helps you to manage Ballerina packages and modules, test, build, and run programs, etc.  It also enables you to easily install, update, and switch among Ballerina distributions.  In the CLI, execute the bal help command to view all the actions you can perform with the Ballerina Tool as shown below:  → bal help NAME  The Ballerina tool  SYNOPSIS  bal <-v | --version>  bal [command] <-h | --help>  bal <command> [<args>]   DESCRIPTION  Ballerina is a statically typed, concurrent programming language, focusing on network interaction and structured  data. It is intended to be the core of a language-centric middleware platform. It has all the general-purpose  functionality expected of a modern programming language, but it also has several unusual aspects that make it  particularly suitable for its intended purpose.   Find more information at: https://ballerina.io/   OPTIONS  -v, --version  Print the Ballerina version information.   -h, --help  Print usage details of a command.   BALLERINA COMMANDS  Here is a list of available subcommands:   Core Commands:  build Compile Ballerina program into an executable  run Build and run Ballerina program  test Run package tests  doc Generate API documentation  clean Clean artifacts generated during the build  format Format Ballerina sources   Package Commands:  new Create a new Ballerina package  init Create a new Ballerina package in the current directory  add Create a new Ballerina module in the package  pull Pull a package from Ballerina Central  push Upload a package to Ballerina Central  search Search Ballerina Central for packages   Other Commands:  encrypt Encrypt sensitive data  grpc Generate Ballerina sources for the given protobuf definition  openapi Generate Ballerina sources for the given OpenAPI definition and vice versa.  version Print Ballerina version  bindgen Generate Ballerina bindings for Java APIs  shell Run ballerina interactive REPL [EXPERIMENTAL]   Update Commands:  dist Manage Ballerina distributions  update Update the Ballerina tool   Use 'bal help <command>' for more information on a specific command.   You can use it in the below format.    bal <THE-COMMAND> <ITS-ARGUEMENTS>     Tip: You can view details of the commands below by executing the bal help <COMMAND>. For example, the below is the output of the bal help pull command.   → bal help pull NAME  ballerina-pull - Fetch packages from Ballerina Central  SYNOPSIS  bal pull <org-name>/<package-name>[:<version>]   DESCRIPTION  The pull command downloads the specified package from Ballerina Central  along with its dependencies. It then caches this package in the  '.ballerina' directory in the user home.   Ballerina Central is a package repository hosted at  https://central.ballerina.io/. A package repository organizes packages  into a three-level hierarchy: organization, package name, and version.  Organizations are unique within a repository and can be mapped to an  individual user or organization registered with the repository.   EXAMPLES  Pull the latest version of 'gmail' connector in 'wso2' organization  from Ballerina Central.  $ bal pull wso2/gmail   Pull the '1.1.0' version of 'gmail' connector in 'wso2' organization  from Ballerina Central.  $ bal pull wso2/gmail:1.1.0   Core Commands  These everyday commands are your best friends! They address the very basics of programming in Ballerina such as compiling, running, testing programs, and generating their documentation.    build Compile a standalone `.bal` file, or an entire package into an executable JAR file. For more information, see .    run Build and run a standalone `.bal` file, an entire package, or a previously-built program. For more information, see .    test Run tests of a Ballerina package. For more information, see .    doc Generate API documents for all public symbols of a Ballerina package. For more information, see .    clean Clean all artifacts generated by the build command for a package.    format Format Ballerina source files as per the .    Package Commands  Ballerina packages are the way to organize real-world Ballerina development tasks. The last 3 commands given below allow you to work with the Ballerina Central and also to share Ballerina packages with others in a safe, secure, and dependable way.    new Create a Ballerina package. For more information, see .    init Create a new Ballerina package in the current directory.    add Create a new Ballerina module in a package.    pull Pull a package from Ballerina Central.    push Upload a package to Ballerina Central. For more information, see .    search Search Ballerina Central for packages.     Other Commands  These powerful supporting tools extend Ballerina to various ecosystem technologies that are inherently cloud-native. This functionality will grow over time and will even be developer extensible in the future.    encrypt Use this tool to encrypt sensitive data and pass them to a Ballerina program via the configuration system.    grpc This is the gRPC stub/skeleton generation tool. For more information, see .   openapi This is the OpenAPI (Swagger) stub/skeleton generation tool. For more information, see .   version Tells you the version of the distribution you are currently using, the language specification version on which it is based, and the update tool version, which is currently in use.   bindgen Use this tool for auto-generating Ballerina bridge code for Java APIs. For more information, see .   help Prints the usage details of any Ballerina command (e.g., `bal help pull`).     Update Commands    dist Manage Ballerina distributions. For more information, see .    update Update the Ballerina Tool. For more information, see .         Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/cli-tools/grpc/","name":"gRPC","summary":"The 'Protocol Buffers to Ballerina' tool provides capabilities to generate Ballerina source code for Protocol Buffer definitions.Table of contents        The code generation tool can produce ballerina stub and ballerina service/client template files.In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you ...","content":"/  /  /  / gRPC  gRPC  The 'Protocol Buffers to Ballerina' tool provides capabilities to generate Ballerina source code for Protocol Buffer definitions.  Table of contents Usage of the Tool  The code generation tool can produce ballerina stub and ballerina service/client template files.    In Ballerina, Protocol Buffers serialization is only supported in the gRPC module. Therefore, you can only use this tool to generate Ballerina source code for gRPC service definitions.   CLI Command  You can generate Ballerina source code using the following command:  $ bal grpc --input <proto-file-path> [--output <path>] [--mode client | service]   CLI Command Options  --input - Path of the input .proto file. This is a mandatory field. You need to provide the path of the definition  file.  --output - Location of the generated Ballerina source files. This is an optional field. If the output path is not specified, the output will be written to a directory corresponding to the package in the Protocol  Buffers definition. If the package is not specified, the output will be written to a ‘temp’ directory in the current location.  --mode - Set the mode as client or service to generate code samples. If not specified, only the stub file is generated.  Sample  The below example shows how you can generate Ballerina source code from the following Protocol Buffers definition (in the helloworld_service.proto file).  syntax = \"proto3\";  service helloWorld {  rpc sayHello(HelloRequest) returns (HelloResponse); }  message HelloRequest { \tstring name = 1; } message HelloResponse { \tstring message = 1; }   Executing the Sample    Execute the below command to generate the service template file.  $ bal grpc --input helloworld_service.proto --mode service --output service  Once you execute the command, the stub file (helloworld_service_pb.bal) and the service template file (helloWorld_sample_service.bal) are generated inside the service directory.  Note: If you have multiple services in a Protocol Buffers definition, this command will generate a stub file with common message types and a service template file for each service definition. This is to avoid duplicating message types in all the service files.  Execute the below command to generate the client/service stub and client template.  $ bal grpc --input helloworld_service.proto --mode client --output client  Once you execute the command, the stub file (helloworld_service_pb.bal) and the client template file (helloWorld_sample_client.bal) are generated inside the client directory.  Execute the below command to generate only the client/service stub.  $ bal grpc --input helloworld_service.proto --output stubs  Once you execute the command, only the stub file (helloworld_service_pb.bal) is generated inside the stubs directory.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/cli-tools/openapi/","name":"OpenAPI","summary":"OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start the development of a service documented in an ...","content":"/  /  /  / OpenAPI  OpenAPI  OpenAPI Specification is a specification that creates a RESTFUL contract for APIs, detailing all of its resources and operations in a human and machine-readable format for easy development, discovery, and integration. Ballerina OpenAPI tooling will make it easy for users to start the development of a service documented in an OpenAPI contract in Ballerina by generating Ballerina service and client skeletons.  Table of contents Using the Capabilities of the OpenAPI Tools  The OpenAPI tools provide the following capabilities.    Generate the Ballerina service or client code for a given OpenAPI definition.  Export the OpenAPI definition of a Ballerina service.  Validate service implementation of a given OpenAPI Contract.   The openapi command in Ballerina is used for OpenAPI to Ballerina and Ballerina to OpenAPI code generations. Code generation from OpenAPI to Ballerina can produce service stubs and client stubs.  The OpenAPI compiler plugin will allow you to validate a service implementation against an OpenAPI contract during the compile time. This plugin ensures that the implementation of a service does not deviate from its OpenAPI contract.  OpenAPI to Ballerina  Generating Service and Client Stub from an OpenAPI Contract  bal openapi -i <openapi-contract-path>  [--tags: tags list]  [--operations: operationsID list]  [--mode service|client ]  [(-o|--output): output file path]   Generates both the Ballerina service and Ballerina client stub for a given OpenAPI file.  The -i <openapi-contract-path> parameter is mandatory and it specifies the path of the OpenAPI contract file (e.g., my-api.yaml or my-api.json).  You can give the specific tags and operations that you need to document as services without documenting all the operations using these optional --tags and --operations commands.  (-o|--output) is an optional parameter. You can use this to give the output path for the generated files. If not, it will take the path of the current directory as the output path.  Modes  If you want to generate a Service only, you can set the mode as service in the OpenAPI tool.  bal openapi -i <openapi-contract-path> --mode service [(-o|--output) output file path]   If you want to generate a Client only, you can set the mode as client in the OpenAPI tool. This client can be used in client applications to call the service defined in the OpenAPI file.  bal openapi -i <openapi-contract-path> --mode client [(-o|--output) output file path]   Ballerina to OpenAPI  Generating the Service for OpenAPI Export  bal openapi -i <ballerina-file-path> [(-o|--output) output openapi file path]   Export the Ballerina service to an OpenAPI Specification 3.0 definition. For the export to work properly, the input Ballerina service should be defined using the basic service and resource-level HTTP annotations.  If you need to document an OpenAPI contract for only one given service, then use this command.  bal openapi -i <ballerina-file-path> (-s | --service) <service-name>   Samples for OpenAPI Commands  Generating the Service and Client Stub from OpenAPI  bal openapi -i hello.yaml   This will generate a Ballerina service and client stub for the hello.yaml OpenAPI contract named hello-service and client named hello-client. The above command can be run from anywhere on the execution path. It is not mandatory to run it from within a Ballerina project.  Output:  The service generation process is complete. The following files were created. -- hello-service.bal -- client.bal -- types.bal   Generating an OpenAPI Contract from a Service  bal openapi -i modules/helloworld/helloService.bal   This will generate the OpenAPI contracts for the Ballerina services, which are in the hello.bal Ballerina file.  bal openapi -i modules/helloworld/helloService.bal (-s | --service) helloworld   This command will generate the helloworld-openapi.yaml file that is related to the helloworld service inside the helloService.bal file. bal openapi -i modules/helloworld/helloService.bal --json  This --json option can be used with the Ballerina to OpenAPI command to generate the helloworld-openapi.json file instead of generating the YAML file.  OpenAPI Validator Compiler Plugin  The OpenAPI Validator Compiler plugin validates a service against a given OpenAPI contract. The Compiler Plugin is activated if a service has the openapi:ServiceInfo annotation. This plugin compares the service and the OpenAPI contract and validates both against a pre-defined set of validation rules. If any of the rules fail, the plugin will give the result as one or more compilation errors.  Annotation for Validator Plugin  The @openapi:ServiceInfo annotation is used to bind the service with an OpenAPI Contract. You need to add this annotation to the service file with the required values for enabling the validations.  The following is an example of the annotation usage.  @openapi:ServiceInfo{  contract: “/path/to/openapi.json|yaml”,  [ tag : “store” ],  [ operations: [“op1”, “op2”] ] [ failOnErrors]: true/false → default : true  [ excludeTags ]: [“pets”, “user”]  [ excludeOperations: [“op1”, “op2”] ]  } service greet on new http:Listener(9090) {  ... }   Annotation Support for Attributes    Contract (Required) : string :   Here, you can provide a path to the OpenAPI contract as a string and the OpenAPI file can either be .yaml or .json. This is a required attribute.    Tag (Optional) : string[]? :   The compiler will only validate resources against operations, which are tagged with a tag specified in the list. If not specified, the compiler will validate resources against all the operations defined in the OpenAPI contract.    Operations (Optional): string[]? :   Should contain a list of operation names that need to be validated against the resources in the service. If not specified, the compiler will validate resources against all the operations defined in the OpenAPI contract. If both tags and operations are defined, it will validate against the union set of the resources.    ExcludeTags (Optional) : string[]? :   This feature is for users to store the tag. It does not need to be validated. At the same time, the excludeTag and Tag cannot store and the plugin will generate warning messages regarding  it.    ExcludeOperations (Optional) : string[]? :   This feature is for users to store the operations that do not need to be validated. At the same time, the excludeOperations and Operations can not store and they will generate warning messages.  The Tag feature can store with excludeOperations. Then, all the tag operations will be validated except the excludeoperations.    FailOnErrors (Optional) : boolean value :   If you need to turn off the validation, add this to the annotation with the value as false.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/cli-tools/update-tool/","name":"Update Tool","summary":"This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases.Table of contents        The Ballerina compiler is a software program, which validates the Ballerina source code and translates it to an executable program. Ballerina has a stable ...","content":"/  /  /  / Update Tool  Update Tool  This guide explains how to maintain your Ballerina installation up to date with the latest patch and minor releases.  Table of contents Understanding Ballerina Distributions  The Ballerina compiler is a software program, which validates the Ballerina source code and translates it to an executable program. Ballerina has a stable and production-ready official compiler called jBallerina, which targets the JVM.  Also, there is a plan to develop a native compiler called nBallerina in the future, which will target platforms such as Linux, Windows, and macOS.  Ballerina distribution is a term, which refers to these jBallerina and nBallerina compilers.  Getting to know the Release Channels  Ballerina distributions are released via two different release channels at the moment. One is the Swan Lake release channel and the other one is the 1.x release channel.  Ballerina yet does not have a release channel for nightly builds that give you access to the latest perhaps unstable features.  Versioning of the releases  Currently, the 1.x channel of the Ballerina distribution releases strictly follows with major.minor.patch version numbers.  Patch Releases  Patch releases of Ballerina distributions contain bug fixes and fixes for critical stability and security related issues. Occasionally, you would see on-demand patch releases as well.  Example patch releases: 1.0.6, 1.1.5, 1.1.10  Minor Releases  These are feature releases of Ballerina distributions. Ballerina programs that you’ve written today should continue to work on these minor releases.  Example minor releases: 1.1.0, 1.2.0, 1.3.0  Release Maintenance  In the 1.x release channel, a minor release 1.x.0 is maintained by issuing a series of patch releases as 1.x.y. The maintenance of a particular minor release stops when there are two newer minor releases available.  In other words, patch releases for 1.x.0 stop when jBallerina 1.(x+2).0 is released. E.g., when 1.2 is available, maintaining 1.0.0 will be stopped.  Installing Ballerina  If you haven’t installed Ballerina yet, see for the instructions.  Once the installation is complete, you would see the directory structure below inside the installation directory.  . ├── bin │ └── bal ├── dependencies │ └── jdk8u202-b08-jre ├── distributions │ ├── ballerina-slp4 │ ├── jballerina-1.1.0 │ ├── jballerina-1.2.8 │ └── ballerina-version └── lib  └── ballerina-command-0.8.8.jar   The distributions is the directory, in which all your installed distributions are maintained. Only one distribution from the above list can be active at a given time.    Note: The Ballerina Tool delegates most of the user requests to the active distribution. The commands such as build, test, run, pull, and push are delegated to the active distribution, while the commands such as dist and version are handled by the tool itself.   E.g., when you invoke bal build, the Ballerina Tool dispatches this request to the active distribution.  You can at any time or manage it using the Ballerina Tool. However, first, you need to update the Ballerina Tool to its latest version.  Updating the Ballerina Tool  The bal update command updates the Ballerina Tool itself to the latest version. Ballerina Tool versions are independent of the Ballerina distribution versions. These tool updates are expected to be rare compared to distribution releases.  → bal update Fetching the latest version from the remote server... Downloading ballerina-command-0.8.8 Downloading ballerina-tool-0.8.8 100% [====================================] 1/1 MB  Updated to latest tool version: 0.8.8 Cleaning old files... Ballerina Tool updated successfully   Managing your Ballerina Distributions  After updating the Ballerina Tool, you can use the bal dist command of it to manage Ballerina distributions. The bal help dist output below shows all the details about the bal dist command.  → bal help dist NAME  bal-dist - Manage Ballerina distributions  SYNOPSIS  bal dist <command> <-h | --help>  bal dist <command> [<args>]   DESCRIPTION  Dist enables you to install, update, and switch among Ballerina distributions  from patch and minor release channels.   OPTIONS  -h, --help  Print usage details of a command.   BALLERINA COMMANDS  Here is a list of available subcommands:   update Update to the latest patch version of the active distribution  pull Fetch a distribution and set it as the active version  use Set a distribution as the active distribution  list List locally and remotely available distributions  remove Remove distributions in your local environment   Use 'bal help dist <command>' for more information on a specific command.   Most of these subcommands are self-explanatory. Therefore, the sections below introduce them briefly.  Listing All Local and Remote Distributions  The bal dist list command lists the installed distributions in your local environment. It also lists the distributions available for you to download.  → bal dist list Distributions available locally:   [1.1.0] jballerina version 1.1.0  [1.2.5] jballerina version 1.2.5 * [1.2.8] jballerina version 1.2.8  [slp3] ballerina version slp3  Distributions available remotely:  1.* channel   [1.0.0] jballerina version 1.0.0  [1.0.1] jballerina version 1.0.1  [1.0.2] jballerina version 1.0.2  [1.0.3] jballerina version 1.0.3  [1.0.4] jballerina version 1.0.4  [1.0.5] jballerina version 1.0.5  [1.1.0] jballerina version 1.1.0  [1.1.1] jballerina version 1.1.1  [1.1.2] jballerina version 1.1.2  [1.1.3] jballerina version 1.1.3  [1.1.4] jballerina version 1.1.4  [1.2.0] jballerina version 1.2.0  [1.2.1] jballerina version 1.2.1  [1.2.2] jballerina version 1.2.2  [1.2.3] jballerina version 1.2.3  [1.2.4] jballerina version 1.2.4  [1.2.5] jballerina version 1.2.5  [1.2.6] jballerina version 1.2.6  [1.2.7] jballerina version 1.2.7  [1.2.8] jballerina version 1.2.8  Swan Lake channel   [slp1] Preview 1  [slp2] Preview 2  [slp3] Preview 3  [slp4] Preview 4  Use 'bal help dist' for more information on specific commands.      Note: The star (*) indicates the active distribution.   Removing a Distribution  The bal dist remove <distribution> command allows you to delete a particular distribution from your local environment. If you’ve been updating Ballerina regularly, you may have accumulated many unused distribution versions. This command helps you to clean them up.  → bal dist remove 1.2.5 Distribution '1.2.5' successfully removed   Updating to the Latest Preview/Patch Version  The bal dist update command updates your active distribution to the latest patch version.  E.g., If the active distribution in your environment is 1.2.7 and there exists the patch version 1.2.8 in our servers, this command will fetch and set it as the active distribution.  → sudo bal dist update Fetching the latest patch distribution for 'jballerina-1.2.7' from the remote server... Fetching the '1.2.8' distribution from the remote server... Downloading 1.2.8 100% [==========================================================] 96/96 MB Successfully set the latest patch distribution '1.2.8' as the active distribution     Note: If the active distribution in your environment is slp4, it will bump to the next Swan Lake Preview version, which is slp5, and will update to it.   Pulling a Specific Distribution  The bal dist pull <distribution> command downloads a particular distribution and stores it in your local environment. It also sets the fetched distribution as the active distribution.  → bal dist pull 1.2.5 Fetching the '1.2.5' distribution from the remote server... Downloading 1.2.5 100% [=====================================================================================] 236/236 MB (0:03:33 / 0:00:00)  Fetching the dependencies for '1.2.5' from the remote server... Dependency 'jdk8u202-b08-jre' is already available locally '1.2.5' successfully set as the active distribution   Changing the Active Distribution  The bal dist use <distribution> command sets a particular distribution version as the active one.  → bal dist use 1.2.5 '1.2.5' is the current active distribution version    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/configurations/","name":"Configurations","summary":"The Ballerina extension provides a set of configurations to allow customisations as per your preferences.Table of contents        It enables all code lens features irrespective of the Code Lens - Docs: Enabled and Code Lens - Executor: Enabled settings and is enabled by default.It enables the ...","content":"/  /  /  / Configurations  Configurations  The Ballerina extension provides a set of configurations to allow customisations as per your preferences.  Table of contents Code Lens - All: Enabled  It enables all code lens features irrespective of the Code Lens - Docs: Enabled and Code Lens - Executor: Enabled settings and is enabled by default.  Code Lens - Docs: Enabled  It enables the Documentation feature, which provides Ballerina document generation capabilities and is enabled by default. This configuration is overridden by the Code Lens - All: Enabled setting.  Code Lens - Executor: Enabled  It enables the Executor feature, which provides quick run and debug capabilities for the Ballerina language. It is enabled by default. This configuration is overridden by the Code Lens - All: Enabled setting.    Tip: The Debug code lens honors the debug.saveBeforeStart setting of the VS Code editor.   Data Mapper: Enabled  It enables the Data Mapper and is disabled by default.  Data Mapper: Url  It specifies the URL of the service backend.  Debug Log  It enables printing debug messages on to the Ballerina output channel and is disabled by default. These debug logs mainly include additional logs added for troubleshooting the extension.    Enable File Watcher  It enables watching file change events of the Ballerina project and is enabled by default.  Enable Telemetry  It enables the Ballerina service and is enabled by default.    Tip: This honors the telemetry.enableTelemetry setting of the VS Code editor.   Home  It specifies the Ballerina home directory path and is only applicable if the Plugin - Dev: Mod is enabled.    Tip: Enclose the parts of the path on Windows with quotations if it includes spaces. E.g., C:\\\"Program Files\"\\Ballerina   Plugin - Dev: Mod  It enables the plugin development mode and is disabled by default. If it is disabled, the extension picks up the Ballerina runtime installed in the environment. Also, if it is enabled, the extension picks up the Ballerina runtime defined in the Home .  Trace Log  It enables printing trace messages onto the Ballerina output channel and is disabled by default. These trace logs mainly include the details of the requests sent form the extension to the Ballerina Language Server.        Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/debugging/","name":"Debugging","summary":"The VS Code Ballerina extension allows you to either run your Ballerina program (without debugging) or debug them easily by launching its debugger.Table of contents        Follow the steps below to run your program (without debugging).On the VSCode editor, open the Ballerina program file you want ...","content":"/  /  /  / Debugging  Debugging  The VS Code Ballerina extension allows you to either run your Ballerina program (without debugging) or debug them easily by launching its debugger.  Table of contents Running Without Debugging  Follow the steps below to run your program (without debugging).    On the VSCode editor, open the Ballerina program file you want to run.  Click Run in the top menu, and then click Run Without Debugging.  Select Ballerina Debug as the Environment.  You view the program being executed in the DEBUG CONSOLE as shown below.        Info: For more information on debugging your code using VS Code, go to the .   Starting a Debug Session  The VS Code Ballerina extension gives you the same debugging experience as the conventional VS Code Debugger. Follow the steps below to start a debug session.        Open the folder, which includes the Ballerina program you want to debug and select the file.  Press the Control + Shift + D keys (for Mac: Command + Shift +D) to launch the Debugger view.  Click create a launch.json file and then select Ballerina Debug as the Environment.   You view the opened launch.json file.  Add/edit the relevant configurations for debugging in the launch.json file.  Add the debug points you require by clicking in front of the line numbers of the file you want to debug.  Then, you can start a program, test, or remote debug session as shown below.    Info: If you launch the debug session through VS Code, the working directory will be the Ballerina package root. However, you can use remote debugging for alternative working directories.     Starting a Program Debug Session  Follow the steps below to start a program debug session.    Select Ballerina Debug from the drop-down available in the upper left corner to start a program debugging session.  Click the Start Debugging icon on the upper left corner to start debugging.   You view the output in the DEBUG CONSOLE.   Starting a Test Debug Session  Follow the steps below to start a test debug session.    Select Ballerina Test from the drop-down available in the upper left corner to start a test debugging session.  Click the Start Debugging icon on the upper left corner to start debugging.   You view the output in the DEBUG CONSOLE.   Starting a Remote Debug Session  Follow the steps below to start a remote debug session.    Select Ballerina Remote from the drop-down available in the upper left corner to start a remote debugging session.  Open the Terminal and execute the Ballerina command, which you want to debug, out of the supported remote debugging commands below.   Debugging a Ballerina package or a single file:  bal run --debug <DEBUGGEE_PORT> <BAL_FILE_PATH/PACKAGE_PATH>  Debugging Ballerina executable JAR:  bal run --debug <DEBUGGEE_PORT> <EXECUTABLE_JAR_FILE_PATH>  Debugging Ballerina tests:  bal test --debug <DEBUGGEE_PORT> <PACKAGE_PATH>  Debugging Ballerina tests during the build:  bal build --debug <DEBUGGEE_PORT> <PACKAGE_PATH>  The terminal will show the following log:   Listening for transport dt_socket at address: 5005  Click the Start Debugging icon on the upper left corner to start debugging.   You view the output in the DEBUG CONSOLE.   Using the Debugging Features  Visual Studio Code allows you to debug Ballerina programs through the Ballerina extension. The debugging features below are supported by Ballerina.    Launch/Attach  Breakpoints  Pause & Continue  Step In/Out/Over  Variables  Call Stacks  Strands  Expression Evaluation     Info The Ballerina debugger is an open-source project and contributors are most welcome to get engaged with it via the GitHub repository. If you encounter any difficulties when using this feature, feel free to create an issue on it.     Using Expression Evaluation  Ballerina expression evaluator allows evaluating Ballerina variables and expressions at runtime allowing them to be viewed when the IDE is in the break mode.  The Ballerina VSCode debugger lets you evaluate expressions in the ways below.  Using the Debug Console      Using the Watch Window      Existing Limitations  The features below are currently not supported.    Anonymous function, query, let, and constructor expressions  Qualified identifiers (Hence, cannot evaluate imported module entities.)  Function invocations with rest arguments  Action invocations     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/diagram-editor/","name":"Diagram Editor","summary":"The Ballerina language possesses bidirectional mapping between its syntaxes and the visual representation. The Diagram Editor of the Ballerina extension helps you to visualize the graphical representation while developing your Ballerina program via the methods below.Table of contents        The Diagrams view shows a list of ...","content":"/  /  /  / Diagram Editor  Diagram Editor  The Ballerina language possesses bidirectional mapping between its syntaxes and the visual representation. The Diagram Editor of the Ballerina extension helps you to visualize the graphical representation while developing your Ballerina program via the methods below.  Table of contents Diagrams View  The Diagrams view shows a list of functions and services of the currently-opened Ballerina project. Once you make new changes, the Diagrams view syncs with the latest upon saving. By clicking on the listed diagram components, you can view the graphical representation of each of them.    Tip: Use the refresh button on the Diagrams view to list the available views.     Diagram View Button  By clicking on the Show Diagram View button on the editor’s title bar, you can quickly switch to the Diagrams view. This option shows the diagram of the first component listed under the Diagrams view.    Tip: The Diagram Editor syncs with the latest when you make changes on the text editor.     Show Diagram View Palette Command  The Ballerina: Show Diagram View is available for quick access.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/language-support/","name":"Language Support","summary":"The Visual Studio Code Ballerina extension brings in language support to enhance the development experience and increase its efficiency. This is built into the extension via a Language Server implementation, which consists of the below features.Table of contents        The extension provides you with suggestions on ...","content":"/  /  /  / Language Support  Language Support  The Visual Studio Code Ballerina extension brings in language support to enhance the development experience and increase its efficiency. This is built into the extension via a Language Server implementation, which consists of the below features.  Table of contents IntelliSense  Code Completion  The extension provides you with suggestions on variables, keywords, and code snippets of language constructs (such as functions, type definitions, services, iterable constructs, etc.)    Symbol Information on Hover  When hovering over a symbol name, you will be provided with quick information about the particular symbol. For example, when hovering over a function name, you will be prompted with the associated documentation.    Signature Help  When typing a function/method call expression, the signature help will show information such as the function/method call’s description and parameter information. Signature help will be triggered when typing the open parenthesis and comma.    Code Navigation  Go to Definition  For a symbol, this feature will navigate you to the definition of the particular symbol. For example, when invoking the go to definition from a function call expression, you will be navigated to the definition of the function. Apart from jumping to the definition, the peek definition will also be supported. The behaviour will be the same not only for the constructs within the sources in the current package but also for external modules and standard libraries as well.    Find all References  Invoking the references on a symbol will prompt you with all the symbol references in the current package.    Diagnostics  The diagnostics show you the syntax and semantic errors in the source code. Varieties of diagnostics such as errors and warnings will be shown. For a selected set of diagnostics, you can see the quick fixes. For example, the variable assignment is required diagnostic will have two associated quick fixes to create a new variable and ignore the return value.    Data Mapping  This code action generates the mappings for record types.      Tip: The Data Mapper: Enabled should be configured to enable the Data Mapper feature.   Code Formatting  Code formatting has the two options below.    Formatting a document       Formatting a selected range in the document     Rename Symbols  This feature allows you to rename symbols by renaming all the references of the particular symbol.    Code Lenses  Documentation Code Lens  The Document This code lens is shown for the public functions without documentation.    Run and Debug Code Lenses  Run and debug code lenses are shown for the entry points of the Ballerina project and for its test cases. The entry points include the main function and the services within the default module of the project.    Code Actions  There are two types of code actions suggested based on the node at a given cursor position and based on the diagnostic at a given cursor position.  Create Variables  The sections below demonstrates the types of code actions available for creating a variable.  Create Variable  Create a variable for an expression where the Variable Assignment Required diagnostic is present.    Create Variable and Type Guard  Create a type guard to handle the error gracefully when the Variable assignment Required diagnostic is present.    Create Variable and Check Error  Add a check expression when the Variable assignment Required diagnostic is present.    Ignore Return Value  Ignore the return value with the _ where the Variable Assignment Required diagnostic is present.    Union Type Variables  The sections below demonstrates the code actions available for union type variables.  Type Guard variable  Type guard a variable, if the variable is of the union type.    Add Check Error  When there is an error union, add a check statement.    Imports  The sections below demonstrates the code actions available for imports.  Import a Module  Add the import statement for a module, which has a reference without an import statement. This supports only the langlibs and the standard libraries.    Optimize Imports  Optimize the import statements to remove unused imports and arrange the imports on the alphabetical order.    Documentation  The sections below demonstrates the code actions available for documentation.  Document This  Add the documentation to the top-level constructs, resources, and methods.    Document All  Document all the top-level constructs.    Update Documentation  Update the existing documentation when parameters are missing or not documented. This depends on the warning diagnostic sent by the compiler.    Incompatible Types  The sections below demonstrates the code actions available for incompatible types.  Change Variable Type  Changes the type of a variable.    Add Type Cast  Add a type cast for the incompatible types.    Fix Return Type  Changes the incompatible return type.    Change Parameter Type  Changes the type of a function/ method parameter.    Create Functions  The sections below demonstrates the code actions available for creating functions.  Create a Function  Creates a function using the selected variables/parameters.    Implement a Method  Implements the selected method.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/quick-start/","name":"Quick Start","summary":"The Visual Studio Code Ballerina extension provides a set of rich language features along with an enhanced user experience. It offers easy development, execution, debugging, and testing for the Ballerina programming language. You can further visualize the graphical representation of your Ballerina source via the Diagram Editor.Table of contents  ...","content":"/  /  /  / Quick Start  Quick Start  The Visual Studio Code Ballerina extension provides a set of rich language features along with an enhanced user experience. It offers easy development, execution, debugging, and testing for the Ballerina programming language. You can further visualize the graphical representation of your Ballerina source via the Diagram Editor.  Table of contents Setting up the Prerequisites  Before getting started, make sure you have installed the and .    Tip: The VSCode Ballerina extension supports both the Ballerina Swan Lake and 1.2.x versions.   Installing the Ballerina Extension  Follow the steps below to install the Ballerina extension.      Go to the in the Visual Studio Code marketplace, and click Install.  Click Open Visual Studio Code and install the extension.  Tip: To verify if the extension is installed, check if the Ballerina SDK Version is displayed on the VSCode status bar. If you get Ballerina SDK: Error or Ballerina SDK: Detecting on the status bar, to troubleshoot.   Running Your First Ballerina Program  Follow the steps below to create a sample Ballerina program in VSCode.      Click View in the menu bar of the editor, and click Command Palette.   Tip: You can use the shortcut methods ⌘ + ↑ + P on Mac and Ctrl + Shift + P on Windows and Linux.  In the search bar, type Ballerina Examples and click Ballerina: Show Examples.  Select the Hello World Main example.  Click on the Run code lens on the editor.   You just ran your first Ballerina program with a few clicks.   Tip: If you wish to debug further, you can either use the Debug codelens or see .  Click the Show Diagram View button on the editor’s title bar to view the graphical representation of the program.  What’s Next?  The VS Code Ballerina extension is enriched with language support capabilities and user configuration support. For more information on these capabilities, see the sections below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/run-and-debug/using-the-debugging-features/","name":"Using the Debugging Features","summary":"Visual Studio Code allows you to debug Ballerina programs through the Ballerina extension. The debugging features below are supported by Ballerina.Table of contents        Info The Ballerina debugger is an open-source project and contributors are mostly welcome to get engaged with it via the  GitHub ...","content":"/  /  /  /  / Using the Debugging Features  Using the Debugging Features  Visual Studio Code allows you to debug Ballerina programs through the Ballerina extension. The debugging features below are supported by Ballerina.  Table of contents Info The Ballerina debugger is an open-source project and contributors are mostly welcome to get engaged with it via the GitHub repository. If you encounter any difficulties when using this feature, feel free to create an issue in it.   Expression Evaluation  Ballerina expression evaluator allows evaluating Ballerina variables and expressions at runtime allowing them to be viewed when the IDE is in the break mode.  The Ballerina VSCode debugger lets you evaluate expressions in the ways below.  Using the Debug Console    Using the Watch Window    Existing Limitations  The features below are currently not supported.    Anonymous function, query, let, and constructor expressions  Qualified identifiers (Hence, cannot evaluate imported module entities.)  Function invocations with rest arguments     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/tooling-guide/visual-studio-code-extension/vs-code-commands/","name":"VS Code Commands","summary":"The VS Code Ballerina extension comprises of a set of palette commands to enable easy development using the inherent capabilities of the Ballerina language.Table of contents        Tip: Click View in the menu bar of the editor and click Command Palette to access the command palette. ...","content":"/  /  /  / VS Code Commands  VS Code Commands  The VS Code Ballerina extension comprises of a set of palette commands to enable easy development using the inherent capabilities of the Ballerina language.  Table of contents Tip: Click View in the menu bar of the editor and click Command Palette to access the command palette. Alternatively, use the VS Code palette shortcut (⌘ + ↑ + P on Mac and Ctrl + Shift + P on Windows and Linux) to execute the commands.   Show Examples  It lists the available examples of the Ballerina language. By clicking on each example, you can explore each source code.      Tip: If you encounter any errors, check the .   Build  It is a quick access to build your Ballerina project. Once executed, the current Ballerina project relative to the currently-opened text editor is built using the bal build .    Run  It runs your Ballerina project. Once executed, the opened Ballerina project is built using the bal run .      Tip: If you use any , the relevant Config.toml file should be added inside the Ballerina project root in case the BAL_CONFIG_FILES and BAL_CONFIG_DATA environment variables are not defined.   Test  It runs all the tests in your Ballerina project using the bal test .      Tip: If you use any , the relevant Config.toml file should be added inside the corresponding module’s test directory root.   Document  It is a quick guide to generate documentation for your Ballerina project. Once executed, the documentation is generated using the bal doc . The generated documentation can be found inside the apidocs directory in the project target.    Show Diagram View  It is a palette reference to access the Diagrams . On execution, the diagram editor of the first diagram component listed under the Diagrams view is rendered.    Add Module  It adds a Ballerina for the given module name using the bal add .    Create Cloud.toml  It generates a Cloud.toml file for your Ballerina project according to the default .     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/annotations_documentation_and_comments/","name":"Annotations, Documentation and Comments","summary":"The sections below include the coding conventions with respect to annotations, documentation, and comments.Table of contents      Example,Example,Example,Example,andExample,Example,Example,Example,\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so ...","content":"/  /  /  / Annotations, Documentation and Comments  Annotations, Documentation and Comments  The sections below include the coding conventions with respect to annotations, documentation, and comments.  Table of contents Annotations   Do not have spaces around the @ symbol.  Indent annotations to align them with the starting position of the owner (statement or definition).  Each annotation attribute (i.e., key-value pairs) should block indent on its own line.   Example,  // Function annotations are aligned with the starting position of the function. @test:Config {  before: beforeFunc,  after: afterFunc } function testFunction() {  io:println(\"I'm in test function!\");  test:assertTrue(true, msg = \"Failed!\"); }     If an annotation is empty, place it in a single line and do not have spaces between both braces.   Example,  @test:Config {}     If you are annotating a parameter or a return type, the annotation should be added inline to the parameter or the return type.   Example,  // Parameter annotation. public function secureFunction1(@untainted string secureInName, @untainted int secureInId, string insecureIn) {  ... }  public function secureFunction2(@untainted string secureInName,  @untainted int secureInId, string insecureIn) {  ... }  // Return type annotation. public function taintedReturn1() returns @tainted string {  ... }  public function taintedReturn2() returns @tainted string {  ... }  Comments   Use // for both single-line and multi-line comments.   Example,  // This is a single-line comment.   and  // Copyright (c) 2019 WSO2 Inc. (http://www.wso2.org) All Rights Reserved. // // WSO2 Inc. licenses this file to you under the Apache License, // Version 2.0 (the \"License\"); you may not use this file except // in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, // software distributed under the License is distributed on an // \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY // KIND, either express or implied. See the License for the // specific language governing permissions and limitations // under the License.     Add a single space between the // and the content.  If the comment is in its own line, then indent it considering its context (i.e., top-level or in a block).   Example,  // This is a top-level comment.  function func1() {  // This is a block-level comment. }  function func2() {  if (true) {  if (true) {  // This is a nested if block-level comment.  }  } }     If the comment is in line with the code, add a space before it.   Example,   type People record {}; // Inline comment  function func1() {  int a = 0; // Inline comment }    Documentation   Always, indent them to align with the starting position of the owner.  Add a space after the # symbol.  Add an empty line after the description.   Example,  # Description. # # + value - value input parameter # + return - return a integer value function getValue(int value) returns int {  return value; }     Add only one space after the parameter marker (+), divider (-), and return.  Begin the param identifier and description with a single space.   Example,  # Description. # # + value - Parameter description # + return - Return value description function getValue(int value) returns int {...}  # Description. service / on new http:Listener(8080) {  # Description.  #  # + caller - Parameter description.  # + request - Parameter description.  resource function get greeting(http:Caller caller, http:Request request) {...} }   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/expressions/","name":"Expressions","summary":"The sections below include the coding conventions with respect to expressions.Table of contents      Do not keep spaces between the function name and opening parentheses (.If it is unable to keep the function invocation in a single line due to it exceeding the max line length, split each ...","content":"/  /  /  / Expressions  Expressions  The sections below include the coding conventions with respect to expressions.  Table of contents Function Invocation    Do not keep spaces between the function name and opening parentheses (.  If it is unable to keep the function invocation in a single line due to it exceeding the max line length, split each argument to its own block-indented line.  Example,   setAgeForEmployee(  employeeName,  employeeID  );   Record Literal    If empty, keep it as an empty block.   Example,  Person p = {};     In a record literal, arrange the fields in a single line. Then, add a space after the comma and leave no spaces between the braces and fields.   Example,  Person p = {name: \"john\", age: 20};     Do not keep any spaces between the key and the colon. Also, Keep only one space between the colon and the value.   Example,  Person person = {  name: \"john\", // in this field Key is the \"name\" and value is \"john\". };     You can define the fields in new lines. If so, make sure all the fields are in a separate line and they are block-indented.   Do’s  Person p = {  name: \"john\",  age: 20 };   Don’ts  Person p = {name: \"john\",  age: 20};  //Or  Person p = { name: \"john\", age: 20 };  //Or  Person p = {  name: \"john\",  age: 20};   Map Literal    For Map literals, follow the same formatting guidelines as .   Example,   // Inline map literal. map<string> mapOfString1 = {name: \"john\", id: \"0\"};  // Mulitline map literal. map<string> mapOfString2 = {  name: \"john\",  id: \"0\" }   Tuple    Always, place a tuple in a single line.   Example,  [string, int] tuple = [\"john\", 20];     If a tuple exceeds the maximum line length limit, move the whole tuple to a new line and indent with four spaces from the starting position of the statement or definition.   Example,  [string, int] tuple = [nameOfEmployee, ageOfTheEmployee];   Array Literal    Place simple arrays in a single line.  Do not keep any spaces between the opening bracket, value, and the closing bracket.   Example,  string[] names = [\"john\", \"doe\", \"jane\", \"doe\"];     If an array cannot be placed on a single line due to it exceeding the max line length, split each value in the array to its own block-indented line.   Example,   string[] names = [  \"john\",  \"doe\",  \"jane\",  \"doe\" ];  Type Casting    Do not keep spaces between the type and the angle brackets (i.e., <string>).  Do not keep spaces between the closing angle bracket and value reference, which will be casted.   Example,  string name = <string>json.name;     Avoid line breaks in type casting.   Do’s  <string>   Don’ts  <  string >   Table Literal    Follow formatting when formatting a table block.   Example,  type Employee record {  readonly int id;  string name;  float salary; };  type EmployeeTable table<Employee> key(id);  public function main() {   EmployeeTable employeeTab = table [  {id: 1, name: \"John\", salary: 300.50},  {id: 2, name: \"Bella\", salary: 500.50},  {id: 3, name: \"Peter\", salary: 750.0}  ];  }   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/","name":"Coding Conventions","summary":"This Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.Table of contents      You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured ...","content":"/  /  / Coding Conventions  Coding Conventions  This Ballerina Style Guide aims at maintaining a standard coding style among the Ballerina community. Therefore, the Ballerina code formatting tools are based on this guide.  Table of contents You can follow your own coding style when writing Ballerina source code. Also, plugins and tools can be configured to match your coding style.   Indentation and Line Length   Use four spaces (not tabs) for each level of indentation.  Keep the maximum length of a line to 120 characters.     Note: You can configure tools and plugins to use tabs when indenting and to change the number of maximum characters of the line length.   Line Spacing    Use only a single space to separate keywords, types, and identifiers.   Do’s  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Don’ts  public function getFullName() returns string {  string fullName = \"john doe\";  return fullName; }   Few exceptions for this rule are:   Do not keep spaces around a type when it is enclosed using angle brackets <string>.   Example,  map<string> names = {};     Do not keep spaces between the type and the opening bracket in the array definition string[].   Example,   string[] names = [];     If it is a list of values separated by commas, add only a single space after each comma and don’t add spaces before the comma.   Example,  [string, int, boolean] tupleVar = [\"\", 0, false];  int[] arrayOfInteger = [1, 2, 3, 4];  map<string> stringMap = {one: st1, two: st2, three: st3};  Person personRecord = {name: \"marcus\", id: 0};  function foo(string name, int id) { }  service hello on ep1, ep2 {  ... }   Blank Lines  Separate both statements and top-level definitions by zero or one blank lines.  Example,  import ballerina/http; import ballerina/io;  const string CITY = \"Colombo\"; const int CITY_NO = 1;  function getName() returns string {  string firstName = \"john\";  string lastName = \"doe\";   return firstName + lastName; }  function setName(string name) { }  function setAge(int age) { }     Note: You can configure tools and plugins to change the number of minimum and maximum blank lines used when formatting.   Blocks   Opening curly braces of a block should be placed inline.   Do’s  if (true) { }  function setName(string name) {  }   Don’ts  if (true) {  }  function setName(string name) {  }     Add a single space before the opening curly braces.   Example,   function func1() {  if (true) {  } }      If an inline block is empty, do not keep spaces in between the opening and closing braces.   Example,  function func1() { }     Indent all the statements inside a block to be at the same level.  Indent the closing brace of a block to align it with the starting position of the block statement.   Example,  if (false) {  ... }  match a {  ... }   Parentheses and Brackets   Do not have spaces after opening parentheses/bracket and before closing parentheses/bracket.   Example,  [string, int] tupleVar = [\"\", 0];  function setValue(string value) {  ... }  setValue(\"value\");     To define empty parentheses, do not keep spaces between the opening and closing parentheses ().   Example,  int|() result = getResult();   Line Breaks    Have only one statement in a line.  When splitting lines, which contain operator(s), split them right before an operator.   Example,  // Binary operations. string s = \"added \" + People.name  + \" in to database.\";  // Function invocation. string s = person  .getName();  // Binary operations in if condition if (isNameAvailable && (i == 1)) {  }     When splitting lines, which contains separator(s), split them right after a separator.   Example,  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     If there isn’t any operator or separator to break the line from, move the whole expression to a new line.   Example,  // String literal. string s1 =  \"My name is not in this description\";  // Function invocation. string s2 =  getPersonNameWithUpperCaseLetters();     If a line exceeds the max line length, start from the end of the line and come towards the start of the line until you find a point, which matches the above rules to break the line.  Indent split lines with relation to the starting position of the statement or definition.   Example,  if (isNameAvailable && (i == 1)) {  }  // Function parameters. function getName(int id, int age,  string searchValue) returns string {  ... }     However, if you cannot add the type-casting expression or statement with the constrained type in a single line due to it exceeding the max line length,  move the casting type with the operators to a new line.   Example,   string name =  <string>json.name;     keep the constrained type on the same line by splitting the statement from a point before the constraint type.   Example,  map<int|string> registry = {  name: \"marcus\" };  table<Employee> employee = table {  {key id, name, address}  };   Top-Level Definitions  For style guidelines on imports, service definition, object definition, record definition, referencing record or abstract object, etc., see .  Operators, Keywords, and Types  For style guidelines on operators, keywords, and types, see .  Statements  For style guidelines on statements such as if, match, transaction, etc., see .  Expressions  For style guidelines on function invocation, literals, tuple, type casting, etc. see .  Annotations, Documentation, and Comments  For style guidelines on annotations, documentation, and comments, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/operators_keywords_and_types/","name":"Operators, Keywords, and Types","summary":"The sections below include the coding conventions with respect to operators, keywords, and types.Table of contents      Example,Example,Do’sDon’tsExample,Example,Example,Example,Example,\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so ...","content":"/  /  /  / Operators, Keywords, and Types  Operators, Keywords, and Types  The sections below include the coding conventions with respect to operators, keywords, and types.  Table of contents Keywords and Types   Do not keep spaces between the type and the pipe operator when it is in a union type (e.g., string|int).   Example,  type method \"POST\"|\"GET\"|\"PUT\";  (int|string) variable = 0;  function getValue(string key) returns (string|error) {  ... }  function getName() returns string|error {  (string|error) valueOrError = getValue(\"name\");  ... }     Do not keep spaces between the type and the optional operator ?.   Example,  string? name;     Avoid line breaks in constrained types.   Do’s   map<int|string> // map reference type   Don’ts  map<  int  |  string > Operators   Keep only a single space before and after the = operator.   Example,  int a = 0;     Do not keep spaces around the semicolon ;.  Do not keep spaces between the unary operator and the expression.   Example,  a = -a;     Keep a single space before and after any binary or ternary operator.   Example,  var fullName = firstName + lastName;  string|() name = isNameAvailable() ? getName() : \"Unknown\";  var elvisOperator = name ?: \"Unknown\";     Keep a single space before and after a compound operator such as -= and +=.   Example,  name += lastName;     When accessing a function, object, or record from another module, do not keep spaces around :.   Example,  io:println(\"john\"); http:Response res = new();   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/calling-java-code-from-ballerina/","name":"Calling Java Code from Ballerina","summary":"Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java.  Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering ...","content":"/  /  / Calling Java Code from Ballerina  Calling Java Code from Ballerina  Ballerina offers a straightforward way to call the existing Java code from Ballerina and also provides a Java API to call Ballerina code from Java. Although Ballerina is not designed to be a JVM language, the current implementation, which targets the JVM, aka jBallerina, provides Java interoperability by adhering to the Ballerina language semantics.  Table of contents Ballerina Bindings to Java Code Your task is to write Ballerina code (Ballerina bindings) that lets you call the corresponding Java API as illustrated in the below diagram.    This guide teaches you how to write those bindings manually as well as how to generate those bindings automatically but first, let’s look at why you want to call Java from Ballerina.  The Need to Call Java from Ballerina   Ballerina is a relatively new language. Therefore, you may experience a shortage of libraries in . In such situations, as a workaround, you can use an existing Java library.  You are already familiar with a stable Java API that you would like to use in your Ballerina package.  You want to take advantage of the strengths of Ballerina but you don’t want to reinvest in the libraries that you or your company have written already.   There may be other reasons but these are great motivations to use Ballerina bindings.  Writing Ballerina Bindings Writing Ballerina bindings manually is a tedious task. You’ll soon see why. Therefore, we’ve developed a tool called bindgen that can generate Ballerina bindings for given Java APIs. The of this guide shows you how to use it. The is a reference guide to the tool.  The explains how to package Java libraries (JAR files) with Ballerina programs. This section is useful because whenever you generate bindings for a Java library, you need to package this Java library and its transitive dependencies to produce a self-contained executable program.  The and sections explain how to write these bindings manually. It is also a useful section for those who want to understand the inner workings of calling Java from Ballerina and for those who want to customize the bindings generated by the bindgen tool.  Using the SnakeYAML Java Library in Ballerina SnakeYAML is a YAML parser for Java. In this section, we’ll learn how to use this library to parse a YAML document using Ballerina.  We’ll develop a Ballerina program that parses the given YAML file and writes the content to the standard out.  Let’s get started.  Step 1 - Writing the Java Code We recommend you to always start by writing the Java code. It gives you an idea of the set of Java classes required to implement your logic. Then, we can use the bindgen tool to generate Ballerina bindings for those classes.  The following Java code uses the SnakeYAML API to parse the given YAML file. Note that this is not the most idiomatic way of writing the Java code for this scenario.  import org.yaml.snakeyaml.Yaml;  import java.io.FileInputStream; import java.io.InputStream; import java.util.Map;  public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Here, we’ve used four Java classes.   org.yaml.snakeyaml.Yaml  java.io.FileInputStream  java.io.InputStream  java.util.Map   You can see them in the imported class list. We encourage you to generate Ballerina bindings for these four classes as a start.  Now, we’ll create an environment for our Ballerina program.  Step 2 - Setting Up the Ballerina Package This section assumes that you have already read .  Creating a Ballerina Package > bal new yaml_package Created new Ballerina package 'yaml_package' at yaml_package.   Adding a Sample YAML File Copy the below content to a file named invoice.yml in the package root directory. invoice: 34843 date : 2001-01-23 bill-to: &id001  given : Chris  family : Dumars  address:  lines: |  458 Walkman Dr.  Suite #292  city : Royal Oak  state : MI  postal : 48046 ship-to: *id001 product:  - sku : BL394D  quantity : 4  description : Basketball  price : 450.00  - sku : BL4438H  quantity :  description : Super Hoop  price : 2392.00 tax : 251.42 total: 4443.52 comments: >  Late afternoon is best.  Backup contact is Nancy  Billsmer @ 338-4338.\\   Verifying the Package > bal build Compiling source \tsameera/yaml_package:0.1.0  ... ...  Creating the BALA file \ttarget/bala/sameera-yaml_package-any-0.1.0.bala  Generating executables \ttarget/bin/yaml_package.jar  > bal run target/bin/yaml_package.jar Hello World!  Great! You are all set for the next step.  Step 3 - Generating the Ballerina Bindings In this step, we’ll use the bindgen tool to generate Ballerina bindings for those four classes that we talked about in Step 1. If you want more information about the tool, you can refer .  > bal bindgen -mvn org.yaml:snakeyaml:1.25 org.yaml.snakeyaml.Yaml java.io.FileInputStream java.io.InputStream java.util.Map  Ballerina package detected at: /Users/sameera/yaml_package  Resolving maven dependencies... snakeyaml-1.25.jar 100% [===============================================] 297/297 KB (0:00:01 / 0:00:00)  Updated the `Ballerina.toml` file with the new platform libraries.  The following JARs were added to the classpath: \tsnakeyaml-1.25.jar  Generating bindings for: \tjava.util.Map \tjava.io.FileInputStream \torg.yaml.snakeyaml.Yaml \tjava.io.InputStream  Generating dependency bindings for: \torg.yaml.snakeyaml.introspector.BeanAccess \tjava.util.function.BiFunction \torg.yaml.snakeyaml.DumperOptions$FlowStyle \t... \t...     The -mvn option specifies the Maven dependency of the Java library required to generate bindings.  The argument list specifies the Java class names.   The bindgen tool generates bindings for:   The specified Java classes.  The Java classes exposed in the public APIs of all the specified classes.   Before we move onto the next step, let’s verify the generated code. > bal build ... ...  Generating executables \ttarget/bin/yaml_package.jar  > bal run target/bin/yaml_package.jar Hello World!   Step 4 - Writing the Ballerina Code   Note: The bindgen tool is still experimental. The generated code is in the process of being improved.   Now, we’ll use the generated bindings and write the Ballerina code, which uses the SnakeYAML library. Here is the Java code. Let’s develop the corresponding Ballerina code step by step. public class SnakeYamlSample {   public static void main(String... a) { \tString filename = a[0]; \ttry (InputStream inputStream = new FileInputStream(filename)) {  Yaml yaml = new Yaml(); Map<String, Object> obj = yaml.load(inputStream);  System.out.println(obj); \t} catch (Exception e) {  System.err.println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + e.getMessage());; \t}  } }   Creating the ‘FileInputStream’ Our goal here is to create a new java.io.FileInputStream instance from the filename. In step 3, we generated bindings for the required Java classes. The following is the code snippet that does the job.  FileInputStream | FileNotFoundException fileInputStream = newFileInputStream3(filename);   Here, FileInputStream is the Ballerina object generated for the java.io.FileInputStream class.   You can find functions that start with newFileInputStream in the generated code. Each such function creates a new java.io.FileInputStream instance. Ballerina does not support function overloading. Therefore, the bindgen tool generates a separate Ballerina function for each overloaded method or constructor. We will improve the function names of the generated bindings in a future release.  All the public methods in the java.io.FileInputStream class are mapped to methods in the generated Ballerina object.   Next, we’ll handle the error using a type guard. if fileInputStream is FileNotFoundException { \t// The type of fileInputStream is FileNotFoundException within this block  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + fileInputStream.message()); } else { \t// The type of fileInputStream is FileInputStream within this block }  Creating the SnakeYAML Entry Point The org.yaml.snakeyaml.Yaml class is the entry point to the SnakeYAML API. The generated corresponding Ballerina object is Yaml. The newYaml1() function is mapped to the default constructor of the Java class. Yaml yaml = newYaml1();  Loading the YAML Document We’ll be using the org.yaml.snakeyaml.Yaml.load(InputStream is) method to get a Java Map instance from the given InputStream. Object mapObj = yaml.load(fileInputStream);   The org.yaml.snakeyaml.Yaml.load(InputStream is) is a generic method. The bindgen tool does not support Java generics at the moment. That is why the corresponding Ballerina method returns an Object.  Printing the Returned Map Instance You can print the content of the Map instance in the standard out as follows. io:println(mapObj);  Completing the Code Here, is the complete code. You can replace the contents in modules/yamlparser/yamlparser.bal with the following code. import ballerina/io;  public function main(string... args) returns error? {  string filename = args[0];  FileInputStream | FileNotFoundException fileInputStream = newFileInputStream3(filename);  if fileInputStream is FileNotFoundException {  io:println(\"The file '\" + filename + \"' cannot be loaded. Reason: \" + fileInputStream.message());  } else {  Yaml yaml = newYaml1();  Object mapObj = yaml.load(fileInputStream);  io:println(mapObj);  } }   Let’s build and run this code. > bal build Compiling source \tsameera/yaml_package:0.1.0  ... ...  Creating the BALA file \ttarget/bala/sameera-yaml_package-java11-0.1.0.bala  Generating executables \ttarget/bin/yaml_package.jar   Now, we need to pass the YAML file name as the first argument. > bal run target/bin/yaml_package.jar invoice.yml {invoice=34843, date=Mon Jan 22 16:00:00 PST 2001, bill-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, ship-to={given=Chris, family=Dumars, address={lines=458 Walkman Dr. Suite #292 , city=Royal Oak, state=MI, postal=48046}}, product=[{sku=BL394D, quantity=4, description=Basketball, price=450.0}, {sku=BL4438H, quantity=null, description=Super Hoop, price=2392.0}], tax=251.42, total=4443.52, comments=Late afternoon is best. Backup contact is Nancy Billsmer @ 338-4338.\\}  In this section, we explained how to use the bindgen tool to generate Ballerina bindings for Java classes and how to use those generated ones.  The next sections provide more details on various aspects related to Java interoperability in Ballerina.  The ‘bindgen’ Tool  The following subsections explain how the bindgen tool works.    Note: The bindgen tool is still experimental. The generated code is in the process of being improved.   The bindgen is a CLI tool, which generates Ballerina bindings for Java classes.  The ‘bindgen’ Command  ballerina bindgen [(-cp|--classpath) <classpath>...]  [(-mvn|--maven) <groupId>:<artifactId>:<version>]  [(-o|--output) <output> | (-m|--modules)]  [--public]  (<class-name>...)   (-cp|--classpath) <classpath>... This optional parameter could be used to specify one or more comma-delimited classpaths for retrieving the required Java libraries needed by the bindgen tool execution. The classpath could be provided as comma-separated paths of JAR files or as comma-separated paths of directories containing all the relevant Java libraries. If the Ballerina bindings are to be generated from a standard Java library, from a library available inside the Ballerina SDK, or from a platform library specified in the Ballerina.toml, then you need not specify the classpath explicitly.  (-mvn|--maven) <groupId>:<artifactId>:<version> This optional parameter could be used to specify a Maven dependency required for the generation of the Ballerina bindings. Here, the specified library and its transitive dependencies will be resolved into the target/platform-libs directory of the package. If the tool is not executed inside a package or if the output path does not point to a package, the target/platform-libs directory structure will be created in the output path to store the Maven dependencies. The tool will also update the Ballerina.toml file with the platform libraries if the command is executed inside a Ballerina package.  (-o|--output) <output> This optional parameter could be used to specify the directory path to which the Ballerina bindings should be inserted. If this path is not specified, the output will be written to the same directory from which the command is run. You can point to the path of a Ballerina module to generate the code inside a Ballerina module.  (-m|--modules) This optional flag could be used to generate Ballerina module-level mappings for each Java package, instead of generating all the bindings inside the default module or a single output directory. If this flag is specified, all the generated Java class mappings belonging to a specific Java package will reside inside a separate module representing this Java package.  --public Set the visibility modifier of the generated binding objects to public. By default, the generated bindings will be module private.  <class-name>... One or more space-separated fully-qualified Java class names for which the Ballerina bridge code is to be generated. Please note that these class names should be provided at the end of the command.  Generated Bridge Code  When the tool is run, a .bal file will be created to represent each Java class. This would contain the respective Ballerina binding object along with the required Java interoperability mappings. These .bal files would reside inside sub directories representing the package structure.  Apart from creating bindings for the specified Java classes, the command will also generate empty Ballerina binding objects for the dependent Java classes. A Java class would be considered dependent if it is used inside one of the generated Ballerina binding objects.  A set of additional utility files will also be generated in order to support the auto-generated Ballerina bindings. This includes a Constants.bal file to store constants used for proper functioning of the Ballerina binding objects and .bal files to store the error types used within the Ballerina binding objects.  The generated bindings will be inside the specified output directory as follows.  <specified-output-dir>  ├── <class-name>.bal // generated classes  ├── ...  ├── <class-name>.bal // generated dependent classes  ├── ...  ├── <class-name>.bal // generated error types  ├── ...  └── Constants.bal   Java to Ballerina Mapping  Java Classes A Java class will be mapped to a Ballerina class. This Ballerina class will have the same name as the Java class.  E.g., The generated Ballerina class of the java.util.ArrayDeque class will be as follows. @java:Binding {  'class: \"java.util.ArrayDeque\" } class ArrayDeque {   *java:JObject;   function init(handle obj) {  self.jObj = obj;  }   ... };  If there are multiple classes with the same simple name, they need to be generated using a single execution. The tool will then apply a numerical identifier at the end of duplicated object names. This could be manually changed into something meaningful if required.  The format for specifying inner classes using the command is <package-name>.ClassName$InnerClassName. The dollar sign might have to be escaped using the backslash key.  E.g., The command to generate bindings for java.lang.Character.Subset class will be as follows. > bal bindgen java.lang.Character\\$Subset   When referring a Java code to figure out the imported classes, you should be cautious about the Java classes from the java.lang package since these will not be visible as imports in the Java code. However, you need not generate bindings for the java.lang.String class since it is mapped into the Ballerina string type from within the Ballerina bindings generated.  Constructors Constructors of Java classes will be mapped to functions outside the Ballerina object. These function names are comprised of the constructor name prefixed with the new keyword. If there are multiple constructors, they will be suffixed with an auto-incremented number.  E.g., Generated constructors of the java.util.ArrayDeque class will be as follows. function newArrayDeque1() returns ArrayDeque {  ... }  function newArrayDeque2(int arg0) returns ArrayDeque {  ... }  function newArrayDeque3(Collection arg0) returns ArrayDeque {  ... }   Methods All public methods will be exposed through Ballerina bindings. Instance methods will reside inside the Ballerina object and these would take the name of the Java method. However, if there are overloaded methods, a numeric suffix will be appended at the end of the name.  E.g., Some of the generated instance methods of the java.util.ArrayDeque class will be as follows. class ArrayDeque {  ...  function add(Object arg0) returns boolean {  ...  }   function isEmpty() returns boolean {  ...  } };  Static methods would reside outside the Ballerina object as functions, which take the name of the Java method with the Java class name appended at the beginning as a prefix.  E.g., A generated static method randomUUID() of the java.util.UUID class will be as follows. Here, the Ballerina equivalent of calling UUID.randomUUID() in Java will be UUID_randomUUID(). function UUID_randomUUID() returns UUID {  ... }   Fields All public fields of a Java class will be exposed through Ballerina bindings in the form of getters and setters. Instance fields will have the respective getter and setter functions inside the Ballerina object, whereas the static fields will have getter and setter functions outside the Ballerina object.  The getter and setter functions of an instance field will take the name of the field prefixed with a get or set at the beginning.  E.g., get<FIELD_NAME>() and set<FIELD_NAME>(<type> arg)  For a static field, the getter and setter (if the field is not final) functions will take the name of the field with a get or set prefix along with the Java simple class name appended at the beginning.  E.g., <Class_Name>_get<FIELD_NAME>() and <Class_Name>_set<FIELD_NAME>(<type> arg)  External Interop Functions These external interop functions are module private and they take the fully-qualified Java method name as the function it is calling. However, if overloaded methods exist, a numeric suffix will be appended at the end.  E.g., Generated external interop function for close() method of java.io.FileInputStream will be as follows. function java_io_FileInputStream_close(handle receiver) returns error? = @java:Method {  name: \"close\",  'class: \"java.io.FileInputStream\",  paramTypes: [] } external;   Dependency Objects When there are dependent Java classes present inside generated Ballerina bindings (as parameters or return types), the bindgen tool generates an empty Ballerina binding object to represent each one of these classes. This will represent a Java class mapping without the constructors, methods, or field bindings. If one of these classes is required later, the bindgen tool could be re-run to generate the Ballerina bindings.  E.g., The generated dependency object representing java.util.List will be as follows. public class List {  *JObject;  public function __init(handle obj) {  self.jObj = obj;  }   public function toString() returns string {  return java:jObjToString(self.jObj);  } };   Ballerina JObject A Ballerina binding class representing a Java class will always be implemented using the JObject abstract object. This is present inside the ballerina/jballerina.java module of the Ballerina standard library and could be accessed as java:JObject if the java module is imported into a package.  To explain the implementation further, this Ballerina object will always store the handle reference of the Java object in it’s jObj field.  public type JObject object {  public handle jObj; };   Java to Ballerina Type Mappings Generated Ballerina bindings will support the following type mappings between Java and Ballerina.   Ballerina primitive - Java primitive  Ballerina string type - Java String object  Ballerina binding objects - Java objects   The Ballerina binding objects will store a handle reference of the Java object using its jObj field. More details on the type mappings could be found in the section of this guide.  Support for Java Subtyping Ballerina bindings provide support for Java subtyping with the aid of structural typing in the language.  E.g., A Ballerina binding object mapping the java.io.FileInputStream Java class could be assigned to a Ballerina binding object mapping the java.io.InputStream as follows. InputStream inputStream = check newFileInputStream3(\"sample.txt\");     Note: For Java Subtyping to work, the Ballerina binding objects need to be fully implemented, it will not work with empty dependency objects.   Support for Java Casting The ballerina/jballerina.java module of the Ballerina standard library provides the cast function to support Java casting. This could be used to cast Ballerina binding objects into their subtypes based on assignability.  E.g., A Ballerina binding object instance mapping the java.io.InputStream Java class inputStream could be casted onto a Ballerina binding object mapping the java.io.FileInputStream Java class as follows. type FileInputStreamTypedesc typedesc<FileInputStream>; FileInputStream fileInputStream = <FileInputStream>check java:cast(inputStream, FileInputStreamTypedesc);   Java Exceptions to Ballerina Errors When generating Ballerina bindings, Java exceptions will be mapped onto Ballerina errors. They will have identical names as that of the corresponding Java exceptions and these will be generated inside the ballerina_bindings/utils/error_types directory. Instead of returning a generic error from the Java side, the bindings will return a more meaningful error representing the exact Java exception.  E.g., The following IOException will be returned from the read() function in the java.io.FileInputStream Ballerina binding object.  function read() returns int|IOException {  int|error externalObj = java_io_FileInputStream_read(self.jObj);  if (externalObj is error) {  IOException e = IOException(IOEXCEPTION, message = externalObj.message(), cause = externalObj);  return e;  } else {  return externalObj;  } }     Note: If a Java exception class is generated as a Ballerina binding object, it would follow the naming convention JException or JError. For instance, the binding object’s name for java.io.FileNotFoundException would be as JFileNotFoundException.   Packaging Java Libraries with Ballerina Programs    Note: This section assumes that you have already read .   When you compile a Ballerina program with bal build, the compiler creates an executable JAR file and when you compile a Ballerina module with bal build -c, the compiler creates a BALA file. In both cases, the Ballerina compiler produces self-contained archives. There are situations in which you need to package JAR files with these archives. The most common example would be packing the corresponding JDBC driver.  There are two kinds of Ballerina packages:   Produces executable programs  Contains a default root module and one or more Ballerina modules.  The default root module has a main method and/or one or more services.  Build the package with bal build.  Produces Ballerina library modules  Contains one or more Ballerina library modules with at least one exported module.  Build the modules with bal build -c.  Usually, the compiled library modules are pushed to Ballerina central.  How you package JAR files with compiled archives is the same in both kinds of packages. Therefore, a sample Ballerina package, which produces an executable is used here.  Here, is a Ballerina package layout of a microservice called “order management”. The module ordermgt - the root module - contains a RESTFul service, which exposes resource functions to create, retrieve, update, and cancel orders. The dbutils module offers utility functions, which use a MySQL database to store orders.  ordermgt_service/ ├── Ballerina.toml ├── main.bal └── javalibs/  └── mysql-connector-java-<version>.jar └── modules/  └── ordermgt/  └── dbutils/   The Java MySQL connector is placed inside the javalibs directory. You are free to store the JAR files anywhere in your file system. This example places those JAR files inside the package directory. As a best practice, maintain Java libraries inside the package. The Ballerina.toml file, which marks a directory as a Ballerina package lives at the root of the package. It is also a manifest file that contains package information, dependent Ballerina module information, and platform-specific library information. Java libraries are considered as platform-specific libraries. Here, is how you can specify a JAR file dependency in theBallerina.toml.  [[platform.java11.dependency]] # Absolute or relative path to the JAR file path = \"<path-to-jar-file-1>\" # A comma-separated list of Ballerina module names, which depends on this JAR modules = [\"<ballerina-module-1>\"]  [[platform.java11.dependency]] path = \"<path-to-jar-file-2>\" modules = [\"<ballerina-module-1>\",\"<ballerina-module-2>\"]   Alternatively, you can also specify Maven dependencies as platform-specific libraries. These dependencies specified would then get resolved into the target/platform-libs directory when building the package. You can specify a Maven dependency in the Ballerina.toml file as shown below.  [[platform.java11.dependency]] # A comma-separated list of Ballerina module names, which depends on this JAR modules = [\"<ballerina-module-1>\"] # Group ID of the Maven dependency groupId = \"<group-id>\" # Artifact ID of the Maven dependency artifactId = \"<artifact-id>\" # Version of the Maven dependency version = \"<version>\"  [[platform.java11.dependency]] modules = [\"<ballerina-module-1>\",\"<ballerina-module-2>\"] groupId = \"<group-id>\" artifactId = \"<artifact-id>\" version = \"<version>\"   If you wish to use a custom Maven repository, you can specify it in the Ballerina.toml file as shown below. [[platform.java11.repository]] id = \"<maven-repository-id>\" url = \"<maven-repository-url>\" username = \"<maven-repository-username>\" password = \"<maven-repository-password>\"   Now, let’s look at the contents of the Ballerina.toml file in this package. [[platform.java11.dependency]] path = \"./javalibs/mysql-connector-java-<version>.jar\" modules = [\"ordermgt\"]   Or, if you are adding it as a Maven dependency, it would take the following form. [[platform.java11.dependency]] modules = [\"ordermgt\"] groupId = \"mysql\" artifactId = \"mysql-connector-java\" version = \"<version>\"   If your package has only the default root module, then you can attach all the JAR file dependencies to your default root module as the best practice.  If your package is a Ballerina library package, then you should specify the JAR file dependencies in each Ballerina module if that module depends on the JAR file.  Now, use ballerina build ordermgt to build an executable JAR. This command packages all JARs specified in your Ballerina.toml with the executable JAR file.  Ballerina FFI Let’s look at the list of language features that enable Ballerina developers to call foreign code written in other programming languages. E.g., while the jBallerina compiler allows you to call any Java code, the nBallerina compiler will allow you to call any C Code.  The External Function Body Usually, the body or the implementation of a function is specified in the same source file. The part, which is enclosed by curly braces is called the function body.  function doSomething(int i) returns string { \t... }   Ballerina also allows you to define a function without a function body and marks it with the external keyword to express that the implementation is not provided by the Ballerina source file.  function doSomething(int i) returns string = external;   Now, let’s see how you can link this function with a foreign function.  import ballerina/jballerina.java;  function doSomething(int i) returns string = @java:Method { \tname: \"doSomethingInJava\" \t'class: \"a.b.c.Foo\" } external;   The @java:Method annotation instructs the jBallerina compiler to link with the doSomethingInJava static method in the Java class a.b.c.Foo. There are a set of annotations and other utilities available in the ballerina/jballerina.java module to make Java interoperability work. This guide covers most of them.  The Handle Type The handle type describes a reference to an externally-managed storage. These values can only be created by a Ballerina function with an external function body. Within the context of jBallerina, a handle type variable can refer to any Java reference type value: a Java object, an array, or the null value.  Consider the randomUUID method in the Java UUID class, which gives you a UUID object. This is the Java method signature.  static UUID randomUUID()   Here, is the corresponding Ballerina function that returns a value of the handle type.  import ballerina/jballerina.java;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  'class: \"java.util.UUID\" } external;   In Java, you can assign the null value to any variable of a reference type. Therefore, a handle type variable may also refer to the Java null.  The following section describes various aspects of Java interoperability in Ballerina. You can copy and paste the following examples into a .bal file and run it using the bal run <file_name.bal> command.  Calling Java Programs from Ballerina The following subsections explain how to call Java code from Ballerina.    Instantiating Java Classes Let’s look at how you can create Java objects in a Ballerina program. The @java:Constructor annotation instructs the compiler to link a Ballerina function with a Java constructor.  The ArrayDeque class in the java.util package has a default constructor. The following Ballerina code creates a new ArrayDeque object. As you can see, the newArrayDeque function is linked with the default constructor. This function returns a handle value and it refers the constructed ArrayDeque instance.  import ballerina/jballerina.java;  public function main() {  handle arrayDeque = newArrayDeque(); }  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;   You can also create a wrapper Ballerina class for Java classes as follows.  import ballerina/jballerina.java;  public function main() {  ArrayDeque ad = new; }  class ArrayDeque {  private handle jObj;   function __init(){  self.jObj = newArrayDeque(); } };  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;      Note: that these @java:* annotations cannot be attached to Ballerina object methods at the moment.   Dealing with Overloaded Constructors When there are two constructors with the same number of arguments available, you need to specify the exact constructor that you want to link with the Ballerina function. The ArrayDeque class contains three constructors and the last two are overloaded ones.  public ArrayDeque(); public ArrayDeque(int numElements); public ArrayDeque(Collection<? extends E> c);   Here, is the updated Ballerina code.  import ballerina/jballerina.java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function newArrayDequeWithSize(int numElements) returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\",  paramTypes: [\"int\"] } external;  function newArrayDequeWithCollection(handle c) returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\",  paramTypes: [\"java.util.Collection\"] } external;   The ‘paramTypes’ Field You can use the paramTypes field to resolve the exact overloaded method. This field is defined as follows.  # The `Class` type represents a fully-qualified Java class name. public type Class string;  # The `ArrayType` represents a Java array type. It is used to specify parameter # types in the `Constructor` and `Method` annotations. # # + class - Element class of the array type # + dimensions - Dimensions of the array type public type ArrayType record {|  Class class;  byte dimensions; |};  (Class | ArrayType)[] paramTypes?;   As per the above definition, paramTypes field takes an array of Java classes or array types. The following table contains more details.    Java Type  Description  Example  Primitive  The Java class name of a primitive type is the same as the name of the primitive type.  The boolean.class.getName() expression evaluates to “boolean”. Similarly, the int.class.getName() expression evaluates to “int”.  Class  Fully-qualified class name  “java.lang.String”  Array  Use the ArrayType record defined above to specify Java array types in overloaded methods.  Method signature: void append(boolean[] states, long l, String[][] args); The corresponding value of the paramField: paramField: [{class:”boolean”, dimensions: 1}, “long” {class:”java.lang.String”, dimensions: 2}]  For more details, look at the following example.  public Builder(Person[][] list, int index); public Builder(Student[][] list, int index);   Here, is the corresponding Ballerina code.  import ballerina/jballerina.java;  function builderWithPersonList(handle list, int index) returns handle = @java:Constructor {  'class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Person\", dimensions:2}, \"int\"] } external;  function builderWithStudentList(handle list, int index) returns handle = @java:Constructor {  'class: \"a.b.c.Builder\",  paramTypes: [{class: \"a.b.c.Student\", dimensions:2}, \"int\"] } external;   Calling Java Methods You can use the java:@Method annotation to link Ballerina functions with Java static and instance methods. There is a small but important difference in calling Java static methods vs calling instance methods.  Calling Static Methods Let’s first look at how to call a static method. The “java.util.UUID” class has a static method with the static UUID randomString() signature.  import ballerina/jballerina.java; import ballerina/io;  function randomUUID() returns handle = @java:Method {  name: \"randomUUID\",  'class: \"java.util.UUID\" } external;  public function main() {  handle uuid = randomUUID();  io:println(uuid); }   The name field is optional here. If the Ballerina function name is the same as the Java method name, you don’t have to specify the name field.  function randomUUID() returns handle = @java:Method {  'class: \"java.util.UUID\" } external;   Calling Instance Methods Now, let’s look at how to call Java instance methods using the same ArrayDeque class in the java.util package. It can be used as a stack with its pop and push instance methods with the following method signatures.  E pop(); void push(E e);   Here, are the corresponding Ballerina functions that are linked to these methods.  function pop(handle arrayDequeObj) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  function push(handle arrayDequeObj, handle e) = @java:Method {  'class: \"java.util.ArrayDeque\" } external; If you compare these functions with the Java method signatures, you would notice the additional handle arrayDequeObj parameter in Ballerina functions. Let’s look at a sample usage to understand the reason.  public function main() {  // Create a new instance of `ArrayDeque`.  handle arrayDequeObj = newArrayDeque();   // Convert a Ballerina string to a Java string.  string str = “Ballerina”  handle handleStr = java:fromString(str);   push(arrayDequeObj, handleStr);  handle e = pop(arrayDequeObj); }   As you can see, you need to first construct an instance of the ArrayDeque class. The arrayDequeObj variable refers to an ArrayDeque object. Then, you need to pass this variable to both the pop and push functions because the corresponding Java methods are instance methods of theArrayDeque class. Therefore, you need an instance of the ArrayDeque class in order to invoke its instance methods. You can think of the arrayDequeObj variable as the method receiver.  Calling Methods Asynchronously  Ballerina internally uses a fixed number of threads. Therefore, when calling a Java method, it should return in a reasonable time frame in order to avoid starvation in the Ballerina code execution.  If the given Java method executes a time consuming (i.e., blocking) task such as an IO operation, better to do that in a separate thread while yielding the original thread to continue the Ballerina code execution. In this case, Ballerina Scheduler needs to be informed that the work is being completed asynchronously by invoking the markAsync method in the BalEnv object. When the work is completed, the complete method has to be called with the return value.    Note: The original return value is ignored.  public static long getFileCountRecursively(BalEnv env, BString path) {  BalFuture balFuture = env.markAsync();  new Thread(() -> {  long result = // slow operation ;  balFuture.complete(result);  }).start(); // in a production system this can be a thread pool/nio pool  return -38263; // this value is ignored  }  public function getFileCountRecursively(string path) returns int = @java:Method {  'class:\"my/test/DirOperations\" } external;   Mapping Java Classes into Ballerina Objects The following pattern is useful if you want to present a clearer Ballerina API, which calls to the underneath Java code. This pattern creates wrapper Ballerina objects for each Java class that you want to expose via your API.  Imagine that you want to design an API to manipulate a stack of string values by using the Java ArrayDeque utility. You can create a Ballerina object type as follows.  public class StringStack {  private handle jObj;   public function __init() {  self.jObj = newArrayDeque();  }   public function push(string element) {  push(self.jObj, java:fromString(element));  }   public function pop() returns string {  handle handleEle = pop(self.jObj);  // Let's talk about error handling and null satefy later in this guide  // This example uses an empty string for now.  return java:toString(handleEle) ?: \"\";   } };  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  function push(handle receiver, handle element) = @java:Method {  'class: \"java.util.ArrayDeque\" } external;   This object presents a much clearer API compared to the previous API. Here, is a sample usage of this object.  public function main() {  StringStack stack = new();  stack.push(\"Ballerina\"); string element = stack.pop(); }   Calling Overloaded Java Methods The “Instantiate Java classes” section presents how to deal with overloaded constructors. You need to use the same approach to deal with overloaded Java methods. Let’s try to call the overloaded append methods in the `java.lang.StringBuffer class. Here, is a subset of those methods.  StringBuffer append(boolean b); StringBuffer append(int i); StringBuffer append(String str); StringBuffer append(StringBuffer sb); StringBuffer append(char[] str);   Here, is the set of Ballerina functions that are linked with the above Java methods. Notice the usage of the paramTypes annotation field. You can find more details of this field in the “Instantiate Java classes” section.  function appendBool(handle sbObj, boolean b) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"boolean\"],  'class: \"java.lang.StringBuffer\" } external;  function appendInt(handle sbObj, int i) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"int\"],  'class: \"java.lang.StringBuffer\" } external;  function appendCharArray(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [{class: \"char\", dimensions: 1}],  'class: \"java.lang.StringBuffer\" } external;  function appendString(handle sbObj, handle str) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.String\"],  'class: \"java.lang.StringBuffer\" } external;  function appendStringBuffer(handle sbObj, handle sb) returns handle = @java:Method {  name: \"append\",  paramTypes: [\"java.lang.StringBuffer\"],  'class: \"java.lang.StringBuffer\" } external;   Java Exceptions as Ballerina Errors A function call in Ballerina may complete abruptly by returning an error or by raising a panic. Panics are rare in Ballerina. The best practice is to handle errors in your normal control flow. Raising a panic is similar to throwing a Java exception. The trap action will stop a panic and give you the control back in Ballerina and the try-catch statement does the same in Java.  Errors in Ballerina belong to the built-int type error. The error type can be considered as a distinct type from all other types: The error type does not belong to the any type, which is the supertype of all other Ballerina types. Therefore, errors are explicit in Ballerina programs and it is almost impossible to ignore them. For more details, see BBEs.  How do Java exceptions are mapped to Ballerina errors? A Java function call may complete abruptly by throwing either a checked exception or an unchecked exception. Unchecked exceptions are usually not part of the Java method signature unlike the checked exceptions.  Java interoperability layer in Ballerina handles checked exceptions differently from unchecked exceptions as explained below. Java unchecked exceptions If the linked Java method throws an unchecked exception, then the corresponding Ballerina function will complete abruptly by raising a panic.  The following example tries to pop an element out of an empty queue. The pop method in the ArrayDeque class throws an unchecked java.util.NoSuchElementException exception in such cases. This exception will cause the Ballerina pop function to raise a panic.  import ballerina/jballerina.java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function pop(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = pop(arrayDeque); }   Here, is the output:  error: java.util.NoSuchElementException at array_deque:pop(array_deque.bal:65535)  array_deque:main(array_deque.bal:13)   You can use the trap action to stop the propagation of the panic and to get an error value.  public function main() {  handle arrayDeque = newArrayDeque();  handle | error element = trap pop(arrayDeque);  if element is error {  io:println(element.reason());  io:println(element.detail());  io:println(element.stackTrace().callStack);  } else {  // .....  } } Java Checked Exceptions Let’s see how you can call a Java method that throws a checked exception. As illustrated in the following example, the corresponding Ballerina function should have the error type as part of its return type.  The java.util.zip.ZipFile class is used to read entries in a ZIP file. There are many constructors in this class. Here, the constructor that takes the file name as an argument is used.  public ZipFile(String name) throws IOException   Since this Java constructor throws a checked exception, the newZipfile Ballerina function returns ZipFile instances or an error.  import ballerina/jballerina.java;  function newZipFile(handle filename) returns handle | error = @java:Constructor {  'class: \"java.util.zip.ZipFile\",  paramTypes: [\"java.lang.String\"] } external;  public function main() {  handle|error zipFile = newZipFile(java:fromString(\"some_file.zip\")); }   Mapping a Java Exception to a Ballerina Error Value Now, let’s briefly look at how a Java exception is converted to a Ballerina error value at runtime. A Ballerina error value contains three components: a reason, a detail, and stack trace.  The reason:   This is a string identifier for the error category.  In this case, the reason value is set to the fully-qualified Java class name of the exception.  Unchecked: Class name of of the thrown unchecked exception  Checked: Class name of the exception that is declared in the method signature  The detail:   The message field is set to e.getMessage().  The cause field is set to the Ballerina error that represents this Java exception’s cause.   Null Safety Ballerina provides strict null safety compared to Java with optional types. The Java null reference can be assigned to any reference type. However, in Ballerina, you cannot assign the nil value to a variable unless the variable’s type is an optional type.  As explained above, Ballerina handle values cannot be created in Ballerina code. They are created and returned by foreign functions and a variable of the handle type refers to a Java reference value. Since Java null is also a valid reference value, this variable can refer to a Java null value.  Let’s look at an example, which deals with Java null. The following code uses the peek method in the ArrayDeque class. Peek retrieves but does not remove the head of the queue or returns null if the queue is empty.  import ballerina/jballerina.java;  function newArrayDeque() returns handle = @java:Constructor {  'class: \"java.util.ArrayDeque\" } external;  function peek(handle receiver) returns handle = @java:Method {  'class: \"java.util.ArrayDeque\" } external;  // Linked with the `java.lang.Object.toString()` method in Java. function toString(handle objInstance) returns handle = @java:Method {  'class: \"java.lang.Object\" } external;  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque);  Handle str = toString(element); }   Since the queue is empty in this case, peek should return null i.e., element should refer to Java null. The output of this program will be as follows.   error: org.ballerinalang.jvm.values.ErrorValue message={ballerina}JavaNullReferenceError \tat array_deque:toString(array_deque.bal:19)  array_deque:main(array_deque.bal:27)   This is equivalent to a Java NPE. In such situations, you should check for null using the java:isNull() function. Here, is the modified example.  public function main() {  handle arrayDeque = newArrayDeque();  handle element = peek(arrayDeque); if java:isNull(element) {  // handle this case  } else {  handle str = toString(element);  } }   There are situations in which you need to pass a Java null to a method or store it in a data structure. In such situations, you can create a handle value that refers to a Java null as follows.  handle nullValue = java:createNull();   Mapping Java Types to Ballerina Types and Vice Versa Mapping Java Types to Ballerina Types The following table summarizes how Java types are mapped to corresponding Ballerina types. This is applicable when mapping a return type of a Java method to a Ballerina type.    Java type  Ballerina type  Notes  Any reference type including “null type”  handle  boolean  boolean  byte  byte, int, float  widening conversion when byte -> int and byte -> float  short  int, float  widening conversion  char  int, float  widening conversion  int  int, float  widening conversion  long  int, float  widening conversion when long -> float  float  float  widening conversion  double  float  Mapping Ballerina Types to Java Types The following table summarizes how Ballerina types are mapped to corresponding Java types. These rules are applicable when mapping a Ballerina function argument to a Java method/constructor parameter.    Ballerina type  Java type  Notes  handle  Any reference type  As specified by the Java method/constructor signature  boolean  boolean  byte  byte, short, char, int, long, float, double  Widening conversion from byte -> short, char, int, long, float, double  int  byte, char, short, int, long  Narrowing conversion when int -> byte, char, short, and int  float  byte, char, short, int, long, float, double  Narrowing conversion when float -> byte, char, short, int, long, float  string  io.ballerina.runtime.api.values.BString  xml  io.ballerina.runtime.api.values.BXml  array  io.ballerina.runtime.api.values.BArray  tuple  io.ballerina.runtime.api.values.BArray  map  io.ballerina.runtime.api.values.BMap  table  io.ballerina.runtime.api.values.BTable  stream  io.ballerina.runtime.api.values.BStream  object  io.ballerina.runtime.api.values.BObject  future  io.ballerina.runtime.api.values.BFuture  function  io.ballerina.runtime.api.values.BFunctionPointer  typedesc  io.ballerina.runtime.api.values.BTypedesc  error  io.ballerina.runtime.api.values.BError  Using Ballerina Arrays and Maps in Java There is no direct mapping between Ballerina arrays and maps to primitive Java arrays and maps. In order to facilitate the use of Ballerina arrays and maps in Java, the ballerina-runtime libraries have to be added as a dependency to the Java project and the relevant classes need to be imported from the ballerina-runtime library. You can find all the released versions of the ballerina-runtime library . The latest version of the dependency can be added to gradle using the following: repositories {  // Use WSO2's Nexus repository manager for resolving dependencies.  maven {  url = 'https://maven.wso2.org/nexus/content/repositories/releases/'  } }  dependencies {  // Add ballerina-runtime as dependency.  implementation 'org.ballerinalang:ballerina-runtime:+' }   Using Ballerina Arrays in Java To use Ballerina arrays in Java, the BArray interface has to be used. The example below illustrates how to write Java intreop code that uses Ballerina arrays. import io.ballerina.runtime.api.values.BArray;  public class ArrayReverse {  public static BArray arrayReverse(BArray arr) {  long len = arr.size();  for(long i = len - 1, j = 0; j < len/2; i--, j++) {  Object temp = arr.get(j);  arr.add(j, arr.get(i));  arr.add(i, temp);  }  return arr;  } }  Associated Ballerina code: import ballerina/io; import ballerina/jballerina.java;  public function main() {  int[] a = [1,2,3,4,5];  int[] b = arrayReverse(a);  io:println(b); }  function arrayReverse(int[] arr) returns int[] = @java:Method {  'class: \"javalibs.app.ArrayReverse\" } external;   Using Ballerina Maps in Java To use Ballerina maps in Java, the BMap interface has to be used. The example below illustrates how to write Java intreop code that uses Ballerina maps. import io.ballerina.runtime.api.values.BMap; import io.ballerina.runtime.api.values.BString;  import java.util.Map;  public class ModifyValues {  public static BMap<Object, Object> modifyMapValues(BMap<Object, Object> map) {  for(Map.Entry mapElement : map.entrySet()) {  BString key = (BString) mapElement.getKey();  long value = (long) mapElement.getValue();  long modifiedValue = value + 10;  map.put(key, modifiedValue);  }  return map;  } }  Associated Ballerina code: import ballerina/io; import ballerina/jballerina.java;  public function main() {  map<int> marks = {sam: 50, jon: 60};  map<int> modifiedMarks = modifyMapValues(marks);  io:println(modifiedMarks); }  function modifyMapValues(map<int> marks) returns map<int> = @java:Method {  'class: \"javalibs.app.ModifyValues\" } external;   Access or Mutate Java Fields The @java:FieldGet and @java:FieldSet annotations allow you to read and update the value of a Java static or instance field respectively. The most common use case is to read a value of a Java static constant.  import ballerina/jballerina.java;  public function pi() returns float = @java:FieldGet {  name:\"PI\",  'class:\"java/lang/Math\" } external;  public function main() {  float r = 4;  float l = 2 * pi() * r; }   In this example, the pi() function returns the value of the java.lang.Math.PI static field. This uses the annotation field name to specify the name of the field. Likewise, if you want to access an instance field, you need to pass the relevant object instance as discussed in the instance methods section.  The @java:FieldSet annotation has the same structure as the above.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/statements/","name":"Statements","summary":"The sections below include the coding conventions with respect to statements.Table of contents      Do’sDon’tsExample,Example,Example,If the pattern body is empty, then keep it as an empty block.Example,Example,This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If ...","content":"/  /  /  / Statements  Statements  The sections below include the coding conventions with respect to statements.  Table of contents If Statement    Always enclose the condition with parentheses in the If statement.   Do’s  if (true) {  ... } else if (false) {  ... }   Don’ts  if true {  ... } else if false {  ... }     Keep the else and else if keywords in the same line with the matching if or else if block’s closing brace separated only by a single space.   Empty block    Do not have any empty if, else if, or else blocks.  If empty, add an empty line between the opening and closing braces.   Example,  if (inProperSallaryRange) {  } else if (inSallaryRange) {  } else {  }   Match Statement  Match Patterns Clause    Block indent each pattern clause in its own line.  Keep a single space before and after the => sign.  If a pattern clause contains only one statement, place it in the same line as the pattern clause enclosing it with curly braces.   Example,  function foo(string|int|boolean a) returns string {  match a {  12 => {  return \"Value is '12'\";  }  }  return \"Value is 'Default'\"; }     If a pattern clause has more than one statement, block indent each statement in its own line.   Example,  match x {  var (s, i) if s is string => {  io:println(\"string\");  }  var (s, i) if s is int => {  io:println(\"int\");  } }     If the pattern body is empty, then keep it as an empty block.   Example,  match x {  var (s, i) if s is string => {}  var (s, i) if s is int => {} }   Transaction Statement    Start each optional clause (onretry, committed, and aborted) in the same line as the closing brace of the matching clause.  If transaction, onretry, committed, and aborted blocks are empty, add an empty line between the braces.   Example,  function func1() {  transaction with retries = 2 {  } onretry {  } aborted {  } committed {  } }     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/coding-conventions/top-level-definitions/","name":"Top-Level Definitions","summary":"The sections below include the coding conventions with respect to top-level definitions.Table of contents      Do’sDon’tsExample,Example,Example,Example,Example,Example,Example,Example,Block indent each of the field definitions (including the Rest field) in their own line.Example,Example,Example:\"Star\"\"Watch\"This website uses cookies so that we can provide you with the best user experience. Read our  to ...","content":"/  /  /  / Top-Level Definitions  Top-Level Definitions  The sections below include the coding conventions with respect to top-level definitions.  Table of contents General Practices    Do not indent the top-level definitions.   Do’s   import ballerina/http;  const int MIN_AGE = 20; int repetitions = 0;  service hello on ep1 {  ... }    Don’ts  // This import is indented correctly. import ballerina/http; const int MIN_AGE = 20; // Not indented correctly.  int repetitions = 0; // Not indented correctly.  // Not indented correctly. service hello on ep1 {  ...  }  Imports    Do not keep spaces between the organization name, divider /, and module name.   Example,  import ballerina/http;     Imports should be sorted alphabetically, first by the organization name and then by the module name.   Function Definition   Do not keep spaces between the function name and the open parentheses ( of the function signature.   Example,  function func1() { }     If the function needs to be split into new lines due to it exceeding the max line length,  can break lines from the parameter list by moving a parameter value only to a new line and indenting it with four spaces from the starting position of the function.  Example,  function getAddress(int value,  string name) returns (string|()) {  ... }     can break before the returns keyword and indent it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name)  returns (string|()) {  ... } can break after the returns keyword by moving the return value to a new line  and indenting it with four spaces from the starting position of the function.   Example,  function getAddress(int value, string name) returns  (string|()) {  ... } Service Definition    Keep the listener inline with the service signature.   Example,  service / on new http:Listener(9090) {  ... }     When formatting service-level function definitions, block indent each element and follow the .   Example,  import ballerina/http;  service / on new http:Listener(9090) {   resource function get greeting() returns string {  return \"Hello, World!\";  }  }     Block indent each function definition, resource definition, and field definition inside a service definition.   Class Definition    Block indent each field definition and each function definition on their own line.  Init function should be placed before all the other functions.  For function definitions in the class definition, follow the .   Example,  class Person {  public boolean isMarried = false;  int age;  string name;   function init(string name, int age = 0) {  self.age = age;  self.name = name;  }   function getName() returns string {  return self.name;  }   function setIsMarried(boolean isMarried) {  self.isMarried = isMarried;  }   function getIsMarried() returns boolean {  return self.isMarried;  } }   Record Definition Block indent each of the field definitions (including the Rest field) in their own line.  Example,  type Person record {  string name;  int...; }  // or  type Person record {|  int id;  string name; |}   Referencing Record or Object   Do not keep spaces between the *, the abstract object name, or the record name.   Example,  *Person;    Also, block-indent.   Example:  type UserId record {  string id = \"\"; };  type User record {  *UserId; // Reference to UserId record.  string name = \"john\";  int age = 20; };  // or type Person object {  string name;   // Object function definitions.  function getName() returns string; };  class Employee {  *Person; // Reference to Person object type.   function init() {  self.name = \"John Doe\";  }   function getName() returns string {  return self.name;  } }   \"Star\"\"Watch\"      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/configurability/defining-configurable-variables/","name":"Defining Configurable Variables","summary":"Ballerina supports configurability through the configurable, module-level variables.Table of contents      The configurable keyword is used to declare a configurable variable. The initialization of configurable variables can be done in the ways below.A configurable variable that is defined with ? as the initializer expression mandates a value to ...","content":"/  /  /  / Defining Configurable Variables  Defining Configurable Variables  Ballerina supports configurability through the configurable, module-level variables.  Table of contents Initialising Configurable Variables  The configurable keyword is used to declare a configurable variable. The initialization of configurable variables can be done in the ways below.    A configurable variable that is defined with ? as the initializer expression mandates a value to be specified through the configuration.   configurable string host = ?;   If a configurable variable is defined with any other initializer expression, the configuration of that variable is optional. The value provided in the initializer can be overridden by a value specified through the configuration.   configurable string host = “0.0.0.0”;   The values of configurable variables would always be a subtype of anydata. A configurable variable is implicitly final and cannot be assigned outside the declaration. The static type of the configurable variable is implicitly readonly. Therefore, it can always be referenced within an isolated function.  Providing Values to Configurable Variables  Ballerina supports providing the values for configurable variables through configuration files, command-line arguments, and environment variables. The precedence order for retrieving configurable values is as follows.    Tip: For more information on the methods below, see .   Using Command-Line Arguments  The module information of the configurable variable can be provided with command-line argument. For more information, see .  Using Configuration Files  The values can be provided through configuration files in the . The file location can be set through an environment variable with the name BAL_CONFIG_FILES. It is possible to specify multiple configuration files using the OS-specific separator. The file precedence order will be as specified in the environment variable. If an environment variable is not specified, it is located in the current working directory with the file name Config.toml.  Using Environment Variables  The values can be provided through an environment variable with the name BAL_CONFIG_DATA in which the content is expected to be in the .  Securing Sensitive Data Using Configurable Variables  A Ballerina runtime can be configured using configurable variables. For more details, see the .  Configuration values containing passwords or secrets should not be passed with the normal configuration.  Such sensitive data can be passed to runtime using a different TOML file, and you can prioritize it higher than the normal configuration by prefixing the file path in the BAL_CONFIG_FILES environment variable.  The configuration of sensitive data can be handled at the deployment of the Ballerina program.  For an example, in a Kubernetes environment, a Kubernetes secret can be used with a pod as files in a volume mounted on one or more of its containers or as container environment variables. The TOML file, which contains the sensitive data can be stored as a secret resource in Kubernetes and can be placed in a volume mount when running a pod. The file path can be specified via an .  Trying it Out  For an example on defining configurable variables in a Ballerina program, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/configurability/providing-values-to-configurable-variables/","name":"Providing Values to Configurable Variables","summary":"You can supply values to configurable variables using the methods below.Table of contents      The configurable variables can be defined in different modules. Therefore, it is necessary to provide the information of the module in which the variable is defined.Currently, TOML-based configuration is supported for configurable variables of ...","content":"/  /  /  / Providing Values to Configurable Variables  Providing Values to Configurable Variables  You can supply values to configurable variables using the methods below.  Table of contents Providing Through TOML Syntax  The configurable variables can be defined in different modules. Therefore, it is necessary to provide the information of the module in which the variable is defined.  Currently, TOML-based configuration is supported for configurable variables of int, float, boolean, string, decimal, enum, the arrays of the respective types, map, record, and table types.  The format below is used to provide the module information of a variable in the TOML-based configuration.  [org-name.module-name] variable-name = “value”   If the configurable variable is defined in the root module of the program, the org-name and module-name are optional. If the configurable variable is defined in the root package of the program, the org-name is considered optional.  The module name headers are not needed for single bal file execution.  For example, if a configurable variable foo is defined in a single bal file, it should be provided in the Config.toml as follows.  foo = “value”   Mapping of the Types  The mapping of Ballerina types to TOML types is given below.    Ballerina Type  Ballerina Example  TOML Type  TOML Example  int, byte  configurable byte age = ?; configurable int port = ?;  Integer  age = 25 port = 9090  string  configurable string name = ?; String  name = “John”  float, decimal  configurable float height = ?; configurable decimal salary = ?; Float  height = 5.6 salary = 50500.65 `  boolean  configurable boolean isAdmin = ?;  Boolean  isAdmin = true  enum  enum Country { LK = \"Sri Lanka\" , US = \"United States\" } configurable Country country = ?;  String  country = “Sri Lanka”  int[] , byte[]  configurable int[] ports = ?;  Array of integers  ports = [9090, 9091]  string[]  configurable string[] colors = ?;  Array of strings  colors = [“Red”, “Green”, “Blue”]  float[], decimal[]  configurable float[] rates = ?;  Array of floats  rates = [55.4, 76.3, 38.5]  boolean[]  configurable boolean[] switches = ?;  Array of booleans  switches = [false, false, true]  map  configurable map < string > person = ?;  TOML table  [person] name = “Anna” city = “London”  map[]  configurable map < string >[] people = ?;  Array of TOML tables  [[people]] name = “John” city = “Paris” [[people]] name = “Jack” city = “Colombo”  record  type Person record { string name; int age; }; configurable Person person = ?;  TOML table  [person] name = “John”</br> age = 45</br>  record[]  type Person record { string name; int age; }; configurable Person[] people = ?;  Array of TOML tables  [[people]] name = “John” age = 45 [[people]] name = “Jack” age = 32  table  configurable table < map < string >> users = ?;  Array of TOML tables  [[users]] name = \"Tom\" occupation = \"Software Engineer\" [[users]] name = \"Harry\" occupation = \"Doctor\"  Providing Through Command-Line Arguments  The values of the variables can be provided through the command-line parameters in the format below,  -Ckey=value   The key of a CLI parameter can be specified as shown below.  key:= [[org-name .] module-name .] variable   Similar to the , the module information of the configurable variable can be provided with the command-line argument in the above format.  The configurable value provided through a command-line argument should be the toString() representation of the intended value. A command-line based configuration is only supported for configurable variables of types int, float, boolean, string, decimal, enum and xml.  For an example on defining configurables in a Ballerina program, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/configurability/trying-it-out/","name":"Trying it Out","summary":"The example below demonstrates how to use configurable variables inside a Ballerina project.Table of contents      Follow the steps below to create the Ballerina package.Execute the command below to create a Ballerina package.Navigate to the created userPortal directory, and execute the command below to add a module.Replace the ...","content":"/  /  /  / Trying it Out  Trying it Out  The example below demonstrates how to use configurable variables inside a Ballerina project.  Table of contents Creating the Ballerina Package  Follow the steps below to create the Ballerina package.    Execute the command below to create a Ballerina package.   bal new userPortal  Navigate to the created userPortal directory, and execute the command below to add a module.   bal add users  Replace the content of the main.bal file with the content below.   import ballerina/io;  import ballerina/log;  import userPortal.users;  configurable string url = ?;  configurable int[] ports = [9090];  public function main() {  io:println(\"Page URL : \", url);  io:println(\"Available ports : \", ports);  io:println(\"Admin : \", users:getAdminUser());  table<users:UserInfo> key(username) userTable = users:getUsers();  io:println(\"Other users : \", userTable );  if(userTable.length() > 2) {  log:printError(\"Maximum number of users is 2\");  }  }   Copy the content below to the users.bal file.   public type UserInfo record {|  readonly string username;  int age;  |};  public type UserTable table<UserInfo> key(username);  configurable UserInfo admin = ?;  configurable UserTable users = ?;  public function getAdminUser() returns UserInfo {  return admin;  }  public function getUsers() returns UserTable {  return users;  }   Create a file named Config.toml with the content below in the package root directory to provide the values through the configuration file.   url = \"http://google.com\"  ports = [9090, 9091, 9092]  [userPortal.users.admin]  username = \"Bob\"  age = 25  [[userPortal.users.users]]  username = \"John\"  age = 56  [[userPortal.users.users]]  username = \"Tom\"  age = 14  [[userPortal.users.users]]  username = \"Anna\"  age = 27  [ballerina.log]  format = \"json\"  Note: The values for the url and port variables are given without a module-name header as those variables are defined in the userPortal root module.  Similarly, the admin and users variables are defined in a userPortal.users non-root module . Therefore, they are provided with the module-name prefix as userPortal.users. Also, the project uses a ballerina/log imported module, which contains a configurable variable format, which is configured in the Config.toml file. As ballerina/log is neither the root module nor from the root package, it is provided with its org-name and module-name as a ballerina.log prefix.   The created package will have the structure below.   .  └── userPortal  ├── Ballerina.toml  ├── Config.toml  ├── main.bal  └── modules  └── users  └── users.bal   Running the Ballerina Package  Follow the steps below to run the Ballerina package you created above.    Execute the command below to build an executable of the package.  bal build  The output will be as shown below.   Compiling source  sample/userPortal:0.1.0   Generating executable  target/bin/userPortal.jar  Execute the command below to run the program.   bal run target/bin/userPortal.jar  The output will be as shown below.   Page URL : http://google.com  Available ports : [9090,9091,9092]  Admin : {\"username\":\"Bob\",\"age\":25}  Other users : [{\"username\":\"John\",\"age\":56},{\"username\":\"Tom\",\"age\":14},{\"username\":\"Anna\",\"age\":27}]  {\"time\":\"2021-05-25T14:01:27.948+05:30\", \"level\":\"ERROR\", \"module\":\"sample/userPortal\", \"message\":\"Maximum number of users is 2\"}  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/data-and-events-processing/using-language-integrated-queries/","name":"Using Language-Integrated Queries","summary":"Language integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. The sections below will explore Ballerina’s first-class support for writing queries that process data with examples.Table of contents      As ...","content":"/  /  /  / Using Language-Integrated Queries  Using Language-Integrated Queries  Language integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. The sections below will explore Ballerina’s first-class support for writing queries that process data with examples.  Table of contents Using Language-Integrated Queries  As of now, language-integrated queries are supported for iterator implementations such as an array, map, stream, and table. The two kinds of integrated queries below can be written in Ballerina.    Query Expressions  Query expressions allow you to generate a list, table, string, or XML. The sections below include the clauses you can use in a query expression.  Query Clauses  Query expressions contain a set of clauses similar to SQL to process the data. They must start with the from clause and can perform various operations such as filter, join, sort, limit, and projection. There are various SQL-like clauses to perform these operations.  ‘From’ Clause  The from clause is used to define the input iterator source that is considered for processing the data. Similar to the for each statement, you can specify any iterator as the expression.  List as the Input  In the example below, the studentList variable is a list iterator.  Student s1 = { firstName: \"Michelle\", lastName: \"Sadler\", intakeYear: 1990,  gpa: 3.5 }; Student s2 = { firstName: \"Ranjan\", lastName: \"Fonseka\", intakeYear: 2001,  gpa: 1.9 };  Student[] studentList = [s1, s2]; string[] studentNames = from Student student in studentList  select student.firstName + \" \" + student.lastName;   Stream as the Input  In the example below, the numberStream variable is a stream iterator.  NumberGenerator numGen = new; var numberStream = new stream<int, error>(numGen);  var oddNumberList = from var num in numberStream  where (num % 2 == 1)  select num;   It is also possible to have more than one from clause as shown below. In the example below, each person value in the personList joins with each department value in the deptList similar to a nested query for each statement.  Person[] personList = [p1, p2, p3]; Department[] deptList = [d1, d2];  Person[] outputPersonList =  from var person in personList  from var dept in deptList  where person.firstName == \"Alex\"  where person.deptAccess == \"XYZ\"  select {  firstName: person.firstName,  lastName: person.lastName,  deptAccess: dept.name  };     Info: Similar to list and stream, you can use all kinds of iterators as the input in the from clause.   ‘Where’ Clause  The where clause allows you to filter by a condition. You can define any conditional expression, which returns a boolean.  Filtering with a Simple Equal Check  The example below has a simple filter condition that performs an equality check.  Person[] outputPersonList =  from var { firstName: fName, lastName: lName, deptAccess: dept } in personList  where dept == \"Human Resource\"  select {  firstName: fName,  lastName: lName,  deptAccess: \"HR\"  };   Filtering with Multiple Conditions  The example below has a where clause with complex conditional expressions that contain logical operators, equality, and range checks.  Student[] outputStudentList =  from var student in studentList  where student.firstName == \"Ranjan\" || student.firstName == \"Alex\" && student.score >= 82.5  select {  firstName: student.firstName,  lastName: student.lastName,  score: student.score  };   Filtering with Multiple Where Clauses  The example below has multiple where clauses defined in the query expression. This is similar to the filtering conditions with a logical && operator.  Person[] outputPersonList =  from var person in personList  from var dept in deptList  where person.firstName == \"Alex\"  where person.deptAccess == \"XYZ\"  select {  firstName: person.firstName,  lastName: person.lastName,  deptAccess: dept.name  };  ‘Let’ Clause  The let clause allows you to define variables that can be used only within the query expression scope. These variables cannot be accessed out of the query expression.  Defining Multiple Variables  The example below defines one or more variables in the let clause and uses them within query expressions.  Person[] outputPersonList =  from var person in personList  let string depName = \"WSO2\", string replaceName = \"Alexander\"  select {  firstName: replaceName,  lastName: person.lastName,  deptAccess: depName  };   Also, the example below uses multiple let clauses to define multiple variables.   Person[] outputPersonList =  from var person in personList  let string depName = \"WSO2\"  let string replaceName = \"Alexander\"  where person.deptAccess == \"XYZ\" && person.firstName == \"Alex\"  select {  firstName: replaceName,  lastName: person.lastName,  deptAccess: depName  };   ‘Join’ Clause  A join clause performs an inner or left outer equijoin. In the join clause, there are two input iterators. During the joining process, each value of an iterator is matched against all the values in the other iterator based on the given condition, and the output values are generated for all the matching event pairs. Therefore, you can only perform equality checks as the joining condition.  Inner Join Clause  The example below joins two lists based on a join condition, which is an equality check. This is an inner join and if there are no matching values, then, there won’t be any output generated from the join operation.   PersonInfo[] personInfoList =  from var person in personList  join Department dept in deptList  on person.id equals dept.id  select {  fname : person.fname,  lname : person.lname,  dept : dept.name  };   Left Outer Join Clause  The example below performs a left outer join between the two input iterator lists. The key difference of the outer join compared to the inner join is even there are no matching values in the other list as per the joining condition, unavailable values are marked as nil.  PersonInfo[] personInfoList =  from var person in personList  outer join Department dept in deptList  on person.id equals dept.id  select {  fname : person.fname,  lname : person.lname,  dept : dept.name  };   ‘Order by` Clause  The order by clause allows ordering the results in an ascending and/or descending order based on the specified attributes. Ordering will be done in an ascending manner by default.  You can use the descending keyword to order in a descending manner. The attributes that are considered for order by operations are order-keys, which should be ordered types.  In the example below, the studentList input iterator list is ordered according to the first name in descending order. You can define more than one order key in the order by clause and it is possible to have more than one order clause.  Student[] orderedStudentList = from var student in studentList  order by student.fname descending  select student; ‘Limit` Clause  The limit clause limits the number of frames/values emitted by a query pipeline. You should define an integer value to specify the number of output values.  The outputPersonList in the example below contains four values because the query expression limits the output values to four.  Person[] outputPersonList =  from var person in personList  limit 4  select {  firstName: person.firstName,  lastName: person.lastName,  age: person.age  };   ‘Select` Clause  The select clause is mandatory in query expressions that are used for projection. You can use this clause to create values required to generate iterators such as list, table, XML, string, and stream.  List as an Output  The select clause of the example below creates a record that allows generating a list as an output.  Report[] reportList = from var student in studentList  where student.gpa >= 2.0  select {  name: student.firstName + \" \" + student.lastName,  degree: student.degreeName,  graduationYear: student.graduationYear  };   XML as an Output  The select clause in the example below is evaluated for each iteration. The emitted values are concatenated to form the XML result.  xml students = from var studentName in school/<student>/<firstName>  limit 2  select <xml> studentName; Stream as an Output  The result of the query expression is a stream (reportStream), of which the members are the result of the select clause.  The example below defines the stream keyword in the query to generate the output as a stream.  stream<Report> reportStream = stream from var student in studentList  where student.gpa >= 2.0  select {  name: student.firstName + \" \" + student.lastName,  degree: student.degreeName,  graduationYear: student.graduationYear  }; String as an Output  The values emitted from the select clause are concatenated to get the string result of the query statement.  In the example below, the students variable is the concatenated string of the query expression results.  string students = from var student in studentList  where student.gpa >= 2.0  select student.firstName + \" \" + student.lastName + \"\\n\";   Table as an Output  In the example below, the query expression starts with a table keyword. The key(id) key specifier specifies the key sequence of the constructed table. The result of the query expression is a table. During the construction of a table, each value emitted from the select clause is added as a new member.  ReportTable|error reportTable =  table key(id) from var student in studentList  where student.gpa >= 2.0  let string degreeName = \"Bachelor of Medicine\",  int graduationYear = calGraduationYear(student.intakeYear)  select {  id: student.id,  name: student.firstName + \" \" + student.lastName,  degree: degreeName,  graduationYear: graduationYear  };   ‘On Conflict’ Clause  An on conflict clause is only allowed for a query expression, which constructs a table with a key sequence. The expression is evaluated when the select clause emits a value that conflicts with a previous value, in the sense that both values have the same key value in the table.  The on conflict clause of the example below gets executed when select emits a row that has the same key as a row that it emitted earlier. It gives an onConflictError error if there is a key conflict.  ReportTable|error result =  table key(id) from var student in duplicateStdList  select {  id: student.id,  name: student.firstName + \" \" + student.lastName,  degree: \"Bachelor of Medicine\",  graduationYear: calGraduationYear(student.intakeYear)  }  on conflict onConflictError;   Query Actions  Query actions are executed in the same way as the clauses in a query expression. However, it does not generate an output such as a list. Rather, it executes a set of defined statements. The block inside the do clause is executed in each iteration.  The below is an example of a query action.  var x = from var person in personList  from var dept in deptList  let string hrDepartment = \"Human Resource\"  do {  if(dept.name == \"HR\") {  Employee employee = {firstName: person.firstName, lastName: person.lastName, deptAccess: hrDepartment};  employeeList[employeeList.length()] = employee;  }  };   Writing an Integrated Query  Follow the steps below to write an integrated query related to an online product order use case. The code snippets in each step denote how some operations are performed.    Create the HTTP service below from which you can request the product details.     Info: The payload is a JSON array that represents the product details.   import ballerina/http;  service /emart on new http:Listener(9090) {  resource function post orderProduct(@http:Payload {} Product[] products) {  …  }  }     Manipulate the product details array (iterator) using query expressions to find the price of each product in the iterator. As per the query, you only consider the grocery products. In this process, there is a join with the table, which contains the product prices.   ProductAmount[] output = from var product in products  where product.Category == \"Grocery\"  join var priceInfo in priceInfoTable  on product.Id equals priceInfo.Id order by product.Name ascending select {  ShoppingCardId: product.ShoppingCardId,  Name: product.Name,  TotalAmount: product.Quantity * priceInfo.Price  };     Use the integrated query below to calculate the total bill amount.    var result = from var productAmount in output  do {  totalBillAmount = totalBillAmount + productAmount.TotalAmount; }; Send the total bill amount as a response to the HTTP request made.   http:Response res = new; res.setPayload(\"Order is accepted, Total grocery bill amount is \" + var result = caller->respond(res);   The below is the complete Ballerina code for writing the integrated query for the online product order use case above.  import ballerina/http; import ballerina/io;  type Product record {  string Name;  int Id;  int Quantity;  string ShoppingCardId;  string Category; };  type PriceInfo record {  int Id;  float Price; };  type ProductAmount record {  string ShoppingCardId;  string Name;  float TotalAmount; };  table<PriceInfo> priceInfoTable = loadPriceInfo();  service /emart on new http:Listener(9090) {  resource function post orderProduct(@http:Payload {} Product[] products) returns string {  ProductAmount[] output = from var product in products  where product.Category == \"Grocery\"  join var priceInfo in priceInfoTable  on product.Id equals priceInfo.Id  order by product.Name ascending select {  ShoppingCardId: product.ShoppingCardId,  Name: product.Name,  TotalAmount: product.Quantity * priceInfo.Price  };  float totalBillAmount = 0;  var result = from var productAmount in output  do {  totalBillAmount = totalBillAmount + productAmount.TotalAmount; };  io:println(output);  return string `Order is accepted; total grocery bill amount is + ${totalBillAmount}`;  } }  function loadPriceInfo() returns table<PriceInfo> {  table<PriceInfo> productDetails = table [{Id: 2345, Price: 120.00},  {Id: 3256, Price: 23.00}];  return productDetails; }   Trying it Out  Follow the steps below to try out the above language integrated query example.    Ballerina.  Copy the Ballerina code above and create an order_service.bal file.  Execute the command below to start the HTTP service, which accepts product order requests.  bal run order_service.bal     Execute the command below to invoke the HTTP service by sending the product order details in the payload.   curl -v http://localhost:9090/emart/orderProduct -d '[{ \"Name\": \"Flour\", \"Id\": 2345, \"Quantity\": 2, \"ShoppingCardId\": \"AXYN34523\", \"Category\": \"Grocery\"}, { \"Name\": \"Carrot\", \"Id\": 3234, \"Quantity\": 1, \"ShoppingCardId\": \"AXYN34523\", \"Category\": \"Vegetable\"}]' -H \"Content-Type:application/json\"   You will receive a response like below that gives the total grocery bill amount.  Order is accepted; total grocery bill amount is + 240.0     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/deployment/aws-lambda/","name":"AWS Lambda","summary":"The AWS Lambda extension provides the functionality to expose a Ballerina function as an AWS Lambda function.Table of contents      Exposing a Ballerina function as an AWS Lambda function is done by importing the ballerinax/awslambda module and simply annotating the Ballerina function with the awslambda:Function annotation. Also, the ...","content":"/  /  /  / AWS Lambda  AWS Lambda  The AWS Lambda extension provides the functionality to expose a Ballerina function as an AWS Lambda function.  Table of contents Exposing a Ballerina function as an AWS Lambda function is done by importing the ballerinax/awslambda module and simply annotating the Ballerina function with the awslambda:Function annotation. Also, the Ballerina function must have the following signature: function (awslambda:Context, json) returns json|error.  Writing a Function  The following Ballerina code gives an example on how to expose a function in AWS Lambda, which generates a SHA256 hash from the given input.  import ballerinax/awslambda; import ballerina/crypto;  @awslambda:Function public function hash(awslambda:Context ctx, json input) returns json|error {  return crypto:hashSha256(input.toJsonString().toBytes()).toBase16(); }   The first parameter with the object contains the information and operations related to the current function execution in AWS Lambda such as the request ID and the remaining execution time.  The second parameter with the json value contains the input request data. This input value format will vary depending on the source, which invoked the function (e.g., an AWS S3 bucket update event). The return type of the function is json|error, which means in a successful scenario, the function can return a json value with the response, or else in an error situation, the function will return an error value, which provides information on the error to the system.  Building the Function  The AWS Lambda functionality is implemented as a compiler extension. Thus, the artifact generation happens automatically when you build a Ballerina module.  Execute the command below to build the above code.  bal build functions.bal You view the output below.  Compiling source \tfunctions.bal  Generating executables \tfunctions.jar \t@awslambda:Function: hash   Run the following command to deploy each Ballerina AWS Lambda function:  aws lambda create-function --function-name $FUNCTION_NAME --zip-file fileb:///aws-ballerina-lambda-functions.zip --handler functions.$FUNCTION_NAME --runtime provided --role $LAMBDA_ROLE_ARN --layers arn:aws:lambda:$REGION_ID:134633749276:layer:ballerina-jre11:6 --memory-size 512 --timeout 10   Run the following command to re-deploy an updated Ballerina AWS Lambda function:  aws lambda update-function-code --function-name $FUNCTION_NAME --zip-file fileb://aws-ballerina-lambda-functions.zip  functions.jar   Deploying the Function  Ballerina’s AWS Lambda functionality is implemented as a custom AWS Lambda layer. As shown in the above instructions output, this information is provided when the function is created. The compiler generates the aws-ballerina-lambda-functions.zip file, which encapsulates all the AWS Lambda functions that are generated. This ZIP file can be used with the AWS web console, or the to deploy the functions. An for the user must be created with the AWSLambdaBasicExecutionRole permission in order to deploy the AWS Lambda functions. The created AWS Lambda Role ARN is required when deploying the functions through the CLI.  Execute the command below to deploy the hash function as an AWS Lambda is shown below.    Info: You need to change the memory size and timeout in the command below according to your application requirements. If not, the default values will be applied.   aws lambda create-function --function-name hash --zip-file fileb://aws-ballerina-lambda-functions.zip --handler functions.hash --runtime provided --role arn:aws:iam::908363916138:role/lambda-role --layers arn:aws:lambda:us-west-1:134633749276:layer:ballerina-jre11:6   You view the output below.  {  \"FunctionName\": \"hash\",  \"FunctionArn\": \"arn:aws:lambda:us-west-1:908363916138:functions:hash\",  \"Runtime\": \"provided\",  \"Role\": \"arn:aws:iam::908363916138:role/lambda-role\",  \"Handler\": \"functions.hash\",  \"CodeSize\": 22160569,  \"Description\": \"\",  \"Timeout\": 3,  \"MemorySize\": 128,  \"LastModified\": \"2020-07-14T06:54:41.647+0000\",  \"CodeSha256\": \"zXHpr2VC8Anauvox1dD8MichiH/55wKkY7RtaUe21dM=\",  \"Version\": \"$LATEST\",  \"TracingConfig\": {  \"Mode\": \"PassThrough\"  },  \"RevisionId\": \"d5400f01-f3b8-478b-9269-73c44f4537aa\",  \"Layers\": [  {  \"Arn\": \"arn:aws:lambda:us-west-1:134633749276:layer:ballerina-jre11:6\",  \"CodeSize\": 697  }  ] }   Invoking the Function  Execute the command below to test the deployed AWS Lambda function by invoking it directly using the CLI.    Info: The payload should be a valid JSON object.   echo '{\"x\":5}' > input.json   You view the output below.  aws lambda invoke --function-name hash --payload fileb://input.json response.txt {  \"StatusCode\": 200,  \"ExecutedVersion\": \"$LATEST\" }   Execute the command below to view the response in the response.txt file.  cat response.txt You view the output below.  \"dd9446a11b2021b753a5df48d11f339055375b59cd81d7559d36b652aaff849d\"   What’s Next?  In a more practical scenario, the AWS Lambda functions will be used by associating them to an external event source such as Amazon DynamoDB or Amazon SQS. For more information on this, go to .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/deployment/azure-functions/","name":"Azure Functions","summary":"The Azure Functions extension provides the functionality to expose a Ballerina function as a serverless function in the Azure Functions platform.Table of contents      This is done by importing the ballerinax/azure.functions module and simply annotating the Ballerina function with the functions:Function annotation.An Azure Function consists of a trigger ...","content":"/  /  /  / Azure Functions  Azure Functions  The Azure Functions extension provides the functionality to expose a Ballerina function as a serverless function in the Azure Functions platform.  Table of contents This is done by importing the ballerinax/azure.functions module and simply annotating the Ballerina function with the functions:Function annotation.  Triggers and Bindings  An Azure Function consists of a trigger and optional bindings. A trigger defines how a function is invoked. A binding is an approach in which you can declaratively connect other resources to the function. There are input and output bindings. An input binding is a source of data into the function. An output binding allows to output data from the function out to an external resource. For more information, go to .  The following Azure Functions triggers and bindings are currently supported in Ballerina:   HTTP and binding  Queue and binding  Blob , binding, and binding  Twilio SMS binding  CosmosDB , binding, and binding  Timer Writing a Function  The following Ballerina code gives an example of using an HTTP trigger to invoke the function, a queue output binding to write an entry to a queue, and also an HTTP output binding to respond back to the caller with a message.  import ballerinax/azure_functions as af;  @af:Function public function fromHttpToQueue(af:Context ctx, @af:HTTPTrigger { authLevel: \"anonymous\" } af:HTTPRequest req, @af:QueueOutput { queueName: \"queue1\" } af:StringOutputBinding msg) returns @af:HTTPOutput af:HTTPBinding {  msg.value = req.body;  return { statusCode: 200, payload: \"Request: \" + req.toString() }; }   The first parameter with the object contains the information and operations related to the current function execution in Azure Functions such as the execution metadata and logging actions to be used by the function. This parameter is optional and can exist at any position in the function’s parameter list. The second parameter with the HTTPTrigger annotation signals that this function is going to have an HTTP trigger and that its details should be stored in the given HTTPRequest value. Then, you declare that you will have a queue output binding by using the QueueOutput annotation with a string result by defining a StringOutputBinding parameter. Also, you declare an HTTP output binding by annotating the HTTPBinding return type with the HTTPOutput annotation. This HTTP output binding can also be defined as a parameter with the same annotation. In this manner, you can mix and match any combination of triggers and input/output bindings with or without the execution context object when defining an Azure Function.  Building the Function  The Azure Functions functionality is implemented as a compiler extension. Thus, the artifact generation happens automatically when you build a Ballerina module. Let’s see how this works by building the above code.  $ bal build functions.bal Compiling source \tfunctions.bal  Generating executables \tfunctions.jar \t@azure.functions:Function: fromHttpToQueue  \tRun the following command to deploy Ballerina Azure Functions: \taz functionapp deployment source config-zip -g <resource_group> -n <function_app_name> --src azure-functions.zip   Deploying the Function  In order to deploy a Ballerina function in Azure Functions, the following prerequisites must be met.    Create an Azure with the given resource group with the following requirements:  Runtime stack - Java 11  Hosting operating system - Windows (default; Linux is not supported in Azure for custom handlers at the moment)  Install the The created resource group and the function app name should be provided to the placeholders shown in the above-generated usage instructions from the compiler.  A custom file for the Azure Functions deployment can be optionally provided by placing a host.json file in the current working directory in which the Ballerina build is done. The required host.json properties are provided/overridden by the values derived from the source code by the compiler extension.  A sample execution to deploy the functions to Azure Functions is shown below.  $ az functionapp deployment source config-zip -g functions1777 -n functions1777 --src azure-functions.zip Getting scm site credentials for zip deployment Starting zip deployment. This operation can take a while to complete ... Deployment endpoint responded with status code 202 {  \"active\": false,  \"author\": \"N/A\",  \"author_email\": \"N/A\",  \"complete\": true,  \"deployer\": \"ZipDeploy\",  \"end_time\": \"2020-07-15T07:32:35.5311903Z\",  \"id\": \"e56a20038b864c5c8432aa7d1c26bfbd\",  \"is_readonly\": true,  \"is_temp\": false,  \"last_success_end_time\": \"2020-07-15T07:32:35.5311903Z\",  \"log_url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest/log\",  \"message\": \"Created via a push deployment\",  \"progress\": \"\",  \"provisioningState\": null,  \"received_time\": \"2020-07-15T07:32:21.9780071Z\",  \"site_name\": \"functions1777\",  \"start_time\": \"2020-07-15T07:32:23.2044517Z\",  \"status\": 4,  \"status_text\": \"\",  \"url\": \"https://functions1777.scm.azurewebsites.net/api/deployments/latest\" }   Invoking the Function  The deployed Azure Function can be tested by invoking it using an HTTP client such as CURL:  $ curl -d \"Hello!\" https://functions1777.azurewebsites.net/api/fromHttpToQueue Request: url=https://functions1777.azurewebsites.net/api/fromHttpToQueue method=POST query= headers=Accept=*/* Connection=Keep-Alive Content-Length=6 Content-Type=application/x-www-form-urlencoded Host=functions1777.azurewebsites.net Max-Forwards=9 User-Agent=curl/7.64.0 X-WAWS-Unencoded-URL=/api/fromHttpToQueue CLIENT-IP=10.0.128.31:47794 X-ARR-LOG-ID=c905b483-af19-4cf2-9ce0-0741e5998a98 X-SITE-DEPLOYMENT-ID=functions1777 WAS-DEFAULT-HOSTNAME=functions1777.azurewebsites.net X-Original-URL=/api/fromHttpToQueue X-Forwarded-For=45.30.94.9:47450 X-ARR-SSL=2048|256|C=US, S=Washington, L=Redmond, O=Microsoft Corporation, OU=Microsoft IT, CN=Microsoft IT TLS CA 5|CN=*.azurewebsites.net X-Forwarded-Proto=https X-AppService-Proto=https X-Forwarded-TlsVersion=1.2 DISGUISED-HOST=functions1777.azurewebsites.net params= identities=[{\"AuthenticationType\":null,\"IsAuthenticated\":false,\"Actor\":null,\"BootstrapContext\":null,\"Claims\":[],\"Label\":null,\"Name\":null,\"NameClaimType\":\"http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name\",\"RoleClaimType\":\"http://schemas.microsoft.com/ws/2008/06/identity/claims/role\"}] body=Hello!     Note: Additionally, when you are using CosmosDB, follow the steps below to configure the connection string of the database manually via the connectionStringSetting field.  Click the Keys tab of the Cosmos DB page.  Copy the value of the PRIMARY CONNECTION STRING.  Click the Configuration tab of the Function App page.  Select New Application Setting and paste the data you copied above as the value. For the key, use the value of the connectionStringSetting key.  Example application setting is as follows. Name - `CosmosDBConnection` Value - `AccountEndpoint=https://db-cosmos.documents.azure.com:443/;AccountKey=12345asda;`   What’s Next?  For a full sample with all the supported Azure Functions triggers and bindings in Ballerina, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/deployment/code-to-cloud/","name":"Code to Cloud","summary":"Ballerina Code to Cloud is designed to allow developers to write code without thinking about the deployment platform.Table of contents      This greatly simplifies the experience of developing and deploying Ballerina code in the cloud. It also enables using cloud native technologies easily without in-depth knowledge.As of now, ...","content":"/  /  /  / Code to Cloud  Code to Cloud  Ballerina Code to Cloud is designed to allow developers to write code without thinking about the deployment platform.  Table of contents This greatly simplifies the experience of developing and deploying Ballerina code in the cloud. It also enables using cloud native technologies easily without in-depth knowledge.  As of now, Ballerina code to cloud supports generating the deployment artifacts of the platforms below.    Docker  Kubernetes   Setting Up the Prerequisites    You need to have Docker installed and configured in your machine.  You need to have kubectl installed and configured in a Kubernetes cluster in order to deploy.   How Code to Cloud Works  Code to cloud builds the containers and required artifacts by deriving the required values from the code. This process happens when the package is being compiled. In order to override the default values given by the compiler, the Cloud.toml file needs to be created in the package directory.  Package Layout  Ballerina encourages to have one microservice per package. In order to adhere to that rule, code to cloud generates only one container per package. These artifacts can be found in the target directory of the package. A complete representation of the package layout is as follows.  ├── Cloud.toml ├── Ballerina.lock ├── Ballerina.toml ├── entry.bal └── target  ├── bala  │ └── module-0.0.1.bala  ├── bin  │ └── <module>.jar  ├── docker  │ └── Dockerfile └── kubernetes  └── <module>-0.0.1.yaml Cloud.toml  The configuration file to be used to override the default values generated by code to cloud.    Note: The Cloud.toml file is completely optional and you only have to specify the values you need to override. If the value is not specified for a certain field, the compiler will take the default value. All the supported properties can be found .   Ballerina.toml  Contains metadata about the Ballerina package. This file is used to fetch defaults for deployment artifacts generation.   Note: The Ballerina.toml file can be used to specify the build option.  [build-options] cloud = \"k8s\" # cloud = \"docker\"  entry.bal  Represents any .bal file that has an entry point. The compiler will be using this file to retrieve service-related information for the deployment artifacts.  target/docker/  Contains the Docker artifacts generated by code to cloud. These artifacts will be required to build the Docker image.  target/kubernetes/  Contains the Kubernetes artifacts generated by code to cloud. These artifacts will be required to deploy the Ballerina application in Kubernetes.  Properties of the ‘Cloud.toml’ File  [container.image]  Contains container image related properties.    Identifier  Description  Default Value  name  Name of the container image  $USER-$MODULE_NAME  repository  Container repository to host the container  ””  tag  Tag of the container  “latest”  base  Base container of the container image  “ballerina/jre11:v1”  cmd  Docker cmd to be executed  “CMD java -Xdiag -cp ‘${APP}:jars/*’ ‘$_init’”  [container.image.user]  Container image user account related properties.    Identifier  Description  Default Value  run_as  Name of the container image  “ballerina”  [[container.copy.files]] Copy files to the Docker container.    Identifier  Description  Default Value  sourceFile  Source file path  ””  target  Target file path in container  ””  [[cloud.config.envs]]  Contains the environment variables required for the application.    Identifier  Description  Example Value  key_ref  Key of the environment variable  “FOO”  name(optional)  Name of the env if its different from the key  “foo”  config_name  Name of the config map  “module-foo”  [[cloud.config.secrets]]  Contains the secrets required for the application.    Identifier  Description  Example Value  key_ref  Reference key of the secret  “MYSQL_ROOT_PASSWORD”  name(optional)  Name of the secret if its different from the key  “ROOT_PASSWORD”  secret_name  Name of the secret group  “db-credential-secret”  [[cloud.config.files]]  Contains the external configuration files for the code.    Identifier  Description  Example Value  file  Path of the external configuration file  “resource/ballerina.conf”  mount_path  Path of the configuration file in the container  “/home/ballerina/foo/ballerina.conf”  [cloud.deployment]  Contains the properties related to the deployment.    Identifier  Description  Default Value  internal_domain_name  Name of the internal domain  $MODULE_NAME  external_accessible  Status of exposing the container outside the cluster  true  min_memory  Minimum memory allocated to the container  “100Mi”  max_memory  Maximum memory allocated to the container  “256Mi”  min_cpu  Minimum CPU allocated to the container  “1000m”  max_cpu  Maximum CPU allocated to the container  “1500m”  [cloud.deployment.autoscaling]  Contains the matrices to auto-scale the container.    Identifier  Description  Default Value  enable  Status of autoscaling  true  min_replicas  Minimum number of replicas of the container alive at a given time  2  max_replicas  Maximum number of replicas of the container alive at a given time  3  cpu  CPU utilization threshold for spawning a new instance  50  memory  Memory utilization threshold for spawning a new instance  80  [cloud.deployment.probes.readiness]  Probe to indicate whether the container is running. No liveness probe will be generated if this property is not specified.    Identifier  Description  Example Value  port  Port of the readiness probe endpoint  9091  path  Endpoint of the readiness probe  “/readyz”  [cloud.deployment.probes.liveness]  Probe to indicate whether the container is running. No liveness probe will be generated if this property is not specified.    Identifier  Description  Example Value  port  Port of the liveness probe endpoint  9091  path  Endpoint of the liveness probe  “/healthz”  [[cloud.deployment.storage.volumes]]  Contains the volume definitions of the application. No default volumes will be generated if this property is not specified.    Identifier  Description  Example Value  name  Name of the volume  “volume1”  local_path  Path of the volume  “files”  size  Maximum size of the volume  “2Gi”  Code to Cloud Samples  For sample use cases of code to cloud, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/deployment/code-to-cloud/samples/","name":"Samples","summary":"The below are a few sample use cases of Ballerina code to cloud.Table of contents      Execute the bal new hello command to create a new package named hello.Replace the content of the /hello/main.bal file with the content below.Note: All the other code is not related to Docker ...","content":"/  /  /  /  / Samples  Samples  The below are a few sample use cases of Ballerina code to cloud.  Table of contents Hello World Sample  Creating the Ballerina Package    Execute the bal new hello command to create a new package named hello.  Replace the content of the /hello/main.bal file with the content below.   Note: All the other code is not related to Docker or Kubernetes and those are completely focused on the business logic.  main.bal   import ballerina/http;   listener http:Listener helloEP = new(9090);   service /helloWorld on helloEP {  resource function get sayHello() retunrs string { return \"Hello, World from service helloWorld ! \"; }  }   Create a file named Cloud.toml in the package directory and add the content below.   Cloud.toml   [container.image]  repository=\"wso2inc\"  name=\"hello\"  tag=\"v0.1.0\"  Generating the Artifacts  Execute the bal build --cloud=k8s command to build the Ballerina package and you view the output below. The --cloud=docker option will build only Docker artifacts. Optionally, the build option can be added to the Ballerina.toml file as below.  [build-options] cloud = \"k8s\"   $> bal build --cloud=k8s Compiling source  wso2/hello:0.1.0  Creating the BALA file  target/bala/hello-2020r2-any-0.1.0.bala  Running Tests   wso2/hello:0.1.0  No tests found   Generating executables  target/bin/hello.jar  Generating artifacts...   @kubernetes:Service - complete 1/1  @kubernetes:Deployment - complete 1/1  @kubernetes:HPA - complete 1/1  @kubernetes:Docker - complete 2/2  Execute the below command to deploy the Kubernetes artifacts: kubectl apply -f /home/wso2/test/c2c-slp5/target/kubernetes/hello  Execute the below command to access service via NodePort: kubectl expose deployment wso2-hello-0--deployment --type=NodePort --name=wso2-hello-0--svc-local     Note: Before deploying the application, let’s observe the artifacts below that are generated. Note the values such as port number, base images, container image name. All these values are derived from the code.   target/docker/hello/Dockerfile  # Auto Generated Dockerfile FROM ballerina/jre11:v1  LABEL maintainer=\"dev@ballerina.io\"  WORKDIR /home/ballerina COPY ballerina-crypto-1.0.1.jar /home/ballerina/jars/ COPY ballerina-rt-2.0.0-Preview5.jar /home/ballerina/jars/ COPY io-native-0.5.1.jar /home/ballerina/jars/ COPY wso2-hello-0.1.0.jar /home/ballerina/jars/ …  RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*  COPY wso2-hello-0.1.0.jar /home/ballerina  EXPOSE 9090 USER ballerina  CMD java -Xdiag -cp \"wso2-hello-0.1.0.jar:jars/*\" 'wso2/hello/0_1_0/$_init'   target/kubernetes/hello/wso2-hello-0.1.0.yaml  --- apiVersion: \"v1\" kind: \"Service\" metadata:  labels:  app: \"wso2-hello-0.1.0\"  name: \"helloep-svc\" spec:  ports:  - name: \"http-helloep-sv\"  port: 9090  protocol: \"TCP\"  targetPort: 9090  selector:  app: \"wso2-hello-0.1.0\"  type: \"ClusterIP\" --- apiVersion: \"apps/v1\" kind: \"Deployment\" metadata:  labels:  app: \"wso2-hello-0.1.0\"  name: \"wso2-hello-0--deployment\" spec:  replicas: 1  selector:  matchLabels:  app: \"wso2-hello-0.1.0\"  template:  metadata:  labels:  app: \"wso2-hello-0.1.0\"  spec:  containers:  - image: \"wso2inc/hello:v0.1.0\"  imagePullPolicy: \"IfNotPresent\"  lifecycle:  preStop:  exec:  command:  - \"sleep\"  - \"15\"  name: \"wso2-hello-0--deployment\"  ports:  - containerPort: 9090  name: \"http-helloep-sv\"  protocol: \"TCP\"  resources:  limits:  memory: \"256Mi\"  cpu: \"500m\"  requests:  memory: \"100Mi\"  cpu: \"200m\"  nodeSelector: {} --- apiVersion: \"autoscaling/v2beta2\" kind: \"HorizontalPodAutoscaler\" metadata:  labels:  app: \"wso2-hello-0.1.0\"  name: \"wso2-hello-0--hpa\" spec:  maxReplicas: 2  metrics:  - resource:  name: \"cpu\"  target:  averageUtilization: 50  type: \"Utilization\"  type: \"Resource\"  minReplicas: 1  scaleTargetRef:  apiVersion: \"apps/v1\"  kind: \"Deployment\"  name: \"wso2-hello-0--deployment\"   Executing the Docker Image  Follow the steps below to execute the Docker image separately.    Execute the docker images command to verify if the Docker image is generated.   REPOSITORY TAG IMAGE ID CREATED SIZE  wso2inc/hello v0.1.0 60d95f0928b2 About a minute ago 228MB  Execute the docker run -d -p 9090:9090 wso2inc/hello:v0.1.0 command to run the generated Docker image.   c04194eb0b4d0d78cbc8ca55e0527d381d8ab4a1a68f8ea5dd3770a0845d5fbb  Execute the curl http://localhost:9090/helloWorld/sayHello command to access the service.   Hello, World from service helloWorld!  Executing the Kubernetes Service  Follow the steps below to execute the Kubernetes service.    Execute the kubectl apply -f /home/wso2/test/c2c-slp5/target/kubernetes/hello command to execute the service.   service/helloep-svc created  deployment.apps/wso2-hello-0--deployment created  horizontalpodautoscaler.autoscaling/wso2-hello-0--hpa created  Execute the kubectl get pods command to verify the Kubernetes pods.   NAME READY STATUS RESTARTS AGE  wso2-hello-0--deployment-7d4d56457b-7jlzx 1/1 Running 0 57s  Execute the kubectl expose deployment wso2-hello-0--deployment --type=NodePort --name=wso2-hello-0--svc-local command to expose the service via NodePort to test in the developer environment.   service/wso2-hello-0--svc-local exposed  Execute the kubectl get svc command to get the IP address and port of the Kubernetes service.   NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE  wso2-hello-0--svc-local NodePort 10.111.61.112 <none> 9090:32437/TCP 4m17s  Tip: If you are using Minikube, execute the minikube ip command to get the IP address.  192.168.49.2  Execute the curl http://192.168.49.2:32437/helloWorld/sayHello command to access the deployed service via cURL.   Hello, World from service helloWorld!  Resource Limits and Auto Scaling Sample  This sample focuses on setting up resource limits and auto-scaling for the generated container. When you specify a resource limit for a container, the kubelet enforces those limits so that the running container is not allowed to use more of that resource than the limit you set.  Auto-scaling policies allow the container to scale seamlessly without overloading a single container. Code to cloud generates artifacts required for the orchestrator to limit the resources taken from one container. It also generates auto-scaling artifacts to smoothly scale when containers are overloaded. Code to cloud sets the default values for these configurations. You can find those values under the . These values will be overridden in this example.  Creating the Ballerina Package    Execute the ballerina new scaling command to create a new package named scaling.  Replace the content of the /scaling/main.bal file with the content below.   main.bal   import ballerina/http;   listener http:Listener helloEP = new(9090);   service /helloWorld on helloEP {  resource function get sayHello() returns string { return \"Hello, World from service helloWorld ! \";  }  }   Create a file named Cloud.toml in the package directory and add the content below.   Cloud.toml   [container.image]  repository=\"wso2inc\"  name=\"scaling-sample\"  tag=\"v0.1.0\"   [cloud.deployment]  min_memory=\"100Mi\" max_memory=\"256Mi\" min_cpu=\"1000m\" max_cpu=\"1500m\" [cloud.deployment.autoscaling]  min_replicas=2  max_replicas=5  cpu=60  memory=80  Generating the Artifacts  Execute the bal build --cloud=k8s command to build the Ballerina package and you view the output below.  Compiling source  wso2/scaling:0.1.0  Creating the BALA file  target/bala/scaling-2020r2-any-0.1.0.bala  Running Tests   wso2/scaling:0.1.0  No tests found   Generating executables  target/bin/scaling.jar  Generating artifacts...   @kubernetes:Service - complete 1/1  @kubernetes:Deployment - complete 1/1  @kubernetes:HPA - complete 1/1  @kubernetes:Docker - complete 2/2 Execute the below command to deploy the Kubernetes artifacts: kubectl apply -f /home/wso2/test/scaling-sample/target/kubernetes/scaling   Execute the below command to access service via NodePort: kubectl expose deployment wso2-scaling--deployment --type=NodePort --name=wso2-scaling--svc-local     Note: The code of this sample is identical to the . The only difference is the contents of the Cloud.toml file. Therefore, the behavior of the application in this sample is also identical to the . The difference is the generated artifacts of Docker and Kubernetes. Let’s observe the artifacts below generated by building the package.   target/docker/scaling/Dockerfile  # Auto Generated Dockerfile FROM ballerina/jre11:v1  LABEL maintainer=\"dev@ballerina.io\"  WORKDIR /home/ballerina  COPY ballerina-crypto-1.0.1.jar /home/ballerina/jars/ COPY mime-native-1.0.1.jar /home/ballerina/jars/ COPY ballerina-rt-2.0.0-Preview5.jar /home/ballerina/jars/ COPY wso2-scaling-0.1.0.jar /home/ballerina/jars/ RUN addgroup troupe \\  && adduser -S -s /bin/bash -g 'ballerina' -G troupe -D ballerina \\  && apk add --update --no-cache bash \\  && chown -R ballerina:troupe /usr/bin/java \\  && rm -rf /var/cache/apk/*  COPY wso2-scaling-0.1.0.jar /home/ballerina  EXPOSE 9090 USER ballerina  CMD java -Xdiag -cp \"wso2-scaling-0.1.0.jar:jars/*\" 'wso2/scaling/0_1_0/$_init'   target/kubernetes/scaling/wso2-scaling-0.1.0.yaml  --- apiVersion: \"v1\" kind: \"Service\" metadata:  labels:  app: \"wso2-scaling-0.1.0\"  name: \"helloep-svc\" spec:  ports:  - name: \"http-helloep-sv\"  port: 9090  protocol: \"TCP\"  targetPort: 9090  selector:  app: \"wso2-scaling-0.1.0\"  type: \"ClusterIP\" --- apiVersion: \"apps/v1\" kind: \"Deployment\" metadata:  labels:  app: \"wso2-scaling-0.1.0\"  name: \"wso2-scaling--deployment\" spec:  replicas: 1  selector:  matchLabels:  app: \"wso2-scaling-0.1.0\"  template:  metadata:  labels:  app: \"wso2-scaling-0.1.0\"  spec:  containers:  - image: \"wso2inc/scaling-sample:v0.1.0\"  imagePullPolicy: \"IfNotPresent\"  lifecycle:  preStop:  exec:  command:  - \"sleep\"  - \"15\"  name: \"wso2-scaling--deployment\"  ports:  - containerPort: 9090  name: \"http-helloep-sv\"  protocol: \"TCP\"  resources:  limits:  memory: \"256Mi\"  cpu: \"1500m\"  requests:  memory: \"100Mi\"  cpu: \"1000m\"  nodeSelector: {} --- apiVersion: \"autoscaling/v2beta2\" kind: \"HorizontalPodAutoscaler\" metadata:  labels:  app: \"wso2-scaling-0.1.0\"  name: \"wso2-scaling--hpa\" spec:  maxReplicas: 5  metrics:  - resource:  name: \"cpu\"  target:  averageUtilization: 60  type: \"Utilization\"  type: \"Resource\"  minReplicas: 2  scaleTargetRef:  apiVersion: \"apps/v1\"  kind: \"Deployment\"  name: \"wso2-scaling--deployment\"    Note: The auto-scaling and resource limits specified in the Cloud.toml file are reflected in the kubernetes artifacts above.  Executing the Kubernetes Service  Follow the steps below to deploy the generated Kubernetes artifacts directly.    Execute the kubectl apply -f /home/wso2/test/c2c-slp5/target/kubernetes/scaling command to execute the service.   service/helloep-svc created  deployment.apps/wso2-scaling-0--deployment created  horizontalpodautoscaler.autoscaling/wso2-scaling-0--hpa created  Execute the kubectl get pods command to verify the Kubernetes pods.   NAME READY STATUS RESTARTS AGE  wso2-scaling-0--deployment-7d4d56457b-7jlzx 1/1 Running 0 57s  Execute the kubectl expose deployment wso2-scaling-0--deployment --type=NodePort --name=wso2-scaling-0--svc-local command to expose the service via NodePort to test in the developer environment.   service/wso2-scaling-0--svc-local exposed  Execute the kubectl get svc command to get the IP address and port of the Kubernetes service.   NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE  wso2-scaling-0--svc-local NodePort 10.111.61.112 <none> 9090:32437/TCP 4m17s  Tip: If you are using Minikube, execute the minikube ip command to get the IP address.  192.168.49.2  Execute the curl http://192.168.49.2:32437/helloWorld/sayHello command to access the deployed service via cURL.   Hello, World from service helloWorld!  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/documenting-ballerina-code/","name":"Documenting Ballerina Code","summary":"Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.Table of contents      Developers can write the documentation in line with the Ballerina source ...","content":"/  /  / Documenting Ballerina Code  Documenting Ballerina Code  Ballerina has a built-in Ballerina Flavored Markdown (BFM) documentation framework named Docerina. The documentation framework allows you to write unstructured documents with a bit of structure to enable generating HTML content as API documentation.  Table of contents Generating Documentation for Modules  Developers can write the documentation in line with the Ballerina source code using the lightweight markup language. They can document special constructs such as parameters, return values, fields, etc. within the code using documentation attributes. Once the code is documented, developers can generate a basic HTML version of their Ballerina modules using the bal doc command. Developers are encouraged to have their custom themes and styles, to have a standard presentation of their Ballerina documentation.  Ballerina documentation design and usage is aligned with the package and module semantics of Ballerina. You can generate documentation for modules using the bal doc command.    Ballerina programmers can place the documentation inline with the source code using the documentation syntax.  Ballerina type definitions, global variables, annotations, listeners, etc. can be documented using the documentation syntax.  Fields, parameters, return values, etc. can be marked using documentation attributes.  HTML documents can be generated using the bal doc command for each Ballerina module and if you have custom handlebars templates, you can use them to generate the HTMLs.   Writing Ballerina Documentation  Ballerina Flavored Markdown documentation is a first-class syntax in the Ballerina language. The # at the beginning of a line denotes a line of documentation. If necessary, you can have multiple lines of documentation, which you can group together.  # <documentation line 1> # <documentation line 2> # ...   When you write documentation, you can use the markdown documentation syntax given above. For example,  # Provides the HTTP actions for interacting with an HTTP server. Apart from the standard # HTTP methods, `forward()` and `execute()` functions are provided. # ...   The supported structure of documentation syntax is as follows:  # <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + <parameter_name/field_name> - <description_line_1> # <description_line_2> # ... # + return - <return_parameter_description_line_1> # <return_parameter_description_line_2>     Tip: Always, add a full stop at the end of a function description. However, for the parameter and return type descriptions, omit the full stop if you have only one sentence. If there are multiple sentences, add the full stop at the end of each sentence. For example,   # Description of the function. # # + i - One sentence only # + s - Sentence one. Sentence two. # + return - Return description public function foo(int i, string s) returns boolean {  return true; }   Sample Usage  # Submits an HTTP request to a service with the specified HTTP verb. # The `submit()` function does not give out a `Response` as the result, # rather it returns an `HttpFuture`, which can be used to do further # interactions with the endpoint. # # Example: # ```ballerina # HttpFuture future = myMsg.submit(\"GET\", \"/test\", req); # ``` # # + httpVerb - The HTTP verb value # + path - The resource path # + request - An HTTP outbound request message # + return - An `HttpFuture` that represents an asynchronous service invocation # or an `error` if the submission fails public function submit(@sensitive string httpVerb, string path, Request request) returns HttpFuture|error;   Documenting a Module  A Ballerina module can have a Module.md file, which describes the module and its usage.  A typical package structure of a Ballerina package is like this:  /  Ballerina.toml # Configuration, which defines the package intent.  main.bal  Module.md # Contains descriptive metadata of the default module to be displayed in  # Ballerina Central. This is optional.  Package.md # Contains descriptive metadata of the package to be displayed in  # Ballerina Central. This is optional.  modules  module1/ Module.md # Contains descriptive metadata to be displayed in  # Ballerina Central. This is optional.  *.bal  [tests/] # Module-specific unit and integration tests  [resources/] # Module-specific resources   module2/  Module.md  *.bal  [tests/]  [resources/]   [resources/] # Resources included in every module in the package.   target/ # Compiled executables and other artifacts end up here   The bal doc command will read the Package.md and Module.md files and prepend them to the generated HTML file.  Check for sample HTML that has Module.md content at the top, followed by the other module constructs.  Generating Ballerina Documentation  Ballerina provides a doc command, which can be executed against a given Ballerina package. This command will result in generating the Ballerina documentation as HTML files for all the modules in the package.  First, let’s create a new Ballerina package:  $ bal new math Created new Ballerina package 'math' at math   Next, move into the package directory and execute bal add <module-name> to add a new Ballerina module.  $ cd math/ $ bal add world Added new ballerina module at 'modules/world'. $ tree . ├── Ballerina.toml ├── main.bal └── modules  └── world  └── world.bal  2 directories, 3 files  Now, let’s add a function to the math module to be documented. Copy and paste the following code into the math/main.bal file.  # Calculates the value of the 'a' raised to the power of 'b'. # ```ballerina # float aPowerB = math:pow(3.2, 2.4); # ``` # # + a - Base value # + b - Exponential value # + return - Calculated exponential value public isolated function pow(float a, float b) returns float {  return 0; }  Add the following class definition to the world module. Copy and paste the following code in to the math/modules/world/world.bal file.  # Represents a person object. # # + name - Name of the person # + age - Age of the person in years # + address - Address of the person # + wealth - Account balance of the person public class Person {  public string name = \"\";  public int age = 0;  public string address = \"\";  public float wealth = 0;   # Gets invoked to initialize the `Person` object.  #  # + name - Name of the person for the constructor  # + age - Age of the person for the constructor  public function init(string name, int age) {  }   # Get the address of the person.  #  # + return - New address of the person  public function getAddress() returns string {  return self.address ;  }   # Add the wealth of the person.  #  # + amt - Amount to be added  # + rate - Interest rate  public function addWealth(int[] amt, float rate=1.5) {  } }  Now, let’s generate documentation of the package: $ bal doc  Output: Compiling source \tuser/math:0.1.0 Generating API Documentation Saved to: target/apidocs   target/apidocs/math folder would contain the following; $ ls target/apidocs/ bundle.js index.html ...     index.html - the entry point for documentation   For other options, run bal doc --help.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/getting-started/building-from-source/","name":"Building from Source","summary":"The sections below will guide you to build and use the basic Ballerina runtime build and also the complete Ballerina distribution build.Table of contents      Follow the steps below to set up the prerequisites.Download and  OpenJDK 11 ( or any other OpenJDK distribution).Info: You can also use ...","content":"/  /  /  / Building from Source  Building from Source  The sections below will guide you to build and use the basic Ballerina runtime build and also the complete Ballerina distribution build.  Table of contents Setting up the Prerequisites  Follow the steps below to set up the prerequisites.    Download and OpenJDK 11 ( or any other OpenJDK distribution).   Info: You can also use .  Set up a for your GitHub account and configure the following environment variables (the access token should have the read package permission).   For Unix/macOS:   export packageUser=\"<YOUR_GITHUB_USERNAME>\";  export packagePAT=\"<YOUR_PERSONAL_ACCESS_TOKEN>\";  For Windows:   set packageUser=<YOUR_GITHUB_USERNAME>  set packagePAT=<YOUR_PERSONAL_ACCESS_TOKEN>  Building the Ballerina Runtime with the Tools  Follow the steps below to build the Ballerina runtime with the corresponding tools.    Fork the to your GitHub account and execute following command to clone it.   git clone --recursive https://github.com/<GITHUB_USERNAME>/ballerina-lang.git  Navigate to the <BALLERINA_LANG_PROJECT> directory, and execute the command below to update the Git submodules.   git submodule update --init  Execute one of the commands below to start the build process.   For Unix/macOS:   ./gradlew clean build  For Windows:   gradlew clean build  Extract the built Ballerina Language distribution (i.e., the <BALLERINA_LANG_PROJECT>/distribution/zip/jballerina-tools/build/distributions/jballerina-tools-<VERSION>.zip file) to a preferred location.  Configure the environment variables below.   For Unix/macOS:   # Set up the `BALLERINA_HOME` environment variable.  export BALLERINA_HOME=\"<YOUR_LOCATION>/jballerina-tools-<VERSION>\";   # Include the binaries to the system `PATH`.  PATH=$BALLERINA_HOME/bin:$PATH;  export PATH;  For Windows:   # Set up the `BALLERINA_HOME` environment variable.  set BALLERINA_HOME=\"<YOUR_LOCATION>\\jballerina-tools-<VERSION>\";   # Include the binaries to the system `PATH`.  set PATH=%PATH%;%BALLERINA_HOME%\\bin;  Testing the Runtime Build  Since this runtime build is just a plain Ballerina language build, you only have the basic language features and JBallerina Java (Java Introp) API in it.  Therefore, follow the steps below to write a basic Ballerina program using only those functionalities to test the runtime build.    Create a hello_world.bal file with the code below.   import ballerina/jballerina.java;   public function main(string... args) {  var systemOut = out();  println(systemOut, java:fromString(\"Hello, World!\"));  }   // Retrieves the current System output stream  public function out() returns handle = @java:FieldGet {  name: \"out\",  'class: \"java.lang.System\"  } external;   // Calls `println` method of the `PrintStream`  function println(handle receiver, handle message) = @java:Method {  paramTypes: [\"java.lang.String\"],  'class: \"java.io.PrintStream\"  } external;   Execute the command below to build and run this program.   bal run hello_world.bal  If your build is successful, you view the output below.   Hello, World!  Building the Complete Ballerina Distribution  With the , you will not get access to the Ballerina Standard Library Packages, which is one of the main features of Ballerina.  Therefore, follow the steps below to build the as well (to get full access to the complete Ballerina distribution).    Fork the ballerina-distribution repository to your GitHub account and execute following command to clone it.   git clone --recursive https://github.com/<GITHUB_USERNAME>/ballerina-distribution.git  Navigate to the <BALLERINA_DISTRIBUTION_PROJECT> directory, and execute the command below to start the build (here, the tests are excluded to speed up the build).   For Unix/macOS:   ./gradlew clean build -x test  For Windows:   gradlew clean build -x test  Extract the built Ballerina Language distribution (i.e., the <BALLERINA_DISTRIBUTION_PROJECT>/ballerina/build/distributions/ballerina-<VERSION>.zip file) to a preferred location.  Configure the environment variables below.   For Unix/macOS:   # Set up the `BALLERINA_HOME` environment variable.  export BALLERINA_HOME=\"<YOUR_LOCATION>/ballerina-<VERSION>\";   # Include the binaries to the system `PATH`.  PATH=$BALLERINA_HOME/bin:$PATH;  export PATH;  For Windows:   # Set up the `BALLERINA_HOME` environment variable.  set BALLERINA_HOME=\"<YOUR_LOCATION>\\ballerina-<VERSION>\";   # Include the binaries to the system `PATH`.  set PATH=%PATH%;%BALLERINA_HOME%\\bin;  Testing the Distribution Build  Since this is a complete Ballerina distribution build, this will have all the Standard Library module dependencies included in it.  Therefore, follow the steps below to write a simple program using the Ballerina to test the distribution build.    Create a hello_world_with_io.bal file with the code below.   import ballerina/io;   // ballerina hello world program  public function main() {  io:println(\"Hello, World with IO!\");  }   Execute the command below to build and run this program.   bal run hello_world_with_io.bal  If your build is successful, you view the output below.   Hello, World with IO!  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/getting-started/installation-options/","name":"Installation Options","summary":"The sections below include information about installing Ballerina.Table of contents      Follow the instructions below to install the latest Ballerina version using the installer. The installer will automatically uninstall the old Ballerina version if you have one already installed.Info: Ballerina installers support operating systems such as Windows, Ubuntu, ...","content":"/  /  /  / Installation Options  Installation Options  The sections below include information about installing Ballerina.  Table of contents Installing Ballerina via Installers  Follow the instructions below to install the latest Ballerina version using the installer. The installer will automatically uninstall the old Ballerina version if you have one already installed.    Info: Ballerina installers support operating systems such as Windows, Ubuntu, Red Hat Enterprise Linux, macOS, and CentOS. If you are using an unsupported operating system, .   Installing on macOS   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the /Library/Ballerina directory.  The package automatically sets your PATH environment variable for you. You may need to restart any open Terminal sessions for the change to take effect.  Installing on Windows   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the C:\\Program Files\\Ballerina directory.  The installer should put the C:\\Program Files\\Ballerina\\<BALLERINA-DIRECTORY>\\bin directory in your PATH environment variable. You may have to restart any open command prompts for the change to take effect.  Installing on Linux   and double-click on it to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution in the /usr/lib64/ballerina directory.    Info: Alternatively, you can use either of the commands below to install Ballerina using the downloaded DEB or RPM file. Replace the ballerina-linux-installer-x64-<BALLERINA-VERSION>.deb or ballerina-linux-installer-x64<BALLERINA-VERSION>.rpm with the actual file path.   For example, for the DEB file: dpkg -i ballerina-linux-installer-x64-swan-lake-preview1.deb For example, for the RPM file: rpm -i ballerina-linux-installer-x64-swan-lake-preview1.rpm Installing via the Ballerina Language ZIP File    Note: Before you install Ballerina using the ZIP file, ensure that you have a supported Java Runtime Environment (JRE) installed. It is recommended to use the version 11 or above.     and unzip it to a preferred location using an archiver tool of your choice. This creates a directory named ballerina-<VERSION> in your system.  Follow either of the steps below depending on your operating system to configure your system environment to run Ballerina:  For Linux or macOS: set the PATH environment variable to point to the bin directory of the unzipped Ballerina distribution.  For Windows: add a new environment variable specifying the following values:  Variable name: PATH  Variable value: The location of the bin directory of the unzipped Ballerina distribution. For example, C:\\Program Files\\Ballerina\\ballerina-<VERSION>\\bin  Updating Ballerina  If you already have a jBallerina version above 1.1.0 installed, you can use the update tool to update to the latest jBallerina version by executing either of the commands below.    Command  Description  bal dist update  Update to the latest patch version of the active distribution  bal dist pull <JBALLERINA-VERSION>  Fetch a specific distribution and set it as the active version  For more information, see .  Building from Source  For instructions, see .  Uninstalling Ballerina  Usually, the installation location is /Library/Ballerina/distributions in macOS, /usr/lib64/Ballerina/distributions in Linux, and C:\\Program Files\\Ballerina\\distributions in Windows. You can either remove a particular jBallerina version or all the jBallerina versions installed in these locations.  To remove:    a specific jBallerina version (via the update tool): execute bal dist remove  all the installed jBallerina versions: delete the /../Ballerina directory in the respective installation location   What’s Next?  Once you have successfully installed Ballerina, now you can .    Tip: To get help when you work with Ballerina, see .     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/getting-started/setting-up-ballerina/","name":"Setting up Ballerina","summary":"Now, that you know a little bit of Ballerina, let's take it for a spin!Table of contents      You can use the Ballerina Playground to write Ballerina programs without installing anything. Ballerina based on the operating system you are using and install it.For more download options, see .Double-click ...","content":"/  /  /  / Setting up Ballerina  Setting up Ballerina  Now, that you know a little bit of Ballerina, let's take it for a spin!  Table of contents Windows  Linux  macOS  Trying Ballerina in the Playground  You can use the Ballerina Playground to write Ballerina programs without installing anything.          Downloading Ballerina   Ballerina based on the operating system you are using and install it.         Windows  Linux macOS  For more download options, see .  Installing Ballerina  Double-click on the package file you downloaded above to launch the installer. The installer guides you through the installation process and installs the Ballerina distribution.  For more installation options, see .  Updating Ballerina  Once you have Ballerina installed, you can use the Update Tool to update it to the latest version. For this, execute the command below in a new CLI tab.  bal dist pull slalpha2    Info: You might need to first update the Update Tool to its latest version. If you have an Update Tool version below 0.8.14, execute the ballerina update command or else execute the bal update command to do this.   For more information, see .  Installing the VSCode Extension  Ballerina provides an extension to try out its development capabilities in Visual Stusio Code. For instructions on setting it up, see .  What’s Next?  Now, that your environment for Ballerina is all set up and running, let’s .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/getting-started/writing-your-first-ballerina-program/","name":"Writing Your First Ballerina Program","summary":"Let's create a simple Ballerina HTTP service and also an HTTP client to invoke it.Table of contents      Write a simple HTTP service as shown below in a file with the .bal extension.hello_service.balIn the CLI, navigate to the location in which you have the hello_service.bal file and run ...","content":"/  /  /  / Writing Your First Ballerina Program  Writing Your First Ballerina Program  Let's create a simple Ballerina HTTP service and also an HTTP client to invoke it.  Table of contents Writing a Simple Service  Write a simple HTTP service as shown below in a file with the .bal extension.  hello_service.bal import ballerina/http;  # A service representing a network-accessible API # bound to port `9090`. service /hello on new http:Listener(9090) {   # A resource representing an invokable API method  # accessible at `/hello/sayHello`.  #  # + return - A string payload which eventually becomes # the payload of the response  resource function get sayHello() returns string {  return \"Hello Ballerina!\";  } }   Running the Service  In the CLI, navigate to the location in which you have the hello_service.bal file and run the service by executing the command below.  bal run hello_service.bal   You get the following output.  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   This means your service is up and running.    Note: You can test the service by invoking it using an already-available HTTP client. For example, execute the command below in a new CLI tab to use as the client.   curl http://localhost:9090/hello/sayHello   You get the following response.  Hello Ballerina!   Alternatively, you can create a Ballerina HTTP client and use that to invoke the service as follows.  Creating an HTTP Client to Invoke the Service  A Ballerina client is a component, which interacts with a network-accessible service. It aggregates one or more actions that can be executed on the network-accessible service and accepts configuration parameters related to the network-accessible service.  Create a Ballerina client as a Ballerina program with a main function as follows to invoke the hello service.    Note: Returning error? from the main function allows you to use the check keyword to avoid handling errors explicitly. This is only done to keep the code simple. However, in real production code, you may have to handle those errors explicitly.   hello_client.bal import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  // Add the relevant endpoint URL to perform the invocation.  http:Client helloClient = check new(\"http://localhost:9090/hello\");   // Perform a `GET` request to the `hello` service. If successful, // the remote call would return an `http:Response` or the payload // (if the `targetType` defaultable parameter is configured).  // Otherwise an `error` on failure.  http:Response helloResp = check helloClient->get(\"/sayHello\");   // Retrieve the payload as a `string` and print it if the // response of the remote call is successful.  io:println(check helloResp.getTextPayload()); }   Invoking the Service Using the Client  In a new tab of the CLI, navigate to the location in which you have the hello_client.bal file and execute the command below to run the hello_client.bal file containing the main function (of the client), which invokes the hello service.    Tip: Make sure the hello service is .   bal run hello_client.bal   This would produce the following output.  Hello Ballerina!   What’s Next?  Now, that you have written your first Ballerina program, you can explore more about writing .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/graphql/implementing-graphql-services/","name":"Implementing GraphQL Services","summary":"In Ballerina, the GraphQL object structure is modeled using services. A Ballerina GraphQL service contains resource methods that map to the fields of the GraphQL objects and work as resolver functions to provide its data. The GraphQL schema is automatically derived from this service structure and its resources.Table of contents ...","content":"/  /  /  /  / Implementing GraphQL Services  Implementing GraphQL Services  In Ballerina, the GraphQL object structure is modeled using services. A Ballerina GraphQL service contains resource methods that map to the fields of the GraphQL objects and work as resolver functions to provide its data. The GraphQL schema is automatically derived from this service structure and its resources.  Table of contents The topics below demonstrates how to implement an using a Ballerina service.  Writing the GraphQL Service  Start with the Ballerina GraphQL service implementation below, which represents the GraphQL root Query object fields.  import ballerina/graphql;  service graphql:Service /query on new graphql:Listener(8080) {  resource function get 'order(int id) returns Order|error => loadOrder(id);  }   This example code includes a single resource function order, which takes in the id parameter and returns an instance of the Order service class. The loadOrder function and the Order service class are implemented in the following way.  function loadOrder(int id) returns Order|error {  stream<record{}, error> rs = dbClient->query(`SELECT id, customerId,  shipperId, date, notes  FROM ORDERS WHERE id = ${id}`, OrderData);  var rec = check rs.next();  check rs.close();  if !(rec is ()) {  return new Order(<OrderData> rec[\"value\"]);  } else {  return error(string `Invalid order: ${id}`);  } }  service class Order {  private OrderData data;  function init(OrderData data) {  self.data = data;  }  resource function get notes() returns string {  return self.data.notes;  }  resource function get date() returns string {  return self.data.date;  }  resource function get customer() returns Customer|error {  return check loadCustomer(self.data.customerId);  }  resource function get shipper() returns Shipper|error {  return check loadShipper(self.data.shipperId);  } }   Here, you execute the required SQL query to load the Order table data and populate the Order object.    Note:” You do not load the customer and shipper information right away. Rather, these are loaded lazily if and when it’s required as expressed through the incoming GraphQL query.   The loadCustomer function shown below is used in the customer resource function to load the customer information from the database and populate a Customer object.  function loadCustomer(int id) returns Customer|error {  stream<record{}, error> rs = dbClient->query(`SELECT id, name, address  FROM CUSTOMER WHERE id = ${id}`, CustomerData);  var rec = check rs.next();  check rs.close();  if !(rec is ()) {  return new Customer(<CustomerData> rec[\"value\"]);  } else {  return error(string `Invalid customer: ${id}`);  } }  service class Customer {  private CustomerData data;  function init(CustomerData data) {  self.data = data;  }  resource function get name() returns string {  return self.data.name;  }  resource function get address() returns string {  return self.data.address;  } }   Similarly, the shipper resource function is implemented to query the corresponding GraphQL object field.  The complete Ballerina source code for our scenario is shown below.  import ballerina/graphql; import ballerinax/mysql;  mysql:Client dbClient = check new(database = \"ORDER_DB\", user = \"root\", password = \"root\");  type OrderData record {  int id;  int customerId;  int shipperId;  string date;  string notes; };  type CustomerData record {  int id;  string name;  string address; };  type ShipperData record {  int id;  string name;  string phone; };  service class Customer {  private CustomerData data;  function init(CustomerData data) {  self.data = data;  }  resource function get name() returns string {  return self.data.name;  }  resource function get address() returns string {  return self.data.address;  } }  service class Shipper {  private ShipperData data;  function init(ShipperData data) {  self.data = data;  }  resource function get name() returns string {  return self.data.name;  }  resource function get phone() returns string {  return self.data.phone;  } }  service class Order {  private OrderData data;  function init(OrderData data) {  self.data = data;  }  resource function get notes() returns string {  return self.data.notes;  }  resource function get date() returns string {  return self.data.date;  }  resource function get customer() returns Customer|error {  return check loadCustomer(self.data.customerId);  }  resource function get shipper() returns Shipper|error {  return check loadShipper(self.data.shipperId);  } }  service graphql:Service /query on new graphql:Listener(8080) {  resource function get 'order(int id) returns Order|error => loadOrder(id);  }  function loadOrder(int id) returns Order|error {  stream<record{}, error> rs = dbClient->query(`SELECT id, customerId, shipperId, date, notes  FROM ORDERS WHERE id = ${id}`, OrderData);  var rec = check rs.next();  check rs.close();  if !(rec is ()) {  return new Order(<OrderData> rec[\"value\"]);  } else {  return error(string `Invalid order: ${id}`);  } }  function loadCustomer(int id) returns Customer|error {  stream<record{}, error> rs = dbClient->query(`SELECT id, name, address  FROM CUSTOMER WHERE id = ${id}`, CustomerData);  var rec = check rs.next();  check rs.close();  if !(rec is ()) {  return new Customer(<CustomerData> rec[\"value\"]);  } else {  return error(string `Invalid customer: ${id}`);  } }  function loadShipper(int id) returns Shipper|error {  stream<record{}, error> rs = dbClient->query(`SELECT id, name, phone  FROM SHIPPER WHERE id = ${id}`, ShipperData);  var rec = check rs.next();  check rs.close();  if !(rec is ()) {  return new Shipper(<ShipperData> rec[\"value\"]);  } else {  return error(string `Invalid shipper: ${id}`);  } }   Executing the GraphQL Service  Follow the steps below to do a test run using the full Ballerina service implementation.    Navigate to the ordersvc directory, which contains the Ballerina package and the database script, and execute the command below to create and populate the database.   Tip: This example uses a MySQL database to provide the data.  $ mysql -u root -p < db.sql  Execute the command below to run the default module of your Ballerina package.   $ bal run .  You view the output below.   Compiling source  laf/ordersvc:0.1.0  Creating balo  target/balo/laf-ordersvc-any-0.1.0.balo  Running executable  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  .Info: Now, the service is available locally at port 8080, and the service is accessible at “http://localhost:8080/query”.  Execute the commands below to send a few GraphQL requests to the service.   curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ order(id: 2) { notes, date, customer { name, address }, shipper { name, phone } } }\" }' 'http://localhost:8080/query'  {  \"data\": {  \"order\": {  \"notes\": \"Street pickup\",  \"date\": \"2021/01/25\",  \"customer\": {  \"name\": \"Nimal Perera\",  \"address\": \"No 22, Galle Road, Colombo 02\"  },  \"shipper\": {  \"name\": \"UPS\",  \"phone\": \"(408)275-4415\"  }  }  } }  curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ order(id: 1) { notes, customer { name, address } } }\" }' 'http://localhost:8080/query'  {  \"data\": {  \"order\": {  \"notes\": \"Doorstep delivery\",  \"customer\": {  \"name\": \"Jack Smith\",  \"address\": \"No 10, N 1st St, San Jose\"  }  }  } }  Info: Ballerina GraphQL services also support GraphQL introspection. For example, you can execute the query below to look up the types available in the service.   curl -X POST -H \"Content-type: application/json\" -d '{ \"query\": \"{ __schema { types { name } } }\" }' 'http://localhost:8080/query' {  \"data\": {  \"__schema\": {  \"types\": [{  \"name\": \"Order\"  }, {  \"name\": \"__TypeKind\"  }, {  \"name\": \"__Field\"  }, {  \"name\": \"Query\"  }, {  \"name\": \"__Type\"  }, {  \"name\": \"Customer\"  }, {  \"name\": \"Shipper\"  }, {  \"name\": \"__InputValue\"  }, {  \"name\": \"String\"  }, {  \"name\": \"Int\"  }, {  \"name\": \"__Schema\"  }]  }  } }       Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/graphql/","name":"GraphQL","summary":"GraphQL has become a prominent technology for implementing data APIs because it provides a convenient and intuitive approach for querying data. It solves potential problems such as data over-fetching and high-latency that you may notice in traditional data services. This guide illustrates a sample GraphQL use case using Ballerina.Table of ...","content":"/  /  /  / GraphQL  GraphQL  GraphQL has become a prominent technology for implementing data APIs because it provides a convenient and intuitive approach for querying data. It solves potential problems such as data over-fetching and high-latency that you may notice in traditional data services. This guide illustrates a sample GraphQL use case using Ballerina.  Table of contents Introducing the Use Case  The use case is a typical e-commerce scenario of processing orders in an online store. The entity-relationship diagram below shows a simplified representation of a real-life implementation that can be used in a relational database.    Defining the Object Graph  In GraphQL, you can define an object graph in your service in which a client can query the specific fields of an object into any nested level. Optionally, you can pass in parameters for these fields as well. A definition of these objects for this use case is shown below.  type Query {  order(id: Int): Order }  type Order {  id: Int  notes: String  customer: Customer  shipper: Shipper }  type Customer {  name: String  address: Address }  type Shipper {  name: String  phone: String }   The code above is written in the GraphQL schema format used to define object types. GraphQL Query is a special object type, which must exist for the schema. This is basically the root-level object that will be used to query. Therefore, in GraphQL queries, you provide the fields inside the Query object to look up the required data.  Writing the Queries  Once you have the GraphQL service with the schema above, send the query below to get order details from your database.  {  order(id: 1) {  notes,  date  } }   In the above code, you instruct the service to look up the order field from the root query object and pass in ‘1’ as the value for parameter id. This field returns an object type, and thereby, you need to list all the fields required from the object, which are notes and date above. If you need to only look up the date field, the GraphQL query would be as follows.  {  order(id: 1) {  date  } }   You can drill into more fields and get their values as well. The query below looks up the full order information including the customer and shipper information.  {  orders(id: 2) {  notes,  date,  customer {  name,  address  },  shipper {  name,  phone  }  } }   Writing a Simple GraphQL Service  The code below (e.g., demo.bal) shows a simple GraphQL service written in Ballerina.  import ballerina/graphql;  service graphql:Service /query on new graphql:Listener(8080) {  resource function get name() returns string {  return \"Jack\";  }  }   The code above exposes a GraphQL service at the endpoint “http://localhost:8080/query”. Its GraphQL schema is similar to the following.  type Query {  name: String }   You can send the GraphQL query below to look up the exposed name field in the root query object.  {  name }  Executing the Simple GraphQL Service  Execute the command below to run the Ballerina GraphQL service above.  bal run demo.bal   You view the output below.  Compiling source  demo.bal  Running executable  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080   A GraphQL request can be executed by sending an HTTP request similar to the following.  curl -X POST -H \"Content-type: application/json\" -d '{\"query\":\"{name}\"}' http://localhost:8080/query {\"data\":{\"name\":\"Jack\"}}   The resource functions here can be provided with parameters to correlate with the GraphQL field parameters as well. Also, in the case of returning objects in fields, the resource method can return a service object to represent this.  Now, that you know the basics of how GraphQL works, for an actual implementation using Ballerina, which has GraphQL as part of its built-in language-level services support, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/grpc/implementing-grpc-services-and-clients/","name":"Implementing gRPC Services and Clients","summary":"The topics below explain how to implement a gRPC service and write a client to invoke it.Table of contents      Execute the bal new service command to create a Ballerina package to implement the service. You view the output below.Execute the bal grpc --mode service --input admin.proto --output ...","content":"/  /  /  /  / Implementing gRPC Services and Clients  Implementing gRPC Services and Clients  The topics below explain how to implement a gRPC service and write a client to invoke it.  Table of contents Implementing a gRPC Service  Execute the bal new service command to create a Ballerina package to implement the service. You view the output below.  Created new Ballerina package 'service' at service.   Execute the bal grpc --mode service --input admin.proto --output service/ command to create the gRPC service skeleton. You view the output below.  Successfully extracted library files. Successfully generated ballerina file.   The AdminService_sample_service.bal file, which contains the service skeleton will be automatically generated in the default module directory of the service.  You can simply fill in the implementation of the service functions that are defined in it. For example, the following is the remote function generated for the add gRPC method.  remote function add(AddRequest value) returns AddResponse|error {  // Implementation goes here. }   The implementation of the add service function can be completed as follows.  remote function add(AddRequest value) returns AddResponse|error {  int result = value.numbers.reduce(function(int n, int i) returns int => n + i, 0);  return {result: result}; }  The below is the full implementation of the service.  import ballerina/grpc; import ballerina/uuid;  listener grpc:Listener ep = new (9090);  map<Person> personMap = {};  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap() } service \"AdminService\" on ep {  remote function add(AddRequest value) returns AddResponse|error {  int result = value.numbers.reduce(function(int n, int i) returns int => n + i, 0);  return {result: result};  }  remote function multiply(MultiplyRequest value) returns MultiplyResponse|error {  return {result: value.v1 * value.v2};  }  remote function addPerson(Person value) returns AddPersonResponse|error {  value.id = uuid:createType1AsString();  personMap[value.id] = value;  return {id: value.id};  }  remote function getPerson(GetPersonRequest value) returns Person|error {  Person? person = personMap[value.id];  if person is Person {  return person;  } else {  return error grpc:NotFoundError(string `Person value for id: ${value.id} doesn't exist.`);  }  } }   Implementing a gRPC Client  After completing the service implementation above, you can call these service methods using a client as follows.  Execute the bal new client command to create a Ballerina package to implement the client. You view the output below.  Created new Ballerina package 'client' at client.   Execute the bal grpc --mode client --input admin.proto --output client/ command to create the service stub/client. You view the output below.  Successfully extracted library files. Successfully generated ballerina file.   The service stub/client is generated in the client default module directory. The AdminService_sample_client.bal file contains sample code instantiating the gRPC client to access the remote service as follows.  AdminServiceClient ep = check new(\"http://localhost:9090\");  public function main () {  }   The ep object contains the remote functions that correspond to the gRPC service methods. The diagram below shows the VS Code code assist in listing the methods.    Complete the automatically-generated code in the client module of the AdminService_sample_client.bal file. The completed gRPC client code, which invokes all the methods defined in the service is as follows.  import ballerina/io;  AdminServiceClient adminServiceClient = check new(\"http://localhost:9090\");  public function main () returns error? {  AddResponse addResult = check adminServiceClient->add({ numbers: [1, 2, 3, 4] });  io:println(\"Add Result: \", addResult.result);  MultiplyResponse mulResult = check adminServiceClient->multiply({ v1: 5, v2: 7 });  io:println(\"Multiply Result: \", mulResult.result);  Person person = { name: \"Jack Dawson\", birthYear: 1990 };  AddPersonResponse addPersonResult = check adminServiceClient->addPerson(person);  io:println(\"Add Person Result: \", addPersonResult.id);  Person getPersonResult = check adminServiceClient->getPerson({ id: addPersonResult.id });  io:println(\"Get Person Result: \", getPersonResult); }   Executing the Implementations  After completing the full code for both the client and the service, you can execute them by building and running both modules from the Ballerina project root directory as follows.    Execute the bal run service command to start the gRPC service. You view the output below.   Compiling source  laf/service:0.1.0  Creating the BALA file  target/bala/laf-service-any-0.1.0.bala  Running executable  [ballerina/grpc] started HTTP/WS listener 0.0.0.0:9090  Info: The gRPC service is up and running at port 9090.  Execute the bal run client command to run the client module, which will try to contact the active service. You view the output below.   Compiling source  laf/client:0.1.0  Creating the BALA file  target/bala/laf-client-any-0.1.0.bala  Running executable  Add Result: 10 Multiply Result: 35 Add Person Result: eb8d852a-7988-4404-8f7e-173544f2af79 Get Person Result: {\"id\":\"eb8d852a-7988-4404-8f7e-173544f2af79\",\"name\":\"Jack Dawson\",\"birthYear\":1990}  Now, the client will establish a connection with the gRPC service, invoke the methods in it, and receive the respective response messages.  What’s Next?  For information on gRPC streaming, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/grpc/","name":"gRPC","summary":"gRPC is an open-source remote procedure call (RPC) technology, which uses HTTP/2 for transport and is based on Google’s Protocol Buffers. It promises high performance, efficient network communication, features such as schema evolution, blocking and non-blocking communication, and bidirectional streaming. The topics below explain how gRPC works and the tools ...","content":"/  /  /  / gRPC  gRPC  gRPC is an open-source remote procedure call (RPC) technology, which uses HTTP/2 for transport and is based on Google’s Protocol Buffers. It promises high performance, efficient network communication, features such as schema evolution, blocking and non-blocking communication, and bidirectional streaming. The topics below explain how gRPC works and the tools and techniques that are required to implement it using Ballerina.  Table of contents Defining the Interface of the Service  In an RPC service, the first step is to define the interface of the service. This is done using an IDL (Interface Definition Language) file. The IDL file of a gRPC service is provided using Protocol Buffers. Protobuf is a standard for serializing structured data. It provides the structures required for defining services, operations, and messages used in the service communication.  For example, the diagram below shows a sample RPC service, which contains the actions to do some computational operations, store them, and return a custom type.    Creating the Proto File  A proto file starts by mentioning the Protobuf syntax version. The latest version is proto3. This is mentioned as follows.  syntax = \"proto3\";   Start defining a message, which is a structure that contains some data fields. An example is shown below.  message Person {  int64 id = 1;  string name = 2;  int32 birthYear = 3; }   A Person entity is represented with the above Protobuf message definition. The fields are defined by stating the type first followed by the name of the field and then the field number. In this way, the first field id has a scalar type of int64 and a field number 1.  The type can be a composite type as well (such as enumerations and other message types). A field number is a unique number that is used to identify the field in the encoded binary format. This makes sure that the messages will be backward compatible as long as the same field numbers are retained. This is how Protobuf manages to support schema evolution.  A field can also be qualified as singular or repeated. This states that the message can have zero or one of these fields, or else, it can have zero or many of these fields respectively. The default is singular. An example of this is shown below.  message AddRequest {  repeated int64 numbers = 1; }  message AddResponse {  int64 result = 1; }   The AddRequest message contains a structure for an additional operation, which has an array of numbers to be added together. The AddResponse message contains a singular result field of the type int64.  Commonly-used Protobuf types and the respective Ballerina types that can be mapped to them are shown below.    int32 - int  int64 - int  float - float  double - float  string - string  bool - bool  bytes - byte[]  stream - stream   Defining the Service  A service is defined in Protobuf as follows.  service AdminService {  rpc Add(AddRequest) returns (AddResponse); }   The snippet above defines the AdminService RPC service with a method Add, which takes in the AddRequest message and returns an AddResponse message. In this manner, multiple methods can be added to a single service. The following Protobuf definition contains the complete service definition for the service shown in the above diagram.  syntax = \"proto3\";  message Person {  string id = 1;  string name = 2;  int32 birthYear = 3; }  message GetPersonRequest {  string id = 1; }  message AddPersonResponse {  string id = 1; }  message AddRequest {  repeated int64 numbers = 1; }  message AddResponse {  int64 result = 1; }  message MultiplyRequest {  int64 v1 = 1;  int64 v2 = 2; }  message MultiplyResponse {  int64 result = 1; }  service AdminService {  rpc add(AddRequest) returns (AddResponse);  rpc multiply(MultiplyRequest) returns (MultiplyResponse);  rpc addPerson(Person) returns (AddPersonResponse);  rpc getPerson(GetPersonRequest) returns (Person); }   The above is the full Protobuf definition for the service.  Implementing gRPC Services and Clients  For instructions on implementing the above service and writing a client to invoke it, see .  Performing gRPC Streaming  For instructions on this, see .    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/grpc/performing-grpc-streaming/","name":"Performing gRPC Streaming","summary":"The topics below demonstrates an example implementation of a gRPC client and bi-directional streaming using Ballerina.Table of contents      Info: gRPC supports both client and bi-directional streaming. In client streaming, the client writes a sequence of messages and sends them to the server via a stream. Once the ...","content":"/  /  /  /  / Performing gRPC Streaming  Performing gRPC Streaming  The topics below demonstrates an example implementation of a gRPC client and bi-directional streaming using Ballerina.  Table of contents Info: gRPC supports both client and bi-directional streaming. In client streaming, the client writes a sequence of messages and sends them to the server via a stream. Once the client has finished writing the messages, it waits for the server to read them and return a response. In bi-directional streaming, the client and server each send a sequence of messages using read-write streams that operate independently allowing them to read and write in any order.   Implementing Bi-Directional Streaming  The diagram below depicts an example implementation of a gRPC client and bi-directional streaming using Ballerina. It shows the streaming calc service, which contains the sum and incrementalSum methods to represent the client and bi-directional streaming operations respectively.    Creating the Protobuf Definition of the Service  The Protobuf definition of the above service is shown below.  syntax = \"proto3\"; import \"google/protobuf/wrappers.proto\";  service StreamingCalcService {  rpc sum(stream google.protobuf.Int64Value) returns (google.protobuf.Int64Value);  rpc incrementalSum(stream google.protobuf.Int64Value) returns (stream google.protobuf.Int64Value); }   The above definition introduces the stream qualifier for the method parameters and the return types. This signifies that the parameter/return value will be sent as a stream of individual values.  The sum method takes in a stream of int64 values and returns a single int64 value. The incrementalSum method takes in and returns a stream of int64 values, which contain the individual results for each intermediate sum value in the calculation.  Implementing the Service and Client  Follow the steps below to create separate service and client packages, and generate the gRPC service and client code.    Execute the bal new service command in a new base directory to create the service. You view the output below.   Created new Ballerina package 'service' at service.  Execute the bal new client command to create the client. You view the output below.   Created new Ballerina package 'client' at client.  Execute the bal grpc --mode service --input streaming_calc.proto --output service/ to extract the library files of the service. You view the output below.   Successfully extracted library files.  Successfully generated ballerina file.  Execute the bal grpc --mode client --input streaming_calc.proto --output client/ to extract the library files of the client. You view the output below.   Successfully extracted library files.  Successfully generated ballerina file.  Update the service skeleton with the code below to add the implementation.   import ballerina/grpc;  listener grpc:Listener ep = new (9090);  @grpc:ServiceDescriptor {  descriptor: ROOT_DESCRIPTOR,  descMap: getDescriptorMap()  }  service \"StreamingCalcService\" on ep {  remote function sum(stream<int, grpc:Error?> clientStream) returns int|error {  int sum = 0;  error? e = clientStream.forEach(function (int value) {  sum += value;  });  return sum;  }  remote function incrementalSum(StreamingCalcServiceIntCaller caller, stream<int, grpc:Error?> clientStream) returns error? {  int sum = 0;  error? e = clientStream.forEach(function (int value) {  sum += value;  checkpanic caller->sendInt(sum);  });  check caller->complete();  }  }    Info: In the code above, the gRPC stream type has been mapped to the stream type in Ballerina. Using the Ballerina stream type, you can iterate through all the values in the stream sent to the service by the client. The only difference between the sum and incrementalSum methods is the use of the caller object to stream out multiple values to the client.  Add the implementation of the generated client as shown below in order to invoke the add operation.   import ballerina/grpc;  import ballerina/io;  StreamingCalcServiceClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  SumStreamingClient calcClient = check ep->sum();  foreach var i in 1...10 {  check calcClient->sendInt(i);  }  check calcClient->complete();  int|grpc:Error? result = check calcClient->receiveInt();  if result is int {  io:println(\"Value: \", result);  } else if result is grpc:Error {  io:println(\"Error: \", result);  } else {  io:println(\"Complete.\");  }  }    Info: In the above implementation, the StreamingCalcServiceMessageListener service is created along with the client code. This service is used as a callback for processing a streaming result from the remote service. A grpc:StreamingClient object is also provided when invoking the remote method of the service. This client is used to send streaming values to the active service request.  Performing Bi-Directional Streaming  Follow the steps below to perform a sample run of the above implementation.    Execute the bal run service/ command to run the service. You view the output below.   Compiling source  laf/service:0.1.0   Creating the BALA file  target/bala/laf-service-any-0.1.0.bala   Running executable   [ballerina/grpc] started HTTP/WS listener 0.0.0.0:9090  Execute the bal run client command to run the client. You view the output below.   Value: 55  Update the client code to use the incrementalSum operation, which implements bi-directional streaming as shown below.   import ballerina/grpc;  import ballerina/io;  StreamingCalcServiceClient ep = check new(\"http://localhost:9090\");  public function main () returns error? {  IncrementalSumStreamingClient streamingClient = check ep->incrementalSum();  _ = start readResponse(streamingClient);  foreach var i in 1...10 {  check streamingClient->sendInt(i);  }  check streamingClient->complete();  }  function readResponse(IncrementalSumStreamingClient streamingClient) returns error? {  while(true) {  int|grpc:Error? result = check streamingClient->receiveInt();  if result is int {  io:println(\"Value: \", result);  } else if result is grpc:Error {  io:println(\"Error: \", result);  break;  } else {  io:println(\"Complete.\");  break;  }  }  }   Execute the bal run client command to run the client. You view the output below.   Value: 1  Value: 3  Value: 6  Value: 10  Value: 15  Value: 21  Value: 28  Value: 36  Value: 45  Value: 55  Complete.  Info: In the above scenario, the service sends the result as a stream of individual values, which contain the incremental sum values of the input stream.       Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/communication-resiliency/","name":"Communication Resiliency","summary":"The HTTP client supports multiple communication resiliency options out of the box.Table of contents      These features allow you to handle and recover from unexpected communication scenarios gracefully.The HTTP client can be configured with a retry configuration using the  property in the  to retry sending the ...","content":"/  /  /  /  /  / Communication Resiliency  Communication Resiliency  The HTTP client supports multiple communication resiliency options out of the box.  Table of contents These features allow you to handle and recover from unexpected communication scenarios gracefully.  Retry  The HTTP client can be configured with a retry configuration using the property in the to retry sending the same request to the endpoint in the case of a failure. This follows an exponential backoff algorithm to execute the retry requests.  The retry_demo.bal below shows an HTTP client configured with a retry configuration.    Info: In the below code, the client is configured to have three retries in the case of a request failure with an initial 3,000 milliseconds retry interval. This interval is multiplied by two with each retry so that the second and third retries will have 6,000 and 12,000-millisecond intervals respectively. Also, it provides 20,000 milliseconds as the maximum value to which the retry interval will increase. Therefore, in this scenario, the fourth and fifth retry intervals will be restricted to 20,000 milliseconds.   retry_demo.bal import ballerina/io; import ballerina/http;  public function main() returns @tainted error? {  http:Client clientEp = check new (\"http://httpbin.org\", {  retryConfig: {  interval: 3,  count: 5,  backOffFactor: 2.0,  maxWaitInterval: 20  }});  http:Response resp = check clientEp->get(\"/get\");  io:println(resp.getTextPayload()); }   Circuit Breaker  The pattern is used to handle temporary faults when communicating across the network. If a remote endpoint is not available due to a high service load or a network failure, your application may be repeatedly trying to communicate with this service, waiting till it returns a successful result.  If the requests keep failing continuously and adding more stress to the backend system, it is not a desirable state for your system. Then, you should rather fail-fast and handle the error from the application. This makes sure the caller is not wasting too many resources by waiting for request timeouts etc. Thus, holding back a chain of network calls, which in-turn may hold up resources such as execution threads and network connections.  Circuit Breaker ‘Closed’ State  As a solution for this, you can have an intermediary between the service client and the backend service that acts as a circuit breaker. In this manner, when the backend service is healthy, the requests originated from the client go through the circuit breaker and the backend service will successfully return the response to the client through the circuit breaker. This is called the closed state in the circuit breaker, which is depicted by the diagram below.    Circuit Breaker ‘Open’ State  If the circuit breaker detects that the backend service is repeatedly failing, it can stop forwarding the client requests to the backend service and fail the requests immediately by returning with a specific error message to the client. In this situation, the circuit breaker is in the open state, which is depicted by the diagram below.    Circuit Breaker ‘Half-Open’ State  While the circuit breaker is in the open state and after a specific timeout since it was in this state, the circuit breaker will allow some requests from the client to be passed to the backend service. This is called the half-open state, which is depicted by the diagram below.    If the requests sent to the backend service are successful in this state, it will go back to the closed state, and all the requests will flow again to the backend service. If the requests sent to the backend in the half-open state fails, the circuit breaker will again go back to the open state.  Circuit Breaker Client Configuration  The circuit breaker pattern can be used in Ballerina HTTP clients by using its . This contains the configuration properties below.    rollingWindow: A rolling window is used to calculate the statistics for backend service errors.  timeWindow: The size of the rolling time window (in seconds).  bucketSize: The time increment of each rolling window slide. New stats are collected in a bucket of this time duration. This information is added to the current time window at the completion of the bucket time period and the oldest bucket is removed from the window.  requestVolumeThreshold: The minimum number of requests that should be in the rolling window to trip the circuit.  failureThreshold: The threshold for request failures. If this threshold exceeds, the circuit is tripped. This is calculated as the ratio between the failures and the total requests in the current rolling window of requests.  resetTime: The time period (in seconds) to wait in the open state before trying again to contact the backend service.  statusCodes: The HTTP status codes that are considered as request failures.   The circuit_breaker_demo.bal example below shows an HTTP client configured with a circuit breaker.  circuit_breaker_demo.bal  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new (\"http://httpbin.org\", {  circuitBreaker: {  rollingWindow: {  timeWindow: 10,  bucketSize: 2,  requestVolumeThreshold: 5  },  failureThreshold: 0.2,  resetTime: 10,  statusCodes: [400, 404, 500]  }  }  );  http:Response resp = check clientEp->get(\"/get\");  io:println(resp.getTextPayload()); }   In the above code, the HTTP client is configured with a circuit breaker configuration, which tracks a 10-second rolling window of request statistics and updates its information within 2-second intervals. By including a request volume threshold of 5, any fewer number of requests in the rolling window will not trigger the logic to trip the circuit.  Otherwise, in the case of 20% requests failure in the rolling window, the circuit will trip and go into the open state. Now, the client will immediately return errors until 10 seconds. Then, it will go into a half-open state and check again if the backend service is responding with successful responses. If the backend request succeeds, the circuit will go back to the closed state and all clients’ requests will be forwarded to the backend service. Or else, it will go back to an open state.  Load Balancing and Failover  In the event of load balancing requests to multiple remote endpoints, Ballerina has the to provide a list of endpoints, and optionally an implementation of the algorithm to select the endpoint to distribute the traffic. The default load balancer rule is to use a round-robin strategy to distribute the load.  HTTP Client-Side Load Balancing  The load-balancer_demo.bal example below shows a scenario of HTTP client-side load balancing.  load-balancer_demo.bal  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:LoadBalanceClient clientEp = check new ({  targets: [{url: \"http://httpbin.org\"},  {url: \"http://httpbin.com\"},  {url: \"http://httpbin.io\"}]  });  http:Response resp = check clientEp->get(\"/get\");  io:println(resp.getTextPayload()); }   In the above code, the three hosts configured using the targets property provide the list of base URLs used for the load balancing requests.  For more detailed configuration options, see the .  Handling Failover Scenarios  Similarly, Ballerina supports fail-over scenarios using the . In this, a list of target URLs can be provided to attempt requests in a sequence, in which, in the case of failure, it will move on to the next available URL in the list for retrying the request.  The fail_over_load-balancer_demo.bal example below shows this in action.  fail_over_load-balancer_demo.bal  import ballerina/io; import ballerina/http;  public function main() returns @tainted error? {  http:FailoverClient clientEp = check new ({  targets: [{url: \"http://localhost:8080\"},  {url: \"http://httpbin.org\"},  {url: \"http://httpbin.com\"}]  });  http:Response resp = check clientEp->get(\"/get\");  io:println(resp.getTextPayload()); }   For more detailed configuration options of the failover client, see the .  What’s Next?  For other use cases of HTTP clients, see the topics below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/data-binding/","name":"Data Binding","summary":"The sections below explain the how to perform data binding with HTTP clients.Table of contents      In the , the default value of the target type parameter is used in the  remote method of the , which is the . You can also pass in the types ...","content":"/  /  /  /  /  / Data Binding  Data Binding  The sections below explain the how to perform data binding with HTTP clients.  Table of contents In the , the default value of the target type parameter is used in the remote method of the , which is the . You can also pass in the types string, json, xml, map<json>, byte[], custom record, and record array types to perform automatic data binding with the returned payload.  In the data binding, any HTTP response that returns the 4xx or 5xx status codes are considered as error situations. Therefore, the remote method will return the error value of the type.  Using JSON and XML in Data Binding  The data_binding_example_one.bal below illustrates an example of using JSON and XML in data binding.  data_binding_example_one.bal  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"https://freegeoip.app\");  json jp = check clientEp->get(\"/json/\");  io:println(\"JSON Payload:\\n\", jp, \"\\n\");  xml xp = check clientEp->get(\"/xml/\");  io:println(\"XML Payload:\\n\", xp); }   Execute the bal run data_binding_example_one.bal command and the output will be as follows.  JSON Payload: {\"ip\":\"45.30.94.9\",\"country_code\":\"US\",\"country_name\":\"United States\",\"region_code\":\"CA\",\"region_name\":\"California\",\"city\":\"San Jose\",\"zip_code\":\"95134\",\"time_zone\":\"America/Los_Angeles\",\"latitude\":37.4073,\"longitude\":-121.939,\"metro_code\":807}  XML Payload: <Response>  <IP>45.30.94.9</IP>  <CountryCode>US</CountryCode>  <CountryName>United States</CountryName>  <RegionCode>CA</RegionCode>  <RegionName>California</RegionName>  <City>San Jose</City>  <ZipCode>95134</ZipCode>  <TimeZone>America/Los_Angeles</TimeZone>  <Latitude>37.4073</Latitude>  <Longitude>-121.939</Longitude>  <MetroCode>807</MetroCode> </Response>   Using a Custom Record Type in Data Binding  Similarly, the data_binding_example_two.bal demonstrates the usage of a custom record type in data binding.    Info: In the record data binding scenario, the field names must match the fields in the returning JSON payload.   data_binding_example_two.bal  import ballerina/http; import ballerina/io;  type Location record {  string ip;  string country_code;  string country_name;  string region_code;  string region_name;  string city;  string zip_code;  string time_zone;  float latitude;  float longitude;  int metro_code; };  public function main() returns @tainted error? {  http:Client clientEp = check new(\"https://freegeoip.app\");  Location loc = check clientEp->get(\"/json/\");  io:println(\"IP: \", loc.ip);  io:println(\"Latitude: \", loc.latitude);  io:println(\"Longitude: \", loc.longitude);  io:println(\"City/State/Country: \", string `${loc.city}, ${loc.region_code}, ${loc.country_name}`); }   Execute the bal run data_binding_example_two.bal command and the output will be as follows.  Compiling source  data_binding_example_two.bal  Running executable  IP: 45.30.94.9 Latitude: 37.4073 Longitude: -121.939 City/State/Country: San Jose, CA, United States   What’s Next?  For other use cases of HTTP clients, see the topics below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/data-streaming/","name":"Data Streaming","summary":"HTTP data streaming can be attained using chunked transfer encoding.Table of contents      In Ballerina, the clients automatically switch between the chunked or non-chunked modes based on the size of the content provided as the payload. This is controlled by the  object’s  property, which has a ...","content":"/  /  /  /  /  / Data Streaming  Data Streaming  HTTP data streaming can be attained using chunked transfer encoding.  Table of contents Data Streaming Modes  In Ballerina, the clients automatically switch between the chunked or non-chunked modes based on the size of the content provided as the payload. This is controlled by the object’s property, which has a default value of . The fully supported modes are as follows.    : If the payload is less than 8KB, the client will not use chunking. It will load the full content to the memory, set the “Content-Length” header with the content size, and send out the request. Otherwise, it will use chunking to stream the data to the remote endpoint.  : The client will always use chunking to stream the payload to the remote endpoint.  : The client will never use chunking, and it will fully read in the payload to memory and send out the request.   Creating the Input Data Stream  To use the HTTP streaming feature effectively, you need to create an HTTP request with a stream of byte[]. For example, if you want to stream the content of a large file to a remote endpoint and read its content using a function such as to read in the full content as a byte array to memory, then you lose the benefit of streaming the data.  Therefore, you should use a stream of byte[] by using an API such as the , which returns a stream<byte[], io:Error>. This stream can be used in places that accept a stream of byte[] such as the object’s .  The data_streaming.bal example below opens a file with a stream and uses it to create an HTTP request to stream its data to a remote endpoint.    Info: Since the code below uses the default HTTP client configurations, if the input file is larger than 8KB, it will automatically stream the content to the remote endpoint using chunked transfer encoding.   data_streaming.bal  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"http://httpbin.org\");  http:Request req = new;  req.setByteStream(check io:fileReadBlocksAsStream(\"/home/laf/input.jpeg\"));  http:Response resp = check clientEp->post(\"/post\", req);  io:println(resp.getTextPayload()); }   What’s Next?  For other use cases of HTTP clients, see the topics below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/","name":"HTTP Clients","summary":"The topics below explain how to process HTTP requests and responses using Ballerina. It provides in-depth details on how HTTP clients are created and how their functionality can be used effectively.Table of contents      An HTTP client in Ballerina is created by instantiating an http:Client object while providing ...","content":"/  /  /  /  / HTTP Clients  HTTP Clients  The topics below explain how to process HTTP requests and responses using Ballerina. It provides in-depth details on how HTTP clients are created and how their functionality can be used effectively.  Table of contents Creating HTTP Clients  An HTTP client in Ballerina is created by instantiating an http:Client object while providing the host and client configurations. The client configuration has a default value of {}, and the default values of its fields can be found in the http:ClientConfiguration record definition.    Info: The error is made union with the http:Client to get an error returned during its initialization.   http:Client|error clientEp = new(\"http://example.com\");   The clientEp instance above represents a client created for the example.com host through the HTTP protocol. In the default configuration, a connection pooling configuration is attached, which means a single-client object is backed by a pool of network connections to the host.  http:Client|error clientEp = new(\"http://example.com\", {  poolConfig: {  maxActiveConnections: 100, // default -1  maxIdleConnections: 10, // default 100  waitTime: 10 // default 30  }  });   The code above creates a client by providing an explicit client configuration, which provides the connection-pooling configuration.  Basic HTTP Requests  After creating an HTTP client object, you can now execute HTTP requests through the .  The below are some of the remote methods that are most often used in the HTTP client object.  GET  An HTTP GET request is executed by using the remote method in the HTTP client. This remote method takes in the request path as the first parameter, and the target type as the second parameter for data-binding operations. The default value of the target type is . The remote method returns a union type consisting of , , and error.  The client_demo_get.bal below is an example of its usage.  client_demo_get.bal import ballerina/io; import ballerina/http;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"http://httpbin.org\");  http:Response resp = check clientEp->get(\"/get\");  io:println(\"Content Type: \", resp.getContentType());  io:println(\"Payload: \", resp.getJsonPayload());  io:println(\"Status Code: \", resp.statusCode);  io:println(\"Header [date]: \", resp.getHeader(\"date\")); }   Execute the bal run client_demo_get.bal command and the output will be as follows.  Content Type: application/json Payload: {\"args\":{},\"headers\":{\"Host\":\"httpbin.org\",\"User-Agent\":\"ballerina\",\"X-Amzn-Trace-Id\":\"Root=1-5fd3b719-0d5a1625098ad73b53c0c094\"},\"origin\":\"45.30.94.9\",\"url\":\"http://httpbin.org/get\"} Status Code: 200 Header [date]: Fri, 11 Dec 2020 18:14:49 GMT   The object can be used to access information such as the client response payload, , , and .  POST  An HTTP POST is executed using the remote method in the HTTP client. You can provide the request path as the first parameter. The second parameter is a value of the , which is a union type of the and other data-binding types such as XML, JSON, and other custom record types. The third parameter is the target type for providing the response data-binding type, similar to the result of the HTTP GET functionality. The default value of the target type is .  The client_demo_post.bal below is an example of its usage.  client_demo_post.bal import ballerina/io; import ballerina/http;  public function main() returns @tainted error? {  http:Client clientEp = check new (\"http://httpbin.org\");  http:Request req = new;  req.setTextPayload(\"Hello!\");  req.setHeader(\"x-user\", \"Jack\");  http:Response resp = check clientEp->post(\"/post\", req);  io:println(\"Payload: \", resp.getJsonPayload()); }   Execute the bal run client_demo_get.bal command and the output will be as follows.  Payload: {\"args\":{},\"data\":\"Hello!\",\"files\":{},\"form\":{},\"headers\":{\"Content-Length\":\"6\",\"Content-Type\":\"text/plain\",\"Host\":\"httpbin.org\",\"User-Agent\":\"ballerina\",\"X-Amzn-Trace-Id\":\"Root=1-5fd3b957-4110242263315d0a3fa66dcc\",\"X-User\":\"Jack\"},\"json\":null,\"origin\":\"45.30.94.9\",\"url\":\"http://httpbin.org/post\"}   EXECUTE  Similar to the and remote methods above, there are other methods such as , , , , and to represent the HTTP methods. There is also a generic remote method for users to specify the HTTP verb and execute the HTTP action.  Multipart Message Handling  For information on this, see .  Data Binding  For information on this, see .  Data Streaming  For information on this, see .  Communication Resiliency  For information on this, see .  Secure Communication  For information on this, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/multipart-message-handling/","name":"Multipart Message Handling","summary":"HTTP multipart messages can be created by using the Multipurpose Internet Mail Extensions (MIME) standard.Table of contents      You can provide MIME entity values to create single or multi-part HTTP messages using the  object.A MIME entity in Ballerina is represented using the  object.The multipart_example_one.bal example below ...","content":"/  /  /  /  /  / Multipart Message Handling  Multipart Message Handling  HTTP multipart messages can be created by using the Multipurpose Internet Mail Extensions (MIME) standard.  Table of contents You can provide MIME entity values to create single or multi-part HTTP messages using the object.  A MIME entity in Ballerina is represented using the object.  Setting a Text Payload  The multipart_example_one.bal example below illustrates how to can use a MIME entity in setting a text payload in an HTTP request.  multipart_example_one.bal import ballerina/http; import ballerina/mime; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"http://httpbin.org\");  http:Request req = new;  mime:Entity entity = new;  entity.setText(\"Hello!\", \"text/plain\");  req.setEntity(entity);  http:Response resp = check clientEp->post(\"/post\", req);  io:println(resp.getTextPayload()); } Execute the bal run multipart_example_one.bal command and the output will be as follows.  {  \"args\": {},  \"data\": \"Hello!\",  \"files\": {},  \"form\": {},  \"headers\": { \t\"Content-Length\": \"6\", \t\"Content-Type\": \"text/plain\", \t\"Host\": \"httpbin.org\", \t\"User-Agent\": \"ballerina\", \t\"X-Amzn-Trace-Id\": \"Root=1-5fd1da83-22ce662a2b5e80ac0f9cb5f0\"  },  \"json\": null,  \"origin\": \"45.30.94.9\",  \"url\": \"http://httpbin.org/post\" }   The code above explicitly creates the MIME entity and sets it in the HTTP request. The same operation happens if you use the method in the object. These functions are effectively helper functions to set the MIME entities in the HTTP request for often-used content types.  Setting the Body with Other Data Types  The object contains functions for setting the body with other data types such as , , and as well.  A multipart message can be created by setting the body parts in the object using the method.  This method takes in an array of objects, and also optionally, the content type of the enclosing entity, in which, the default is set to .  Using Other Multipart Values  If required, you can override the default multipart/form-data with other multipart values such as , , and .  The multipart_example_two.bal below shows how a multipart/mixed message is created using plain text content and an image file as an attachment.  multipart_example_two.bal import ballerina/http; import ballerina/mime; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"http://httpbin.org\");  http:Request req = new;  mime:Entity mpEntity = new;  mime:Entity textEntity = new;  textEntity.setText(\"Hello!\");  mime:Entity imageEntity = new;  imageEntity.setByteArray(<@untainted> check io:fileReadBytes(  \"/home/laf/input.jpeg\"), \"image/jpg\");  mime:ContentDisposition contentDisp = new;  contentDisp.disposition = \"attachment\";  contentDisp.fileName = \"input.jpeg\";  imageEntity.setContentDisposition(contentDisp);  mpEntity.setBodyParts([textEntity, imageEntity], mime:MULTIPART_MIXED);  req.setEntity(mpEntity);  http:Response resp = check clientEp->post(\"/post\", req);  io:println(resp.getTextPayload()); }  In the above code, the method in the object is used to set the content disposition of the entity. This provides information on how the recipient should handle the data. For example, if it should be displayed inline, treated as form data, or downloaded as an attachment.  Processing HTTP Response Entities  Similar to how you work with MIME entities in HTTP requests, the HTTP response entities can also be processed using the method in the object.  The multipart_example_three.bal below is an example of its usage.  multipart_example_three.bal import ballerina/http; import ballerina/mime; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEp = check new(\"http://httpbin.org\");  http:Response resp = check clientEp->get(\"/image/jpeg\");  mime:Entity entity = check resp.getEntity();  io:println(\"Content Type: \", entity.getContentType());  io:println(\"Content Length: \", entity.getContentLength()); }   Execute the bal run multipart_example_three.bal command and the output will be as follows.  Content Type: image/jpeg Content Length: 35588   What’s Next?  For other use cases of HTTP clients, see the topics below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-clients/secure-communication/","name":"Secure Communication","summary":"The HTTP client supports numerous secure communication features such as Transport Level Security (TLS) and mutual authentication.Table of contents      The TLS features are used with the HTTP client by using the https protocol in the endpoint URL. Optionally, you can provide the information on the truststore or ...","content":"/  /  /  /  /  / Secure Communication  Secure Communication  The HTTP client supports numerous secure communication features such as Transport Level Security (TLS) and mutual authentication.  Table of contents Configuring Secure Communication  The TLS features are used with the HTTP client by using the https protocol in the endpoint URL. Optionally, you can provide the information on the truststore or server public certificate location to use for validating the server certificates received when creating an HTTP connection over TLS. This is provided using the secureSocket property in the instance when creating the .  Communicating with an HTTPS Endpoint  The https_client_demo.bal example below shows a scenario of communicating with an HTTPS endpoint.  https_client_demo.bal import ballerina/http; import ballerina/io;  public function main() returns error? {  http:Client clientEp = check new (\"https://httpbin.org\");  http:Response resp = check clientEp->get(\"/get\");  io:println(\"Payload: \", check resp.getJsonPayload()); }   Execute the bal run https_client_demo.bal command and the output will be as follows:  Payload: {  \"args\": {},  \"headers\": {  \"Host\": \"httpbin.org\",  \"User-Agent\": \"ballerina\",  \"X-Amzn-Trace-Id\": \"Root=1-5fd3c1dc-0f5b5c3809c89dca2044ef70\"  },  \"origin\": \"45.30.94.9\",  \"url\": \"https://httpbin.org/get\" }   Communicating with an HTTPS Endpoint configured with Public Certificate  The https_client_cert_demo.bal example below shows how a public certificate can be used for the client when communicating with an HTTPS endpoint.  https_client_cert_demo.bal import ballerina/http; import ballerina/io;  public function main() returns error? {  http:Client clientEp = check new(\"https://httpbin.org\",  secureSocket = {  cert: \"/path/to/public.crt\"  }  );  http:Response resp = check clientEp->get(\"/get\");  io:println(\"Payload: \", check resp.getTextPayload()); }   Execute the bal run https_client_cert_demo.bal command and the output will be as follows.  Payload: {  \"args\": {},  \"headers\": {  \"Host\": \"httpbin.org\",  \"User-Agent\": \"ballerina\",  \"X-Amzn-Trace-Id\": \"Root=1-5fd3c1dc-0f5b5c3809c89dca2044ef70\"  },  \"origin\": \"45.30.94.9\",  \"url\": \"https://httpbin.org/get\" }   Communicating with an HTTPS Endpoint configured with TrustStore  The https_client_truststore_demo.bal example below shows how a truststore can be used for the client when communicating with an HTTPS endpoint.  https_client_truststore_demo.bal import ballerina/http; import ballerina/io;  public function main() returns error? {  http:Client clientEp = check new(\"https://httpbin.org\",  secureSocket = {  cert: {  path: \"/path/to/truststore.p12\",  password: \"password\"  }  }  );  http:Response resp = check clientEp->get(\"/get\");  io:println(\"Payload: \", check resp.getTextPayload()); }   Execute the bal run https_client_truststore_demo.bal command and the output will be as follows.  Payload: {  \"args\": {},  \"headers\": {  \"Host\": \"httpbin.org\",  \"User-Agent\": \"ballerina\",  \"X-Amzn-Trace-Id\": \"Root=1-5fd3c1dc-0f5b5c3809c89dca2044ef70\"  },  \"origin\": \"45.30.94.9\",  \"url\": \"https://httpbin.org/get\" }   Mutual TLS  In , the server is authenticated using the certificate provided to the client, and the secure communication is started based on this information. In the Mutual TLS (mTLS) scenario, the client gets the chance to authenticate itself with the remote server as well.  This is done by additionally providing a keystore or public cert and private key of the client. This is done via the key property of secureSocket property in the [HTTP client configuration]((/learn/api-docs/ballerina/#/ballerina/http/latest/records/ClientConfiguration). The keystore will also contain your private key and the certificates that will be used in the authentication done by the remote server.  The mutual_tls_demo.bal example below shows an HTTP client configured for mutual authentication.  mutual_tls_demo.bal import ballerina/io; import ballerina/http;  public function main() returns error? {  http:Client clientEp = check new(\"https://httpbin.org\",  secureSocket = {  cert: \"/path/to/public.crt\",  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"path/to/private.key\"  }  }  );  http:Response resp = check clientEp->get(\"/get\");  io:println(\"Payload: \", resp.getTextPayload()); }   For more information on Ballerina’s authentication/authorization features, see the .  What’s Next?  For other use cases of HTTP clients, see the topics below.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-services/extended-request-response-access/","name":"Extended Request/Response Access","summary":"The service resources have the functionality of handling request and response data manually  without binding them to resource parameters or the return value.Table of contents      This is done by optionally taking in the  and  typed parameters, which represent calling the remote client and the ...","content":"/  /  /  /  /  / Extended Request/Response Access  Extended Request/Response Access  The service resources have the functionality of handling request and response data manually without binding them to resource parameters or the return value.  Table of contents Interacting With the Remote Client  This is done by optionally taking in the and typed parameters, which represent calling the remote client and the current request information respectively.  The contains functionality to interact with the remote client such as responding to the client using the remote method. The object contains operations to look up information regarding the current incoming HTTP request such as the request payload, [query](https://docs.central.ballerina.io/ballerina/http/latest/classes/Request#getQueryParams/ parameters, , and .  Example  The example below demonstrates this functionality in action.  import ballerina/http;  service / on new http:Listener(8080) {  resource function post greeting(http:Caller caller,  http:Request request) returns error? {  string name = check request.getTextPayload();  check caller->respond(string `Hello, ${name}!`);  }  }   Execution  The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl -d \"Jack\" http://localhost:8080/greeting Hello, Jack!   Executing Additional Logic  Using this approach, you can also execute additional logic even after the response is sent back to the client. For example, in the case of a network issue when responding back to the client, you can do custom operations for failure-recovery or do extended logging operations.  The remote method also takes in an object if you need finer control in the response such as setting the status code or overriding the default .  Example  The example below shows how you can send an HTTP 202 (Accepted) status code from your response.  import ballerina/http;  service / on new http:Listener(8080) {  resource function post greeting(http:Caller caller,  http:Request request) returns error? {  string name = check request.getTextPayload();  http:Response resp = new;  resp.setTextPayload(string `Hello, ${name}!`);  resp.statusCode = 202;  check caller->respond(resp);  }  }   Execution  The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl -v -d \"Jack\" http://localhost:8080/greeting * Trying 127.0.0.1:8080... * TCP_NODELAY set * Connected to localhost (127.0.0.1) port 8080 (#0) > POST /greeting HTTP/1.1 > Host: localhost:8080 > User-Agent: curl/7.68.0 > Accept: */* > Content-Length: 4 > Content-Type: application/x-www-form-urlencoded > * upload completely sent off: 4 out of 4 bytes < HTTP/1.1 202 Accepted < content-type: text/plain < content-length: 12 < server: ballerina < date: Wed, 27 Jan 2021 06:41:37 -0800 < * Connection #0 to host localhost left intact Hello, Jack!   What’s Next?  For other use cases of HTTP services, see the topics below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-services/","name":"HTTP Services","summary":"The topics below cover details on the HTTP services support in Ballerina. They explore the basics of creating an HTTP service and how Ballerina provides a convenient abstraction for defining complex operations.Table of contents      A Ballerina service’s structure and its semantics are defined by the service type ...","content":"/  /  /  /  / HTTP Services  HTTP Services  The topics below cover details on the HTTP services support in Ballerina. They explore the basics of creating an HTTP service and how Ballerina provides a convenient abstraction for defining complex operations.  Table of contents Structuring an HTTP Service  A Ballerina service’s structure and its semantics are defined by the service type (i.e., the type of the listener attached to it). A basic HTTP service is structured in Ballerina as shown below.    The elements of the service are as follows.    Service name: the service name represents the base path of the HTTP service. This is an optional value. If it’s kept empty, the base path defaults to the value “/”.  Listener object: provides an instance of the to bind to a specific host/port.  Resource: a resource represents a specific subpath that can be accessed in relation to the service base path.   Accessor: this is the HTTP method used to access the resource. This can be any HTTP method (e.g., get, put, post, delete). Only a single accessor can be associated with a single resource. If you need to support multiple HTTP methods to a single resource, you can define distinct service resources with the same name and different accessors. The default special accessor can be used to dispatch all the requests with the resource path regardless of the HTTP method.  Name: the name represents the path of the resource in relation to the service base path. You can provide hierarchical values as well (e.g., foo/bar). In this case, the final path to this resource would be /base/foo/bar.  The . special name is used to represent the service itself in a resource. Thus, requests that are directly sent to the base path will be dispatched to this resource.   Return type: this is an optional return type, which can be of type or . An anydata return value would be returned with an HTTP status code 200 OK.  The full source code for the hello service above is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function get greeting() returns string {  return \"Hello!\";  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal Compiling source  demo.bal  Running executable  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/greeting Hello!   Creating Hierarchical Resources  Hierarchical resources in HTTP services are defined by providing the hierarchical path of the resource as the resource name. The path segments are separated using /. The example below shows how the /base/foo/bar path is represented in an HTTP service resource.  import ballerina/http;  service /base on new http:Listener(8080) {  resource function get foo/bar() returns string {  return \"Hi!\";  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/base/foo/bar Hi!   Defining Resource Path Segments  Resource path segments can be defined with parameters similar to how we define function parameters. This is done with the [<type> <name>] syntax in the path segment. The parameter type must be one of these types: int, string, float, boolean, decimal. Path parameters for the HTTP resource can be defined using this functionality. An example is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function get person/[int id]() returns string {  return string `Person with id ${id}`;  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/person/1001 Person with id 1001   Defining Resource Path Segment Parameters  There can be multiple resource path segment parameters and they can be mixed and located anywhere with general path segments.  A resource path rest parameter can be used to represent zero or more path segments. An example of this is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function get person/[int... ids]() returns string {  return string `Persons with ids ${ids.toString()}`;  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/person/1/2/3 Persons with ids [1,2,3]   This functionality can also be generally used in a situation in which you want to dispatch all requests coming to a certain base path and its subpaths. This can be accomplished by having a [string… paths] resource path rest parameter. An example of this scenario is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function get log/[string... paths]() returns string {  return string `Path: ${paths.toString()}`;  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/log/hello Path: [\"hello\"]  $ curl http://localhost:8080/log/hello/world Path: [\"hello\",\"world\"]  $ curl http://localhost:8080/log/1/2/3 Path: [\"1\",\"2\",\"3\"]   Defining Query Parameters  In a resource function, the query parameters are represented using the resource function parameters. The parameter type must be one of the types: int, string, float, boolean, and decimal. The name of the parameter represents the query parameter name. An example of this functionality is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function get search/[string keyword](int offset,  int size)  returns string {  return string `Search: k=${keyword} o=${offset} s=${size}`;  }  }   The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl \"http://localhost:8080/search/aliens?offset=20&size=10\" Search: k=aliens o=20 s=10   Payload Data Binding  For information on this, see .  Extended Request/Response Access  For information on this, see .  Multipart Message Handling  For information on this, see .  Secure Communication  For information on this, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-services/multipart-message-handling/","name":"Multipart Message Handling","summary":"You can carry out multipart message handling in Ballerina HTTP services.Table of contents      As used in the HTTP , similarly, multipart messages can be created in service resources by using the Multipurpose Internet Mail Extensions (MIME) standard. You can provide MIME entity values to create single or ...","content":"/  /  /  /  /  / Multipart Message Handling  Multipart Message Handling  You can carry out multipart message handling in Ballerina HTTP services.  Table of contents Using MIME Entities  As used in the HTTP , similarly, multipart messages can be created in service resources by using the Multipurpose Internet Mail Extensions (MIME) standard. You can provide MIME entity values to create single or multi-part HTTP messages using the object.  A MIME entity in Ballerina is represented using the object.  Example  The example below shows how to set a text payload in the response using a MIME entity.    Info: The code below explicitly creates the MIME entity and sets it in the HTTP response. The same operation happens if you use the method in the object. These functions are effectively helper functions to set the MIME entities in the HTTP response for often-used content types.   import ballerina/mime; import ballerina/http;  service / on new http:Listener(8080) {  resource function get greeting(http:Caller caller) returns error? {  mime:Entity entity = new;  entity.setText(\"Hello!\", \"text/plain\");  http:Response resp = new;  resp.setEntity(entity);  check caller->respond(resp);  }  }   Execution  The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl http://localhost:8080/greeting Hello!   What’s Next?  For other use cases of HTTP services, see the topics below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-services/payload-data-binding/","name":"Payload Data Binding","summary":"The HTTP service resource payloads can be directly data bound to the resource function parameters.Table of contents      To distinguish between query parameters and resource payload parameters, the parameters that represent the resource payload are annotated with . The supported parameter types are string, json, xml, byte[], record ...","content":"/  /  /  /  /  / Payload Data Binding  Payload Data Binding  The HTTP service resource payloads can be directly data bound to the resource function parameters.  Table of contents Using the Annotation  To distinguish between query parameters and resource payload parameters, the parameters that represent the resource payload are annotated with . The supported parameter types are string, json, xml, byte[], record types, and record array types.  Example  An example of payload data binding is shown below.  import ballerina/http;  service / on new http:Listener(8080) {  resource function post upload/[string name](  @http:Payload byte[] payload)  returns string {  return string `'${name}' uploaded with ${payload.length()} bytes`;  }  }   Execution  The execution of the service and its invocation is shown below.  $ bal run demo.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  $ curl -d \"XXXXXX\" http://localhost:8080/upload/file1 'file1' uploaded with 6 bytes   What’s Next?  For other use cases of HTTP services, see the topics below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/http-services/secure-communication/","name":"Secure Communication","summary":"The HTTP listener can be configured to enable transport security to restrict to HTTPS clients for communication.Table of contents      This is done by providing the optional secureSocket property in the  instance when creating the .The example below shows how an HTTPS service is configured with public ...","content":"/  /  /  /  /  / Secure Communication  Secure Communication  The HTTP listener can be configured to enable transport security to restrict to HTTPS clients for communication.  Table of contents Configuring Secure Communication  This is done by providing the optional secureSocket property in the instance when creating the .  Example of HTTPS Endpoint configured Public Certificate and Private Key  The example below shows how an HTTPS service is configured with public certificate and private key.  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\"  keyFile: \"/path/to/private.key\",  }  } );  service / on securedEP {  resource function get greeting() returns string {  return \"Hello!\";  } }   Example of HTTPS Endpoint configured KeyStore  The example below shows how an HTTPS service is configured with KeyStore.  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  path: \"/path/to/keystore.p12\"  password: \"password\",  }  } );  service / on securedEP {  resource function get greeting() returns string {  return \"Hello!\";  } }   For more information on Ballerina’s authentication/authorization features, see the .  What’s Next?  For other use cases of HTTP services, see the topics below.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/http/","name":"HTTP","summary":"The topics below explain how to process HTTP requests and responses using Ballerina.Table of contents      For information, see .For information, see .This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable ...","content":"/  /  /  / HTTP  HTTP  The topics below explain how to process HTTP requests and responses using Ballerina.  Table of contents Working with HTTP Clients  For information, see .  Working with HTTP Services  For information, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/websocket/","name":"WebSocket","summary":"WebSocket is a low-latency communication protocol used for efficient full-duplex communication between web browsers and servers over TCP. The topics below explain how to implement WebSocket-based services using Ballerina.Table of contents      The first step in WebSocket communication is the HTTP upgrade operation that is carried out in ...","content":"/  /  /  / WebSocket  WebSocket  WebSocket is a low-latency communication protocol used for efficient full-duplex communication between web browsers and servers over TCP. The topics below explain how to implement WebSocket-based services using Ballerina.  Table of contents Upgrading the WebSocket  The first step in WebSocket communication is the HTTP upgrade operation that is carried out in order to switch to WebSocket communication.  In an HTTP Ballerina service, you switch to the WebSocket protocol using an HTTP upgrade operation. This is done by defining a specific HTTP service resource function at the HTTP upgrade path, which returns a WebSocket service implementation.  The example below demonstrates this operation.  import ballerina/http; import ballerina/io; import ballerina/websocket;  service /ws on new websocket:Listener(8080) {  resource function get .(http:Request req)  returns websocket:Service|  websocket:Error {  return new WsService();  }  }   In the example above, /ws is the configured upgrade path, and the WsService instance should have functions defined in the abstract object. These remote functions correspond to the events generated for the WebSocket communication. The sections below describe how these are implemented.  Using Primary Events  These individual events are notified to the user through their own remote functions in the WebSocket Ballerina service.  Connection Creation  The connection creation state is achieved when the WebSocket client establishes a connection after a successful handshake operation. At this moment, the remote function below is called if it is available in the service.  remote function onOpen(websocket:Caller caller);   This remote function provides an instance of a object, which can be used to communicate back with the WebSocket client. This saves the caller object when the connection is created so whenever the application wants to send messages to the connected clients, it can use the stored caller objects to do so.  Connection Creation Example  The example below implements an HTTP service resource to broadcast a message to all the connected WebSocket clients.    Create a ws_connection_creation.bal file with the content below.   Info: In the code below, the first service is bound to an WebSocket listener. The provided request implementation at /ws signals to the system that it is executing an HTTP upgrade to the WebSocket protocol. After the protocol upgrade is done, the WsService service will assume the functionality of a WebSocket service.  import ballerina/http; import ballerina/websocket;  service /ws on new websocket:Listener(8080) {  resource function get .(http:Request req)  returns websocket:Service|  websocket:Error {  return new WsService();  }  }  websocket:Caller[] callers = [];  service class WsService {  *websocket:Service;  remote function onOpen(websocket:Caller caller) {  callers.push(caller);  }  }  service /broadcaster on new http:Listener(8081) {  resource function post broadcast(@http:Payload {} string payload)  returns string|error? {  foreach var targetCaller in callers {  check targetCaller->writeTextMessage(payload);  }  return \"OK\";  } }   Execute the bal run ws_connection_creation.bal command to run the above service. You view the output below.   Compiling source  ws_connection_creation.bal Running executables  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:8081  Open multiple web browser tabs and start the developer tools JavaScript console.  Enter the lines below to create a WebSocket client that connects to our server, registers a callback, and prints any message received from the server.   var ws = new WebSocket(\"ws://localhost:8080/ws\"); ws.onmessage = function(frame) {console.log(frame.data)};   Send an HTTP request to the broadcaster service you deployed to send messages to the WebSocket clients that were stored in your application.   $ curl -d \"Hello!\" http://localhost:8081/broadcaster/broadcast  Now, you view the message above in all the browser tabs you opened with the WebSocket clients.  Sub-Protocol Handling  When a WebSocket connection is created, you can provide a list of sub-protocols that the client can handle in an order of priority. This is done in the following manner when the WebSocket client is created.  var ws = new WebSocket(\"ws://localhost:8080/ws/subscribe\", [\"xml\", \"json\"]);   Sub-protocols are given in the WebSocket constructor’s second parameter, which can be a single string value or an array of strings. In the statement above, you are requesting either xml or json to be used as the protocol.  The server-side will be configured to handle zero or multiple sub-protocols. The server will check the client’s sub-protocol list in the priority order to see if it is supported in the given service. If it finds a match, it will return this single first-matched protocol to the client.  The server-side configuration of sub-protocols is done using the annotation using its subProtocols field.  Sub-Protocol Handling Example  The example below shows the usage of this by updating the created before to negotiate a sub-protocol and print the selected one in connection open.    Create a ws_sub_protocol_handling.bal file with the content below.   Info: In the below code, the service is configured to support json and mqtt sub-protocols.  @websocket:ServiceConfig {  subProtocols: [\"mqtt\", \"json\"],  idleTimeoutInSeconds: 120 } service /ws on new websocket:Listener(8080) {  resource function get .(http:Request req)  returns websocket:Service|  websocket:Error {  return new WsService();  }  }  service class WsService {  *websocket:Service;  remote function onOpen(websocket:Caller caller) {  callers.push(caller);  io:println(\"Negotiated sub-protocol: \",  caller.getNegotiatedSubProtocol());  }  }   Use the WebSocket client created in the above example with xml and json sub-protocols.  Execute the ws_sub_protocol_handling.bal command to run the above service. This will print the following in the standard output of the service execution location when a connection is created.   Info: The service has negotiated to use the json protocol since the client’s highest priority, which is xml is not supported.  Compiling source  ws_sub_protocol_handling.bal Running executables  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080 [ballerina/http] started HTTP/WS listener 0.0.0.0:8081 Negotiated sub-protocol: json  Data Message  A data message is received when a WebSocket client either sends a text or a binary message to a WebSocket service. If available, the remote functions below are called in the service to handle text and binary messages respectively.  remote function onTextMessage(websocket:Caller caller, string text);  remote function onBinaryMessage(websocket:Caller caller, byte[] data);   Data Message Example  The example below demonstrates the data message functionality via a simple WebSocket service class, which echoes the message you send to it.    Create a ws_data_message.bal file with the content below.   service class WsService {  *websocket:Service;  remote function onOpen(websocket:Caller caller) {  callers.push(caller);  io:println(\"Negotiated sub-protocol: \",  caller.getNegotiatedSubProtocol());  }  remote function onTextMessage(websocket:Caller caller,  string text) returns error? {  check caller->writeTextMessage(\"Echo: \" + text);  }  remote function onBinaryMessage(websocket:Caller caller,  byte[] data) returns error? {  check caller->writeBinaryMessage(data);  }  }   Execute the bal run ws_data_message.bal command to run the above service. You view the output below.   Compiling source  ws_data_message.bal Running executables  [ballerina/http] started HTTP/WS listener 0.0.0.0:8080  Now, the program is compiled and the service is up and running at port 8080.  Open up developer tools in a web browser such as Firefox or Chrome.  Type the statements below to create a WebSocket client, and send some data to the server.   var ws = new WebSocket(\"ws://localhost:8080/ws/echo\"); ws.onmessage = function(frame) {console.log(frame.data)}; ws.send(\"Hello!\");    The execution of this command results in the message below printed in the console. This is the response returned from the WebSocket service.   Echo: Hello!  Control Message  A WebSocket contains two control messages: ping and pong. A WebSocket server or a client can send a ping message, and the opposite side should respond with a corresponding pong message by returning the same payload sent with the ping message. These ping/pong sequences are used as a heartbeat mechanism to check if the connection is healthy.  You not need to explicitly control these messages as they are handled automatically by the services and clients. However, if required, you can override the default implementations of the ping/pong messages. This is done by providing implementations to the remote functions below in a WebSocket service.  remote function onPing(websocket:Caller caller, byte[] data);  remote function onPong(websocket:Caller caller, byte[] data);   Control Message Example  An example implementation of the ping/pong functions is shown below.  remote function onPing(websocket:Caller caller,  byte[] data) returns error? {  io:println(string `Ping received with data: ${data.toBase64()}`);  check caller->pong(data); }  remote function onPong(websocket:Caller caller,  byte[] data) {  io:println(string `Pong received with data: ${data.toBase64()}`); }   Connection Error  In the event of an error in the WebSocket connection, the connection will be closed automatically by generating the required connection close frame. The remote function below can be implemented in the service to receive the notification that this is going to happen and perform any possible cleanup or custom logging operations.  remote function onError(websocket:Caller caller, error err);   Connection Close  If the connection is closed from the client-side, the service will be notified by calling the remote function below.  remote function onClose(websocket:Caller caller, int statusCode,  string reason);   Connection Close Example  An example implementation of this remote function, which logs the information about the connection closure is shown below.  remote function onClose(websocket:Caller caller, int statusCode,  string reason) {  io:println(string `Client closed connection with ${statusCode} because of ${reason}`); }   Securing WebSocket Communication  For information on this, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/network-communication/websocket/securing-websocket-communication/","name":"Securing WebSocket Communication","summary":"Whenever possible, you should use WebSocket with TLS. This makes sure that your data communication is secure through the network.Table of contents      For your WebSocket service to be compatible with this approach, you can configure a secure socket for your WebSocket listener. This WebSocket listener is the ...","content":"/  /  /  /  / Securing WebSocket Communication  Securing WebSocket Communication  Whenever possible, you should use WebSocket with TLS. This makes sure that your data communication is secure through the network.  Table of contents Configuring a Secure Socket  For your WebSocket service to be compatible with this approach, you can configure a secure socket for your WebSocket listener. This WebSocket listener is the one used in the , so it will be upgrading a TCP connection with TLS.  Afterward, in your WebSocket client, you can use the wss protocol scheme to connect to a secure WebSocket server. An example of a secure WebSocket client initialization is shown below.  var ws = new WebSocket(\"wss://localhost:8443/ws\");   Securing WebSocket Communication Example    Create a wss_service.bal file with the content below.   Info: This updates your initial WebSocket echo service to enable TLS on the communication channel.  listener websocket:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\"  keyFile: \"/path/to/private.key\",  }  }  );  service /ws on securedEP {  resource function get .(http:Request req) returns websocket:Service|websocket:UpgradeError {  return new WsService();  }  }  service class WsService {  *websocket:Service;  remote function onTextMessage(websocket:Caller caller, string text) returns websocket:Error? {  check caller->writeTextMessage(\"Echo: \" + text);  }  }   Execute the commands below to run the above service.   $ ballerina run wss_service.bal  You view the output below.   Compiling source  wss_service.bal  Running executables  [ballerina/websocket] started WSS listener 0.0.0.0:9090  In the code above, you simply created a WebSocket listener by providing the , which contains the secure socket parameters.  Write a Ballerina WebSocket client (wss_client.bal) below to make a connection and send requests to the service above.   Info: As you are using a self-signed certificate in this example, web browsers will generally reject secure WebSocket connections.  import ballerina/io;  import ballerina/websocket; public function main() returns error? {  websocket:Client wsClient = check new (\"wss://localhost:8443/ws\",  secureSocket = {  cert: \"/path/to/public.crt\"  }  );  _ = check wsClient->writeTextMessage(\"Hello, World!\");  string response = check wsClient->readTextMessage();  io:println(response);  }   Execute the commands below to run the above client.   $ bal run wss_client.bal  You view the output below.   Compiling source  wss_client.bal  Running executable  Response: Echo: Hello, World!  In the code above, you created a by providing the value containing the secure socket parameters. From here onwards, any communication done from the client to the WebSocket server will be done with TLS.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/publishing-packages-to-ballerina-central/","name":"Publishing Packages to Ballerina Central","summary":"The sections below include information about publishing packages to Ballerina Central.Table of contents      Pushing a package uploads it to .Before you push your package, the following has to be done.For steps to build a Ballerina archive, see .To get your token, register on Ballerina Central and visit ...","content":"/  /  / Publishing Packages to Ballerina Central  Publishing Packages to Ballerina Central  The sections below include information about publishing packages to Ballerina Central.  Table of contents The CLI Command  Pushing a package uploads it to .  $ cd myFirstPackage $ bal push   Setting Up  Before you push your package, the following has to be done.    You must generate the Ballerina archive of the package.   For steps to build a Ballerina archive, see .    You must enter your Ballerina Central access token in Settings.toml in your home repository (<USER_HOME>/.ballerina/).   To get your token, register on Ballerina Central and visit the user dashboard at .  If you are connected to the internet via an HTTP proxy, add the following section to Settings.toml and change accordingly.  [proxy] host = \"localhost\" port = \"3128\" username = \"\" password = \"\"   To successfully push your package, your package should contain Package.md file containing an overview of the package.  Organizations  When you push a package to Ballerina Central, the runtime validates organizations for the user against the org defined in your package’s Ballerina.toml file. Therefore, when you have more than one organization in Ballerina Central, be sure to pick the organization name that you intend to push the package into and set that as the org in the Ballerina.toml file inside the package directory.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/observing-ballerina-code/","name":"Observing Ballerina Code","summary":"Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs.Table of contents      Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide observability. Ballerina becomes fully observable by ...","content":"/  /  / Observing Ballerina Code  Observing Ballerina Code  Observability is a measure of how well internal states of a system can be inferred from knowledge of its external outputs.  Table of contents Providing Observability in Ballerina  Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system to provide observability. Ballerina becomes fully observable by exposing itself via these three methods to various external systems allowing to monitor metrics such as request count and response time statistics, analyze logs, and perform distributed tracing.  HTTP/HTTPS based Ballerina services and any client connectors are observable by default. HTTP/HTTPS and SQL client connectors use semantic tags to make tracing and metrics monitoring more informative.  This guide focuses on enabling Ballerina service observability with some of its supported systems.  and are used for metrics monitoring, and is used for distributed tracing. Ballerina logs can be fed to any external log monitoring system like to perform log monitoring and analysis.  Observing a Ballerina Service  Follow the steps below to observe a sample Ballerina service.  Step 1 - Setting up the Prerequisites  Make sure you have already installed to set up external products such as Jaeger, Prometheus, etc. You can follow to install Docker.  Step 2 - Installing and Configuring the External Systems    Set up Prometheus for collecting metrics information by following the section on Set up Grafana to visualize metrics by following the section on Set up Jaeger analyze tracing as mentioned in the section Set up Elastic Stack only if you are interested in analysing logs by following the section on Step 3 - Creating a ‘Hello World’ Ballerina Service  Create a Service as shown below and save it as hello_world_service.bal.  import ballerina/http; import ballerina/log; import ballerinax/prometheus as _; import ballerinax/jaeger as _;  service /hello on new http:Listener(9090) {  resource function get sayHello(http:Caller caller, http:Request req) returns error? {  log:printInfo(\"This is a test Info log\");  log:printError(\"This is a test Error log\");  http:Response res = new;  res.setPayload(\"Hello, World!\");  check caller->respond(res);  }  }   Step 4 - Observing the ‘Hello World’ Ballerina Service  By default, observability is not included in the executable created by Ballerina. It can be added by using the –observability-included build flag or by adding the following section to the Ballerina.toml file.  [build-options] observabilityIncluded=true   To include the Prometheus and Jaeger extensions into the executable, the ballerinax/prometheus and ballerinax/jaeger modules need to be imported in your Ballerina code.  import ballerinax/prometheus as _; import ballerinax/jaeger as _;   Observability is disabled by default at runtime as well and it can be enabled selectively for metrics and tracing by adding the following runtime configurations to the Config.toml file.  [ballerina.observe] metricsEnabled=true metricsReporter=\"prometheus\" tracingEnabled=true tracingProvider=\"jaeger\"   The created configuration file can be passed to the Ballerina program with the BAL_CONFIG_FILES environment variable along with the path of the configuration file.  $ BAL_CONFIG_FILES=<path-to-conf>/Config.toml bal run --observability-included hello_world_service.bal  [ballerina/http] started HTTP/WS listener 0.0.0.0:9797 ballerina: started Prometheus HTTP listener 0.0.0.0:9797 ballerina: started publishing traces to Jaeger on localhost:55680 [ballerina/http] started HTTP/WS listener 0.0.0.0:9090   When Ballerina observability is enabled, the Ballerina runtime exposes internal metrics via an HTTP endpoint for metrics monitoring and traces will be published to Jaeger. Prometheus should be configured to scrape metrics from the metrics HTTP endpoint in Ballerina.  Ballerina logs are logged on the console. Therefore, the logs need to be redirected to a file, which can then be pushed to to perform the log analysis.  Therefore, redirect the standard output to a file if you want to monitor logs.  $ BAL_CONFIG_FILES=<path-to-conf>/Config.toml nohup bal run --observability-included hello_world_service.bal > ballerina.log &   Step 5 - Sending Few Requests  Send few requests to Example cURL command:  $ curl http://localhost:9090/hello/sayHello   Step 6 - Viewing Tracing and Metrics in the Dashboard  View the tracing information on Jaeger via and view metrics information from the Grafana dashboard on .  Sample view of Jaeger dashboard for hello_world_service.bal is shown below. Sample view of Grafana dashboard for hello_world_service.bal is shown below. Step 7 - Visualizing the Logs  If you have configured log analytics, view the logs in Kibana via Monitoring Metrics Metrics help to monitor the runtime behavior of a service. Therefore, metrics are a vital part of monitoring Ballerina services. However, metrics are not the same as analytics. For example, you should not use metrics to do something like per-request billing. Metrics are used to measure what Ballerina service does at runtime to make better decisions using the numbers. The code generates business value when it continuously runs in production. Therefore, it is imperative to continuously measure the code in production.  In order to support Prometheus as the metrics reporter, an HTTP endpoint starts with the context of /metrics in default port 9797 when starting the Ballerina service.  Configuring Advanced Metrics for Ballerina This section focuses on the Ballerina configurations that are available for metrics monitoring with Prometheus, and the sample configuration is provided below.  [ballerina.observe] metricsEnabled=true metricsReporter=\"prometheus\"  [ballerinax.prometheus] port=9797 host=\"0.0.0.0\"   The descriptions of each configuration above are provided below with possible alternate options.    Configuration Key  Description  Default Value  Possible Values  ballerina.observe. metricsEnabled  Whether metrics monitoring is enabled (true) or disabled (false)  false  true or false  ballerina.observe. metricsReporter  Reporter name that reports the collected Metrics to the remote metrics server. This is only required to be modified if a custom reporter is implemented and needs to be used.  choreo  prometheus or if any custom implementation, the name of the reporter.  ballerinax.prometheus. port  The value of the port in which the service ‘/metrics’ will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service.  9797  Any suitable value for port 0 - 0 - 65535. However, within that range, ports 0 - 1023 are generally reserved for specific purposes, therefore it is advisable to select a port without that range.  ballerinax.prometheus. host  The name of the host in which the service ‘/metrics’ will bind to. This service will be used by Prometheus to scrape the information of the Ballerina service.  0.0.0.0  IP or Hostname or 0.0.0.0 of the node in which the Ballerina service is running.  Setting Up the External Systems for Metrics There are mainly two systems involved in collecting and visualizing the metrics. is used to collect the metrics from the Ballerina service and can connect to Prometheus and visualize the metrics in the dashboard.  Setting Up Prometheus  is used as the monitoring system, which pulls out the metrics collected from the Ballerina service ‘/metrics’. This section focuses on the quick installation of Prometheus with Docker and configures it to collect metrics from the Ballerina service with default configurations. Follow the steps below to configure Prometheus.    Tip: There are many other ways to install the Prometheus and you can find possible options from .     Create a prometheus.yml file in the /tmp/ directory.  Add the following content to /tmp/prometheus.yml.  global:  scrape_interval: 15s  evaluation_interval: 15s  scrape_configs:  - job_name: 'prometheus'  static_configs:  - targets: ['a.b.c.d:9797']   Here the targets 'a.b.c.d:9797' should contain the host and port of the /metrics service that’s exposed from Ballerina for metrics collection. Add the IP of the host in which the Ballerina service is running as a.b.c.d and its port (default 9797). If you need more information, go to the .  If your Ballerina service is running on localhost and Prometheus in a Docker container, add the target as host.docker.internal:9797 to access the localhost from Docker.    Start the Prometheus server in a Docker container with the command below.   $ docker run -p 19090:9090 -v /tmp/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus     Go to and check whether you can see the Prometheus graph. Ballerina metrics should appear in Prometheus graph’s metrics list when Ballerina service is started.   Setting Up Grafana Let’s use to visualize metrics in a dashboard. For this, we need to install Grafana, and configure Prometheus as a data source. Follow the steps below to configure Grafana.    Start Grafana as a Docker container with the command below.   $ docker run -d --name=grafana -p 3000:3000 grafana/grafana  For more information, go to .    Go to to access the Grafana dashboard running on Docker.  Log in to the dashboard with the default user, username: admin and password: admin  Add Prometheus as a data source with Browser access configuration as provided below.  Import the Grafana dashboard designed to visualize Ballerina metrics from . This dashboard consists of service and client invocation level metrics in near real-time view.   Ballerina HTTP Service Metrics Dashboard Panel will be as below.   Ballerina HTTP Client Metrics Dashboard Panel will be as below.   Ballerina SQL Client Metrics Dashboard Panel will be as below.   Distributed Tracing  Tracing provides information regarding the roundtrip of a service invocation based on the concept of spans, which are structured in a hierarchy based on the cause and effect concept. A trace can spread across several services that can be deployed in several nodes, depicting a high-level view of interconnections among services as well, hence coining the term distributed tracing.  A span is a logical unit of work, which encapsulates a start and end time as well as metadata to give more meaning to the unit of work being completed. For example, a span representing a client call to an HTTP endpoint would give the user the latency of the client call and metadata like the HTTP URL being called and HTTP method used. If the span represents an SQL client call, the metadata would include the query being executed.  Tracing gives the user a high-level view of how a single service invocation is processed across several distributed microservices.    Identify service bottlenecks - The user can monitor the latencies and identify when a service invocation slows down, pinpoint where the slowing down happens (by looking at the span latencies) and take action to improve the latency.  Error identification - If an error occurs during the service invocation, it will show up in the list of traces. The user can easily identify where the error occurred and information of the error will be attached to the relevant span as metadata.   Ballerina supports standards by default. This means that Ballerina services can be traced using OpenTelemetry implementations like .  Configuring Advanced Tracing for Ballerina  Tracing can be enabled in Ballerina with the few configurations as mentioned in the . This section mainly focuses on the configuration options with the description and possible values.  The sample configuration that enables tracing and uses Jaeger as the tracer as provided below.  [ballerina.observe] tracingEnabled=true tracingProvider=\"jaeger\"   The table below provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  ballerina.observe.tracingEnabled  Whether tracing is enabled (true) or disabled (false)  false  true or false  ballerina.observe.tracingProvider  The tracer name, which implements the tracer interface.  choreo  jaeger or the name of the tracer of any custom implementation.  Using the Jaeger Client The below are the sample configuration options that are available to support Jaeger as the tracer provider in Ballerina.  [ballerina.observe] tracingEnabled=true tracingProvider=\"jaeger\"  [ballerinax.jaeger] agentHostname=\"localhost\" agentPort=55680 samplerType=\"const\" samplerParam=1.0 reporterFlushInterval=2000 reporterBufferSize=1000   The table below provides the descriptions of each configuration option and possible values that can be assigned.    Configuration Key  Description  Default Value  Possible Values  ballerina.observe. agentHostname  Hostname of the Jaeger agent  localhost  IP or hostname of the Jaeger agent. If it is running on the same node as Ballerina, it can be localhost.  ballerina.observe. agentPort  Port of the Jaeger agent  55680  The port on which the Jaeger agent is listening.  ballerina.observe. samplerType  Type of the sampling methods used in the Jaeger tracer.  const  const, probabilistic, or ratelimiting.  ballerina.observe. samplerParam  It is a floating value. Based on the sampler type, the effect of the sampler param varies  1.0  For const 0 (no sampling) or 1 (sample all spans), for probabilistic 0.0 to 1.0, for ratelimiting any positive integer (rate per second).  ballerina.observe. reporterFlushInterval  The Jaeger client will be sending the spans to the agent at this interval.  2000  Any positive integer value.  ballerina.observe. reporterBufferSize  Queue size of the Jaeger client.  2000  Any positive integer value.  Setting Up the External Systems for Tracing You can configure Ballerina to support distributed tracing with Jaeger. This section focuses on configuring Jaeger with Docker as a quick installation.  Setting Up the Jaeger Server There are many possible ways to deploy Jaeger. For more information, see . This focuses on an all-in-one deployment with Docker.    Install Jaeger via Docker and start the Docker container by executing command below.   $ docker run -d -p 13133:13133 -p 16686:16686 -p 55680:55680 jaegertracing/opentelemetry-all-in-one     Go to and load the web UI of the Jaeger to make sure it is functioning properly.   The image below is the sample tracing information you can see from Jaeger.    Distributed Logging Ballerina distributed logging and analysis is supported by Elastic Stack. Ballerina has a log module for logging in to the console. In order to monitor the logs, the Ballerina standard output needs to be redirected to a file.  This can be done by running the Ballerina service as below.  $ nohup bal run hello_world_service.bal > ballerina.log &   You can view the logs with the command below.  $ tail -f ~/wso2-ballerina/workspace/ballerina.log   Setting Up the External Systems for Log Analytics  Setting Up Elastic Stack The elastic stack comprises of the following components.    Beats - Multiple agents that ship data to Logstash or Elasticsearch. In our context, Filebeat will ship the Ballerina logs to Logstash. Filebeat should be a container running on the same host as the Ballerina service. This is so that the log file (ballerina.log) can be mounted to the Filebeat container.  Logstash - Used to process and structure the log files received from Filebeat and send them to Elasticsearch.  Elasticsearch - Storage and indexing of the logs received by Logstash.  Kibana - Visualizes the data stored in Elasticsearch   Elasticsearch and Kibana are provided as Alternatively, Docker containers can be used to set up Elasticsearch and Kibana as well.    Download the Docker images using the following commands.   # Elasticsearch Image $ docker pull docker.elastic.co/elasticsearch/elasticsearch:6.5.1 # Kibana Image $ docker pull docker.elastic.co/kibana/kibana:6.5.1 # Filebeat Image $ docker pull docker.elastic.co/beats/filebeat:6.5.1 # Logstash Image $ docker pull docker.elastic.co/logstash/logstash:6.5.1     Start Elasticsearch and Kibana containers by executing the following commands.   $ docker run -p 9200:9200 -p 9300:9300 -it -h elasticsearch --name elasticsearch docker.elastic.co/elasticsearch/elasticsearch:6.5.1 $ docker run -p 5601:5601 -h kibana --name kibana --link elasticsearch:elasticsearch docker.elastic.co/kibana/kibana:6.5.1   If you run on Linux you may have to increase the vm.max_map_count for the Elasticsearch container to start. Execute the following command to do that.  $ sudo sysctl -w vm.max_map_count=262144     Create a logstash.conf file in the /tmp/pipeline/ directory and include the following content in the file.   input {  beats {  port => 5044  } } filter {  grok {  match => { \"message\" => \"%{TIMESTAMP_ISO8601:date}%{SPACE}%{WORD:logLevel}%{SPACE}\\[%{GREEDYDATA:module}\\]%{SPACE}\\-%{SPACE}%{GREEDYDATA:logMessage}\"}  } } output {  elasticsearch {  hosts => \"elasticsearch:9200\"  index => \"ballerina\"  document_type => \"ballerina_logs\"  } }   Here the 3 stages are specified in the pipeline. Input is specified as beats and listens to port 5044. A grok filter is used to structure the Ballerina logs and the output is specified to push to Elasticsearch on elasticsearch:9200.    Start the Logstash container by the following command.   $ docker run -h logstash --name logstash --link elasticsearch:elasticsearch -it --rm -v /tmp/pipeline:/usr/share/logstash/pipeline/ -p 5044:5044 docker.elastic.co/logstash/logstash:6.5.1     Configure Filebeat to ship the Ballerina logs. Create a filebeat.yml file in the /tmp/ directory and include the following content in the file.   filebeat.prospectors: - type: log  paths:  - /usr/share/filebeat/ballerina.log output.logstash:  hosts: [\"logstash:5044\"]     Start the Filebeat container with the following command.   The -v flag is used for bind mounting, where the container will read the file from the host machine. Provide the path to the ballerina.log file, to be bind-mounted to the filebeat container.  $ docker run -v /tmp/filebeat.yml:/usr/share/filebeat/filebeat.yml -v /<path-to-ballerina.log>/ballerina.log:/usr/share/filebeat/ballerina.log --link logstash:logstash docker.elastic.co/beats/filebeat:6.5.1     Access Kibana to visualize the logs at . Add an index named ballerina and click on Discover to visualize the logs.     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/running-ballerina-code/","name":"Running Ballerina Code","summary":"The sections below include information on running Ballerina programs.Table of contents      A Ballerina application can have:A  function that runs as a terminating process.A , which is a hosted non-terminating process.Both of these are considered as entry points for program execution.These applications can be structured into a ...","content":"/  /  / Running Ballerina Code  Running Ballerina Code  The sections below include information on running Ballerina programs.  Table of contents Understanding the Structure  A Ballerina application can have:    A function that runs as a terminating process.  A , which is a hosted non-terminating process.  Both of these are considered as entry points for program execution.  These applications can be structured into a single program file or a Ballerina module. A collection of modules can be managed together with versioning and dependency management as part of a Ballerina package.  Source files and modules can contain zero or more entry points, and the runtime engine has precedence and sequence rules for choosing which entry point to execute.    Running Standalone Source Code  A single Ballerina source code file can be placed into any folder.  If the source file contains at least one entry point, it can be executed using the run command.  $ bal run foo.bal   You can compile a source file with an entry point into an executable JAR.  $ bal build [-o outputfilename.jar] foo.bal   You can run .jar files directly:  $ bal run filename.jar   Running a Package A package is a folder that manages modules as part of common versioning, dependency management, build, and execution. You can build and run items collectively or individually as modules. See for in-depth structuring of packages.  Running a Ballerina package:  $ bal run myFirstPackage $ bal run <ballerina-package-path>   Building a Ballerina package:  $ bal build myFirstPackage $ bal build <ballerina-package-path>   Alternatively, you can cd into the Ballerina package and run:  $ bal build   Building a Ballerina package will generate a .jar inside the target/bin/ of the package directory.  You can run the .jar file directly:  $ bal run target/bin/testPackage.jar   Options for running programs with entry points in a package:  $ bal run main.bal $ bal run main.jar   Configuring Your Ballerina Runtimes  Ballerina Runtime Configurable Variables  A Ballerina runtime can be configured using configurable variables. The values for configurable variables can be provided through command-line parameters and configuration files.  When loading the values to the configurable variables, command-line arguments get the higher precedence than the configuration TOML files. For more details, see .  Consider the following example, which uses configurable variables.  import ballerina/io;  configurable int id = ?; configurable string name = \"Ann\"; configurable boolean married = true;  public function main() {  io:println(\"User ID : \", id);  io:println(\"User Name : \", name);  io:println(\"Married : \", married); }   ? denotes that id is a required configuration. Hence, the configuration must specify a value for the id key. If a default value is assigned, the configuration is optional. Hence, the configuration may or may not contain values for the name and married configurable variables.  Consider the below Config.toml file.  id = 1001 name = \"Jhone\"   Since the Config.toml file contains a value for the name key, the program default value will be overridden by the value in the Config.toml file.  $ bal run main.bal User ID : 1001 User Name : Jhone Married : true   When running a program with configurable values, Ballerina locates the TOML files in the following ways:    From an environment variable with the name BAL_CONFIG_FILES that provides a list of paths to the TOML files separated by the OS-specific separator. The file precedence order will be as specified in the environment variable.  From an environment variable with the name BAL_CONFIG_DATA that contains the content of the configuration TOML file.  If the above environment variables are not specified, the configuration file is located in the current directory with the file name Config.toml by default.  Currently, TOML-based configuration is supported for configurable variables of types int, float, boolean, string, decimal, the arrays of the respective types, and table.  In the example below, you can set the path to the Config.toml file using the following command.  $ export BAL_CONFIG_FILES = <path> $ bal run main.bal User ID : 1001 User Name : Jhone Married : true   It is possible to provide the values for configurable variables through command-line arguments in the format of -Ckey=value. The key of a command-line argument can be specified as,  key:= [[org-name .] module-name .] variable   The org-name and module-name is optional for the variable defined in the root module or in a single Ballerina file. Currently, command-line-based configuration is supported for configurable variables of types int, float, boolean, string, decimal, and xml.  In the example below, you can use the following command to pass values from the command-line.  $ bal run main.bal -- -Cid=1001 -Cname=Jhone -Cmarried=true User ID : 1001 User Name : Jhone Married : true   Configuring Sensitive Data as Configurable Variables  You can provide sensitive data to configurable variables through a separate TOML file and specify it using the BAL_CONFIG_FILES environment variable with higher priority.  For in-depth details, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/security/http-client-authentication/","name":"HTTP Client Authentication","summary":"Ballerina HTTP clients can be configured to enforce authentication.Table of contents      The Ballerina HTTP client can be configured to send authentication information to the endpoint being invoked. Ballerina has built-in support for the following client authentication mechanisms.The following example represents how an HTTP client can be configured ...","content":"/  /  /  / HTTP Client Authentication  HTTP Client Authentication  Ballerina HTTP clients can be configured to enforce authentication.  Table of contents The Ballerina HTTP client can be configured to send authentication information to the endpoint being invoked. Ballerina has built-in support for the following client authentication mechanisms.    Basic authentication  JWT authentication  OAuth2 authentication   The following example represents how an HTTP client can be configured to call a secured endpoint. The auth field of the client configurations (http:ClientConfiguration) should have either one of the http:CredentialsConfig, http:BearerTokenConfig, http:JwtIssuerConfig, http:OAuth2ClientCredentialsGrantConfig, http:OAuth2PasswordGrantConfig, and http:OAuth2RefreshTokenGrantConfig records.  import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  // ...  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );   Basic Auth  Ballerina supports Basic Authentication for clients. The auth field of the client configurations (http:ClientConfiguration) should have the http:CredentialsConfig record.  The http:CredentialsConfig configurations include:    username - The username for Basic authentication  password - The password for Basic authentication   import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"alice\",  password: \"123\"  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }   Self-Signed JWT Auth  Ballerina supports self-signed JWT Authentication for clients. The auth field of the client configurations (http:ClientConfiguration) should have the http:JwtIssuerConfig record.  The http:JwtIssuerConfig configurations include:    username - JWT username, which is mapped to the sub  issuer - JWT issuer, which is mapped to the iss  audience - JWT audience, which is mapped to the aud  jwtId - JWT ID, which is mapped to the jti  keyId - JWT key ID, which is mapped to the kid  customClaims - Map of custom claims  expTime - Expiry time in seconds  signatureConfig - JWT signature configurations  algorithm - Cryptographic signing algorithm for JWS  jwt:RS256 - The RSA-SHA256 algorithm  jwt:RS384 - The RSA-SHA384 algorithm  jwt:RS512 - The RSA-SHA512 algorithm  jwt:NONE - Unsecured JWTs (no signing)  config - KeyStore configurations or private key configurations  keyStore - KeyStore to be used in JWT signing  keyAlias - Signing key alias  keyPassword - Signing key password  — OR —  keyFile - Private key to be used in JWT signing  keyPassword - Password of the private key (if encrypted)  import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  username: \"ballerina\",  issuer: \"wso2\",  audience: [\"ballerina\", \"ballerina.org\", \"ballerina.io\"],  jwtId: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\",  keyId: \"5a0b754-895f-4279-8843-b745e11a57e9\",  customClaims: { \"scp\": \"hello\" },  expTime: 3600,  signatureConfig: {  algorithm: jwt:RS256,  config: {  keyFile: \"/path/to/private.key\",  }  }  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }   Bearer Token Auth  Ballerina supports Bearer Token Authentication for clients. The auth field of the client configurations (http:ClientConfiguration) should have the http:BearerTokenConfig record.  The http:BearerTokenConfig configurations include:    token - Bearer token for authentication   import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  token: \"JlbmMiOiJBMTI4Q0JDLUhTMjU2In\"  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }   OAuth2  Ballerina supports Basic Authentication for clients. It supports the client credentials grant type, password grant type, and refresh token grant type, in which, the credentials can be provided manually, and after that refreshing is handled internally. The auth field of the client configurations (http:ClientConfiguration) should have either one of the http:OAuth2ClientCredentialsGrantConfig, http:OAuth2PasswordGrantConfig, or http:OAuth2RefreshTokenGrantConfig records.  Client Credentials Grant Type  The http:OAuth2ClientCredentialsGrantConfig configurations include:    tokenUrl - Token URL for the authorization endpoint  clientId - Client ID for the client credentials grant authentication  clientSecret - Client secret for the client credentials grant authentication  scopes - Scope(s) of the access request  defaultTokenExpTime - Expiration time (in seconds) of the tokens if the authorization server response does not contain an expires_in field  clockSkew - Clock skew (in seconds) that can be used to avoid token validation failures due to clock synchronization problems  optionalParams - Map of optional parameters to be used for the authorization endpoint  credentialBearer - Bearer of the authentication credentials, which is sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which are used to call the authorization endpoint  httpVersion - The HTTP version of the client  customHeaders - The list of custom HTTP headers  customPayload - The list of custom HTTP payload parameters  auth - The client auth configurations  oauth2:ClientCredentialsGrantConfig  oauth2:PasswordGrantConfig  oauth2:RefreshTokenGrantConfig  secureSocket - SSL/TLS-related configurations  disable - Disable SSL validation  cert - Configurations associated with the crypto:TrustStore or single certificate file that the client trusts  key - Configurations associated with the crypto:KeyStore or a combination of the certificate and private key of the client  import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9090/oauth2/token\",  clientId: \"s6BhdRkqt3\",  clientSecret: \"7Fjfp0ZBr1KtDRbnfVdmIw\",  scopes: [\"hello\"],  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }   Password Grant Type  The http:OAuth2PasswordGrantConfig configurations include:    tokenUrl - Token URL for the authorization endpoint  username - Username for the password grant authentication  password - Password for the password grant authentication  clientId - Client ID for the password grant authentication  clientSecret - Client secret for the password grant authentication  scopes - Scope(s) of the access request  refreshConfig - Configurations for refreshing the access token  refreshUrl - Refresh token URL for the refresh token server  scopes - Scope(s) of the access request  optionalParams - Map of optional parameters to be used for the authorization endpoint  credentialBearer - Bearer of the authentication credentials, which is sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which are used to call the authorization endpoint  defaultTokenExpTime - Expiration time (in seconds) of the tokens if the authorization server response does not contain an expires_in field  clockSkew - Clock skew (in seconds) that can be used to avoid token validation failures due to clock synchronization problems  optionalParams - Map of optional parameters to be used for the authorization endpoint  credentialBearer - Bearer of the authentication credentials, which is sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which are used to call the authorization endpoint  httpVersion - The HTTP version of the client  customHeaders - The list of custom HTTP headers  customPayload - The list of custom HTTP payload parameters  auth - The client auth configurations  oauth2:ClientCredentialsGrantConfig  oauth2:PasswordGrantConfig  oauth2:RefreshTokenGrantConfig  secureSocket - SSL/TLS-related configurations  disable - Disable SSL validation  cert - Configurations associated with the crypto:TrustStore or single certificate file that the client trusts  key - Configurations associated with the crypto:KeyStore or a combination of the certificate and private key of the client  import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  tokenUrl: \"https://localhost:9090/oauth2/token\",  username: \"admin\",  password: \"123\",  clientId: \"s6BhdRkqt3\",  clientSecret: \"7Fjfp0ZBr1KtDRbnfVdmIw\",  scopes: [\"hello\"],  refreshConfig: {  refreshUrl: \"https://localhost:9090/oauth2/token/refresh\",  scopes: [\"hello\"],  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  }  },  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }   Refresh Token Grant Type  The http:OAuth2RefreshTokenGrantConfig configurations include:    refreshUrl - Refresh token URL for the refresh token server  refreshToken - Refresh token for the refresh token server  clientId - Client ID for authentication against the authorization endpoint  clientSecret - Client secret for authentication against the authorization endpoint  scopes - Scope(s) of the access request  defaultTokenExpTime - Expiration time (in seconds) of the tokens if the authorization server response does not contain an expires_in field  clockSkew - Clock skew (in seconds) that can be used to avoid token validation failures due to clock synchronization problems  optionalParams - Map of optional parameters to be used for the authorization endpoint  credentialBearer - Bearer of the authentication credentials, which is sent to the authorization endpoint  http:AUTH_HEADER_BEARER - Indicates that the authentication credentials should be sent via the Authentication Header  http:POST_BODY_BEARER - Indicates that the Authentication credentials should be sent via the body of the POST request  clientConfig - HTTP client configurations, which are used to call the authorization endpoint  httpVersion - The HTTP version of the client  customHeaders - The list of custom HTTP headers  customPayload - The list of custom HTTP payload parameters  auth - The client auth configurations  oauth2:ClientCredentialsGrantConfig  oauth2:PasswordGrantConfig  oauth2:RefreshTokenGrantConfig  secureSocket - SSL/TLS-related configurations  disable - Disable SSL validation  cert - Configurations associated with the crypto:TrustStore or single certificate file that the client trusts  key - Configurations associated with the crypto:KeyStore or a combination of certificate and private key of the client  import ballerina/http; import ballerina/log;  http:Client securedEP = check new(\"https://localhost:9090\",  auth = {  refreshUrl: \"https://localhost:9090/oauth2/token/refresh\",  refreshToken: \"tGzv3JOkF0XG5Qx2TlKWIA\",  clientId: \"s6BhdRkqt3\",  clientSecret: \"7Fjfp0ZBr1KtDRbnfVdmIw\",  scopes: [\"hello\"],  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  }  },  secureSocket = {  cert: \"/path/to/public.crt\"  } );  public function main() {  // Send a `GET` request to the specified endpoint.  http:Response|http:ClientError response = securedEP->get(\"/foo/bar\");  if (response is http:Response) {  log:print(response.statusCode.toString());  } else {  log:printError(\"Failed to call the endpoint.\", 'error = response);  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/security/http-listener-authentication-and-authorization/","name":"HTTP Listener Authentication and Authorization","summary":"Ballerina HTTP services/resources can be configured to enforce authentication and authorization.Table of contents      The Ballerina HTTP services/resources can be configured to authenticate and authorize the inbound requests. Ballerina has built-in support for the following listener authentication mechanisms.The example below represents how a service can be secured. The ...","content":"/  /  /  / HTTP Listener Authentication and Authorization  HTTP Listener Authentication and Authorization  Ballerina HTTP services/resources can be configured to enforce authentication and authorization.  Table of contents The Ballerina HTTP services/resources can be configured to authenticate and authorize the inbound requests. Ballerina has built-in support for the following listener authentication mechanisms.    Basic authentication  JWT authentication  OAuth2 authentication   The example below represents how a service can be secured. The http:ServiceConfig annotation should have an auth field, which is an array of elements consisting of http:FileUserStoreConfigWithScopes, http:LdapUserStoreConfigWithScopes, http:JwtValidatorConfigWithScopes, or http:OAuth2IntrospectionConfigWithScopes records. Each of these records consists of a record specific configuration (http:FileUserStoreConfig, http:LdapUserStoreConfig, http:JwtValidatorConfig, http:OAuth2IntrospectionConfig in this order) and an optional field, which consists of a string or string[]. The record-specific configuration is used for authentication and the optional field can be used for authorization.  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  @http:ServiceConfig {  auth: [  // ...  ] } service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }   The auth array field may have one or more elements. If any of the elements get succeeded with authentication and authorization, the request will get the chance to invoke the API. The aforementioned optional field (scopes), which is there inside each and every element of the auth field may also have one or more elements.  These concepts are applied to the http:ResourceConfig annotation as well. The example below represents how a resource can be secured.  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  service /foo on securedEP {   @http:ResourceConfig {  auth: [  // ...  ]  }  resource function get bar() returns string {  return \"Hello, World!\";  } }   Also, the security enforcement that is done for the service using the http:ServiceConfig can be overridden by the http:ResourceConfig annotation for a specific API(s).    Note: It is required to use HTTPS when enforcing authentication and authorization checks to ensure the confidentiality of sensitive authentication data.   Basic Auth  File User Store  Ballerina supports the file user store basic authentication and authorization for services/resources. The auth field of a service/resource annotation should have an http:FileUserStoreConfigWithScopes record as an element. If the fileUserStoreConfig field is assigned with the http:FileUserStoreConfig implementation, the authentication will be evaluated. Optionally, you can have the string|string[] value for the scopes field also. Then, the authorization will be evaluated.  The http:FileUserStoreConfig configurations are kept blank for future improvements and backward compatibility.  The file user store is defined in the Config.toml as follows: [[ballerina.auth.users]] username=\"alice\" password=\"password1\" scopes=[\"scope1\"]  [[ballerina.auth.users]] username=\"bob\" password=\"password2\" scopes=[\"scope2\", \"scope3\"]  [[ballerina.auth.users]] username=\"eve\" password=\"password3\"   import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  @http:ServiceConfig {  auth: [  {  fileUserStoreConfig: {},  scopes: [\"hello\"]  }  ] } service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur.  curl -k -v https://localhost:9090/foo/bar  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-length: 0 < server: ballerina < content-type: text/plain < When a request is made with valid authentication information, if the authenticated user does not have the required permission, an authorization failure will occur.  curl -k -v https://localhost:9090/foo/bar -H \"Authorization: Basic <token>\"  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Basic <token> > < HTTP/1.1 403 Forbidden < content-length: 0 < server: ballerina < content-type: text/plain <   When a request is made with valid authentication information, if the authenticated user has the required permission, this will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Basic <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Basic <token> > < HTTP/1.1 200 OK < content-length: 13 < server: ballerina < content-type: text/plain < Hello, World!   Imperative Method  There is an imperative method to handle authentication and authorization as follows:  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  ListenerFileUserStoreBasicAuthHandler handler = new;  service /foo on securedEP {  resource function get bar(@http:Header { name: \"Authorization\" } string header) returns string|http:Unauthorized|http:Forbidden {  auth:UserDetails|http:Unauthorized authn = handler.authenticate(header);  if (authn is http:Unauthorized) {  return authn;  }  http:Forbidden? authz = handler.authorize(<auth:UserDetails> authn, [\"write\", \"update\"]);  if (authz is http:Forbidden) {  return authz;  }  return \"Hello, World!\";  } }   LDAP User Store  Ballerina supports LDAP user store basic authentication and authorization for services/resources. The auth field of a service/resource annotation should have a http:LdapUserStoreConfigWithScopes record as an element. If the ldapUserStoreConfig field is assigned with the http:LdapUserStoreConfig implementation, the authentication will be evaluated. Optionally, you can have the string|string[] value for the scopes field also. Then, the authorization will be evaluated.  The http:LdapUserStoreConfig configurations include:    domainName - Unique name to identify the user store  connectionUrl - Connection URL to the LDAP server  connectionName - The username to connect to the LDAP server  connectionPassword - Password for the ConnectionName user  userSearchBase - DN of the context or object under which the user entries are stored in the LDAP server  userEntryObjectClass - Object class used to construct user entries  userNameAttribute - The attribute used for uniquely identifying a user entry  userNameSearchFilter - Filtering criteria used to search for a particular user entry  userNameListFilter - Filtering criteria for searching user entries in the LDAP server  groupSearchBase - DN of the context or object under which the group entries are stored in the LDAP server  groupEntryObjectClass - Object class used to construct group entries  groupNameAttribute - The attribute used for uniquely identifying a group entry  groupNameSearchFilter - Filtering criteria used to search for a particular group entry  groupNameListFilter - Filtering criteria for searching group entries in the LDAP server  membershipAttribute - Define the attribute that contains the distinguished names (DN) of user objects that are in a group  userRolesCacheEnabled - To indicate whether to cache the role list of a user  connectionPoolingEnabled - Define whether LDAP connection pooling is enabled  connectionTimeout - Connection timeout (in seconds) when making the initial LDAP connection  readTimeout - Reading timeout (in seconds) for LDAP operations  secureSocket - The SSL configurations for the LDAP client socket. This needs to be configured in order to communicate through LDAPs  cert - Configurations associated with the crypto:TrustStore or single certificate file that the client trusts  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  @http:ServiceConfig {  auth: [  {  ldapUserStoreConfig: {  domainName: \"ballerina.io\",  connectionUrl: \"ldap://localhost:20000\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeout: 5000,  readTimeout: 60000  },  scopes: [\"hello\"]  }  ] } service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur.  curl -k -v https://localhost:9090/foo/bar  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-length: 0 < server: ballerina < content-type: text/plain < When a request is made with valid authentication information, if the authenticated user does not have the required permission, an authorization failure will occur.  curl -k -v https://localhost:9090/foo/bar -H \"Authorization: Basic <token>\"  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Basic <token> > < HTTP/1.1 403 Forbidden < content-length: 0 < server: ballerina < content-type: text/plain <   When a request is made with valid authentication information, if the authenticated user has the required permission, this will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Basic <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Basic <token> > < HTTP/1.1 200 OK < content-length: 13 < server: ballerina < content-type: text/plain < Hello, World!   Imperative Method  There is an imperative method to handle authentication and authorization as follows:  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  ListenerFileUserStoreBasicAuthHandler handler = new({  domainName: \"ballerina.io\",  connectionUrl: \"ldap://localhost:20000\",  connectionName: \"uid=admin,ou=system\",  connectionPassword: \"secret\",  userSearchBase: \"ou=Users,dc=ballerina,dc=io\",  userEntryObjectClass: \"identityPerson\",  userNameAttribute: \"uid\",  userNameSearchFilter: \"(&(objectClass=person)(uid=?))\",  userNameListFilter: \"(objectClass=person)\",  groupSearchBase: [\"ou=Groups,dc=ballerina,dc=io\"],  groupEntryObjectClass: \"groupOfNames\",  groupNameAttribute: \"cn\",  groupNameSearchFilter: \"(&(objectClass=groupOfNames)(cn=?))\",  groupNameListFilter: \"(objectClass=groupOfNames)\",  membershipAttribute: \"member\",  userRolesCacheEnabled: true,  connectionPoolingEnabled: false,  connectionTimeout: 5000,  readTimeout: 60000 });  service /foo on securedEP {  resource function get bar(@http:Header { name: \"Authorization\" } string header) returns string|http:Unauthorized|http:Forbidden {  auth:UserDetails|http:Unauthorized authn = handler.authenticate(header);  if (authn is http:Unauthorized) {  return authn;  }  http:Forbidden? authz = handler.authorize(<auth:UserDetails> authn, [\"write\", \"update\"]);  if (authz is http:Forbidden) {  return authz;  }  return \"Hello, World!\";  } }   JWT Auth  Ballerina supports JWT authentication and authorization for services/resources. The auth field of a service/resource annotation should have a http:JwtValidatorConfigWithScopes record as an element. If the jwtValidatorConfig field is assigned with the http:JwtValidatorConfig implementation, the authentication will be evaluated. Optionally, you can have the string|string[] value for the scopes field also. Then, the authorization will be evaluated.  The http:JwtValidatorConfig configurations include:    issuer - Expected issuer, which is mapped to the iss  audience - Expected audience, which is mapped to the aud  clockSkew - Clock skew (in seconds) that can be used to avoid token validation failures due to clock synchronization problems  signatureConfig - JWT signature configurations  jwksConfig - JWKS configurations  url - URL of the JWKS endpoint  cacheConfig - Configurations related to the cache, which are used to store preloaded JWKs information  clientConfig - HTTP client configurations, which call the JWKs endpoint  certFile - Public certificate file  trustStoreConfig - JWT TrustStore configurations  trustStore - TrustStore used for signature verification  certAlias - Token-signed public key certificate alias  cacheConfig - Configurations related to the cache, which are used to store parsed JWT information   import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  @http:ServiceConfig {  auth: [  {  jwtValidatorConfig: {  issuer: \"wso2\",  audience: \"ballerina\",  signatureConfig: {  certFile: \"/path/to/public.crt\"  },  scopeKey: \"scp\"  },  scopes: [\"hello\"]  }  ] } service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur.  curl -k -v https://localhost:9090/foo/bar  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-length: 0 < server: ballerina < content-type: text/plain < When a request is made with valid authentication information, if the authenticated user does not have the required permission, an authorization failure will occur.  curl -k -v https://localhost:9090/foo/bar -H \"Authorization: Bearer <token>\"  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 403 Forbidden < content-length: 0 < server: ballerina < content-type: text/plain <   When a request is made with valid authentication information, if the authenticated user has the required permission, this will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 200 OK < content-length: 13 < server: ballerina < content-type: text/plain < Hello, World!   Imperative Method  There is an imperative method to handle authentication and authorization as follows:  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  ListenerFileUserStoreBasicAuthHandler handler = new({  issuer: \"wso2\",  audience: \"ballerina\",  signatureConfig: {  certFile: \"/path/to/public.crt\"  },  scopeKey: \"scp\" });  service /foo on securedEP {  resource function get bar(@http:Header { name: \"Authorization\" } string header) returns string|http:Unauthorized|http:Forbidden {  jwt:Payload|http:Unauthorized authn = handler.authenticate(header);  if (authn is http:Unauthorized) {  return authn;  }  http:Forbidden? authz = handler.authorize(<jwt:Payload> authn, [\"write\", \"update\"]);  if (authz is http:Forbidden) {  return authz;  }  return \"Hello, World!\";  } }   OAuth2  Ballerina supports OAuth2 authentication and authorization for services/resources. The auth field of a service/resource annotation should have an http:OAuth2IntrospectionConfigWithScopes record as an element. If the oauth2IntrospectionConfig field is assigned with the http:OAuth2IntrospectionConfig implementation, the authentication will be evaluated. Optionally, the user can have the string|string[] value for the scopes field also. Then, the authorization will be evaluated.  The http:OAuth2IntrospectionConfig configurations include:    url - URL of the introspection server  tokenTypeHint - A hint about the type of the token submitted for introspection  optionalParams - Map of optional parameters used for the introspection endpoint  cacheConfig - Configurations for the cache used to store the OAuth2 token and other related information  defaultTokenExpTime - Expiration time (in seconds) of the tokens if the introspection response does not contain an exp field  clientConfig - HTTP client configurations, which call the introspection server  httpVersion - The HTTP version of the client  customHeaders - The list of custom HTTP headers  customPayload - The list of custom HTTP payload parameters  auth - The client auth configurations  secureSocket - SSL/TLS-related configurations  disable - Disable SSL validation  cert - Configurations associated with the crypto:TrustStore or single certificate file that the client trusts  key - Configurations associated with the crypto:KeyStore or a combination of the certificate and private key of the client  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  @http:ServiceConfig {  auth: [  {  oauth2IntrospectionConfig: {  url: \"https://localhost:9999/oauth2/token/introspect\",  tokenTypeHint: \"access_token\",  scopeKey: \"scp\",  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  }  },  scopes: [\"hello\"]  }  ] } service /foo on securedEP {  resource function get bar() returns string {  return \"Hello, World!\";  } }   When the service is invoked without authentication information or invalid authentication information, an authentication failure will occur.  curl -k -v https://localhost:9090/foo/bar  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > < HTTP/1.1 401 Unauthorized < content-length: 0 < server: ballerina < content-type: text/plain < When a request is made with valid authentication information, if the authenticated user does not have the required permission, an authorization failure will occur.  curl -k -v https://localhost:9090/foo/bar -H \"Authorization: Bearer <token>\"  > GET /foo/bar HTTP/1.1 > Host: localhost:9090 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 403 Forbidden < content-length: 0 < server: ballerina < content-type: text/plain <   When a request is made with valid authentication information, if the authenticated user has the required permission, this will result in a successful invocation.  curl -k -v https://localhost:9091/hello -H 'Authorization: Bearer <token>'  > GET /hello HTTP/1.1 > Host: localhost:9091 > User-Agent: curl/7.47.0 > Accept: */* > Authorization: Bearer <token> > < HTTP/1.1 200 OK < content-length: 13 < server: ballerina < content-type: text/plain < Hello, World!   Imperative Method  There is an imperative method to handle authorization as follows:  import ballerina/http;  listener http:Listener securedEP = new(9090,  secureSocket = {  key: {  certFile: \"/path/to/public.crt\",  keyFile: \"/path/to/private.key\"  }  } );  ListenerFileUserStoreBasicAuthHandler handler = new({  url: \"https://localhost:9999/oauth2/token/introspect\",  tokenTypeHint: \"access_token\",  scopeKey: \"scp\",  clientConfig: {  secureSocket: {  cert: \"/path/to/public.crt\"  }  } });  service /foo on securedEP {  resource function get bar(@http:Header { name: \"Authorization\" } string header) returns string|http:Unauthorized|http:Forbidden {  oauth2:IntrospectionResponse|http:Unauthorized|http:Forbidden auth = handler->authorize(header, [\"write\", \"update\"]);  if (auth is http:Unauthorized || auth is http:Forbidden) {  return auth;  }  return \"Hello, World!\";  } }    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/structuring-ballerina-code/","name":"Structuring Ballerina Code","summary":"The below are everything you need to know about using Ballerina packages to structure your code.Table of contents      It also introduces the package-related commands in the bal command-line tool.There are two ways to write your code in a Ballerina program:The single source file program is a quick ...","content":"/  /  / Structuring Ballerina Code  Structuring Ballerina Code  The below are everything you need to know about using Ballerina packages to structure your code.  Table of contents It also introduces the package-related commands in the bal command-line tool.  Organizing Your Code  There are two ways to write your code in a Ballerina program:    In a single Ballerina source file (with the .bal extension)  In a Ballerina package   The single source file program is a quick and easy way to get started with Ballerina. However, when your code grows, you often want to:   organize your code by splitting it into multiple files  hide implementation-related parts from the API  manage your dependencies to achieve reproducible builds  write test cases to validate the functionality   Otherwise, you will end up with a messy, unstructured codebase, which is hard to navigate and understand. Therefore, code organization plays a significant role in improving readability, and thereby, writing a Ballerina package is the first step towards organizing code in Ballerina.  Working with Ballerina Packages  A Ballerina package organizes Ballerina code providing a unique namespace for all the functions, types, variables, and constants defined within the package. In Ballerina, how you package and distribute Ballerina code is also via packages.  A package has an organization name, package name, and a version, which are used to identify a package uniquely. The organization typically represents a user. It allows you to group all your packages. Both the organization and package names have to be valid Ballerina . Package versions have to be semantic as described in the .  A Ballerina package is stored in a directory. It contains a collection of source (.bal) files and a package manifest (Ballerina.toml file). The manifest file marks a directory as a Ballerina package.  Writing Your First Ballerina Package  Follow the steps below to write a simple program in a Ballerina package, which prints Hello World! in the console.    Get Ballerina .  In the CLI, execute the command below to create a new Ballerina package.   bal new helloworld  This generates a package directory with the structure below.   helloworld  ├── Ballerina.toml  └── main.bal  0 directories, 2 files  The Ballerina.toml File   This file identifies a directory as a Ballerina package. It will include the content below.   [build-options]  observabilityIncluded = true  The above Ballerina.toml file represents an application package. The organization, name, and the version of the package are set with default values when building or running the package. You can change those by adding the entries below in the Ballerina.toml file.   [package]  org = \"examples\"  name = \"helloworld\"  version = \"0.1.0\"   [build-options]  observabilityIncluded = true  The main.bal File   This file generated by the bal new command will have the content below.   import ballerina/io;   public function main() {  io:println(\"Hello World!\");  }    This function prints Hello World! in the console.  Navigate to the created helloworld package directory.  Execute the command below to build an executable of this file.   bal build  You view the output below.   Compiling source  examples/helloworld:0.1.0   Generating executable  target/bin/helloworld.jar  Execute the command below to run the program.   bal run  You view the output below.   Compiling source  examples/helloworld:0.1.0   Running executable   Hello World!  Note: You can have one or more Ballerina source files with the .bal extension at the root of your package directory. The variables, functions, types, and constants defined in one source file are visible to other files in the same directory because they are in the same namespace.   Creating a Library Package  Execute the command below to create a library package.  bal new helloworld --template lib   In addition to the Ballerina.toml file and the source BAL file, the Package.md file will be created. For lib packages, the Ballerina.toml file will include the content below.    Info: The [package] table contains metadata about the generated package. The package name is helloworld and its current 0.1.0 version is in the examples organization.   [package] org = \"examples\" name = \"helloworld\" version = \"0.1.0\"  [build-options] observabilityIncluded = true   Execute the command below to build the Ballerina archive of the package.  bal build -c   Working with Ballerina Modules  Now, that you successfully built and executed a Ballerina package, next, see .      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/structuring-ballerina-code/working-with-ballerina-modules/","name":"Working With Ballerina Modules","summary":"Ballerina modules allow you to organize the code further in a package namespace.Table of contents      A  is a collection of related modules that are versioned and distributed as a single unit.A module name can contain one or more Ballerina identifiers separated by dots (.):identifier[.identifer]* The value ...","content":"/  /  /  / Working With Ballerina Modules  Working With Ballerina Modules  Ballerina modules allow you to organize the code further in a package namespace.  Table of contents Creating Ballerina Modules  A is a collection of related modules that are versioned and distributed as a single unit.  A module name can contain one or more Ballerina identifiers separated by dots (.):  identifier[.identifer]* The value of the first identifier of the modules belonging to the same package will always be the package name.  Creating the Package  Execute the command below to create a package called winery to demonstrate Ballerina modules.    Info: This package exposes an API to list the available wine types and to get details about a particular wine. Inside that, you can organize the source code with three modules named winery, winery.model, and winery.storage.   bal new winery   The generated winery package will have the directory structure below.  winery ├── Ballerina.toml └── main.bal  0 directories, 2 files   Updating the Default Module  The main.bal file is at the root of the package directory. Similarly, you can have more source files at the root. Symbols such as functions, variables in one file are visible to other files because they are in the same namespace.  This namespace is called the default module of the package. The name of the default module is the same as the package name. Therefore in this example, the name of the default module is winery.  Replace the content in the main.bal file at the root of the package with the function below to use it in the default module’s main function.  import ballerina/io; import examples/winery.storage; import winery.model;  public function main() {  model:Wine[] wines = storage:getWineList();  foreach var wine in wines {  io:println(wine);  } }     Note: Notice the usage of the examples organization name in the second import declaration. The organization name is optional if the module is in the current package.   Creating the Other Modules  The other modules of a package should be placed inside the modules directory of the package. Each top-level directory inside the modules directory will become a Ballerina module.  The module names are derived by combining the package name and the directory name. E.g., If the directory name is model, then the module name will be winery.model.  Creating the Second Module    Navigate to the winery directory, and execute the command below to add the winery.model module.   Tip: You need to provide the module name without the package name in the add command.  bal add model  You view the output below.   Added new bal module at ‘modules/model’  This creates the modules directory and places the model directory in it. This modules/model directory contains the winery.model module. Now, the winery package will have the directory structure below.   .  ├── Ballerina.toml  ├── main.bal  └── modules  └── model  └── model.bal   2 directories, 3 files  Open the modules/model/model.bal file and add the content below to define the Wine record type.   public type Wine record {  string id;  string name;  string color;  string country;  };   Creating the Third Module    Execute the command below to create another winery.storage module to retrieve a list of wines from a storage.   bal add storage  You view the output below.   Added new ballerina module at ‘modules/storage’  Now, the winery package will have the directory structure below.   .  ├── Ballerina.toml  ├── main.bal  └── modules  ├── model  │ └── model.bal  └── storage  └── storage.bal   3 directories, 4 files Replace the content of the storage.bal file with the content below.   import winery.model;   public function getWineList() returns model:Wine[] {  return [{  id: \"W125678\",  name: \"Corton-Charlemagne Grand Cru, Coche-Dury\",  color: \"White\",  country: \"France\"  }, {  id: \"W425478\",  name: \"Échezeaux, Dom. de la Romanée-Conti\",  color: \"Red\",  country: \"France\"  }];  }   Now, there are three modules in the winery package as follows.    winery (the default module)  winery.model  winery.storage   Importing Modules  Importing Modules in the Current Package  In Ballerina, before you refer to any public symbol from another module, you need to import the particular module using an import declaration. The below is the import declaration syntax.  import [org-name /] module-name [as import-prefix];     The org-name is optional if you are importing a module from the current package.  The import-prefix has to be a valid Ballerina identifier and the import-prefix is used to refer to public symbols in the declared module.  The import-prefix is also optional. If it is not available, you can use the last part of the module-name.   The below is a sample import declaration.  import examples/winery.model   Since the import-prefix is not given here, you can use model to refer to the symbols in the winery.model module. Here, model:Wine is called a qualified identifier.  model:Wine[] wines = [];   Importing Modules in Other Packages  You would have noticed the following import in the main.bal file in the previous example.  import ballerina/io   It is possible to figure out the package name from an import declaration because the first part of the module name is always the package name. Therefore, here, the default module io is being imported from the io package in the ballerina organization. The organization name is required when you are importing modules in other packages.  Declaring Dependencies in a Package  When you add import declarations for required modules in your code and perform a build, the compiler automatically figures out the latest compatible versions of the required packages. Also, the compiler creates/updates the Dependencies.toml file with those resolved dependencies.  Build and run this example as follows.   $ bal build  Compiling source \texamples/winery:0.1.0  Running Tests  \twinery.model \tNo tests found  winery.storage \tNo tests found  winery \tNo tests found  Generating executable \ttarget/bin/winery.jar  $ bal run target/bin/winery.jar {\"id\":\"W125678\",\"name\":\"Corton-Charlemagne Grand Cru, Coche-Dury\",\"color\":\"White\",\"country\":\"France\"} {\"id\":\"W425478\",\"name\":\"Échezeaux, Dom. de la Romanée-Conti\",\"color\":\"Red\",\"country\":\"France\"}   The generated Dependencies.toml will have the content below.  [[dependency]] org = \"ballerina\" name = \"io\" version = \"0.5.3”   The compiler has added a dependency to the ballerina/io package in the Dependencies.toml file.  From the second build onwards, the compiler honors the version declared in the TOML file unless there are version conflicts.  You can also update the dependencies in the Dependencies.toml file. If you found a newer version of the ballerina/io package and you want to use it in your code, you can either delete the corresponding dependency declaration from the TOML file or update the version. If you delete the dependency declaration, then the compiler updates the file with the latest version during the next build.    Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/testing-ballerina-code/executing-tests/","name":"Executing Tests","summary":"The sections below include information about executing tests in Ballerina.Table of contents      Tests will be automatically executed when you run the build command or you can explicitly run them using the test command.Execute all the tests in the current package with the following command.List all the test ...","content":"/  /  /  / Executing Tests  Executing Tests  The sections below include information about executing tests in Ballerina.  Table of contents Executing Tests Using CLI Commands  Tests will be automatically executed when you run the build command or you can explicitly run them using the test command.  Execute all the tests in the current package with the following command.  $ bal test   List all the test groups in the package.  $ bal test --list-groups   Run only the tests belonging to the given group(s) in the current package.  $ bal test --groups <group_1>,<group_2>   Run the tests in the current package excluding the given group(s).  $ bal test --disable-groups <group_1>   Run only the given test function(s) in the current package.  $ bal test --tests <test_function>   Run a given set of functions in the default module only.  $ bal test --tests PackageName:<test_function>   Run all the functions in the given module.  $ bal test --tests PackageName.<module_name>:*   Run only the previously-failed test cases in the current package.  $ bal test --rerun-failed   Generate an HTML test report without code coverage information. Also, dump the test results in the JSON format.  $ bal test --test-report   Dump only the test results in the JSON format.  $ bal test --code-coverage   Generate an HTML test report with code coverage information. Also, dump the test results in the JSON format.  $ bal test --test-report --code-coverage   Generate a JaCoCo XML test report with code coverage information. Also, dump the test results in the JSON format.  $ bal test --code-coverage --coverage-format=xml   Generate an HTML test report and a JaCoCo XML test report with code coverage information. Also, dump the test results in the JSON format.  $ bal test --test-report --code-coverage --coverage-format=xml   For more options of the test command, run the following.  $ bal test --help  Test Report  By default, a summary of the test statuses is printed in the console at the end of the test execution. In addition to the results printed in the console, an HTML test report can be generated by passing the --test-report flag in the Ballerina command. The link to the file will be printed in the console at the end of the test execution. The test report contains the total passed, failed, and skipped tests of the entire package and of the individual modules.  Example:  $ bal test --test-report   A sample view of the test report is shown below.    Code Coverage Report  The Ballerina test framework provides an option to analyze the code coverage of a standard Ballerina package. This feature provides details about the coverage of the program source code by the tests executed.  You can pass the --code-coverage flag along with the --test-report flag in the test execution command and  generate the code coverage report at the end of the test execution. The generated file is an extended version of the  test report. In addition to the test results, this file would contain details about the source code coverage at different levels.    Package-level coverage as an average  Module-level coverage as an average  Individual source file coverage   The code coverage only includes the Ballerina source files being tested and not any files under the tests/ directory.  Example:  $ bal test --test-report --code-coverage   A sample view of the code coverage report is shown below.    JaCoCo XML Report  You can pass the --coverage-format=xml flag along with the --code-coverage flag in the test execution command and  generate the JaCoCo XML report at the end of the test execution.  This file can be uploaded to CI/CD tools (e.g., CodeCov) to display the coverage information for both Ballerina and  the native Java sources used within a Ballerina package.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/testing-ballerina-code/mocking/","name":"Mocking","summary":"Mocking is useful to control the behavior of functions and objects to control the communication with other modules and external endpoints. A mock can be created by defining return values or replacing the entire object or function with a user-defined equivalent. This feature will help you to test the Ballerina ...","content":"/  /  /  / Mocking  Mocking  Mocking is useful to control the behavior of functions and objects to control the communication with other modules and external endpoints. A mock can be created by defining return values or replacing the entire object or function with a user-defined equivalent. This feature will help you to test the Ballerina code independently from other modules and external endpoints.  Table of contents Mocking Objects  The Test module provides capabilities to mock an object for unit testing. This allows you to control the behavior of the object member functions and values of member fields via stubbing or replacing the entire object with a user-defined equivalent. This feature will help you to test the Ballerina code independently from other modules and external endpoints.  Mocking objects can be done in two ways.    Creating a test double (providing an equivalent object in place of the real)  Stubbing the member function or member variable (specifying the behavior of the functions and values of the variables)   Creating a Test Double  You can write a custom mock object and substitute it in place of the real object. The custom object should be made structurally equivalent to the real object via the mocking features in the test module.  Example:  Let’s make changes to the example in the to define a test  double for the clientEndpont object.    Note: Only the get function is implemented since it is the only function used in the sample. Attempting to call  any other member function of the clientEndpoint will result in a runtime error.   main_test.bal  import ballerina/test; import ballerina/http;  // An instance of this object can be used as the test double for the `clientEndpoint`. public client class MockHttpClient {   remote function get(@untainted string path, map<string|string[]>? headers = (), http:TargetType targetType = http:Response) returns @tainted http:Response| http:PayloadType | http:ClientError {   http:Response response = new;  response.statusCode = 500;  return response;  } }  @test:Config {} public function testGetRandomJoke() {   // create and assign a test double to the `clientEndpoint` object  clientEndpoint=<http:Client>test:mock(http:Client, new MockHttpClient());   // invoke the function to test  string|error result = getRandomJoke(\"Sheldon\");   // verify that the function returns an error  test:assertTrue(result is error); }   Stubbing Member Functions and Variables of an Object  Instead of creating a test double, you may also choose to create a default mock object and stub the functions to return a specific value or to do nothing.  Example:  The example in the shows how the get function of the client object can be stubbed to return a value. Let’s make changes to that example to get a random joke from a specific category (e.g., food or movies).  main.bal  import ballerina/io; import ballerina/http; import ballerina/regex;  http:Client clientEndpoint = check new (\"https://api.chucknorris.io/jokes/\");  // This function performs a `get` request to the Chuck Norris API and returns a random joke // or an error if the API invocations fail. function getRandomJoke(string name, string category = \"food\") returns @tainted string|error {  string replacedText = \"\";  http:Response response = check clientEndpoint->get(\"/categories\");   // Check if the provided category is available   if (response.statusCode == http:STATUS_OK) {  json[] categories = <json[]>check response.getJsonPayload();   if (!isCategoryAvailable(categories, category)) {  error err = error(\"'\" + category + \"' is not a valid category.\");  io:println(err.message());  return err;  }   } else {  return createError(response);  }   // Get a random joke from the provided category  response = check clientEndpoint->get(\"/random?category=\" + category);   if (response.statusCode == http:STATUS_OK) {  json payload = check response.getJsonPayload();  json joke = check payload.value;   replacedText = regex:replaceAll(joke.toJsonString(), \"Chuck Norris\", name);  return replacedText;   } else {  return createError(response);  }  }   utils.bal  The util functions below are used to validate the categories and construct errors based on the HTTP response.  import ballerina/io; import ballerina/http;  // This function checks if the provided category is a valid one. function isCategoryAvailable(json[] categories, string category) returns boolean {  foreach var cat in categories {  if (cat.toJsonString() == category) {  return true;  }  }  return false; }  // Returns an error based on the HTTP response. function createError(http:Response response) returns error {  error err = error(\"error occurred while sending GET request\");  io:println(err.message(), \", status code: \", response.statusCode);  return err; }   test_utils.bal  The util functions below are used to construct mock responses required for testing.  import ballerina/http;  // Returns a mock HTTP response to be used for the random joke API invocation. function getMockResponse() returns http:Response {  http:Response mockResponse = new;  json mockPayload = {\"value\":\"When Chuck Norris wants an egg, he cracks open a chicken.\"};  mockResponse.setPayload(mockPayload);  return mockResponse; }  // Returns a mock response to be used for the category API invocation. function getCategoriesResponse() returns http:Response {  http:Response categoriesRes = new;  json[] payload = [\"animal\",\"food\",\"history\",\"money\",\"movie\"];  categoriesRes.setJsonPayload(payload);  return categoriesRes; }   Stubbing to Return a Specific Value  main_test.bal  This test stubs the behavior of the get function to return a specific value in 2 ways:    Stubbing to return a specific value in general  Stubbing to return a specific value based on the input   import ballerina/test; import ballerina/http;  @test:Config {} public function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint` object  clientEndpoint = test:mock(http:Client);   // Stub to return the specified mock response when the `get` function is called.  test:prepare(clientEndpoint).when(\"get\").thenReturn(getMockResponse());   // Stub to return the specified mock response when the specified argument is passed.  test:prepare(clientEndpoint).when(\"get\").withArguments(\"/categories\")  .thenReturn(getCategoriesResponse());   // Invoke the function to test.  string result = checkpanic getRandomJoke(\"Sheldon\");   // Verify the return value against the expected string.  test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\"); }   Stubbing with Multiple Values to Return Sequentially for Each Function Call  main_test.bal  This test stubs the behavior of the get function to return a specified sequence of values for each get function  invocation (i.e., the first call to the get function will return the first argument and the second call will return the second  argument).  import ballerina/test; import ballerina/http;  @test:Config {} public function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint` object.  clientEndpoint = test:mock(http:Client);   // Stub to return the corresponding value for each invocation test:prepare(clientEndpoint).when(\"get\")  .thenReturnSequence(getCategoriesResponse(), getMockResponse());   // Invoke the function to test  string result = checkpanic getRandomJoke(\"Sheldon\");   // Verify the return value against the expected string  test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\"); }   Stubbing a Member Variable  If a client object has a public member variable, it can be stubbed to return a mock value for testing.  Example:  main.bal  # A record that represents a Product. # # + code - Code used to identify the product # + name - Product Name # + quantity - Quantity included in the product public type Product record {|  readonly int code;  string name;  string quantity; |};  # A table with a list of Products uniquely identified using the code. public type ProductInventory table<Product> key(code);  // This is a sample data set in the defined inventory. ProductInventory inventory = table [  {code: 1, name: \"Milk\", quantity: \"1l\"},  {code: 2, name: \"Bread\", quantity: \"500g\"},  {code: 3, name: \"Apple\", quantity: \"750g\"}  ];  # This client represets a product. # # + productCode - An int code used to identify the product. public client class ProductClient {  public int productCode;   public function init(int productCode) {  self.productCode = productCode;  } }  // The Client which represents the product with the code `1` (i.e. \"Milk\"). ProductClient productClient = new (1);  # Get the name of the product represented by the ProductClient. # # + return - The name of the product public function getProductName() returns string?{  if (inventory.hasKey(productClient.productCode)){  Product? product = inventory.get(productClient.productCode);  if(product is Product){  return product.name;  }  }  }   main_test.bal  This test stubs the member variable productCode of the ProductClient to set a mock product code.  import ballerina/test;  @test:Config {} function testMemberVariable() {  int mockProductCode = 2;  // Create a mockClient which represents product with the code `mockProductCode`  ProductClient mockClient = test:mock(ProductClient);  // Stub the member variable `productCode`  test:prepare(mockClient).getMember(\"productCode\").thenReturn(mockProductCode);  // Replace `productClient` with the `mockClient`  productClient = mockClient;  // Assert for the mocked product name.  test:assertEquals(getProductName(), \"Bread\"); }   Stubbing to Do Nothing  If a function has an optional or no return type specified, this function can be mocked to do nothing when writing  test cases.  Example:  main.bal  import ballerina/email;  email:SmtpClient smtpClient = check new (\"localhost\", \"admin\",\"admin\");  // This function sends out emails to specified email addresses and returns an error if sending failed. function sendNotification(string[] emailIds) returns error? {  email:Message msg = {  'from: \"builder@abc.com\",  subject: \"Error Alert ...\",  to: emailIds,  body: \"\"  };  return check smtpClient->sendMessage(msg); }  main_test.bal  This test stubs the behavior of the send function to do nothing for testing the sendNotification function.  import ballerina/test; import ballerina/email;  @test:Config {} function testSendNotification() {  string[] emailIds = [\"user1@test.com\", \"user2@test.com\"];   // Create a default mock SMTP client and assign it to the `smtpClient` object.  smtpClient = test:mock(email:SmtpClient);   // Stub to do nothing when the`send` function is invoked.  test:prepare(smtpClient).when(\"sendMessage\").doNothing();   // Invoke the function to test and verify that no error occurred.  test:assertEquals(sendNotification(emailIds), ()); }   Mocking Functions  The Ballerina test framework provides the capability to mock a function. You can easily mock a function in a module that you are testing or a function of an imported module by using the mocking feature. This feature will help you to test your Ballerina code independently from other modules and functions.  The object specified with the @test:Mock {} annotation will be considered as a mock function, which gets triggered in place of the real function.    moduleName : “<moduleName>“ - (optional) Name of the module in which the function to be mocked resides in. If the function is within the same module, this can be left blank or “.” (no module) can be passed. If the function is in a different module but within the same package, just passing the module name will suffice. For functions in completely separate modules, the fully-qualified module name must be passed, which includes the packageOrg (i.e., packageOrg/moduleName). For native functions, the Ballerina module needs to be specified.  functionName : “<functionName>“ - Name of the function to be mocked.  Example:  main.bal  // This function returns the result provided by the `intAdd` function. public function addValues(int a, int b) returns int {  return intAdd(a, b); }  // This function adds two integers and returns the result. public function intAdd(int a, int b) returns int {  return (a + b); }   main_test.bal  This is the initialization of the mock function, which should be called in place of the intAdd function.  import ballerina/test;  @test:Mock { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();   After the initialization, the following options can be used to stub the behavior of a function written in the  module being tested.  Stubbing to Return a Specific Value  This test stubs the behavior of the get function to return a specific value in 2 ways:    Stubbing to return a specific value in general  Stubbing to return a specific value based on the input   import ballerina/test;  @test:Mock { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();  @test:Config {} function testReturn() {  // Stub to return the specified value when the `intAdd` is invoked.  test:when(intAddMockFn).thenReturn(20);  // Stub to return the specified value when the `intAdd` is invoked with the specified arguments.  test:when(intAddMockFn).withArguments(0, 0).thenReturn(-1);  test:assertEquals(addValues(10, 6), 20, msg = \"function mocking failed\");  test:assertEquals(addValues(0, 0), -1, msg = \"function mocking with arguments failed\"); }   Stubbing to Invoke Another Function in Place of the Real  This test stubs the behavior of the intAdd function to substitute it with a user-defined mock function.  import ballerina/test;  @test:Mock { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();  @test:Config {} function testCall() {  // Stub to call another function when `intAdd` is called.  test:when(intAddMockFn).call(\"mockIntAdd\");  test:assertEquals(addValues(11, 6), 5, msg = \"function mocking failed\"); }  // The mock function to be used in place of the `intAdd` function public function mockIntAdd(int a, int b) returns int {  return (a - b); }   This test stubs the behavior of an imported function to substitute it with a user-defined mock function.  import ballerina/test; import ballerina/io;  @test:Mock {  moduleName: \"ballerina/io\",  functionName: \"println\" } test:MockFunction printlnMockFn = new();  int tally = 0;  // This is a function that can be called in place of the `io:println` function. public function mockPrint(any|error... val) {  tally = tally + 1; }  @test:Config {} function testCall() {  test:when(printlnMockFn).call(\"mockPrint\");   io:println(\"Testing 1\");  io:println(\"Testing 2\");  io:println(\"Testing 3\");   test:assertEquals(tally, 3); }   This test calls the original intAdd function after it has been stubbed with a user-defined mock function.  import ballerina/test;  @test:Mock { functionName: \"intAdd\" } test:MockFunction intAddMockFn = new();  @test:Config {} function testCallOriginal() {  // Stub to call another function when `intAdd` is called.  test:when(intAddMockFn).call(\"mockIntAdd\");  test:assertEquals(addValues(11, 6), 5, msg = \"function mocking failed\");  // Stub to call the original `intAdd` function.  test:when(intAddMockFn).callOriginal();  test:assertEquals(addValues(11, 6), 17, msg = \"function mocking failed\");  }  // The mock function to be used in place of the `intAdd` function public function mockIntAdd(int a, int b) returns int {  return (a - b); }   What’s Next?  Now, that you are aware of the details on writing tests, learn the different options that can be used when .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/testing-ballerina-code/testing-quick-start/","name":"Quick Start","summary":"The Ballerina Language has a built-in robust test framework, which allows you to achieve multiple levels of the test pyramid including unit testing, integration testing, and end to end testing.  It provides features such as assertions, data providers, mocking, and code coverage, which enable the programmers to write comprehensive ...","content":"/  /  /  / Quick Start  Quick Start  The Ballerina Language has a built-in robust test framework, which allows you to achieve multiple levels of the test pyramid including unit testing, integration testing, and end to end testing. It provides features such as assertions, data providers, mocking, and code coverage, which enable the programmers to write comprehensive tests.  Table of contents Writing a Simple Function  To get started, let’s write a simple Ballerina function and test it.    First, let’s create a Ballerina package. Use the bal new command to create the package. For more information on the command, see .   A tests directory needs to be created to store the test files. In this example, the main_test.bal test file needs to be  added within a tests directory.   package-directory/  Ballerina.toml  main.bal  tests/  main_test.bal  Let’s write a function which handles sending a get request in the main.bal file of the default module.   // main.bal  import ballerina/io;  import ballerina/http;  import ballerina/regex;   http:Client clientEndpoint = check new (\"https://api.chucknorris.io/jokes/\");   // This function performs a `get` request to the Chuck Norris API and returns a random joke // with the name replaced by the provided name or an error if the API invocation fails.  function getRandomJoke(string name) returns @tainted string|error {  http:Response response = check clientEndpoint->get(\"/random\");  if (response.statusCode == http:STATUS_OK) {  var payload = response.getJsonPayload();  if (payload is json) {  json joke = check payload.value;  string replacedText = regex:replaceAll(joke.toJsonString(), \"Chuck Norris\", name);  return replacedText;  }  } else {  error err = error(\"error occurred while sending GET request\");  io:println(err.message(), \", status code: \", response.statusCode, \", reason: \", response.getJsonPayload());  return err;  }   error err = error(\"error occurred while sending GET request\");  return err;  }   Now, let’s write a simple test case to verify the behavior of the main function in the main_test.bal file.   // main_test.bal  import ballerina/io;  import ballerina/test;  import ballerina/http;  // This test function tests the behavior of the `getRandomJoke` when  // the API returns a successful response.  @test:Config {}  function testGetRandomJoke() {  // Create a default mock HTTP Client and assign it to the `clientEndpoint`  clientEndpoint = test:mock(http:Client);  // Stub the behavior of the `get` function to return the specified mock response.  test:prepare(clientEndpoint).when(\"get\").thenReturn(getMockResponse());  // Invoke the function to test.  string result = checkpanic getRandomJoke(\"Sheldon\");  io:println(result);  // Verify the return value. test:assertEquals(result, \"When Sheldon wants an egg, he cracks open a chicken.\");  }  // Returns a mock HTTP response to be used for the jokes API invocation.  function getMockResponse() returns http:Response {  http:Response mockResponse = new;  json mockPayload = {\"value\":\"When Chuck Norris wants an egg, he cracks open a chicken.\"};  mockResponse.setPayload(mockPayload);  return mockResponse;  }   Finally, let’s execute the tests using the following command.   $ bal test --code-coverage   This will print an output similar to the following.   Compiling source  foo/joke:0.1.0   Running Tests with Coverage  joke  When Sheldon wants an egg, he cracks open a chicken.   [pass] testGetRandomJoke   1 passing  0 failing  0 skipped   Generating Test Report  target/test_results.json   What’s Next?  Now, that you have an understanding of how a test case can be written and executed, you can dive deep into the available  features in the section.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/testing-ballerina-code/writing-tests/","name":"Writing Tests","summary":"The sections below include information about writing tests in Ballerina.Table of contents      Unit tests bound to a module need to be placed in a sub folder called tests/ within the module. In a standard\n Ballerina package, a module is mapped to a test suite. All tests within ...","content":"/  /  /  / Writing Tests  Writing Tests  The sections below include information about writing tests in Ballerina.  Table of contents Project Structure  package-directory/  Ballerina.toml  main.bal  [resources]  tests/ # tests for default module  main_test.bal # The test file for main.bal  [resources] # Resources for the tests    Test Source Files  Unit tests bound to a module need to be placed in a sub folder called tests/ within the module. In a standard  Ballerina package, a module is mapped to a test suite. All tests within a module’s tests/ subfolder are considered to be part of the same test suite.  The test source files could have any name. The test functions are just Ballerina functions, which use a special annotation to mark the function as a test. Test functions must be specified with the @test:Config {} annotation and there is no restriction on the test function name.  Test Resources  The resources sub directory found within the tests/ directory is meant to contain any files or resources that are exclusively required for testing. You can access the resource files either using the absolute path or using the path relative to the package root.  Defining a Test  The test module provides the necessary annotations to construct a test suite. Therefore, importing the test module is essential in order to write Ballerina tests.  import ballerina/test;   Once the test module is imported, the following annotation can be used to write a test function.  @test:Config {}  The function specified after the annotation is a test function. This annotation supports the following value fields.    enable: {true|false} - Enable/disable the test. Default: true  before: <function name> - The function to be run just before the test is run. Default: none  after: <function name> - The function to be run just after the test is run. Default: none  dependsOn: [<function names>, …] - List of functions on which the test function depends. The order in which the comma-separated list appears has no prominence. In case there needs to be an order, the dependsOn parameter can be used to create an ordered sequence of functions with one function depending on the other.  dataProvider: <function name> - Specifies the function that will be used to provide the data sets for the test.  groups: [“<test group name”, …] - A comma-separated list of test group names (one or more) to which this test  belongs.   Example:  import ballerina/io; import ballerina/test;  function beforeFunc() {  // This is the function, which will be executed before the Test functions. }  function afterFunc() {  // This is the function, which will be executed after the Test functions. }  // This test function will not be executed. @test:Config { enable: false } function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // This test function depends on the `testFunction3`. @test:Config{ before: beforeFunc,  after: afterFunc,  dependsOn: [testFunction3],  dataProvider: dataGen,  groups: [\"g1\"] } function testFunction2 (int value) returns error? {  test:assertEquals(value, 1, msg = \"value is not correct\"); }   function dataGen() returns (int[][]) {  return [[1]]; }  // This is a random test function. This will randomly execute without depending on the other functions. // However, note that the `testFunction2` function depends on this. @test:Config {  groups: [\"g1\", \"g2\"] } function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   Visibility of Symbols  The functions, services, and the global variables defined in a module are accessible from within the test files. Hence, you cannot redefine a symbol in the test files if it is already declared in the module.  On the other hand, symbols defined in the test files will not be visible inside the module source files. When running tests, the symbols in the module source files will be initialized first followed by the ones in the test files.  Using Assertions  The Ballerina test framework supports the following assertions, which help to verify the expected behavior of a piece of code. These assertions can be used to decide if the test is passing or failing based on the condition.  assertTrue(boolean expression, string message)  Asserts that the expression is true with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertTrue() {  boolean value = false;  test:assertTrue(value, msg = \"AssertTrue failed\"); }   assertFalse(boolean expression, string message)  Asserts that the expression is false with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertFalse() {  boolean value = false;  test:assertFalse(value, msg = \"AssertFalse failed\"); }   assertEquals(anydata|error actual, anydata expected, string message)  Asserts that the actual value is equal to the expected value with an optional message.  Example: import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertEquals(answer, 8, msg = \"IntAdd function failed\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertNotEquals(anydata actual, anydata expected, string message)  Asserts that the actual value is not equal to the expected value with an optional message.  Example:  import ballerina/test;  @test:Config {} function testAssertIntEquals() {   int answer = 0;  int a = 5;  int b = 3;  answer = intAdd(a, b);  test:assertNotEquals(answer, 8, msg = \"Matches\"); }  function intAdd(int a, int b) returns (int) {  return (a + b); }   assertExactEquals(any|error actual, any|error expected, string message)  Asserts that the actual entity is exactly equal to the expected entity with an optional message.  Example: import ballerina/test;  class Person {  public string name = \"\";  public int age = 0;  public Person? parent = ();  private string email = \"default@abc.com\";  string address = \"No 20, Palm grove\"; }  @test:Config {} function testAssertExactEqualsObject() {  Person p1 = new;  Person p2 = p1;  test:assertExactEquals(p1, p2, msg = \"Objects are not exactly equal\"); }   assertNotExactEquals(any|error actual, any|error expected, string message)  Asserts that the actual entity is not exactly equal to the expected entity with an optional message.  Example:  import ballerina/test;  class Person {  public string name = \"\";  public int age = 0;  public Person? parent = ();  private string email = \"default@abc.com\";  string address = \"No 20, Palm grove\"; }  @test:Config {} function testAssertNotExactEqualsObject() {  Person p1 = new;  Person p2 = new ();  test:assertNotExactEquals(p1, p2, msg = \"Objects are exactly equal\"); }   assertFail(string message)  Fails the test. This is useful to fail a test based on a check for a condition while it is in execution.  Example:  import ballerina/test;  @test:Config {} function foo() {  error? e = trap bar(); // Expecting `bar()` to panic  if (e is error) {  test:assertEquals(e.message().toString(), \"Invalid Operation\", msg = \"Invalid error reason\"); // Some other assertions  } else {  test:assertFail(msg = \"Expected an error\");  } }  function bar() {  panic error(\"Invalid Operation\"); }   Difference between expected and actual values when using ‘assertEquals’  Values with different types  The diff shows the expected and actual values preceded by the type within the angle brackets.  Example:  import ballerina/test;  @test:Config {} function testAssertStringAndInt() {  test:assertEquals(1, \"1\"); }   Output:  [fail] testAssertStringAndInt:   Assertion Failed!   expected: <string> '1'  actual : <int> '1'   Values of the string type  The diff is displayed in the GNU format using + and - to show the  line differences.  Example:  import ballerina/test;  @test:Config {} function testAssertString() {  test:assertEquals(\"hello Ballerina user\\nWelcome to Ballerina\", \"hello user\\nWelcome to Ballerina\"); }   Output:  [fail] testAssertString:  Assertion Failed!   expected: 'hello user  Welcome to Ballerina'  actual : 'hello Ballerina user  Welcome to Ballerina'   Diff :   --- expected  +++ actual   @@ -1,2 +1,2 @@   -hello user  +hello Ballerina user  Welcome to Ballerina    Values of the JSON/record/map type  The diff lists the JSON key mismatch using the expected keys and actual keys. The JSON value mismatch is listed per key showing the expected and actual values.  Example:  import ballerina/test;  @test:Config {} function testAssertJson() {  json j1 = {  name: \"Anne\",  age: \"21\",  marks: {  maths: 99,  english: 90,  status: {pass: true}  }  };  json j2 = {  name2: \"Amie\",  age: 21,  marks: {  maths: 35,  english: 90,  status: {pass: false}  }  };  test:assertEquals(j1, j2); }   Output:  [fail] testAssertJson:  Assertion Failed!   expected: '{\"name2\":\"Amie\",\"age\":21,\"marks\":{\"maths\":35,\"english\":90,\"status\":{\"pass\":false...'  actual : '{\"name\":\"Anne\",\"age\":\"21\",\"marks\":{\"maths\":99,\"english\":90,\"status\":{\"pass\":true...'   Diff :   expected keys : name2  actual keys : name   key: age  expected value : <int> 21  actual value : <string> 21   key: marks.maths  expected value : 35  actual value : 99   key: marks.status.pass  expected value : false  actual value : true    Values of other anydata type  The diff is displayed showing the expected and actual values.  Example:  import ballerina/test;  @test:Config {} function testAssertTuples() {  [int, string] a = [10, \"John\"];  [int, string] b = [12, \"John\"];  test:assertEquals(a, b); }   Output:  [fail] testAssertTuples:  Assertion Failed!   expected: '12 John'  actual : '10 John'   Setup and Teardown  The following test annotations can be used to set up and tear down the instructions. These annotations enable executing the instructions at different levels.  @test:BeforeSuite {}  The function annotated with the BeforeSuite annotation will be run once before any of the tests in the test suite. This can be used for initializing the test suite level pre-requisites.  Example:  import ballerina/io; import ballerina/test;  // The `BeforeSuite` function is executed before running all the test functions in this module. @test:BeforeSuite function beforeFunc() {  io:println(\"I'm the before suite function!\"); }  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // Test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed\"); }   @test:BeforeGroups {}  For each group specified in this annotation, the BeforeGroups annotated function will be executed once before  any of the tests belonging to the group.  Example:  import ballerina/io; import ballerina/test;  // The `beforeGroups1` function is executed before running all the test functions belonging to the `g1` group. @test:BeforeGroups { value:[\"g1\"] } function beforeGroups1() {  io:println(\"I'm the before groups function!\"); }  // Another `beforeGroups2` function is executed before running all the test functions belonging to the `g1` and `g2` groups. @test:BeforeGroups { value:[\"g1\", \"g2\"] } function beforeGroups2() {  io:println(\"I'm another before groups function!\"); }  // A test function that belongs to the `g1` group. @test:Config { groups:[\"g1\"] } function testFunction1() {  io:println(\"I belong to group g1!\");  test:assertTrue(true, msg = \"Failed\"); }  // A test function that belongs to the `g2` group. @test:Config { groups:[\"g2\"] } function testFunction2() {  io:println(\"I belong to group g2 \");  test:assertTrue(true, msg = \"Failed\"); }   @test:BeforeEach  The BeforeEach annotated function will be run before each test in the test suite. This can be used to initialize  the test-level prerequisites repeatedly before every test function.  Example:  import ballerina/io; import ballerina/test;  // The `BeforeEach` function, which is executed before each test function @test:BeforeEach function beforeFunc() {  io:println(\"I'm the before function!\"); }  // The first test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // The second test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // The third test function. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   @test:AfterEach  The AfterEach annotated function will be run after each test within the test suite. This can be used to clean up the test-level aspects repeatedly after every test function.  Example:  import ballerina/io; import ballerina/test;  // This `AfterEach` function is executed before each test function. @test:AfterEach function afterFunc() {  io:println(\"I'm the after function!\"); }  // The first test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed!\"); }  // The second test function. @test:Config {} function testFunction2() {  io:println(\"I'm in test function 2!\");  test:assertTrue(true, msg = \"Failed!\"); }  // The third test function. @test:Config {} function testFunction3() {  io:println(\"I'm in test function 3!\");  test:assertTrue(true, msg = \"Failed!\"); }   @test:AfterGroups {}  Example:  For each group specified in this annotation, the AfterGroups annotated function will be executed once after all the  tests belonging to the group is executed.  import ballerina/io; import ballerina/test;  // A test function that belongs to the `g1` group. @test:Config { groups:[\"g1\"] } function testFunction1() {  io:println(\"I belong to group g1!\");  test:assertTrue(true, msg = \"Failed\"); }  // A test function that belongs to the `g2` group. @test:Config { groups:[\"g2\"] } function testFunction2() {  io:println(\"I belong to group g2 \");  test:assertTrue(true, msg = \"Failed\"); }  // The `afterGroupsFunc1` function is executed before running all the test functions belonging to the `g1` group. @test:AfterGroups { value:[\"g1\"] } function afterGroupsFunc1() {  io:println(\"I'm the after groups function!\"); }  // The `afterGroupsFunc2` function is executed before running all the test functions belonging to the `g1` and `g2` groups. @test:AfterGroups { value:[\"g1\", \"g2\"] } function afterGroupsFunc2() {  io:println(\"I'm another after groups function!\"); }   @test:AfterSuite {}  The AfterSuite annotated function will be run once after all the tests in the test suite are run. This can be used for cleaning up the test suite level aspects. A test suite covers tests related to a module.  Example:  import ballerina/io; import ballerina/test;  // Test function. @test:Config {} function testFunction1() {  io:println(\"I'm in test function 1!\");  test:assertTrue(true, msg = \"Failed\"); }  // The `AfterSuite` function is executed after all the test functions in this module. @test:AfterSuite {} function afterFunc() {  io:println(\"I'm the after suite function!\"); }   Test Configurations  Configurations for testing can be provided using configurable variables. The values for configurable variables can be provided in a file named Config.toml located in the tests directory.  For information on using configurable variables, see  .  What’s Next?  As an integration language, you will be using lots of connectors when writing Ballerina code. Setting up mock backends  for these external endpoints will be a tedious task (e.g., email client and SalesForce client). The mocking support in  Ballerina will allow you to unit test your code without needing to set up mock backends by allowing you to control  what the client objects return without actually sending requests to backends.  To learn about the mocking API, see .   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/cloud-native/","name":"Cloud Native","summary":"See how the Ballerina programming language has built-in cloud support, which helps developers deploy to cloud platforms like Docker and Kubernetes.Table of contents      In a microservice architecture, smaller services are developed, deployed, and scaled individually. These disaggregated services communicate with each other over the network forcing developers ...","content":"/  /  /  / Cloud Native  Cloud Native  See how the Ballerina programming language has built-in cloud support, which helps developers deploy to cloud platforms like Docker and Kubernetes.  Table of contents In a microservice architecture, smaller services are developed, deployed, and scaled individually. These disaggregated services communicate with each other over the network forcing developers to deal with the as a part of their application logic. For decades, programming languages have treated networks simply as I/O sources. Ballerina language introduces language constructs that seamlessly map to network programming concepts such as services and network resources. The sections below demonstrate a few of these language constructs and how they help to develop distributed services.  Network-Friendly Type System  Ballerina’s type system is specifically focused on aiding the development of networked and distributed applications. Ballerina is a null safe language with builtin support for popular wire formats JSON and XML, and seamless conversions between JSON and user-defined types.  Get Started  The sample below demonstrates a few simple usages of json and xml types.  public function main() returns error? {  string name = \"Katie Melua\";   // XML literal.  xml album = xml `<Album>  <name>Piece By Piece</name>  <artist>${name}</artist>  <song>Spider's Web</song>  <song>Nine Million Bicycles</song>  </Album>`;  io:println(\"XML Value: \", album);   // Extract the list of song names from the XML value using a query expression.  string[] songs = from var song in album/<song> select song.data();  io:println(\"Extracted song names: \", songs);   // JSON literal.  json jAlbum = {  \"name\": (album/<name>).data(),  \"artist\": name,  songs  };  io:println(\"JSON value: \", jAlbum);   json artistName = check jAlbum.artist;  io:println(\"Album artist: \", artistName); }   The Ballerina source file is compiled and executed in the following manner.  bal run xml_json_sample.bal   Output: Compiling source  xml_json_sample.bal  Running executable.  <Album>  <name>Piece By Piece</name>  <artist>Katie Melua</artist>  <song>Spider's Web</song>  <song>Nine Million Bicycles</song>  </Album> Extracted song names: [\"Spider's Web\",\"Nine Million Bicycles\"] JSON value: {\"name\":\"Piece By Piece\",\"artist\":\"Katie Melua\",\"songs\":[\"Spider's Web\",\"Nine Million Bicycles\"]} Album artist: Katie Melua   Services  Ballerina introduces service typing where services, which work in conjunction with a listener object, can have one or more resource methods in which the application logic is implemented. The listener object provides an interface between the network and the service. It receives network messages from a remote process according to the defined protocol and translates it into calls on the resource methods of the service that has been attached to the listener object.  Get Started  The below is a simple Hello World service to get you started.  import ballerina/http;  service / on new http:Listener(9090) {   resource function get greeting() returns string {  return \"Hello World!\";  }  }   The Ballerina source file is compiled and executed in the following manner.  bal run hello.bal   You view the output below.  Compiling source  hello.bal  Running executable  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090  $ curl http://localhost:9090/greeting Hello, World!   Ballerina services come with built-in concurrency. Every request to a resource method is handled in a separate strand (Ballerina concurrency unit), which gives implicit concurrent behavior to a service.  Some protocols supported out-of-the-box include the below.    Async Network Protocol  In the request-response paradigm, network communication is done by blocking calls. However, blocking an OS thread to perform a network interaction is very expensive. That’s why many other languages supported async I/O and with that, you have to implement complicated logic to handle asynchronous events using techniques such as callbacks and promises. On the other hand, Ballerina’s request-response protocols are implicitly non-blocking and will take care of asynchronous invocations.  Get Started  The code snippet below shows a call to a simple HTTP GET request endpoint.  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEP = check new (\"http://www.mocky.io\");  string payload = check clientEP->get(\"/v2/5ae082123200006b00510c3d/\", targetType = string);  io:println(payload); }   Although the above get operation is seemingly a blocking operation, internally, it does an asynchronous execution using the non-blocking I/O, where the current execution thread is released to the Ballerina runtime scheduler to be used by other Ballerina strands. After the I/O operation is done, the program execution automatically resumes from where it was suspended. This pattern gives you a much more convenient programming model than handling the non-blocking I/O manually while providing maximum performance efficiency.  Client Objects  Client objects allow Ballerina developer to communicate with a remote process which follow a certain protocol. The remote methods of the client object correspond to distinct network messages defined by the protocol for the role played by the client object.  Get Started  The sample below illustrates sending out a tweet by invoking tweet remote method in the twitter client object.  import ballerina/io; import ballerinax/twitter;  configurable string clientId = ?; configurable string clientSecret = ?; configurable string accessToken = ?; configurable string accessTokenSecret = ?;  // Twitter package defines this type of endpoint // that incorporates the twitter API. // We need to initialize it with OAuth data from apps.twitter.com. // Instead of providing this confidential data in the code // we read it from a configuration file. twitter:Client twitterClient = new ({  clientId: clientId,  clientSecret: clientSecret,  accessToken: accessToken,  accessTokenSecret: accessTokenSecret,  clientConfig: {} }); public function main() returns error? {  twitter:Status status = check twitterClient->tweet(\"Hello World!\");  io:println(\"Tweeted: \", <@untainted>status.id); }   Code to Cloud  Although in the past, you simply wrote their program, built it, and ran it, today, you also need to think of various deployment options such as Docker, Kubernetes, serverless environments, and service meshes. However, this deployment process is not part of the programming experience. You have to write code in a certain way to work well in a given execution environment and removing this from the programming problem isn’t good.  Ballerina specializes in moving from code to cloud while providing a unique developer experience. The Ballerina compiler can be extended to read the source code and generate artifacts to deploy your code into different clouds. These artifacts can be Dockerfiles, Docker images, Kubernetes YAML files, or serverless functions.  From Code to Kubernetes Kubernetes is the preferred platform for running applications with multiple microservices in production. It can be used for automating deployment and scaling, and the management of containerized applications. Kubernetes defines a set of unique building blocks that need to be defined as YAML files and deployed into the Kubernetes cluster.  However, in many cases, creating these YAML files could be out of your comfort zone, and thereby, the Ballerina compiler can create these YAML files while compiling the source code. The code below shows the build option you need to use to do this.  The following code snippet shows how the Ballerina compiler can generate YAML files to deploy your code to Kubernetes.  import ballerina/http;  service /hello on new http:Listener(9090) {  resource function get sayHello() returns string  returns error? {  check caller->respond(\"Hello, World!\");  } }   Building the source with bal build --cloud=k8s will generate the Kubernetes YAML files and Docker image that is required to deploy the hello application into Kubernetes.  Building the source with bal build --cloud=docker will generate the Docker image and Dockerfile.  From Code to AWS Lambda AWS Lambda is an event-driven, serverless computing platform. Ballerina functions can be deployed in AWS Lambda by annotating a Ballerina function with @awslambda:Function, which should have the function (awslambda:Context, json) returns json|error function signature.  The sample below illustrates a simple echo function with AWS Lambda annotations.  import ballerinax/awslambda;  // The `@awslambda:Function` annotation marks a function to // generate an AWS Lambda function @awslambda:Function public function echo(awslambda:Context ctx, json input) returns json {  return input; }   From Code to Azure Functions Azure Functions is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. Ballerina functions can be deployed in Azure by annotating a Ballerina function with @azure_functions:Function.  import ballerina/uuid; import ballerinax/azure_functions as af;  // HTTP request/response with no authentication @af:Function public function hello(@af:HTTPTrigger { authLevel: \"anonymous\" } string payload) returns @af:HTTPOutput string|error {  return \"Hello, \" + payload + \"!\"; }   CI/CD with GitHub Actions In a microservice architecture, continuous integration and continuous delivery (CI/CD) is critical in creating an agile environment for incorporating incremental changes to your system. There are different technologies that provide this CI/CD functionality and very recently GitHub has introduced GitHub Actions, which are now available for general usage. GitHub Actions provide a convenient mechanism for implementing CI/CD pipelines using their workflow concept right from your GitHub repositories.  With (Ballerina GitHub Actions)[https://github.com/marketplace/actions/ballerina-action], it is much easier to create a Ballerina development environment with built-in CI/CD.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/concurrent/","name":"Concurrent","summary":"Ballerina's concurrency model supports both threads and coroutines.Table of contents      Ballerina’s concurrency model supports both threads and coroutines and has been designed to have a close correspondence with sequence diagrams.A Ballerina program is executed on one or more threads. A thread can consist of one or more ...","content":"/  /  /  / Concurrent  Concurrent  Ballerina's concurrency model supports both threads and coroutines.  Table of contents Ballerina’s concurrency model supports both threads and coroutines and has been designed to have a close correspondence with sequence diagrams.  A Ballerina program is executed on one or more threads. A thread can consist of one or more strands, which are language-managed, logical threads of control. Only one strand of a particular thread can run at a time. The strands belonging to a single thread are cooperatively multitasked. Therefore, strands of a single thread behave as coroutines relative to each other.  Strands enable cooperative multitasking by “yielding”. The runtime scheduler may switch the execution of a strand only when it yields via a wait action, a worker receive action, a library function resulting in a blocking call, etc.  A strand is created due to the execution of either a named worker declaration or start action.  Concurrent operations in a function can be defined by multiple named workers. A function has a default worker and may additionally contain named workers. A worker executes concurrently with the other workers (function worker and named workers) in the function.  import ballerina/io;  type Person record {|  string name;  boolean employed; |};  function process(Person[] members, int[] quantities) {  worker w1 {  Person[] employedMembers = from Person p in members  where p.employed  select p;  int count = employedMembers.length();  count -> w2;  string `Employed Members: ${count}` -> function;  }   worker w2 {  int total = int:sum(...quantities);  int employedCount = <- w1;   int avg = employedCount == 0 ? 0 : total/employedCount;  string `Average: ${avg}` -> function;  }   string x = <- w1;  io:println(x);   string y = <- w2;  io:println(y); }   Worker message passing (via Ballerina’s send (->) and receive (<-) actions) is used for communication between workers. The compiler also explicitly verifies that the send and receive actions are in a consistent state in order to avoid any deadlock scenarios at runtime.  The @strand annotation can be used on a named worker or start action to make the corresponding strand run on a separate thread.  import ballerina/io;  type Person record {|  string name;  boolean employed; |};  function process(Person[] members, int[] quantities) {   @strand {  thread: \"any\"  }  worker w1 {  Person[] employedMembers = from Person p in members  where p.employed  select p;  employedMembers.length() -> function;  }   int quantitiesSum = int:sum(...quantities);  int employedMemCount = <- w1;   io:println(\"Average: \", employedMemCount == 0 ? 0 : quantitiesSum/employedMemCount); }   Concurrency in Ballerina works well with sequence diagrams. A function can be viewed as a sequence diagram. Each worker is represented by a separate lifeline (vertical line).  Immutability in the type system can be leveraged to write reliable concurrent programs. Immutability in Ballerina is deep guaranteeing that an immutable structure will always have only immutable values. Therefore, an immutable value can be safely accessed concurrently without using a lock statement.  type Details record {|  int id;  string location?; |};  function process(map<Details> & readonly entities) {  string[] detailsWithLocation = [];  string[] detailsWithoutLocation = [];   foreach var [name, details] in entities.entries() {  if details.hasKey(\"location\") {  detailsWithLocation.push(name);  } else {  detailsWithoutLocation.push(name);  }  }   // The casts within the workers are safe because the lists were created  // based on an immutable map and is therefore guaranteed to have the // exact same entries with the exact same fields.  worker w1 {  foreach var name in detailsWithoutLocation {  persistId(<record {| int id; |} & readonly> entities.get(name));  }  }   worker w2 {  foreach var name in detailsWithLocation {  persistIdWithLocation(  <record {| int id; string location; |} & readonly> entities.get(name));  }  } }  function persistId(record {| int id; |} rec) {  }  function persistIdWithLocation(record {| int id; string location; |} rec) {  }       Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/data-oriented/","name":"Data Oriented","summary":"Language-integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. See how Ballerina provides first-class support for writing queries that process data.Table of contents      As of now, language-integrated queries are ...","content":"/  /  /  / Data Oriented  Data Oriented  Language-integrated queries specify the logic in SQL-like syntax to process data and events. They are easy to write and understand due to the simplicity of the syntax. See how Ballerina provides first-class support for writing queries that process data.  Table of contents As of now, language-integrated queries are supported for iterator implementations such as an array, map, stream, and table. There are two kinds of integrated queries that can be written in Ballerina:    allows generating a list, table, string or XML  executes a set of statements for each element of the iterator   Query Expressions  Query expressions allow you to generate a list, stream, table, string, or XML. The sections below look at the clauses you can use in a query expression.  Query Clauses  Query expressions contain a set of clauses similar to SQL to process the data. They must start with the from clause and can perform various operations such as filter, join, sort, limit, and projection. There are various SQL-like clauses below to perform these operations.  ‘from’ Clause  The from clause is used to define the input iterator source that is considered for processing the data. Similar to the for each statement, you can specify any iterator as the expression. Similar to a list and stream, you can use all kinds of iterators as the input in the from clause.  ‘where’ Clause  The where clause allows you to filter by condition. You can define any conditional expression, which returns a boolean. A where clause contains logical operators, equality, and range checks.  ‘let’ Clause  The let clause allows you to define variables that can be used only within the query expression scope. These variables cannot be accessed out of the query expression. You can define one or more variables in the let clause and use them within query expressions.  ‘join’ Clause  A join clause performs an inner or left outer equijoin. In the join clause, there are two input iterators. During the joining process, each value of an iterator is matched against all the values in the other iterator based on the given condition, and the output values are generated for all the matching event pairs. Here, you can only perform equality checks as the joining condition.  ‘order by’ Clause  The order by clause allows ordering the result in the ascending and/or descending order based on the specified attributes. Ordering will be done in an ascending manner by default. You can use the descendingthe keyword to order in a descending manner. Here, attributes that are considered for the order by operations are order-keys, which should be an ordered type. You can define more than one order key in the order by clause and it’s possible to have more than one order by clause.  ‘limit’ Clause  The limit clause limits the number of frames/values emitted by a query pipeline. You should define an integer value to specify the number of output values.  ‘select’ Clause  The select clause is a mandatory clause in query expressions that is used for projection. You can use this clause to create the values required to generate iterators such as list, table, XML, string, and stream.  ‘on conflict’ Clause  An on conflict clause is only allowed for a query expression that constructs a table with a key sequence. The expression is evaluated when the select clause emits a value that conflicts with a previous value, in the sense, that both values have the same key value in the table. The on conflict clause gets executed when the select clause emits a row that has the same key as a row that it emitted earlier. It gives an onConflictError error if there is a key conflict.  Query Actions  Query actions are executed in the same way as the clauses in the query expression. However, it doesn’t generate an output such as a list. Rather, it executes a set of statements defined by you. The block inside the do clause is executed in each iteration.  Query Action Example  var x = from var person in personList  from var dept in deptList  let string hrDepartment = \"Human Resource\"  do {  if (dept.name == \"HR\") {  Employee employee = {firstName: person.firstName, lastName: person.lastName, deptAccess: hrDepartment};  employeeList[employeeList.length()] = employee;  }  };   Writing Integrated Queries  The example below provides in-depth knowledge on how to utilize the capabilities of the Ballerina query expressions. This example explains the use case of finding popular books in a store.  import ballerina/io;  type Author record {|  readonly int id;  string name; |};  type Category record {|  readonly int id;  string name; |};  type Book record {|  readonly int id;  string title;  int year;  float price;  Author[] authors;  Category[] categories; |};  type Sale record {|  int bookId;  int qty; |};  type AuthorTable table<Author> key(id); type CategoryTable table<Category> key(id); type BookTable table<Book> key(id);  error onConflictError = error(\"Key Conflict\", message = \"record with same key exists.\");   In the above code, the necessary custom types and variables are created to perform the data manipulation.  function loadAuthors() returns AuthorTable|error {  json[] authors = [  {\"id\": 1, \"name\": \"Giada De Laurentiis\"},  {\"id\": 2, \"name\": \"J. K. Rowling\"},  {\"id\": 3, \"name\": \"Henrique C. M. Andrade\"},  {\"id\": 4, \"name\": \"Buğra Gedik\"},  {\"id\": 5, \"name\": \"Deepak S. Turaga\"}  ];  // Iterates through `authors` JSON array, constructs `Author` records, and collects them into a table.  return table key(id) from var author in authors  select check author.cloneWithType(Author)  on conflict onConflictError; }   Here, the author details are represented as JSON elements. In this method, the respective author JSON elements are converted into tabular data using Ballerina query expressions for further processing.  function loadCategories() returns CategoryTable|error {  xml categories = xml `<categories>  <category>  <id>1</id>  <name>cooking</name>  </category>  <category>  <id>2</id>  <name>children</name>  </category>  <category>  <id>3</id>  <name>fantasy</name>  </category>  <category>  <id>4</id>  <name>education</name>  </category>  </categories>`;  // Iterates through `categories` xml array, constructs `Category` records, and collects them into a table.  return table key(id) from var category in categories/<category>  select {  id: check 'int:fromString((category/**/<id>/*).toString()),  name: (category/**/<name>/*).toString()  }  on conflict onConflictError; }   The above method iterates through a categories XML array and constructs a table with the category ID and name. Query expression clauses such as from, select, and on conflict are used in it.  function getCategories(CategoryTable categories, int[] ids) returns Category[] {  // Query `categories` for each id, and collects matching categories into an array.  return from int id in ids  join Category c in categories on id equals c.id  select c; }   The above method returns the book category names according to the given category IDs. As written in the query expression, a join clause iterates through the categories array to find the respective category name according to the ID.  function getAuthors(AuthorTable authors, int[] ids) returns Author[] {  // Query `authors` for each id, and collects matching authors into an array.  return from int id in ids  join Author a in authors on id equals a.id  select a; }   Here, the author names are identified according to the author IDs. As similar to the previous method, query joins are utilized to create the authors array.  function loadBooks() returns BookTable|error {  map<anydata>[] books = [  {\"id\": 1, \"title\": \"Everyday Italian\", \"year\": 2005, \"price\": 30.00, \"authors\": [1], \"categories\": [1]},  {\"id\": 2, \"title\": \"Harry Potter\", \"year\": 1997, \"price\": 29.99, \"authors\": [2], \"categories\": [2, 3]},  {\"id\": 3, \"title\": \"Fundamentals of Stream Processing\", \"year\": 2014, \"price\": 123.99, \"authors\": [3, 4, 5], \"categories\": [4]},  {\"id\": 4, \"title\": \"Fantastic Beasts\", \"year\": 2001, \"price\": 29.99, \"authors\": [2], \"categories\": [2, 3]}  ];  // Iterates through `books` map<anydata> array, constructs `Book` records, and collects them into a table.  return table key(id) from var book in books  let AuthorTable authors = check loadAuthors()  let CategoryTable categories = check loadCategories()  select {  id: <int>book[\"id\"],  title: <string>book[\"title\"],  year: <int>book[\"year\"],  price: <float>book[\"price\"],  authors: getAuthors(authors, check book[\"authors\"].cloneWithType()),  categories: getCategories(categories, check book[\"categories\"].cloneWithType())  }  on conflict onConflictError; }   Now, the author details and book category details exist as individual table values. The book details exist as an array. Further, this array has the necessary keys to identify the respective authors and book categories. Hence, there is a requirement to generate a table that contains thenrelevant book details, author names, and category names. As shown in the above example, Ballerina query expressions can be utilized to create such table values.  function getPopularBooks(stream<Sale> sales, int minSales, int 'limit) returns Book[]|error {  // Join each sale value from `sales` stream with retrieved `BookTable`  // filter books with at least `minSales` number of sales,  // order filtered books by sales quantity,  // and collect `'limit` number of books into an array.  return from Sale s in sales  join Book b in check loadBooks() on s.bookId equals b.id  where s.qty >= minSales  order by s.qty descending  limit 'limit  select b; }   Now, you have the book details as a table value and there is a requirement to identify the popular books based on the number of sales copies. As shown in the above example, you have to combine the sales array and the books table to identify the popular books. In this example, Ballerina query clauses such as join, where, order by, and limit are utilized to cater to the requirement.  public function main() returns error? {  Sale[] sales = [  {bookId: 1, qty: 150},  {bookId: 2, qty: 3500},  {bookId: 3, qty: 1250},  {bookId: 4, qty: 2100}  ];  // Retrieve 2 most popular books with at least 1000 sales.  Book[]|error mostPopular2Books = getPopularBooks(sales.toStream(), 1000, 2);  io:println(mostPopular2Books); }   The main method is responsible for identifying the popular books according to the number of copies sold. Hence, the respective getPopularBooks method gets called with the required parameters.      Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/graphical/","name":"Graphical","summary":"See why the support for a graphical model lays the foundation for designing the syntax and semantics of the Ballerina programming language.Table of contents      In today’s cloud-era, we need technologies that can model distributed systems in a more developer-friendly way. This means that for a single use ...","content":"/  /  /  / Graphical  Graphical  See why the support for a graphical model lays the foundation for designing the syntax and semantics of the Ballerina programming language.  Table of contents In today’s cloud-era, we need technologies that can model distributed systems in a more developer-friendly way. This means that for a single use case we need to model a flow that shows how multiple actors interact with each other, how concurrent execution flows, and what remote endpoints are involved. Sequence diagrams are known to be the best way to visually describe this.  That’s why sequence diagrams are the foundation for designing the syntax and semantics of the Ballerina language. Ballerina provides the flexibility of a general-purpose language while having features to model solutions based on higher-level abstractions.    “[With Ballerina] you can get sequence diagrams automatically. When things start to get complicated and you need to understand and socialize with the rest of your team what it is that you’re building, these diagrams become very helpful.” – Christian Posta, field CTO, solo.io   Sequence Diagrams in Ballerina  In Ballerina, there is a bidirectional mapping between the textual representation of code in the Ballerina syntax and the visual representation as a sequence diagram. It allows you to visualize any function or a service resource written in Ballerina as a sequence diagram. The diagram will display all the logic and network interaction of that function. You can view these diagrams using the Ballerina VSCode plugin.    One of the key benefits of the diagram is that it acts as documentation to the code. It makes it far easier to comprehend the program than reading the source code. Even if you are not familiar with Ballerina code syntax it is easier to understand the diagram.  Get Started  The Ballerina IDE plugin ( the ) can generate a sequence diagram dynamically from the source code. To start generating a sequence diagram from your Ballerina code, viewer.  Graphical Syntax  Functions  Functions in Ballerina are visualized as a sequence diagram. The diagram will have a lifeline with start and end which represent the default worker of the function. The worker lifeline will be displayed as a flow diagram to represent function logic.    Client Objects and Remote Methods  Ballerina has special network client objects, like HTTP clients and database connections, that have their own lifeline to represent its functionality and the messages that it can receive. The messages sent to or the invocations done on these network clients are called remote methods — a special method inside a client object that represents a call through the network. Remote calls are distinguished from normal method calls by using the arrow “->” notation.  The following code shows an HTTP client that is used to do GET and POST requests to a remote endpoint:  function execute() returns error?{  http:Client lookupService = check new(lookupUrl);  http:Client reportService = check new(reportUrl);   json result = check lookupService->get(\"/query\");  http:Response response = check reportService->post(\"/report\", result); }   The HTTP clients represented by lookupService and reportService variables are of type http:Client, which represents remote HTTP endpoints. The following diagram shows the generated sequence diagram for the above remote method calls    We can see here how the HTTP clients have become participants of the sequence diagram with its own lifeline, where we visualize the messages sent and received to represent the network calls we do.   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/flexibly-typed/","name":"Flexibly Typed","summary":"See how the Ballerina programming language's flexible type system helps developers work with networked resources in their code.Table of contents      In a programming language, the type system is the foundation for representing data and implementing logic. It provides the means of creating abstractions to the solutions that ...","content":"/  /  /  / Flexibly Typed  Flexibly Typed  See how the Ballerina programming language's flexible type system helps developers work with networked resources in their code.  Table of contents In a programming language, the type system is the foundation for representing data and implementing logic. It provides the means of creating abstractions to the solutions that you provide. While some languages provide basic functionality, others strive to give in-built functionality for specialized domains.  With more services being available in the cloud, the network-distributed programming domain has grown. As the developer is given the added responsibility of working with networked resources in their code, it is critical that the programming language itself aids in this operation. That’s why Ballerina’s network-friendly type system is specialized for this domain.  Statically Typed and Structural  Ballerina is a statically-typed language, which means type compatibility between the constructs is checked at compile-time. Statically-typed languages are generally more robust to changes and refactorings, easier to debug, and aids in creating better language tooling.  The type system of the Ballerina language is primarily structural with added support for nominal typing. This means that the type compatibility is identified by considering the structure of the value rather than just relying on the name of the type. This is different from languages like Java, C++, and C# that have nominal type systems in which it is bound by the name of the actual type.  Shapes in Ballerina  Types in Ballerina deal with an abstraction of values that don’t consider storage identity. This abstraction is called a shape. For simple types like int and boolean, there is no difference between a shape and a value because they don’t have a storage identity. To understand the concept of a shape, let’s look at the in Ballerina. Because records have storage identity, a reference to the value is stored in the variable rather than storing the actual value. This is comparable to references in Java or pointers in C++.  Here’s an example of a record that stores the state of a door:  type DoorState record {|  boolean open;  boolean locked; |};   Now, let’s create some values of the DoorState record type:  DoorState v1 = { open: false, locked: true }; DoorState v2 = { open: false, locked: true }; DoorState v3 = { open: false, locked: true };   The three variables above all represent a single state of the door being closed and locked. Nonetheless, we have created three different values where each variable is stored in a distinct memory reference. If we ignore the storage identity of these variables, we are left with the representation of the data it has, which is { open: false, locked: true }. This is a single shape of the type DoorState.  In this way, there are four possible shapes for DoorState as shown in the variables below:  DoorState ds1 = { open: true, locked: true }; DoorState ds2 = { open: true, locked: false }; DoorState ds3 = { open: false, locked: true }; DoorState ds4 = { open: false, locked: false };   A type in Ballerina represents a set of the possible shapes it can have. So any value that belongs to either of the above four shapes will be considered to be of the type DoorState.   Figure 1: Set of shapes of the type DoorState  Subtypes in Ballerina  Subtyping in Ballerina is semantic. It is defined by means of shapes, where S is a subtype of T if the set of shapes denoted by S are a subset of the shapes denoted by T. The examples below demonstrate this behavior.  The type boolean is a simple basic type in Ballerina without a storage identity, so its values become equivalent to its shapes. Therefore, the boolean type is defined as having two shapes, true and false.  The boolean type’s shapes can be defined in set notation as Sboolean = { true, false }. This can be visualized as seen in Figure 2 below.   Figure 2: Set of shapes of the type boolean  Now, according to our subtyping rules, we can derive new types based on the boolean type by creating subsets of its shapes. For example, a new type we can create is boolean_false where its only supported shape/value would be false. The new type is shown in Figure 3 below.   Figure 3: Shapes sets of types boolean and boolean_false  The new type boolean_false can be defined in Ballerina code in the following manner:  type boolean_false false;   This example uses the value false in defining the new boolean_false type. In a more practical scenario, you can provide multiple values as a union when defining new types using the T1|T2 syntax. A type that only denotes a single shape is called a singleton type. This new type can be used in the code in the following way.  boolean_false bv1 = false; boolean bv2 = true; bv2 = bv1;   As you can see, bv1 of type boolean_false can be assigned to bv2 of type boolean because bv1’s type is a subset of bv2’s type. In simple terms, all the values that can be held in the variable bv1 can be held in the variable bv2, thus the assignment is possible.  We have now seen how Ballerina’s subtyping works in relation to simple types. Let’s take a look at creating subtypes of records by revisiting our DoorState scenario. Here, we will create a new type EmergencyDoorState, where the locked field has to always have the value false. The resultant types and their shapes can be seen below in Figure 4.   Figure 4: Shapes sets of types DoorState and EmergencyDoorState  The type definition of EmergencyDoorState type is shown below:  type EmergencyDoorState record {|  boolean open;  boolean_false locked = false; |};   In the above type, we have modified the field locked to be of type boolean_false, which allows its only value to be false. In this type definition, default values in Ballerina records have been used, wherein the absence of an explicit value provided by the user, the default value mentioned here will be used.  In this manner, the type EmergencyDoorState can only have the shapes { open: true, locked: false } and { open: false, locked: false }. These two elements make it a subset of the DoorState shapes set, thus EmergencyDoorState is a subtype of DoorState.  The following code snippet shows a sample usage of the EmergencyDoorState type:  EmergencyDoorState eds1 = { open: true }; DoorState eds2 = eds1; io:println(\"Door - Open: \", eds2.open, \" Locked: \", eds2.locked);   Benefits of a Structural Type System A structural type system proves beneficial when you have multiple systems interacting with each other since data exchange and type compatibilities can be resolved easier. Let’s dive into a Ballerina example, which shows this behavior.  type Result record {|  string name;  string college;  int grade; |}; ... Result[] results = from var person in persons  let int lgrade = (grades[person.name] ?: 0), string targetCollege = \"Stanford\"  where lgrade > 75  select {  name: person.name,  college: targetCollege,  grade: lgrade  };    In the example above, you filter records from a list and create a new value using the select clause. Its structure is defined dynamically at that time and the values are created. These values are assigned to an array of Result records, which is possible because the generated values are structurally compatible with the Result record type.  In situations such as above, a separate system from our core application may be generating values to be consumed by us. In these cases, instead of worrying about sharing the code for the data type definitions, you can simply concentrate on the compatibility of the data in order to ensure interoperability.  Open-by-Default  Ballerina’s open-by-default concept is tied around the . This means that you should design network-aware programs to accept all the data that is sent to you and make the best effort to understand it. Also, when sending data, you should make the best effort to conform to the standard protocols that were agreed upon beforehand. This strategy makes sure you have the best chance of interacting with different systems in a reliable manner.  The main facilitator of this in the type system is the open record concept in Ballerina. The sections above demonstrated closed records and the sections below demonstrate a record type to represent the details of a person.  Get Started  The code snippet below shows a call to a simple HTTP GET request endpoint:  enum CreditScore {  POOR,  FAIR,  GOOD,  EXCELLENT }  type Person record {|  string name;  int birthYear;  boolean married = false;  CreditScore creditScore?;  json...; |};   Here, the type Person is an open record type, the notation json...; denotes that this record type can contain additional fields that are not mentioned in the record type descriptor, as long as these additional fields belong to type json.  The earlier DoorState record type was defined explicitly as a closed record type. Therefore, you were able to list out all the possible shapes in the DoorState type. If this type was defined as an open record, you would have an infinite number of shapes since DoorState values can have any arbitrary field set in the code.  The Person record type above has an creditScore (denoted by the suffix \"?\"). This means the field value of creditScore of a Person record can be skipped without setting a value. Later on, this field can be accessed using the \"?.\" operator, which would return a value of type CreditScore?, which is equivalent to the union type CreditScore|(). In Ballerina, the nil value and the type is represented by ().  Let’s create a new type Student, which will be a subtype of the Person type.  type Student record {|  string name;  int birthYear;  boolean married;  CreditScore creditScore?;  string college; |};   The Student type defined above has an extra field college of type string compared to the Person type. All the possible shapes in the Student type are included in the set of shapes in Person as well. This is possible because the Person type is an open record. If we make the Person type a closed record, Student will no longer be a subtype of Person.  Sample usage of the above types is shown below:  public function main() {  Student s1 = {  name: \"Tom\",  birthYear: 1990,  married: false,  college: \"Yale\"  };  Student s2 = {  name: \"Anne\",  birthYear: 1988,  married: true,  creditScore: GOOD,  college: \"Harvard\"  };  Person p1 = s1;  CreditScore? cScore = p1?.creditScore;   if cScore != () {  io:println(\"P1's credit score: \", cScore);  } else {  io:println(\"P1's credit score: N/A\");  }   Person p2 = s2;  cScore = p2?.creditScore;   if cScore != () {  io:println(\"P2's credit score: \", cScore);  } else {  io:println(\"P2's credit score: N/A\");  }   io:println(p2); }   $ bal run sample.bal P1's credit score: N/A P2's credit score: GOOD {\"name\":\"Anne\",\"birthYear\":1988,\"married\":true,\"creditScore\":\"GOOD\",\"college\":\"Harvard\"}   Network Communication with Data Binding  The type system features for records in Ballerina can be used when implementing operations with structural validation, data types handling, and payload passthrough operations. The functionality will be demonstrated using an HTTP service in Ballerina:  http:Client highCreditStoreCustomersDb = check new (\"http://example.com/\");  service / on new http:Listener(8080) {   resource function post 'record(@http:Payload {} Person entry) returns error? {  if entry?.creditScore == GOOD || entry?.creditScore == EXCELLENT {  io:println(\"High credit score \", entry);  http:Response r = check highCreditStoreCustomersDb->post(\"/store\", entry);  } else {  io:println(\"Low credit score \", entry);  }  return string `Record processed for: ${entry.name}`;  } }   $ bal run sample.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080   Test Scenarios    Description  Request  Output  A request is sent without setting the married field. Since this field has a default value in the Person type, the value is automatically populated to that. The ethnicity field is not set since it is marked as optional.  curl -d '{ \"name\": \"John Little\", \"birthYear\": 1855 }' http://localhost:8080/record  Low credit score {\"name\":\"John Little\",\"birthYear\":1855,\"married\":false}  A request is sent with a string value given for the integer field birthYear. The service validates the value for the field and the request fails.  curl -d '{ \"name\": \"John Little\", \"birthYear\": \"1855\" }' http://localhost:8080/record  data binding failed: error {ballerina/lang.typedesc}ConversionError message='map '<' json > ' value cannot be converted to 'Person'  A request is sent with the optional ethnicity field also set. curl -d '{ \"name\": \"Sunil Perera\", \"birthYear\": 1950, \"married\": true, \"creditScore\": \"GOOD\" }' http://localhost:8080/record  High credit score {\"name\":\"Sunil Perera\",\"birthYear\":1950,\"married\":true,\"creditScore\":\"GOOD\"}   A request is sent with a non-existing value of the Ethnicity union type. This is validated by the service and the request fails.  curl -d '{ \"name\": \"Tim Kern\", \"birthYear\": 1995, \"creditScore\": \"HIGH\", \"country\": \"Japan\", \"zipcode\": \"98101\" }' http://localhost:8080/record  data binding failed: error {ballerina/lang.typedesc}ConversionError message='map< json >' value cannot be converted to 'Person'   A request is sent with additional fields not explicitly mentioned in the Person type. Since Person is an open record type, the service accepts and makes these extra fields available to be passed through to other systems, e.g. a forwarding service.  curl -d '{ \"name\": \"Tim Kern\", \"birthYear\": 1995, \"creditScore\": \"EXCELLENT\", \"country\": \"Japan\", \"zipcode\": \"98101\" }' http://localhost:8080/record  High credit score {\"name\":\"Tim Kern\",\"birthYear\":1995,\"married\":false,\"creditScore\":\"EXCELLENT\",\"country\":\"Japan\",\"zipcode\":\"98101\"}  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/learn/user-guide/why-ballerina/reliable-maintainable/","name":"Reliable, Maintainable","summary":"The sections below explain how the explicit error handling, static types, and concurrency safety combined with a familiar, readable syntax make programs reliable and maintainable.Table of contents      Error handling refers to the act of reacting to and recovering from errors. Error handling plays a critical role in ...","content":"/  /  /  / Reliable, Maintainable  Reliable, Maintainable  The sections below explain how the explicit error handling, static types, and concurrency safety combined with a familiar, readable syntax make programs reliable and maintainable.  Table of contents Explicit Error Handling  Error handling refers to the act of reacting to and recovering from errors. Error handling plays a critical role in producing reliable, maintainable applications. Ballerina is designed with a conscious decision to have explicit errors instead of exceptions. As a result, Ballerina has explicit error reporting and explicit error testing and handling. It is explained further using examples.  Errors are expected in network handling. In fact, “The network is reliable” is one of the . Therefore, explicit error handling is a must when dealing with network services because it forces you to check for errors and handle or pass them to the caller.  In Ballerina, errors are reported by functions returning values of the error type. The error values are part of their basic type.  Error Reporting  This example defines a TCP client, which communicates with a remote TCP server. Both read and write methods interact with the network. Hence, errors can occur at any time.  # The TCP client is used to connect to a remote TCP server. public client class TcpClient {  # Initializes the TCP client.  function init(string host, int port) returns error? {}  # Reads bytes from the connected remote host.  remote function read() returns byte[] | error {}  # Writes bytes to the connected remote host.  remote function write(byte[] bytes) returns error? {} }   When the read method is completed successfully, it returns a byte[] value. In the case of a failure, it returns an error value. You can describe this behavior using union types in Ballerina. The union type byte[] | error means that the value could be either a byte[] or an error. The fact that this method can fail is explicit in the method signature.  # Reads bytes from the connected remote host. remote function read() returns byte[] | error {}   The write method does not return anything if it completes successfully but it returns an error otherwise. Optional types in Ballerina can be used to describe this behavior. Options types are syntactic sugar for union types containing the nil type, which is written as (). The error? is sugar for error | (). The examples below show how you can check whether a function returns the expected value or an error.  # Writes bytes to the connected remote host. remote function write(byte[] bytes) returns error? {}   Error Checking  Ballerina has language constructs for explicit error checking. Both explicit error reporting and checking improves code readability and maintainability simply because they are explicit. When you read Ballerina code, you can quickly notice code that reports errors and checks for errors.  Usually, a function handles errors by passing them up to the caller. Even the main function, which is the program entry point can return an error resulting in an error printed in your terminal.  The function below returns information about the provided domain name. It internally does a WHOIS database lookup via the provided TCP client. The code is correct and readable but it is verbose. Most of the time, you don’t need to handle every error. Instead, you pass errors to the caller.  function whois(string domain, tcp:Client whoisClient) returns string|error {  error? err = whoisClient->writeBytes(domain.toBytes());  // The `is` operator tests whether a value belongs to a type.  if err is error {  // The `is` operator causes the type to be narrowed.  // The type of `err` variable is `error` in this block.  return err;  }  byte[]|error bytes = whoisClient->readBytes();  if bytes is error {  return bytes;  } else {  return string:fromBytes(bytes);  } }   This is operator-based error checking pattern is very common and you would end up having too many of them in your code.   if result is error {  // handle error  }   Ballerina provides a much more lightweight, shorthand for this pattern. The behavior of the function below is the same as the previous version but it is much more elegant. The check expr check expression performs an explicit error check, and the control flow also remains explicit.  function whois(string domain, tcp:Client whoisClient) returns string|error {  // If `writeBytes` failed with an error, then `check` makes  // the function return that error immediately  check whoisClient->writeBytes(domain.toBytes());  byte[] bytes = check whoisClient->readBytes();  return string:fromBytes(bytes); }   This function shows another pattern that handles errors in a single place. You can attach an on fail clause to some Ballerina statements such as do, while, transactions, foreach, etc. In this example, check does not simply return on error. The enclosing block decides how to handle the error. If the enclosing block has an on fail clause, it catches the error. If the enclosing block does not have an on fail block, it passes the error up to its enclosing block. Finally, the function handles the error by returning the error. This behavior is different from exceptions in that control flow is explicit.  function whois(string domain, tcp:Client whoisClient) returns string|error {  do {  check whoisClient->writeBytes(domain.toBytes());  byte[] bytes = check whoisClient->readBytes();  return string:fromBytes(bytes);  } on fail var err {  return error(\"Failed to communicate with the given whois server\", cause = err);  } }   Ignoring Return Values and Error  Ballerina does not allow ignoring return values of expressions.  // Error string:toBytes(\"ballerina.io\");   However, you can explicitly ignore a return value of an expression by assigning the result of the expressions to _;. This is like an implicitly-declared variable of the any type that cannot be referenced.  // Ok _ = string:toBytes(\"ballerina.io\");   However, Ballerina does not allow ignoring the value of an expression if the type includes an error. You are forced to handle the error explicitly.  // Error _ = whois(\"ballerina.io\", whoisClient);   As explained earlier, _ is like an implicitly-declared variable of the any; this is a union type that includes all the types in Ballerina except for the error type. Therefore, the type that includes all values supported by Ballerina is any|error. As per the typing rules in Ballerina, the above statement causes a compilation error because string|error is not a subtype of the any type.  Dealing with Abnormal Errors  ballerina has made a conscious decision to distinguish normal errors from abnormal errors. The sections above explained how to deal with normal errors. Out of memory, division by zero, programming bugs are examples of abnormal errors in Ballerina. Such errors typically result in immediate program termination.  Abnormal errors can be reported using the panic statement. Some language constructs such as type casts generate panics.  function toInt(any a) returns int {  // This is a programming bug  // Raise a panic if the value of `a` is not an `int`  return <int>a; }   A panic always has an associated error value as illustrated in the example below.  function divide(int m, int n) returns int {  if n == 0 {  panic error(\"division by 0\");  }  return m / n; }   Panics can be trapped with a trap expression. Ballerina raises a panic on an integer overflow. You can convert this panic to an error with a trap expression.  int|error result = trap (m + n);       Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/page-not-available.html","name":"Oops, we are sorry.","summary":"The page you are looking for is not available for this Ballerina version.You can either  to the previous page, use other keywords to  or contact the .This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If ...","content":"/ Oops, we are sorry.   The page you are looking for is not available for this Ballerina version.  You can either to the previous page, use other keywords to or contact the .     Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/search.html","name":"Search","summary":"This website uses cookies so that we can provide you with the best user experience. Read our  to find out more.If you wish to disable cookies you can do so from your browser.  ...","content":"/ Search Swan Lake  v1.2  Loading Search Results ...  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/terms-of-service/","name":"Terms of Service","summary":"Table of contents            The following Terms of Use (“Terms”) govern your access to and use of the  and any other site to which a link to these terms may appear (“Sites”). These Terms are a legal agreement between you and ...","content":"/ Terms of Service  Terms of Service  Table of contents Overview  The following Terms of Use (“Terms”) govern your access to and use of the and any other site to which a link to these terms may appear (“Sites”). These Terms are a legal agreement between you and WSO2. Your registration for, or use of the Sites and any software, repositories, other services, or projects hosted on the Sites (“Services”) shall be deemed to be your acceptance of these Terms. These Terms do not govern your access and use of the Ballerina programming language or related commercial support and services offerings, which may be made available to you under separate license terms.  If you are agreeing to these Terms on behalf of a company or other legal entity, you represent that you have the authority to, and do hereby bind such entity to these Terms. You may not use the Ballerina Sites or Services if you are a person barred from using the Sites or Services under the laws of the United States or other countries, including the country in which you are resident or from which you use the Sites, or international laws or treaties. You may not use the Ballerina Sites or Services if you are or represent an entity that is listed on any U.S. Government Denied Party/Person List. You affirm that you are over the age of 13 as the Service is not intended for children under 13. IF YOU ARE 13 OR OLDER BUT UNDER THE AGE OF 18, OR THE LEGAL AGE OF MAJORITY WHERE YOU RESIDE IF THAT JURISDICTION HAS AN OLDER AGE OF MAJORITY, THEN YOU AGREE TO REVIEW THE TERMS WITH YOUR PARENT OR GUARDIAN TO MAKE SURE THAT BOTH YOU AND YOUR PARENT OR GUARDIAN UNDERSTAND AND AGREE TO THESE TERMS. YOU AGREE TO HAVE YOUR PARENT OR GUARDIAN REVIEW AND ACCEPT THESE TERMS ON YOUR BEHALF. IF YOU ARE A PARENT OR GUARDIAN AGREEING TO THE TERMS FOR THE BENEFIT OF A CHILD OVER 13, THEN YOU AGREE TO AND ACCEPT FULL RESPONSIBILITY FOR THAT CHILD’S USE OF THE SERVICE, INCLUDING ALL FINANCIAL CHARGES AND LEGAL LIABILITY THAT HE OR SHE MAY INCUR.  Certain disclaimers  You understand and agree that the Sites and all Services on it are provided “AS-IS” and that we assume no responsibility for the timeliness, deletion, mis-delivery, or failure to store any user communications or personalization settings. We also assume no responsibility in relation to User Content made available through the Sites. You are responsible for obtaining access to the Services and that access may involve third-party fees (such as internet service provider or airtime charges).  You agree that you are responsible for your own use of the Services, for any posts you make, or code or data files you provide and for any consequences thereof. You agree that you will use the Services in compliance with all applicable local, state, national, and international laws, rules and regulations, including any laws regarding the transmission of technical data exported from your country of residence and all United States export control laws.  Your use of the Sites and Services    As a condition to using certain Services on the Sites, we may require that you log in with your existing SSO credentials through certain federated identity service providers as set out in the account registration procedure on the Sites. You will provide us with true, accurate, current, and complete information. You may not use anyone else’s password. You are solely responsible for maintaining the confidentiality of your account and password. You agree to immediately notify WSO2 of any unauthorized use of your password or accounts or any other breach of security. WSO2 will not be responsible for any loss or damage that may result if you fail to comply with these requirements. You will not employ the use of automation, mashups, programs, robots, or agents in the process of registering your account.  You will be responsible for all activity occurring under your accounts and will comply with all applicable local, state and foreign laws, treaties, and regulations in connection with your use of the Services, including without limitation, laws, and regulations governing data privacy, international communications, and transmission of technical or personal data.  You agree not to (a) access (or attempt to access) the administrative interface of the Services by any means other than through the interface that is provided by WSO2 in connection with the Services unless you have been specifically allowed to do so in a separate agreement with WSO2, and (b) engage in any activity that interferes with or disrupts the Sites and Services (or the servers and networks which are connected to the Sites and Services).  You may not access or use the Sites and Services for the purpose of bringing an intellectual property infringement claim against WSO2 or for the purpose of creating a product or service competitive with the Sites or Services.  Your account may have usage limits as further explained on the Services or other documentation provided by WSO2. The Services may not permit you to exceed the hard usage limits. WSO2 reserves the right to enforce soft usage limits in its sole discretion. Repeated exceeding of the hard or soft usage limits may lead to termination of your account.  The software and technology relating to the Ballerina Sites and the Services are the property of WSO2, its partners, and affiliates. You agree not to modify, adapt, distribute, reverse engineer, sell, assign, or otherwise transfer any portion of the Sites for any purpose including the unauthorized access to the Ballerina Sites. Copyright and other intellectual property laws protect these materials. Reproduction or retransmission of the materials, in whole or in part, in any manner, without the prior written consent of WSO2, is a violation of copyright law. For more details, see .  Privacy and restrictions on use    Our describes how we collect, use, and store any personal information belonging to you and is hereby incorporated by reference into these Terms. You agree that you will protect the privacy and legal rights of the end users of your repositories or other content stored or managed via the Services. You must provide a legally adequate privacy notice and protection for such end users.  You agree that you are responsible for your own conduct while accessing or using the Sites and Services and for any consequences thereof. You agree to use the Services only for purposes that are legal, proper, and in accordance with these Terms and any applicable laws or regulations. By way of example, and not as a limitation, you may not and may not allow any third party to:   send, upload, post, email, transmit, or otherwise make available any Content (as defined in the that is unlawful, harmful, threatening, abusive, harassing, tortious, defamatory, vulgar, obscene, libelous, invasive of another’s privacy, hateful, or racially, ethnically, or otherwise objectionable;  harm minors in any way;  impersonate any person or entity (via the use of an email address or otherwise), including, but not limited to, a WSO2 official, guide or host, or falsely state, or otherwise misrepresent your affiliation with a person or entity;  forge headers or otherwise manipulate identifiers in order to disguise the origin of any User Content transmitted through the service;  remove any copyright, trademark, or other proprietary rights notices contained in or on the Sites and Services or any content posted thereon;  send, upload, post, email, transmit, or otherwise make available any Content that you do not have a right to make available under any law or under contractual or fiduciary relationships (such as inside information, proprietary and confidential information learned or disclosed as part of employment relationships or under nondisclosure agreements);  send, upload, post, email, transmit, or otherwise make available any Content that infringes any patent, trademark, trade secret, copyright, or other proprietary rights (“Rights”) of any party;  send, upload, post, email, transmit, or otherwise make available any unsolicited or unauthorized advertising, promotional materials, spam, pyramid schemes, or any other form of solicitation;  send, upload, post, email, transmit, or otherwise make available any material that contains software viruses or any other computer code, files, or programs designed to interrupt, destroy, or limit the functionality of any computer software, hardware, or telecommunications equipment;  interfere with or disrupt the Sites and Services, servers, or networks connected to the Sites and Services, or disobey any requirements, procedures, policies, or regulations of networks connected to the Sites and Services;  display any portion of the Site via an HTML IFRAME;  submit content that falsely expresses or implies that such content is sponsored or endorsed by WSO2;  use the Sites and Services to send emails to distribution lists, newsgroups, or group mail aliases;  add deep hyperlinks to images or other non-hypertext content served by the Services;  intentionally or unintentionally violate any applicable local, state, national, or international law, ordinance, or regulation;  provide material support or resources (or to conceal or disguise the nature, location, source, or ownership of material support or resources) to any organization(s) designated by the United States government as a foreign terrorist organization pursuant to section 219 of the Immigration and Nationality Act;  stalk or otherwise harass another;  exploit the Sites and Services for any unauthorized commercial purposes;  use the Services in connection with illegal peer-to-peer file sharing;  collect or store personal data about other users in connection with the prohibited conduct and activities set forth above; and  use the Sites and Services or any interfaces provided with the Services to access any Ballerina software or Services in a manner that violates these Terms or other terms and conditions for use of such Ballerina software or Service.  You acknowledge, consent, and agree that WSO2 may access, preserve, and disclose your account information and User Content if required to do so by law or in a good faith belief that such access preservation or disclosure is reasonably necessary to:   comply with a legal process;  enforce these Terms;  perform any part of the Services;  respond to claims that any User Content violates the rights of third parties;  respond to your requests for customer service; or  protect the rights, property, or personal safety of WSO2, its users, and the public.  You understand that the Services and software embodied within the Services may include security components that permit digital materials to be protected, and that use of these materials is subject to usage rules set by WSO2 and/or content providers who provide content to the Services. You may not attempt to override or circumvent any of the usage rules embedded into the Services. Any unauthorized reproduction, publication, further distribution, or public exhibition of the materials provided on the service, in whole or in part, is strictly prohibited.  Using the Ballerina Sites or Services for acts or content in violation of these Terms may result in disabling or blocking of your account or access to the Sites without warning and WSO2 may take maximum legal action applicable within law. If we determine (in our sole discretion) that your account has been used to submit any content that violates our terms, we may remove such content from the site at any time without notice to you, and your account will be considered for blocking or disabling in our sole discretion.  User content    You understand that all code, data files, text, documentation, software, sound, graphics, illustrations, video, or other materials (“Content”), whether publicly posted or privately transmitted, are the sole responsibility of the person from whom such Content originated. This means that you, and not WSO2, are entirely responsible for all Content that you upload, post, email, transmit, or otherwise make available via the Services (“User Content”), as well as for any actions taken by WSO2 or other users as a result of your User Content. In connection with User Content, you affirm, represent, and warrant that you either own your User Content or have the necessary licenses, rights, consents, and permissions to grant the rights and licenses granted in these Terms.  You retain all ownership rights in User Content owned by you. WSO2 simply displays or makes the User Content available and does not control the User Content posted via the Services and, as such, does not guarantee the accuracy, integrity or quality of such User Content. You understand that by using the Services, you may be exposed to Content that is inaccurate, misleading, offensive, indecent, infringing, or otherwise objectionable. Under no circumstances will WSO2 be liable in any way for any User Content, including, but not limited to, any errors or omissions in any User Content, or any loss or damage of any kind incurred as a result of the use of any User Content posted, emailed, transmitted, or otherwise made available via the Sites and Services. You understand that WSO2 cannot, and does not, review all User Content and does not endorse any User Content. You further understand that WSO2 does not scan the User Content for malicious computer code such as computer viruses, trojans, computer worms, rootkits, back doors, adware, or spyware and that such content may contain such malicious code, and you agree to use such User Content at your own risk.  By submitting User Content to the Ballerina Sites you acknowledge and agree that:   your User Content does not contain confidential or proprietary information;  we are not under any obligation of confidentiality, express or implied, with respect to your User Content;  you have the right to specify or upload the terms under which other users of the Sites or Services will be licensed to use your User Content. We encourage users to, where possible, grant permissive licenses to their User Content. However, we will neither monitor nor bear responsibility for ensuring that the license terms attached to your User Content are complied with. We undertake no liability for any violation of the license terms under which you make your User Content available. If you do not specify or upload such license terms with respect to any User Content, you hereby grant us and all other users of the Sites and Services, a worldwide, perpetual, non-exclusive, irrevocable, sub-licensable, royalty-free license to use, distribute, reproduce, modify, adapt, publish, translate, publicly perform, and publicly display your User Content (in whole or in part) on the Sites and Services and to incorporate such User Content into other works in any format or medium now known or later developed;  we may delete or archive any User Content where such content has not been used for a certain period of time as determined by us, in our discretion. We may also delete or limit access to any User Content that we determine is violating these terms or any other applicable laws, rules, or regulations; and  you are not entitled to any compensation or reimbursement of any kind from WSO2 under any circumstances.  Copyright information  It is our policy to respond to notices of alleged infringement that comply with the Digital Millennium Copyright Act. If you believe that your work has been copied in a way that constitutes copyright infringement or your intellectual property rights have been otherwise violated, please provide WSO2’s Copyright Agent the following information:    an electronic or physical signature of the person authorized to act on behalf of the owner of the copyright or other intellectual property interest;  a description of the copyrighted work or other intellectual property that you claim has been infringed;  a description of where the material that you claim is infringing is located on the Sites;  your address, telephone number, and email address;  a statement by you that you have a good faith belief that the disputed use is not authorized by the copyright owner, its agent, or the law; and  a statement by you made under penalty of perjury, that the above information in your notice is accurate and that you are the copyright or intellectual property owner, or authorized to act on the copyright or intellectual property owner’s behalf.   WSO2’s agent for notice of claims of copyright or other intellectual property infringement can be reached as follows:    By mail: Attn: Copyright Agent, WSO2 Inc. 787 Castro Street, Mountain View CA 94041, USA  By phone: (+1) 408 754 7388  By Fax: (+1) 408 689 4328   User disagreements  You alone are responsible for your involvement and interactions with other users of the Services. WSO2 reserves the right but has no obligation to monitor disagreements between you and other users. If you have a dispute with any other users of the Services, you irrevocably and forever release WSO2 (and WSO2’s affiliates, officers, directors, agents, subsidiaries, joint ventures, and employees) from claims, demands, and damages (actual and consequential) of every kind and nature, known and unknown, arising out of or in any way connected with such disputes. IF YOU ARE A CALIFORNIA RESIDENT, YOU WAIVE CALIFORNIA CIVIL CODE SECTION 1542, WHICH SAYS: “A GENERAL RELEASE DOES NOT EXTEND TO CLAIMS WHICH THE CREDITOR DOES NOT KNOW OR SUSPECT TO EXIST IN HIS OR HER FAVOR AT THE TIME OF EXECUTING THE RELEASE, WHICH IF KNOWN BY HIM OR HER MUST HAVE MATERIALLY AFFECTED HIS OR HER SETTLEMENT WITH THE DEBTOR.”  Our trademarks and proprietary rights    You acknowledge and agree that WSO2 (or its licensors) own all legal right, title, and interest in and to the Sites and the Services. The visual interfaces, graphics, design, systems, methods, information, computer code, software, services, “look and feel”, organization, compilation of the content, code, data, and all other elements of the Sites and Services (collectively, “Ballerina Materials“) are protected by United States copyright, trade dress, patent, and trademark laws, international conventions, and all other relevant intellectual property and proprietary rights, and applicable laws. Except for any User Content owned and/or posted by you or other users, all Ballerina Materials are the copyrighted property of WSO2 or its licensors. Furthermore, all trademarks, service marks, and trade names contained in the Ballerina Materials are proprietary to WSO2 or its licensors. Except as expressly set forth herein, your use of the Sites or Services does not grant you ownership of, or any other rights with respect to, any content, code, data, user comments or other materials that you may access on or through the Sites or Services. WSO2 reserves all rights to the Ballerina Materials not expressly granted in the Terms.  The following names, trademarks, service marks, logos, and product and service names are trademarks of WSO2: “Ballerina”, “BallerinaCon”, “Ballerina Central”, and “WSO2” and the WSO2 and Ballerina logos. Without WSO2’s prior permission, you agree not to display or use in any manner such names and marks, except for reasonable attribution purposes.  Third party Sites and Services  The Sites and Services may hyperlink to and integrate with third-party applications, websites, and other services. You decide whether and how to use and interact with such services. We do not make any warranty regarding such services or content they may provide, and will not be liable to you for any damages related to such services. Use of such third-party services may be governed by other terms and privacy notices that are not part of this Agreement and are not controlled by us.  Revisions to these Terms and termination    We may at any time revise these Terms by updating this page. We will not send individual email notifications on these updates. By using the Ballerina Sites and Services, you agree to be bound by any such revisions and are therefore encouraged to periodically visit this page. Your continued use of the Sites and Services after revisions are made to this policy will constitute your acceptance of such revised terms.  You agree that WSO2 in its sole discretion and for any or no reason may terminate these Terms and your account for the Services. You agree that any termination of your access to the Services may be without prior notice, and you agree that WSO2 will not be liable to you or any third party for such termination. If WSO2 terminates these Terms or your access or use of the Services due to your breach of these Terms or any suspected fraudulent, abusive, or illegal activity, then termination of these Terms shall be in addition to any other remedies WSO2 may have at law or in equity.  Upon any termination or expiration of these Terms, whether by you or WSO2, ANY INFORMATION (INCLUDING USER CONTENT) THAT YOU HAVE POSTED OR SUBMITTED ON OR THROUGH THE SERVICE OR THAT WHICH IS RELATED TO YOUR ACCOUNT MAY NO LONGER BE ACCESSED BY YOU and WSO2 will have no obligation to maintain any such information in its databases or to forward any such information to you or any third party. However, you acknowledge that the ecosystem and community beyond WSO2 may build a lasting dependency upon your User Content once it is posted upon the Sites. To ensure community continuity, WSO2 retains the right to continue to host and maintain your User Content on the Sites and Services even after the termination of your account, or the expiration of these terms, at our sole discretion. In the event of any contradiction between the right granted herein and any term of the license specified with your User Content, you agree that the right granted in this section 9.3 shall prevail. You are solely responsible for retrieving your User Content from the Services prior to termination of your account for any reason, provided that if we terminate your account, we will attempt to provide you a with reasonable opportunity to retrieve your User Content.  Subscriptions and mail notifications  It’s your choice. If you have chosen to subscribe to receive any services related information, Ballerina updates, newsletters, or other informational material, you have the right to opt-out of receiving such email notifications at any point by clicking on the “unsubscribe” link at the bottom of any email sent by us, or by notifying us at if you would like us to delete all contact information and personal data we have from you.  Limitation of liability and disclaimer of warranties  YOUR USE OF THE SITES AND SERVICE IS AT YOUR SOLE RISK. THE SERVICE IS PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS. WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, AND LICENSORS EXPRESSLY DISCLAIM ALL WARRANTIES OF ANY KIND, WHETHER EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.  YOU EXPRESSLY UNDERSTAND AND AGREE THAT WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, AND LICENSORS SHALL NOT BE LIABLE TO YOU FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR EXEMPLARY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR LOSS OF PROFITS, GOODWILL, USE, DATA OR OTHER INTANGIBLE LOSSES (EVEN IF WSO2 HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES), RESULTING FROM:    THE USE OR THE INABILITY TO USE THE SERVICE;  THE COST OF PROCUREMENT OF SUBSTITUTE GOODS AND SERVICES RESULTING FROM ANY GOODS, DATA, INFORMATION OR SERVICES PURCHASED OR OBTAINED OR MESSAGES RECEIVED OR TRANSACTIONS ENTERED INTO THROUGH OR FROM THE SERVICE;  UNAUTHORIZED ACCESS TO OR ALTERATION OF YOUR TRANSMISSIONS OR DATA;  STATEMENTS OR CONDUCT OF ANY THIRD PARTY ON THE SERVICE; OR  ANY OTHER MATTER RELATING TO THE SERVICE.   Indemnification  YOU AGREE TO HOLD HARMLESS AND INDEMNIFY WSO2 AND ITS SUBSIDIARIES, AFFILIATES, OFFICERS, AGENTS, EMPLOYEES, ADVERTISERS, LICENSORS, SUPPLIERS, OR PARTNERS FROM AND AGAINST ANY THIRD PARTY CLAIM ARISING FROM OR IN ANY WAY RELATED TO (A) YOUR BREACH OF THE TERMS, (B) YOUR VIOLATION OF APPLICABLE LAWS, RULES OR REGULATIONS IN CONNECTION WITH THE SERVICE, OR (C) YOUR USER CONTENT, INCLUDING ANY LIABILITY OR EXPENSE ARISING FROM ALL CLAIMS, LOSSES, DAMAGES (ACTUAL AND CONSEQUENTIAL), SUITS, JUDGMENTS, LITIGATION COSTS, AND ATTORNEYS’ FEES, OF EVERY KIND AND NATURE. IN SUCH CASE, WSO2 WILL PROVIDE YOU WITH WRITTEN NOTICE OF SUCH CLAIM, SUIT OR ACTION; WILL PROVIDE YOU THE OPPORTUNITY TO CONTROL THE DEFENSE AND/OR SETTLEMENT OF SUCH CLAIM, SUIT OR ACTION; AND WILL PROVIDE YOU REASONABLE ASSISTANCE IN SUCH DEFENSE OR SETTLEMENT, UPON REASONABLE REQUEST.  General  These Terms will be governed by and construed in accordance with the laws of the State of California, without giving effect to its conflict of laws provisions. Any claims, legal proceeding or litigation arising in connection with the service will be brought solely in Santa Clara County, California, and you consent to the jurisdiction of such courts. The failure of WSO2 to exercise or enforce any right or provision of these Terms not constitute a waiver of such right or provision. If any provision of the Terms is found by a court of competent jurisdiction to be invalid, the parties nevertheless agree that the court should endeavor to give effect to the parties’ intentions as reflected in the provision, and the other provisions of these Terms remain in full force and effect. These Terms constitute the entire agreement between you and WSO2 and govern your use of the Sites and Services superseding any prior agreements between you and WSO2 with respect to the Sites and Services.        Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/why-ballerina/batteries-included-old/","name":"Batteries Included","summary":"Ballerina includes not only the programming language but also a full platform, which consists of various components of the surrounding ecosystem. The Ballerina platform consists of the following components.This contains a list of modules that help developers rapidly build applications. From HTTP and HTTP/2 to WebSockets, WebSub, AMQP, JSON, XML, ...","content":"/  / Batteries Included  Batteries Included  Ballerina includes not only the programming language but also a full platform, which consists of various components of the surrounding ecosystem. The Ballerina platform consists of the following components.  Standard Library  This contains a list of modules that help developers rapidly build applications. From HTTP and HTTP/2 to WebSockets, WebSub, AMQP, JSON, XML, ProtoBuf, gRPC, and OpenAPI.   Ballerina Central  This is a centralized module repository where you can discover modules of reusable code and assemble them in powerful ways.    Documentation  Ballerina has a built-in documentation framework based on markdown named Docerina. Docerina allows you to write unstructured documents with a bit of structure to enable HTML content generation as API documentation.   Testing  Ballerina has a built-in test framework named Testerina. Testerina enables you to write testable code and provides a set of building blocks to help you write and execute tests.   IDE Plugins  We provide plugins for popular IDEs so you can code in your preferred platform.   \"Ballerina will enable fast, quality, 12-factor ready deployments out of the box. The strong annotation set is a great ‘batteries included’ approach that will have Devs and Ops collaborating from the start of development.\"  Jim Kittle, an application architect at a leading university in the United States.  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/why-ballerina/from-code-to-cloud-old/","name":"From Code to Cloud","summary":"In the past, developers simply wrote their program, built it and ran it. Today, developers also need to think of the various deployment options such as Docker, Kubernetes, serverless environments and service meshes. But this deployment process is not part of the programming experience for developers. They have to write ...","content":"/  / From Code to Cloud  From Code to Cloud  In the past, developers simply wrote their program, built it and ran it. Today, developers also need to think of the various deployment options such as Docker, Kubernetes, serverless environments and service meshes. But this deployment process is not part of the programming experience for developers. They have to write code in a certain way to work well in a given execution environment, and removing this from the programming problem isn’t good.  Ballerina specializes in moving from code to cloud while providing a unique developer experience. Its compiler can be extended to read annotations defined in the source code and generate artifacts to deploy your code into different clouds. These artifacts can be Dockerfiles, Docker images, Kubernetes YAML files or serverless functions.  From Code to Kubernetes  is the preferred platform for running applications with multiple microservices in production. It can be used for automating deployment and scaling, and management of containerized applications. Kubernetes defines a set of unique building blocks that need to be defined as YAML files and deployed into the Kubernetes cluster.  However, in many cases, creating these YAML files is out of a developer’s comfort zone. The Ballerina compiler can create these YAML files while compiling the source code, so you don’t have to! The code below shows the build option you need to use to do this:  Get Started  The following code snippet shows how Ballerina compiler can generate YAML files to deploy your code to Kubernetes.  import ballerina/http; service /hello on new http:Listener(9090) {  resource function get sayHello() returns string? {  return \"Hello, World!\";  } }   Building the source with bal build --cloud=k8s will generate the Kubernetes YAML files and Docker image that is required to deploy hello application into Kubernetes.  Building the source with bal build --cloud=docker will generate the Docker image and Dockerfile.  From Code to AWS Lambda  is an event-driven, serverless computing platform. Ballerina functions can be deployed in AWS Lambda by annotating a Ballerina function with @awslambda:Function, which should have the function signature function (awslambda:Context, json) returns json|error.   From Code to Azure Functions  is a serverless solution that allows you to write less code, maintain less infrastructure, and save on costs. Ballerina functions can be deployed in Azure by annotating a Ballerina function with @azure_functions:Function.   CI/CD with GitHub Actions  In a microservice architecture, continuous integration and continuous delivery (CI/CD) is critical in creating an agile environment for incorporating incremental changes to your system. There are different technologies that provide this CI / CD functionality and very recently GitHub has introduced , which is now available for general usage. GitHub Actions provides a convenient mechanism for implementing CI/CD pipelines using their workflows concept, right from our GitHub repositories.  With we can create a Ballerina development environment with built-in CI/CD. The following article has a comprehensive guideline:  Support for SaaS Connectors  We have discussed how Ballerina supports different technologies to automate cloud deployments. To obtain the full strength of the cloud, applications should be able to integrate with Software-as-a-Service (SaaS) provided by different cloud vendors.  Ballerina provides a simple workflow to connect and integrate with these SaaS services. For example, the following code snippet shows how to initialize and send out a tweet with the Twitter SaaS service:  import ballerina/config; import ballerina/log; import wso2/twitter; // Twitter package defines this type of endpoint // that incorporates the twitter API. // We need to initialize it with OAuth data from apps.twitter.com. // Instead of providing this confidential data in the code // we read it from a toml file. twitter:Client twitterClient = new ({  clientId: config:getAsString(\"clientId\"),  clientSecret: config:getAsString(\"clientSecret\"),  accessToken: config:getAsString(\"accessToken\"),  accessTokenSecret: config:getAsString(\"accessTokenSecret\"),  clientConfig: {} });  public function main() {  twitter:Status|error status = twitterClient->tweet(\"Hello World!\");  if (status is error) {  log:printError(\"Tweet Failed\", status);  } else {  log:printInfo(\"Tweeted: \" + <@untainted>status.id.toString());  } }   Ballerina has many out-of-the-box SaaS connectors, which you can find in .  \"We were attracted by Ballerina’s cloud native features, such as the automatic generation of Docker, Kubernetes, and Helm artifacts, as well as its small footprint and faster boot times. It is also capable of running as a Lambda function (serverless) in AWS. Together, these capabilities have enabled us to easily run microservices in containers at scale and integrate with CI/CD tools with less effort.\"  Harsha Pulleti, integration architect and senior manager, Motorola  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/why-ballerina/network-aware-type-system-old/","name":"Network-Aware Type System","summary":"In a programming language, the type system is the foundation for representing data and implementing logic. It provides the means of creating abstractions to the solutions that you provide. While some languages provide basic functionality, others strive to give in-built functionality for specialized domains.\n       ...","content":"/  / Network-Aware Type System  Network-Aware Type System  In a programming language, the type system is the foundation for representing data and implementing logic. It provides the means of creating abstractions to the solutions that you provide. While some languages provide basic functionality, others strive to give in-built functionality for specialized domains.  With more services being available in the cloud, the network-distributed programming domain has grown. As the developer is given the added responsibility of working with networked resources in their code, it is critical that the programming language itself aids in this operation. That’s why Ballerina’s network-friendly type system is specialized for this domain.  Statically Typed and Structural  Ballerina is a statically typed language, which means all the variables are checked at compile-time and only compatible values are assigned. Statically typed languages are generally more robust, easier to debug, and aids in creating better language tooling.  Ballerina’s type system is also structural as opposed to nominal. This means that the type compatibility is identified by considering the structure of the value. This is different from languages like Java, C++, and C# that have nominal type systems where it is bound by the name of the actual type.  Shapes in Ballerina  Types in Ballerina deal with an abstraction of values that don’t consider storage identity. This abstraction is called a shape. For simple types like int and boolean, there is no difference between a shape and a value because they don’t have a storage identity. To understand the concept of a shape, let’s look at the in Ballerina. Because records have storage identity, a reference to the value is stored in the variable rather than storing the actual value. This is comparable to references in Java or pointers in C++.  Here’s an example of a record that stores the state of a door:  type DoorState record {|  boolean open;  boolean locked; |};   Now let’s create some values of the DoorState record type:  DoorState v1 = { open: false, locked: true }; DoorState v2 = { open: false, locked: true }; DoorState v3 = { open: false, locked: true };   The three variables above all represent a single state of the door being closed and locked. Nonetheless, we have created three different values where each variable is stored in a distinct memory reference. If we ignore the storage identity of these variables, we are left with the representation of the data it has, which is { open: false, locked: true }. This is a single shape of the type DoorState.  In this way, there are four possible shapes for DoorState as shown in the variables below:  DoorState ds1 = { open: true, locked: true }; DoorState ds2 = { open: true, locked: false }; DoorState ds3 = { open: false, locked: true }; DoorState ds4 = { open: false, locked: false };   A type in Ballerina represents a set of the possible shapes it can have. So any value that belongs to either of the above four shapes will be considered to be of the type DoorState. Figure 1: Set of shapes of the type DoorState  Subtypes in Ballerina  Subtyping in Ballerina is semantic. It is defined by means of shapes, where S is a subtype of T, if the shapes representing S are a subset of the shapes representing T. Let’s demonstrate this behavior with a few examples. The type boolean is a simple basic type in Ballerina without a storage identity, so its values become equivalent to its shapes. Therefore the boolean type is defined as having two shapes true and false. The boolean type’s shapes can be defined in set notation as Sboolean = { true, false }. This can be visualized as seen in Figure 2 below. Figure 2: Set of shapes of the type boolean  Now, according to our subtyping rules, we can derive new types based on the boolean type by creating subsets of its shapes. For example, a new type we can create is boolean_false where its only supported shape/value would be false. The new type is shown in Figure 3 below.  Figure 3: Shapes sets of types boolean and boolean_false  The new type boolean_false can be defined in Ballerina code in the following manner: type boolean_false false;   Here, we are using the value false in defining the new type boolean_false. In a more practical scenario, we can provide multiple values as a union when defining new types using the syntax T1|T2. A type created with a single value is called a singleton type. This new type can be used in the code in the following way. boolean_false bv1 = false; boolean bv2 = true; bv2 = bv1;   As you can see, bv1 of type boolean_false can be assigned to bv2 of type boolean because bv1’s type is a subset of bv2’s type. In simple terms, all the values that can be held in the variable bv1 can be held in the variable bv2, thus the assignment is possible.  We have now seen how Ballerina’s subtyping works in relation to simple types. Let’s take a look at creating subtypes of records by revisiting our DoorState scenario. Here, we will create a new type EmergencyDoorState, where the locked field has to always have the value false. The resultant types and their shapes can be seen below in Figure 4.  Figure 4: Shapes sets of types DoorState and EmergencyDoorState  The type definition of EmergencyDoorState type is shown below:  type EmergencyDoorState record {|  boolean open;  boolean_false locked = false; |};   In the above type, we have modified the field locked to be of type boolean_false, which allows its only value to be false. In this type definition, default values in Ballerina records have been used, wherein the absence of an explicit value provided by the user, the default value mentioned here will be used.  In this manner, the type EmergencyDoorState can only have the shapes { open: true, locked: false } and { open: false, locked: false }. These two elements make it a subset of the DoorState shapes set, thus EmergencyDoorState is a subtype of DoorState. The following code snippet shows a sample usage of the EmergencyDoorState type: EmergencyDoorState eds1 = { open: true }; DoorState eds2 = eds1; io:println(\"Door - Open: \", eds2.open, \" Locked: \", eds2.locked);   Benefits of a Structural Type System  A structural type system proves beneficial when you have multiple systems interacting with each other since data exchange and type compatibilities can be resolved easier. Let’s dive into a Ballerina example, which shows this behavior.  type Result record {|  string name;  string college;  int grade; |}; ... Result[] results = from var person in persons  let int lgrade = (grades[person.name] ?: 0),  where lgrade > 75  string targetCollege = \"Stanford\"  select {  name: person.name,  college: targetCollege,  grade: lgrade };   In the example above, we filter records from a list and create a new value using the select clause. Its structure is defined dynamically at that time and the values are created. These values are assigned to an array of Result records, which is possible because the generated values are structurally compatible with the Result record type. In situations such as above, a separate system from our core application may be generating values to be consumed by us. In these cases, instead of worrying about sharing the code for the data type definitions, you can simply concentrate on the compatibility of the data in order to ensure interoperability. Open-by-Default  Ballerina’s open-by-default concept is tied around the . This means that we should design network-aware programs to accept all the data that is sent to you and make the best effort to understand it. But when sending data, you should make the best effort to conform to the standard protocols that were agreed upon beforehand. This strategy makes sure we have the best chance of interacting with different systems in a reliable manner. The main facilitator of this in the type system is the open record concept in Ballerina. So far we have looked at closed records. Let’s take a look at a record type to represent the details of a person.  Get Started  The code snippet below shows a call to a simple HTTP GET request endpoint:  type Ethnicity \"Asian\"|\"White\"|\"African American\"|\"Native American/Alaskan Native\"|\"Pacific Islander\"|\"Native Hawaiian\";  type Person record {  string name;  int birthYear; boolean married = false;  Ethnicity ethnicity?; };  Here, the type Person is an open record type defined with an inclusive-record-type-descriptor by using the \"{\" and \"}\" delimiters. This is the default behavior when defining record types in Ballerina. An open record is not limited to the fields that are declared in the record type, so we can set additional fields that are not explicitly mentioned in the type definition.  The earlier DoorState record type was defined explicitly as a closed record type with an exclusive-record-type-descriptor by using the \"{|\" and \"|}\" delimiters. Therefore we were able to list out all the possible shapes in the DoorState type. If this type was defined as an open record, we would have an infinite number of shapes since DoorState values can have any arbitrary field set in the code.  The Person record type above has an ethnicity (denoted by the suffix \"?\"). This means the field value of ethnicity of a Person record can be skipped without setting a value. Later on, this field can be accessed using the \"?.\" operator, which would return a value of type Ethnicity?, which is equivalent to the union type Ethnicity|(). In Ballerina, the nil value and the type is represented by ().  Let’s create a new type Student, which will be a subtype of the Person type. type Student record {  string name;  int birthYear; boolean married;  Ethnicity ethnicity?;  string college; };   The Student type defined above has an extra field college of type string compared to the Person type. All the possible shapes in the Student type are included in the set of shapes in Person as well. This is possible because the Person type is an open record. If we make the Person type a closed record, Student will no longer be a subtype of Person.  Sample usage of the above types is shown below:  public function main() {  Student s1 = { name: \"Tom\", birthYear: 1990, married: false,  college: \"Yale\" };  Student s2 = { name: \"Anne\", birthYear: 1988, married: true,  ethnicity: \"White\", college: \"Harvard\" };  Person p1 = s1;  Ethnicity? eth = p1?.ethnicity;  if eth != () {  io:println(\"P1's ethnicity: \", eth);  } else {  io:println(\"P1's ethnicity: N/A\");  }  Person p2 = s2;  eth = p2?.ethnicity;  if eth != () {  io:println(\"P2's ethnicity: \", eth);  } else {  io:println(\"P2's ethnicity: N/A\");  }  io:println(p2); }   $ bal run sample.bal P1's ethnicity: N/A P2's ethnicity: White name=Anne birthYear=1988 married=true ethnicity=White college=Harvard   Network Communication with Data Binding  The type system features for records in Ballerina can be used when implementing operations with structural validation, data types handling, and payload passthrough operations. The functionality will be demonstrated using an HTTP service in Ballerina: http:Client asianRecordsDB = check new (\"http://example.com/\");  service / on new http:Listener(8080) {   resource function get 'record(@http:Payload {} Person entry) returns error? {  if entry?.ethnicity == \"Asian\" {  io:println(\"Asian Record: \", entry);  json jsonPayload = check entry.cloneWithType(json);  _ = check asianRecordsDB->post(\"/store\", <@untainted>jsonPayload);  } else {  io:println(\"Non-Asian Record: \", entry);  }  }  }   $ bal run sample.bal [ballerina/http] started HTTP/WS listener 0.0.0.0:8080    Test Scenarios  Description  Request  Output  A request is sent without setting the married field. Since this field has a default value in the Person type, the value is automatically populated to that. The ethnicity field is not set since it is marked as optional.  curl -d '{ \"name\": \"John Little\", \"birthYear\": 1855 }' http://localhost:8080/record  Non-Asian Record: name=John Little birthYear=1855 married=false  A request is sent with a string value given for the integer field birthYear. The service validates the value for the field and the request fails.  curl -d '{ \"name\": \"John Little\", \"birthYear\": \"1855\" }' http://localhost:8080/record  data binding failed: error {ballerina/lang.typedesc}ConversionError message='map '<' json > ' value cannot be converted to 'Person'  A request is sent with the optional ethnicity field also set. curl -d '{ \"name\": \"Sunil Perera\", \"birthYear\": 1950, \"married\": true, \"ethnicity\": \"Asian\" }' http://localhost:8080/record  Asian Record: name=Sunil Perera birthYear=1950 married=true ethnicity=Asian   A request is sent with a non-existing value of the Ethnicity union type. This is validated by the service and the request fails.  curl -d '{ \"name\": \"Tim Kern\", \"birthYear\": 1995, \"ethnicity\": \"Japanese\", \"country\": \"Japan\", \"zipcode\": \"98101\" }' http://localhost:8080/record  data binding failed: error {ballerina/lang.typedesc}ConversionError message='map< json >' value cannot be converted to 'Person'   A request is sent with additional fields not explicitly mentioned in the Person type. Since Person is an open record type, the service accepts and makes these extra fields available to be passed through to other systems, e.g. a forwarding service.  curl -d '{ \"name\": \"Tim Kern\", \"birthYear\": 1995, \"ethnicity\": \"Asian\", \"country\": \"Japan\", \"zipcode\": \"98101\" }' http://localhost:8080/record  Asian Record: name=Tim Kern birthYear=1995 married=false ethnicity=Asian country=Japan zipcode=98101  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/why-ballerina/sequence-diagrams-for-programming-old/","name":"Sequence Diagrams for Programming","summary":"In today’s cloud-era, we need technologies that can model distributed systems in a more developer-friendly way. This means that for a single use case we need to model a flow that shows how multiple actors interact with each other, how concurrent execution flows, and what remote endpoints are involved. Sequence ...","content":"/  / Sequence Diagrams for Programming  Sequence Diagrams for Programming  In today’s cloud-era, we need technologies that can model distributed systems in a more developer-friendly way. This means that for a single use case we need to model a flow that shows how multiple actors interact with each other, how concurrent execution flows, and what remote endpoints are involved. Sequence diagrams are known to be the best way to visually describe this.  That’s why it is the foundation for designing the syntax and semantics of the Ballerina language. Ballerina provides the flexibility of a general-purpose language while having features to model solutions based on higher-level abstractions.  Sequence Diagrams in Ballerina  In Ballerina, there is a bidirectional mapping between the textual representation of code in Ballerina syntax and the visual representation as a sequence diagram.  In Ballerina services, the entry point is the service resource function. The actor who invokes the service resource is shown as the “caller”. The “Default” participant is the resource function itself, showing the operations in its lifeline. From the resource function, further function calls are shown in its lifeline and their internal operations are expanded and merged to the same sequence diagram to show their operations as well.  Get Started  The Ballerina IDE plugin (for example, the ) can generate a sequence diagram dynamically from the source code. To start generating a sequence diagram from your Ballerina code, .  Client Objects and Remote Methods  Ballerina has special network client objects, like HTTP clients and database connections, that have their own lifeline to represent its functionality and the messages that it can receive. The messages sent to or the invocations done on these network clients are called remote methods — a special method inside a client object that represents a call through the network. Remote calls are distinguished from normal method calls by using the arrow “->” notation.  The following code shows an HTTP client that is used to do GET and POST requests to a remote endpoint:  public function execute(http:Client lkSvc, http:Client rpSvc) {  var res1 = lkSvc->get(\"/query\");  boolean report = true;  http:Request req = new;  if report {  var res2 = rpSvc->post(\"/report\", req);  } }   The HTTP clients represented by lookupService and reportService variables are of type http:Client, which represents remote HTTP endpoints. The following diagram shows the generated sequence diagram for the above remote method calls.  We can see here how the HTTP clients have become participants of the sequence diagram with its own lifeline, where we visualize the messages sent and received to represent the network calls we do.  In a similar manner, a database client is used to model a remote database server in order to interact using its remote methods to carry out database operations.  public function lookupAccountTx(jdbc:Client db, boolean clearTx) returns @tainted error? {  var result = db->query(\"SELECT * FROM AccountTx\", Account);  if clearTx {  _ = check db->execute(\"DELETE FROM AccountTx\");  } }   The following diagram shows how the database operations are also automatically mapped to a sequence diagram similar to the HTTP client operations.  Let’s look at an HTTP service resource called withdrawMoney as shown in the code below. The caller is the name of the first parameter of this method, which also happens to be a client object that represents the caller of our service resource.  resource function withdrawMoney(http:Caller caller, http:Request request,  string id, decimal val) returns @tainted error?   The caller instance of type http:Caller can be used by the resource author to communicate back with the caller by invoking its remote methods. This model allows you to easily implement messaging patterns like bi-directional communication. There can be multiple interactions with the caller rather than just returning the result at the end of the resource method definition.  The line below shows how we responded to the client using the caller instance.  var result = check caller->respond(\"Fail: no funds\");   The following diagram shows how the HTTP resource definition is visualized, and how its interactions in the resource are shown.  The result here represents the response retrieved back from the caller, where for example, if there was an error communicated back to the caller, we can perform further actions in our resource method rather than ignoring it. This pattern encourages a more robust approach to handling errors.  Concurrency  Concurrency in Ballerina is enabled by strands, which are lightweight threads. A single operating system thread can contain multiple strands. A single strand is run at a time in a thread, and the strands belonging to a single thread are cooperatively multitasked. Strands allow us to optimize the usage of CPU time and is beneficial in implementing non-blocking I/O operations.  A worker represents a single strand execution in a function. Concurrent operations in a function are defined by multiple workers as shown in the example below.  public function initSystem(http:Client lookupService,  http:Client reportService) {  worker proc1 {  // process something  var res1 = lookupService->get(\"/query\");  int x = 0;  foreach var i in 1...10 { x += i; }  x -> proc2;  x = <- proc2;  http:Request req = new;  var res2 = reportService->post(\"/report\", req);  }  worker proc2 {  // process other things  int x = 1;  int i = 1;  while i < 10 { x *= i; }  x = <- proc1;  var res1 = lookupService->get(\"/query\");  // process more  x -> proc1;  } }   In the code, we are contacting a couple of network endpoints, retrieving information and reporting the state at the end. The network operations are mixed in with some computational code that is required to do some calculations.  This concurrency execution is visualized in the generated sequence diagram below:  The workers have become participants in the sequence diagram alongside the HTTP clients. The workers’ activations occur concurrently and communication between them is done using message passing — Ballerina’s send (->) and receive (<-) actions. The compiler also explicitly verifies that the send and receive actions are in a consistent state in order to avoid any deadlock scenarios in the runtime.  Ballerina has many out-of-the-box SaaS connectors, which you can find in .  \"[With Ballerina] you can get sequence diagrams automatically. When things start to get complicated and you need to understand and socialize with the rest of your team what it is that you're building, these diagrams become very helpful,\"  Christian Posta, field CTO, solo.io   Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."},{"page":"/why-ballerina/the-network-in-the-language-old/","name":"The Network in the Language","summary":"In a microservice architecture, smaller services are built, deployed and scaled individually. These disaggregated services communicate with each other over the network forcing developers to deal with the  as a part of their application logic.For decades, programming languages have treated networks simply as I/O sources. Ballerina treats the network ...","content":"/  / The Network in the Language  The Network in the Language  In a microservice architecture, smaller services are built, deployed and scaled individually. These disaggregated services communicate with each other over the network forcing developers to deal with the as a part of their application logic.  For decades, programming languages have treated networks simply as I/O sources. Ballerina treats the network differently by making networking concepts like client objects, services, resource functions, and listeners a part of the syntax. So you can use the language-provided constructs to write network programs that just work.  Services  Ballerina introduces service typing where services, which work in conjunction with a listener object, can have one or more resource methods in which the application logic is implemented. The listener object provides an interface between the network and the service. It receives network messages from a remote process according to the defined protocol and translates it into calls on the resource methods of the service that has been attached to the listener object.  Get Started  Here’s a simple Hello World service to get you started:  import ballerina/http;  service / on new http:Listener(9090) {   resource function get greeting() returns string {  return \"Hello World!\";  }  }   The Ballerina source file is compiled and executed in the following manner:  $ bal run hello.bal  Compiling source  hello.bal  Running executable  [ballerina/http] started HTTP/WS listener 0.0.0.0:9090  $ curl http://localhost:9090/greeting Hello, World!   Ballerina services come with built-in concurrency. Every request to a resource method is handled in a separate strand (Ballerina concurrency unit), which gives implicit concurrent behavior to a service.  Some protocols supported out-of-the-box include:  Async Network Protocol  In the request-response paradigm, network communication is done by blocking calls, but blocking a thread to a network call is very expensive. That’s why other languages supported async I/O and developers have to implement async/await by using callback-based code techniques.  On the other hand, Ballerina’s request-response protocols are implicitly non-blocking and will take care of asynchronous invocations.  Get Started  The code snippet below shows a call to a simple HTTP GET request endpoint:  import ballerina/http; import ballerina/io;  public function main() returns @tainted error? {  http:Client clientEP = check new (\"http://www.mocky.io\");  string payload = check clientEP->get(\"/v2/5ae082123200006b00510c3d/\", targetType = string);  io:println(payload); }  The above “get” operation is seemingly a blocking operation for the developer, but internally it does an asynchronous execution using non-blocking I/O, where the current execution thread is released to the operating system to be used by others. After the I/O operation is done, the program execution automatically resumes from where it was suspended. This pattern gives the developer a much more convenient programming model than handling non-blocking I/O manually while providing maximum performance efficiency. Client Objects  Client objects allow workers to send network messages that follow a certain protocol to a remote process. The remote methods of the client object correspond to distinct network messages defined by the protocol for the role played by the client object.  Get Started  The following sample illustrates sending out a tweet by invoking tweet remote method in the twitter client object.  import ballerina/io; import ballerinax/twitter;  configurable string clientId = ?; configurable string clientSecret = ?; configurable string accessToken = ?; configurable string accessTokenSecret = ?;  // Twitter package defines this type of endpoint // that incorporates the twitter API. // We need to initialize it with OAuth data from apps.twitter.com. // Instead of providing this confidential data in the code // we read it from a configuration file. twitter:Client twitterClient = new ({  clientId: clientId,  clientSecret: clientSecret,  accessToken: accessToken,  accessTokenSecret: accessTokenSecret,  clientConfig: {} }); public function main() returns error? {  twitter:Status status = check twitterClient->tweet(\"Hello World!\");  io:println(\"Tweeted: \", <@untainted>status.id); }  Resiliency  The network is unreliable. That’s why network programs need to be written in a way that handles failures. In some cases, an automatic retry will help recover from failures while in others failover techniques will help deliver uninterrupted service. Techniques like circuit breakers also help to prevent catastrophic cascading failure across multiple programs.  Get Started  Ballerina helps developers write resilient, robust programs with out-of-the-box support for techniques such as:  Get Started  The code snippet below shows how you can easily configure a circuit breaker to handle network-related errors in the Ballerina HTTP client object.  http:Client backendClientEP = check new(\"http://localhost:8080\", {  circuitBreaker: {  rollingWindow: {  timeWindowInMillis: 10000,  bucketSizeInMillis: 2000,  requestVolumeThreshold: 0  },  failureThreshold: 0.2,  resetTimeInMillis: 10000,  statusCodes: [400, 404, 500]  },  timeoutInMillis: 2000  });  Error Handling  Due to the inherent unreliability of networks, errors are an expected part of network programming. That’s why in Ballerina errors are explicitly checked rather than thrown as exceptions. It’s impossible to ignore errors by design because of Ballerina’s comprehensive error handling capabilities:  Get Started  Below is a simple example of how you can explicitly check for errors:  twitter:Status|error result = twitterClient->tweet(\"Hello World!\"); if result is error {  io:println(\"Tweet failed: \", result); } else {  io:println(\"Tweeted: \", <@untainted>status.id); }    The tweet remote method can return the expected twitter:Status value or an error due to network unreliability. Ballerina supports union types so the status variable can be either twitter:Status or error type. Also the Ballerina IDE tools support type guard where it guides developers to handle errors and values correctly in the if-else block.  Network Data Safety  Distributed systems work by sharing data between different components. Network security plays a crucial role because all these communications happen over the network. Ballerina provides built-in libraries to implement transport-level security and to protect data.  Identity and access management also plays a critical role in microservice-based applications. Ballerina supports out-of-the-box protection for services as well as clients by using Basic-auth, OAuth2 and JWT. The following BBEs show how to secure services and clients by enforcing authorization.  Service  Client  Ballerina ensures security by default. Its built-in makes sure that malicious, untrusted data doesn’t propagate through the system. If untrusted data is passed to a security-sensitive parameter, a compiler error is generated. You can then redesign the program to erect a safe wall around the dangerous input.  Observability by Default  Increasing the number of smaller services that communicate with each other means that debugging an issue will be harder. Enabling observability on these distributed services will require effort. Monitoring, logging, and distributed tracing are key methods that reveal the internal state of the system and provide observability.  Ballerina becomes fully observable by exposing itself via these three methods to various external systems. This helps with monitoring metrics such as request count and response time statistics, analyzing logs, and performing distributed tracing. For more information, follow this guide:  Get Started  Below is a simple example of how you can explicitly check for errors:  Cookie Policy This website uses cookies so that we can provide you with the best user experience. Read our to find out more. If you wish to disable cookies you can do so from your browser."}];