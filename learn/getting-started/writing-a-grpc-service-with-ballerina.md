---
layout: ballerina-language-basics-left-nav-pages-swanlake
title: Writing a gRPC service with Ballerina
description: This guide will walk you through writing a simple Ballerina gRPC service and invoking the service through Ballerina gRPC client application.
keywords: ballerina, grpc, protocol buffers, protobuf, ballerina packages, language-guide, standard library
permalink: /learn/user-guides/getting-started/writing-a-grpc-service-with-ballerina
active: language-basics
intro: This guide will walk you through writing a simple Ballerina gRPC service and invoking the service through Ballerina gRPC client application.
redirect_from:
- /learn/getting-started/writing-a-grpc-service-with-ballerina
- /learn/getting-started/writing-a-grpc-service-with-ballerina/
- /learn/user-guide/getting-started/writing-a-grpc-service-with-ballerina
- /learn/user-guide/getting-started/writing-a-grpc-service-with-ballerina/
---

## Table of Contents
- [Table of Contents](#table-of-contents)
- [Prerequisites](#prerequisites)
- [Creating Service Definition](#creating-service-definition)
- [Implementation](#create-a-ballerina-project)
    - [Developing a gRPC service](#developing-a-gRPC-service)
       - [Create a Ballerina project](#create-a-ballerina-project)
       - [Generate source code](#generate-source-code)
       - [Update and run the application](#update-and-run-the-application)
    - [Developing a gRPC client](#developing-a-gRPC-client)
        - [Create a Ballerina project](#create-a-ballerina-project)
        - [Generate source code](#generate-source-code)
        - [Update and run the application](#update-and-run-the-application)

## Prerequisites
To complete this tutorial, you need:

- A command terminal
- A text editor. [VSCode](https://code.visualstudio.com/) with the [Ballerina extension](https://marketplace.visualstudio.com/items?itemName=WSO2.ballerina) installed is our preferred 
  choice, and it has good support for Ballerina.
- A Ballerina installation. Follow the steps in [Installing Ballerina](https://ballerina.io/learn/installing-ballerina/setting-up-ballerina/).
- Some experience in gRPC service at least one programming language

## Creating Service Definition

In an RPC program, the first step is to define the interface of the service using an Interface Definition Language(IDL). gRPC commonly uses Protocol Buffers as IDL.
Here we are going to use the simple service definition to illustrate the server and client implementation in Ballerina Language.

```proto
syntax = "proto3";

package helloworld;

// The greeting service definition.
service Greeter {
 // Sends a greeting
 rpc sayHello (HelloRequest) returns (HelloReply);
}

// The request message with the user's name.
message HelloRequest {
 string name = 1;
}

// The response message with the greetings
message HelloReply {
 string message = 1;
}
```
> Note: The sample service definition is taken from the quick start guide in gRPC official site.

Let’s start implementing Ballerina service and client for the above definition.

## Implementation

As illustrated in the diagram below, we first need to compile the service definition file(helloworld.proto) and generate the source code for both client and service applications. In Ballerina, we can generate the source code using the built-in 'Protocol Buffers to Ballerina' tool.

![gRPC Getting Started](/learn/images/grpc-getting-started.png)

Let’s walk through implementing gRPC service and client in Ballerina Language.

### Developing a gRPC service

As with any other Ballerina Program, we need to start with creating a Ballerina project. Then we can generate service code in the project and write business logic.

#### Create a Ballerina project

A new Ballerina project can be created by executing the following command in the directory in which you want to create the project.

```$ bal new greeter_service```

> Note: For more information on creating Ballerina packages, please see the link.

Automatically created `main.bal` file along with project creation is removed, As we are not going to use it in this guide.

#### Generate source code

The service code for the service definition can be generated by executing the following command inside the Ballerina project directory.

```$ bal grpc --mode service --input helloworld.proto --output greeter_service/```

Once successfully executed, you will see the below output.

```
Successfully extracted library files.
Successfully generated ballerina file.
```

And once you move into the directory, we will see the following two files,

```
greeter_service
├── - - -
├── greeter_service.bal
└── helloworld_pb.bal
```

Here,
- The `helloworld_pb.bal` file is the stub file. It contains classes that client/service use to talk to each other 
and ballerina types corresponding to request and response messages.
- The `greeter_service.bal` file is the service template file. It contains service(s) with all the remote methods 
  defined in the proto file.

#### Update and run the application

Let’s update the service template file(`greeter_service.bal`) and add the business logic to the remote method. In this case, we only need to update the `sayHello` method as below,

```ballerina
import ballerina/grpc;
 
listener grpc:Listener grpcListener = new (9090);
 
@grpc:ServiceDescriptor {descriptor: ROOT_DESCRIPTOR_HELLOWORLD, descMap: getDescriptorMapHelloworld()}
service "Greeter" on grpcListener {
 
   remote function sayHello(HelloRequest value) returns HelloReply|error {
       return { message: "Hello " + value.name};
   }
}
```

In this code,
- The Listener declaration creates a new gRPC listener with port 9090. The listener is the entity that listens to the 
input coming to the port and then dispatches it to the correct service(s).
- The service declaration creates a service and attaches it to the listener. The service annotation is to create an 
  internal mapping between service declarations and the proto definition. Do not change it.
- The gRPC service can have one or more remote methods depending on the proto definition. Here service has only one 
  method called `sayHello` that has `HelloRequest` type as the request and `HelloReply` type as the response.

Let’s run this project in your terminal:

```
$ bal run
Compiling source
	example/greeter_service:0.1.0

Running executable
```

Now we completed server-side implementation and it is running on port 9090. Let’s move on to the gRPC client-side implementation.

### Developing a gRPC client

Similar to the service, the client application also starts with creating a new Ballerina project. Once created, we can generate the client code and update the code to call the remote methods exposed by the service.

#### Create Ballerina project

A new Ballerina project can be created by executing the following command in the directory in which you want to create the project.

```$ bal new greeter_client```

> Note: For more information on creating Ballerina packages, please see the link.

Automatically created `main.bal` file along with project creation is removed, As we are not going to use it in this guide.

#### Generate gRPC code

The source code related to the service definition can be generated by executing the following command inside the Ballerina project directory.

```$ bal grpc --mode client --input helloworld.proto --output greeter_client/```

Once successfully executed, you could be able to view the below output.
```
Successfully extracted library files.
Successfully generated ballerina file.
```

And once you move into the directory, we will see the following two new files,
```
greeter_client
├── - - -
├── greeter_client.bal
└── helloworld_pb.bal
```

Here,
- The `helloworld_pb.bal` file is the stub file that contains the classes that client/service use to talk to each 
other and ballerina types corresponding to request and response messages.
- The `greeter_client.bal` file is the client template file that contains the main function with client declaration.

#### Update and Run the application

Let’s update the client template file(`greeter_client.bal`) and write code to do a remote call with the server and get the server response back. Sample code is as follows,

```
import ballerina/io;
 
GreeterClient ep = check new ("http://localhost:9090");
public function main() returns error? {
   HelloReply sayHello = check ep->sayHello({name: "Ballerina"});
   io:println(`Response : ${sayHello.message}`);
}
```

In this code,

- The client declaration creates a connection to the remote server which is listening on port 9090. The generated 
client has remote methods that can use to talk to a remote server.
- The main function contains the statements that call the `sayHello` remote function and prints the response to the 
  console.

Let’s run this project in your terminal:

```
$ bal run
Compiling source
	example/greeter_client:0.1.0

Running executable
```

Since the server is up and running. Once the client application is successfully executed, the client application 
invokes the `sayHello` function with `HelloRequest` message and receives the `HelloReply` as the response. You will 
see the below output print on the console.

```
Response : Hello Ballerina
```
